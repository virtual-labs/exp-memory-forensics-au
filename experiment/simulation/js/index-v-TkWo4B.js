function G3(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in t)) {
          const o = Object.getOwnPropertyDescriptor(r, i);
          o &&
            Object.defineProperty(
              t,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const s of o.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const o = {};
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (o.credentials = "omit")
        : (o.credentials = "same-origin"),
      o
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const o = n(i);
    fetch(i.href, o);
  }
})();
function Ap(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
var W3 = { exports: {} },
  Dv = {},
  j3 = { exports: {} },
  Gt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bp = Symbol.for("react.element"),
  mk = Symbol.for("react.portal"),
  gk = Symbol.for("react.fragment"),
  vk = Symbol.for("react.strict_mode"),
  yk = Symbol.for("react.profiler"),
  xk = Symbol.for("react.provider"),
  _k = Symbol.for("react.context"),
  Sk = Symbol.for("react.forward_ref"),
  Ak = Symbol.for("react.suspense"),
  bk = Symbol.for("react.memo"),
  wk = Symbol.for("react.lazy"),
  GC = Symbol.iterator;
function Ek(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (GC && t[GC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var $3 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  X3 = Object.assign,
  Y3 = {};
function If(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = Y3),
    (this.updater = n || $3);
}
If.prototype.isReactComponent = {};
If.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
If.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function q3() {}
q3.prototype = If.prototype;
function Jb(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = Y3),
    (this.updater = n || $3);
}
var Qb = (Jb.prototype = new q3());
Qb.constructor = Jb;
X3(Qb, If.prototype);
Qb.isPureReactComponent = !0;
var WC = Array.isArray,
  K3 = Object.prototype.hasOwnProperty,
  ew = { current: null },
  Z3 = { key: !0, ref: !0, __self: !0, __source: !0 };
function J3(t, e, n) {
  var r,
    i = {},
    o = null,
    s = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (s = e.ref),
    e.key !== void 0 && (o = "" + e.key),
    e))
      K3.call(e, r) && !Z3.hasOwnProperty(r) && (i[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = n;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    i.children = l;
  }
  if (t && t.defaultProps)
    for (r in ((a = t.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: bp,
    type: t,
    key: o,
    ref: s,
    props: i,
    _owner: ew.current,
  };
}
function Mk(t, e) {
  return {
    $$typeof: bp,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function tw(t) {
  return typeof t == "object" && t !== null && t.$$typeof === bp;
}
function Ck(t) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var jC = /\/+/g;
function r1(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? Ck("" + t.key)
    : e.toString(36);
}
function f0(t, e, n, r, i) {
  var o = typeof t;
  (o === "undefined" || o === "boolean") && (t = null);
  var s = !1;
  if (t === null) s = !0;
  else
    switch (o) {
      case "string":
      case "number":
        s = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case bp:
          case mk:
            s = !0;
        }
    }
  if (s)
    return (
      (s = t),
      (i = i(s)),
      (t = r === "" ? "." + r1(s, 0) : r),
      WC(i)
        ? ((n = ""),
          t != null && (n = t.replace(jC, "$&/") + "/"),
          f0(i, e, n, "", function (c) {
            return c;
          }))
        : i != null &&
          (tw(i) &&
            (i = Mk(
              i,
              n +
                (!i.key || (s && s.key === i.key)
                  ? ""
                  : ("" + i.key).replace(jC, "$&/") + "/") +
                t
            )),
          e.push(i)),
      1
    );
  if (((s = 0), (r = r === "" ? "." : r + ":"), WC(t)))
    for (var a = 0; a < t.length; a++) {
      o = t[a];
      var l = r + r1(o, a);
      s += f0(o, e, n, l, i);
    }
  else if (((l = Ek(t)), typeof l == "function"))
    for (t = l.call(t), a = 0; !(o = t.next()).done; )
      (o = o.value), (l = r + r1(o, a++)), (s += f0(o, e, n, l, i));
  else if (o === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return s;
}
function Um(t, e, n) {
  if (t == null) return t;
  var r = [],
    i = 0;
  return (
    f0(t, r, "", "", function (o) {
      return e.call(n, o, i++);
    }),
    r
  );
}
function Tk(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var ci = { current: null },
  d0 = { transition: null },
  Rk = {
    ReactCurrentDispatcher: ci,
    ReactCurrentBatchConfig: d0,
    ReactCurrentOwner: ew,
  };
function Q3() {
  throw Error("act(...) is not supported in production builds of React.");
}
Gt.Children = {
  map: Um,
  forEach: function (t, e, n) {
    Um(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      Um(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      Um(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!tw(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
Gt.Component = If;
Gt.Fragment = gk;
Gt.Profiler = yk;
Gt.PureComponent = Jb;
Gt.StrictMode = vk;
Gt.Suspense = Ak;
Gt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Rk;
Gt.act = Q3;
Gt.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var r = X3({}, t.props),
    i = t.key,
    o = t.ref,
    s = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((o = e.ref), (s = ew.current)),
      e.key !== void 0 && (i = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var a = t.type.defaultProps;
    for (l in e)
      K3.call(e, l) &&
        !Z3.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = n;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    r.children = a;
  }
  return { $$typeof: bp, type: t.type, key: i, ref: o, props: r, _owner: s };
};
Gt.createContext = function (t) {
  return (
    (t = {
      $$typeof: _k,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = { $$typeof: xk, _context: t }),
    (t.Consumer = t)
  );
};
Gt.createElement = J3;
Gt.createFactory = function (t) {
  var e = J3.bind(null, t);
  return (e.type = t), e;
};
Gt.createRef = function () {
  return { current: null };
};
Gt.forwardRef = function (t) {
  return { $$typeof: Sk, render: t };
};
Gt.isValidElement = tw;
Gt.lazy = function (t) {
  return { $$typeof: wk, _payload: { _status: -1, _result: t }, _init: Tk };
};
Gt.memo = function (t, e) {
  return { $$typeof: bk, type: t, compare: e === void 0 ? null : e };
};
Gt.startTransition = function (t) {
  var e = d0.transition;
  d0.transition = {};
  try {
    t();
  } finally {
    d0.transition = e;
  }
};
Gt.unstable_act = Q3;
Gt.useCallback = function (t, e) {
  return ci.current.useCallback(t, e);
};
Gt.useContext = function (t) {
  return ci.current.useContext(t);
};
Gt.useDebugValue = function () {};
Gt.useDeferredValue = function (t) {
  return ci.current.useDeferredValue(t);
};
Gt.useEffect = function (t, e) {
  return ci.current.useEffect(t, e);
};
Gt.useId = function () {
  return ci.current.useId();
};
Gt.useImperativeHandle = function (t, e, n) {
  return ci.current.useImperativeHandle(t, e, n);
};
Gt.useInsertionEffect = function (t, e) {
  return ci.current.useInsertionEffect(t, e);
};
Gt.useLayoutEffect = function (t, e) {
  return ci.current.useLayoutEffect(t, e);
};
Gt.useMemo = function (t, e) {
  return ci.current.useMemo(t, e);
};
Gt.useReducer = function (t, e, n) {
  return ci.current.useReducer(t, e, n);
};
Gt.useRef = function (t) {
  return ci.current.useRef(t);
};
Gt.useState = function (t) {
  return ci.current.useState(t);
};
Gt.useSyncExternalStore = function (t, e, n) {
  return ci.current.useSyncExternalStore(t, e, n);
};
Gt.useTransition = function () {
  return ci.current.useTransition();
};
Gt.version = "18.3.1";
j3.exports = Gt;
var L = j3.exports;
const We = Ap(L),
  Fv = G3({ __proto__: null, default: We }, [L]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Pk = L,
  Ik = Symbol.for("react.element"),
  Lk = Symbol.for("react.fragment"),
  Ok = Object.prototype.hasOwnProperty,
  Nk = Pk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Dk = { key: !0, ref: !0, __self: !0, __source: !0 };
function eI(t, e, n) {
  var r,
    i = {},
    o = null,
    s = null;
  n !== void 0 && (o = "" + n),
    e.key !== void 0 && (o = "" + e.key),
    e.ref !== void 0 && (s = e.ref);
  for (r in e) Ok.call(e, r) && !Dk.hasOwnProperty(r) && (i[r] = e[r]);
  if (t && t.defaultProps)
    for (r in ((e = t.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: Ik,
    type: t,
    key: o,
    ref: s,
    props: i,
    _owner: Nk.current,
  };
}
Dv.Fragment = Lk;
Dv.jsx = eI;
Dv.jsxs = eI;
W3.exports = Dv;
var Q = W3.exports,
  oS = {},
  tI = { exports: {} },
  Zi = {},
  nI = { exports: {} },
  rI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(U, j) {
    var W = U.length;
    U.push(j);
    e: for (; 0 < W; ) {
      var B = (W - 1) >>> 1,
        q = U[B];
      if (0 < i(q, j)) (U[B] = j), (U[W] = q), (W = B);
      else break e;
    }
  }
  function n(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var j = U[0],
      W = U.pop();
    if (W !== j) {
      U[0] = W;
      e: for (var B = 0, q = U.length, Z = q >>> 1; B < Z; ) {
        var H = 2 * (B + 1) - 1,
          X = U[H],
          ne = H + 1,
          oe = U[ne];
        if (0 > i(X, W))
          ne < q && 0 > i(oe, X)
            ? ((U[B] = oe), (U[ne] = W), (B = ne))
            : ((U[B] = X), (U[H] = W), (B = H));
        else if (ne < q && 0 > i(oe, W)) (U[B] = oe), (U[ne] = W), (B = ne);
        else break e;
      }
    }
    return j;
  }
  function i(U, j) {
    var W = U.sortIndex - j.sortIndex;
    return W !== 0 ? W : U.id - j.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance;
    t.unstable_now = function () {
      return o.now();
    };
  } else {
    var s = Date,
      a = s.now();
    t.unstable_now = function () {
      return s.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    _ = !1,
    y = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var j = n(c); j !== null; ) {
      if (j.callback === null) r(c);
      else if (j.startTime <= U)
        r(c), (j.sortIndex = j.expirationTime), e(l, j);
      else break;
      j = n(c);
    }
  }
  function b(U) {
    if (((_ = !1), S(U), !v))
      if (n(l) !== null) (v = !0), G(C);
      else {
        var j = n(c);
        j !== null && Y(b, j.startTime - U);
      }
  }
  function C(U, j) {
    (v = !1), _ && ((_ = !1), g(P), (P = -1)), (m = !0);
    var W = p;
    try {
      for (
        S(j), d = n(l);
        d !== null && (!(d.expirationTime > j) || (U && !O()));

      ) {
        var B = d.callback;
        if (typeof B == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var q = B(d.expirationTime <= j);
          (j = t.unstable_now()),
            typeof q == "function" ? (d.callback = q) : d === n(l) && r(l),
            S(j);
        } else r(l);
        d = n(l);
      }
      if (d !== null) var Z = !0;
      else {
        var H = n(c);
        H !== null && Y(b, H.startTime - j), (Z = !1);
      }
      return Z;
    } finally {
      (d = null), (p = W), (m = !1);
    }
  }
  var M = !1,
    T = null,
    P = -1,
    R = 5,
    E = -1;
  function O() {
    return !(t.unstable_now() - E < R);
  }
  function D() {
    if (T !== null) {
      var U = t.unstable_now();
      E = U;
      var j = !0;
      try {
        j = T(!0, U);
      } finally {
        j ? N() : ((M = !1), (T = null));
      }
    } else M = !1;
  }
  var N;
  if (typeof x == "function")
    N = function () {
      x(D);
    };
  else if (typeof MessageChannel < "u") {
    var z = new MessageChannel(),
      V = z.port2;
    (z.port1.onmessage = D),
      (N = function () {
        V.postMessage(null);
      });
  } else
    N = function () {
      y(D, 0);
    };
  function G(U) {
    (T = U), M || ((M = !0), N());
  }
  function Y(U, j) {
    P = y(function () {
      U(t.unstable_now());
    }, j);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || m || ((v = !0), G(C));
    }),
    (t.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (U) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var j = 3;
          break;
        default:
          j = p;
      }
      var W = p;
      p = j;
      try {
        return U();
      } finally {
        p = W;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (U, j) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var W = p;
      p = U;
      try {
        return j();
      } finally {
        p = W;
      }
    }),
    (t.unstable_scheduleCallback = function (U, j, W) {
      var B = t.unstable_now();
      switch (
        (typeof W == "object" && W !== null
          ? ((W = W.delay), (W = typeof W == "number" && 0 < W ? B + W : B))
          : (W = B),
        U)
      ) {
        case 1:
          var q = -1;
          break;
        case 2:
          q = 250;
          break;
        case 5:
          q = 1073741823;
          break;
        case 4:
          q = 1e4;
          break;
        default:
          q = 5e3;
      }
      return (
        (q = W + q),
        (U = {
          id: u++,
          callback: j,
          priorityLevel: U,
          startTime: W,
          expirationTime: q,
          sortIndex: -1,
        }),
        W > B
          ? ((U.sortIndex = W),
            e(c, U),
            n(l) === null &&
              U === n(c) &&
              (_ ? (g(P), (P = -1)) : (_ = !0), Y(b, W - B)))
          : ((U.sortIndex = q), e(l, U), v || m || ((v = !0), G(C))),
        U
      );
    }),
    (t.unstable_shouldYield = O),
    (t.unstable_wrapCallback = function (U) {
      var j = p;
      return function () {
        var W = p;
        p = j;
        try {
          return U.apply(this, arguments);
        } finally {
          p = W;
        }
      };
    });
})(rI);
nI.exports = rI;
var Fk = nI.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Uk = L,
  Yi = Fk;
function Xe(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var iI = new Set(),
  Sh = {};
function Ic(t, e) {
  ff(t, e), ff(t + "Capture", e);
}
function ff(t, e) {
  for (Sh[t] = e, t = 0; t < e.length; t++) iI.add(e[t]);
}
var Ys = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  sS = Object.prototype.hasOwnProperty,
  kk =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  $C = {},
  XC = {};
function zk(t) {
  return sS.call(XC, t)
    ? !0
    : sS.call($C, t)
    ? !1
    : kk.test(t)
    ? (XC[t] = !0)
    : (($C[t] = !0), !1);
}
function Bk(t, e, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function Hk(t, e, n, r) {
  if (e === null || typeof e > "u" || Bk(t, e, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function ui(t, e, n, r, i, o, s) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = o),
    (this.removeEmptyString = s);
}
var Ir = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    Ir[t] = new ui(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  Ir[e] = new ui(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  Ir[t] = new ui(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  Ir[t] = new ui(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    Ir[t] = new ui(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  Ir[t] = new ui(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  Ir[t] = new ui(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  Ir[t] = new ui(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  Ir[t] = new ui(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var nw = /[\-:]([a-z])/g;
function rw(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(nw, rw);
    Ir[e] = new ui(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(nw, rw);
    Ir[e] = new ui(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(nw, rw);
  Ir[e] = new ui(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  Ir[t] = new ui(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
Ir.xlinkHref = new ui(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  Ir[t] = new ui(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function iw(t, e, n, r) {
  var i = Ir.hasOwnProperty(e) ? Ir[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (Hk(e, n, i, r) && (n = null),
    r || i === null
      ? zk(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : i.mustUseProperty
      ? (t[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))));
}
var ra = Uk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  km = Symbol.for("react.element"),
  Nu = Symbol.for("react.portal"),
  Du = Symbol.for("react.fragment"),
  ow = Symbol.for("react.strict_mode"),
  aS = Symbol.for("react.profiler"),
  oI = Symbol.for("react.provider"),
  sI = Symbol.for("react.context"),
  sw = Symbol.for("react.forward_ref"),
  lS = Symbol.for("react.suspense"),
  cS = Symbol.for("react.suspense_list"),
  aw = Symbol.for("react.memo"),
  Pa = Symbol.for("react.lazy"),
  aI = Symbol.for("react.offscreen"),
  YC = Symbol.iterator;
function vd(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (YC && t[YC]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var Pn = Object.assign,
  i1;
function Gd(t) {
  if (i1 === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      i1 = (e && e[1]) || "";
    }
  return (
    `
` +
    i1 +
    t
  );
}
var o1 = !1;
function s1(t, e) {
  if (!t || o1) return "";
  o1 = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var r = c;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          r = c;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        r = c;
      }
      t();
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var i = c.stack.split(`
`),
          o = r.stack.split(`
`),
          s = i.length - 1,
          a = o.length - 1;
        1 <= s && 0 <= a && i[s] !== o[a];

      )
        a--;
      for (; 1 <= s && 0 <= a; s--, a--)
        if (i[s] !== o[a]) {
          if (s !== 1 || a !== 1)
            do
              if ((s--, a--, 0 > a || i[s] !== o[a])) {
                var l =
                  `
` + i[s].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= s && 0 <= a);
          break;
        }
    }
  } finally {
    (o1 = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? Gd(t) : "";
}
function Vk(t) {
  switch (t.tag) {
    case 5:
      return Gd(t.type);
    case 16:
      return Gd("Lazy");
    case 13:
      return Gd("Suspense");
    case 19:
      return Gd("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = s1(t.type, !1)), t;
    case 11:
      return (t = s1(t.type.render, !1)), t;
    case 1:
      return (t = s1(t.type, !0)), t;
    default:
      return "";
  }
}
function uS(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case Du:
      return "Fragment";
    case Nu:
      return "Portal";
    case aS:
      return "Profiler";
    case ow:
      return "StrictMode";
    case lS:
      return "Suspense";
    case cS:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case sI:
        return (t.displayName || "Context") + ".Consumer";
      case oI:
        return (t._context.displayName || "Context") + ".Provider";
      case sw:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case aw:
        return (
          (e = t.displayName || null), e !== null ? e : uS(t.type) || "Memo"
        );
      case Pa:
        (e = t._payload), (t = t._init);
        try {
          return uS(t(e));
        } catch {}
    }
  return null;
}
function Gk(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return uS(e);
    case 8:
      return e === ow ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ja(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function lI(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function Wk(t) {
  var e = lI(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      o = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (s) {
          (r = "" + s), o.call(this, s);
        },
      }),
      Object.defineProperty(t, e, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (s) {
          r = "" + s;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function zm(t) {
  t._valueTracker || (t._valueTracker = Wk(t));
}
function cI(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    r = "";
  return (
    t && (r = lI(t) ? (t.checked ? "true" : "false") : t.value),
    (t = r),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function G0(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function fS(t, e) {
  var n = e.checked;
  return Pn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function qC(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (n = Ja(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function uI(t, e) {
  (e = e.checked), e != null && iw(t, "checked", e, !1);
}
function dS(t, e) {
  uI(t, e);
  var n = Ja(e.value),
    r = e.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (r === "submit" || r === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? hS(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && hS(t, e.type, Ja(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function KC(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function hS(t, e, n) {
  (e !== "number" || G0(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var Wd = Array.isArray;
function tf(t, e, n, r) {
  if (((t = t.options), e)) {
    e = {};
    for (var i = 0; i < n.length; i++) e["$" + n[i]] = !0;
    for (n = 0; n < t.length; n++)
      (i = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== i && (t[n].selected = i),
        i && r && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + Ja(n), e = null, i = 0; i < t.length; i++) {
      if (t[i].value === n) {
        (t[i].selected = !0), r && (t[i].defaultSelected = !0);
        return;
      }
      e !== null || t[i].disabled || (e = t[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function pS(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Xe(91));
  return Pn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function ZC(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(Xe(92));
      if (Wd(n)) {
        if (1 < n.length) throw Error(Xe(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = { initialValue: Ja(n) };
}
function fI(t, e) {
  var n = Ja(e.value),
    r = Ja(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    r != null && (t.defaultValue = "" + r);
}
function JC(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function dI(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mS(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? dI(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var Bm,
  hI = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, r, i);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        Bm = Bm || document.createElement("div"),
          Bm.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Bm.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function Ah(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var th = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  jk = ["Webkit", "ms", "Moz", "O"];
Object.keys(th).forEach(function (t) {
  jk.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (th[e] = th[t]);
  });
});
function pI(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (th.hasOwnProperty(t) && th[t])
    ? ("" + e).trim()
    : e + "px";
}
function mI(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = pI(n, e[n], r);
      n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : (t[n] = i);
    }
}
var $k = Pn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function gS(t, e) {
  if (e) {
    if ($k[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Xe(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Xe(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Xe(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Xe(62));
  }
}
function vS(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var yS = null;
function lw(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var xS = null,
  nf = null,
  rf = null;
function QC(t) {
  if ((t = Mp(t))) {
    if (typeof xS != "function") throw Error(Xe(280));
    var e = t.stateNode;
    e && ((e = Hv(e)), xS(t.stateNode, t.type, e));
  }
}
function gI(t) {
  nf ? (rf ? rf.push(t) : (rf = [t])) : (nf = t);
}
function vI() {
  if (nf) {
    var t = nf,
      e = rf;
    if (((rf = nf = null), QC(t), e)) for (t = 0; t < e.length; t++) QC(e[t]);
  }
}
function yI(t, e) {
  return t(e);
}
function xI() {}
var a1 = !1;
function _I(t, e, n) {
  if (a1) return t(e, n);
  a1 = !0;
  try {
    return yI(t, e, n);
  } finally {
    (a1 = !1), (nf !== null || rf !== null) && (xI(), vI());
  }
}
function bh(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var r = Hv(n);
  if (r === null) return null;
  n = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((t = t.type),
        (r = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !r);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(Xe(231, e, typeof n));
  return n;
}
var _S = !1;
if (Ys)
  try {
    var yd = {};
    Object.defineProperty(yd, "passive", {
      get: function () {
        _S = !0;
      },
    }),
      window.addEventListener("test", yd, yd),
      window.removeEventListener("test", yd, yd);
  } catch {
    _S = !1;
  }
function Xk(t, e, n, r, i, o, s, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, c);
  } catch (u) {
    this.onError(u);
  }
}
var nh = !1,
  W0 = null,
  j0 = !1,
  SS = null,
  Yk = {
    onError: function (t) {
      (nh = !0), (W0 = t);
    },
  };
function qk(t, e, n, r, i, o, s, a, l) {
  (nh = !1), (W0 = null), Xk.apply(Yk, arguments);
}
function Kk(t, e, n, r, i, o, s, a, l) {
  if ((qk.apply(this, arguments), nh)) {
    if (nh) {
      var c = W0;
      (nh = !1), (W0 = null);
    } else throw Error(Xe(198));
    j0 || ((j0 = !0), (SS = c));
  }
}
function Lc(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function SI(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function e2(t) {
  if (Lc(t) !== t) throw Error(Xe(188));
}
function Zk(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = Lc(t)), e === null)) throw Error(Xe(188));
    return e !== t ? null : t;
  }
  for (var n = t, r = e; ; ) {
    var i = n.return;
    if (i === null) break;
    var o = i.alternate;
    if (o === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === o.child) {
      for (o = i.child; o; ) {
        if (o === n) return e2(i), t;
        if (o === r) return e2(i), e;
        o = o.sibling;
      }
      throw Error(Xe(188));
    }
    if (n.return !== r.return) (n = i), (r = o);
    else {
      for (var s = !1, a = i.child; a; ) {
        if (a === n) {
          (s = !0), (n = i), (r = o);
          break;
        }
        if (a === r) {
          (s = !0), (r = i), (n = o);
          break;
        }
        a = a.sibling;
      }
      if (!s) {
        for (a = o.child; a; ) {
          if (a === n) {
            (s = !0), (n = o), (r = i);
            break;
          }
          if (a === r) {
            (s = !0), (r = o), (n = i);
            break;
          }
          a = a.sibling;
        }
        if (!s) throw Error(Xe(189));
      }
    }
    if (n.alternate !== r) throw Error(Xe(190));
  }
  if (n.tag !== 3) throw Error(Xe(188));
  return n.stateNode.current === n ? t : e;
}
function AI(t) {
  return (t = Zk(t)), t !== null ? bI(t) : null;
}
function bI(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = bI(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var wI = Yi.unstable_scheduleCallback,
  t2 = Yi.unstable_cancelCallback,
  Jk = Yi.unstable_shouldYield,
  Qk = Yi.unstable_requestPaint,
  $n = Yi.unstable_now,
  ez = Yi.unstable_getCurrentPriorityLevel,
  cw = Yi.unstable_ImmediatePriority,
  EI = Yi.unstable_UserBlockingPriority,
  $0 = Yi.unstable_NormalPriority,
  tz = Yi.unstable_LowPriority,
  MI = Yi.unstable_IdlePriority,
  Uv = null,
  fs = null;
function nz(t) {
  if (fs && typeof fs.onCommitFiberRoot == "function")
    try {
      fs.onCommitFiberRoot(Uv, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var zo = Math.clz32 ? Math.clz32 : oz,
  rz = Math.log,
  iz = Math.LN2;
function oz(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((rz(t) / iz) | 0)) | 0;
}
var Hm = 64,
  Vm = 4194304;
function jd(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function X0(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = t.suspendedLanes,
    o = t.pingedLanes,
    s = n & 268435455;
  if (s !== 0) {
    var a = s & ~i;
    a !== 0 ? (r = jd(a)) : ((o &= s), o !== 0 && (r = jd(o)));
  } else (s = n & ~i), s !== 0 ? (r = jd(s)) : o !== 0 && (r = jd(o));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (o = e & -e), i >= o || (i === 16 && (o & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= r; 0 < e; )
      (n = 31 - zo(e)), (i = 1 << n), (r |= t[n]), (e &= ~i);
  return r;
}
function sz(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function az(t, e) {
  for (
    var n = t.suspendedLanes,
      r = t.pingedLanes,
      i = t.expirationTimes,
      o = t.pendingLanes;
    0 < o;

  ) {
    var s = 31 - zo(o),
      a = 1 << s,
      l = i[s];
    l === -1
      ? (!(a & n) || a & r) && (i[s] = sz(a, e))
      : l <= e && (t.expiredLanes |= a),
      (o &= ~a);
  }
}
function AS(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function CI() {
  var t = Hm;
  return (Hm <<= 1), !(Hm & 4194240) && (Hm = 64), t;
}
function l1(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function wp(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - zo(e)),
    (t[e] = n);
}
function lz(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var r = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var i = 31 - zo(n),
      o = 1 << i;
    (e[i] = 0), (r[i] = -1), (t[i] = -1), (n &= ~o);
  }
}
function uw(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var r = 31 - zo(n),
      i = 1 << r;
    (i & e) | (t[r] & e) && (t[r] |= e), (n &= ~i);
  }
}
var on = 0;
function TI(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var RI,
  fw,
  PI,
  II,
  LI,
  bS = !1,
  Gm = [],
  Va = null,
  Ga = null,
  Wa = null,
  wh = new Map(),
  Eh = new Map(),
  Na = [],
  cz =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function n2(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Va = null;
      break;
    case "dragenter":
    case "dragleave":
      Ga = null;
      break;
    case "mouseover":
    case "mouseout":
      Wa = null;
      break;
    case "pointerover":
    case "pointerout":
      wh.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Eh.delete(e.pointerId);
  }
}
function xd(t, e, n, r, i, o) {
  return t === null || t.nativeEvent !== o
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i],
      }),
      e !== null && ((e = Mp(e)), e !== null && fw(e)),
      t)
    : ((t.eventSystemFlags |= r),
      (e = t.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      t);
}
function uz(t, e, n, r, i) {
  switch (e) {
    case "focusin":
      return (Va = xd(Va, t, e, n, r, i)), !0;
    case "dragenter":
      return (Ga = xd(Ga, t, e, n, r, i)), !0;
    case "mouseover":
      return (Wa = xd(Wa, t, e, n, r, i)), !0;
    case "pointerover":
      var o = i.pointerId;
      return wh.set(o, xd(wh.get(o) || null, t, e, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (o = i.pointerId), Eh.set(o, xd(Eh.get(o) || null, t, e, n, r, i)), !0
      );
  }
  return !1;
}
function OI(t) {
  var e = Zl(t.target);
  if (e !== null) {
    var n = Lc(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = SI(n)), e !== null)) {
          (t.blockedOn = e),
            LI(t.priority, function () {
              PI(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function h0(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = wS(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var r = new n.constructor(n.type, n);
      (yS = r), n.target.dispatchEvent(r), (yS = null);
    } else return (e = Mp(n)), e !== null && fw(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function r2(t, e, n) {
  h0(t) && n.delete(e);
}
function fz() {
  (bS = !1),
    Va !== null && h0(Va) && (Va = null),
    Ga !== null && h0(Ga) && (Ga = null),
    Wa !== null && h0(Wa) && (Wa = null),
    wh.forEach(r2),
    Eh.forEach(r2);
}
function _d(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    bS ||
      ((bS = !0),
      Yi.unstable_scheduleCallback(Yi.unstable_NormalPriority, fz)));
}
function Mh(t) {
  function e(i) {
    return _d(i, t);
  }
  if (0 < Gm.length) {
    _d(Gm[0], t);
    for (var n = 1; n < Gm.length; n++) {
      var r = Gm[n];
      r.blockedOn === t && (r.blockedOn = null);
    }
  }
  for (
    Va !== null && _d(Va, t),
      Ga !== null && _d(Ga, t),
      Wa !== null && _d(Wa, t),
      wh.forEach(e),
      Eh.forEach(e),
      n = 0;
    n < Na.length;
    n++
  )
    (r = Na[n]), r.blockedOn === t && (r.blockedOn = null);
  for (; 0 < Na.length && ((n = Na[0]), n.blockedOn === null); )
    OI(n), n.blockedOn === null && Na.shift();
}
var of = ra.ReactCurrentBatchConfig,
  Y0 = !0;
function dz(t, e, n, r) {
  var i = on,
    o = of.transition;
  of.transition = null;
  try {
    (on = 1), dw(t, e, n, r);
  } finally {
    (on = i), (of.transition = o);
  }
}
function hz(t, e, n, r) {
  var i = on,
    o = of.transition;
  of.transition = null;
  try {
    (on = 4), dw(t, e, n, r);
  } finally {
    (on = i), (of.transition = o);
  }
}
function dw(t, e, n, r) {
  if (Y0) {
    var i = wS(t, e, n, r);
    if (i === null) y1(t, e, r, q0, n), n2(t, r);
    else if (uz(i, t, e, n, r)) r.stopPropagation();
    else if ((n2(t, r), e & 4 && -1 < cz.indexOf(t))) {
      for (; i !== null; ) {
        var o = Mp(i);
        if (
          (o !== null && RI(o),
          (o = wS(t, e, n, r)),
          o === null && y1(t, e, r, q0, n),
          o === i)
        )
          break;
        i = o;
      }
      i !== null && r.stopPropagation();
    } else y1(t, e, r, null, n);
  }
}
var q0 = null;
function wS(t, e, n, r) {
  if (((q0 = null), (t = lw(r)), (t = Zl(t)), t !== null))
    if (((e = Lc(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = SI(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (q0 = t), null;
}
function NI(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ez()) {
        case cw:
          return 1;
        case EI:
          return 4;
        case $0:
        case tz:
          return 16;
        case MI:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Ua = null,
  hw = null,
  p0 = null;
function DI() {
  if (p0) return p0;
  var t,
    e = hw,
    n = e.length,
    r,
    i = "value" in Ua ? Ua.value : Ua.textContent,
    o = i.length;
  for (t = 0; t < n && e[t] === i[t]; t++);
  var s = n - t;
  for (r = 1; r <= s && e[n - r] === i[o - r]; r++);
  return (p0 = i.slice(t, 1 < r ? 1 - r : void 0));
}
function m0(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function Wm() {
  return !0;
}
function i2() {
  return !1;
}
function Ji(t) {
  function e(n, r, i, o, s) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = o),
      (this.target = s),
      (this.currentTarget = null);
    for (var a in t)
      t.hasOwnProperty(a) && ((n = t[a]), (this[a] = n ? n(o) : o[a]));
    return (
      (this.isDefaultPrevented = (
        o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1
      )
        ? Wm
        : i2),
      (this.isPropagationStopped = i2),
      this
    );
  }
  return (
    Pn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = Wm));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = Wm));
      },
      persist: function () {},
      isPersistent: Wm,
    }),
    e
  );
}
var Lf = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  pw = Ji(Lf),
  Ep = Pn({}, Lf, { view: 0, detail: 0 }),
  pz = Ji(Ep),
  c1,
  u1,
  Sd,
  kv = Pn({}, Ep, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: mw,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== Sd &&
            (Sd && t.type === "mousemove"
              ? ((c1 = t.screenX - Sd.screenX), (u1 = t.screenY - Sd.screenY))
              : (u1 = c1 = 0),
            (Sd = t)),
          c1);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : u1;
    },
  }),
  o2 = Ji(kv),
  mz = Pn({}, kv, { dataTransfer: 0 }),
  gz = Ji(mz),
  vz = Pn({}, Ep, { relatedTarget: 0 }),
  f1 = Ji(vz),
  yz = Pn({}, Lf, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  xz = Ji(yz),
  _z = Pn({}, Lf, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  Sz = Ji(_z),
  Az = Pn({}, Lf, { data: 0 }),
  s2 = Ji(Az),
  bz = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  wz = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Ez = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function Mz(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = Ez[t]) ? !!e[t] : !1;
}
function mw() {
  return Mz;
}
var Cz = Pn({}, Ep, {
    key: function (t) {
      if (t.key) {
        var e = bz[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = m0(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? wz[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: mw,
    charCode: function (t) {
      return t.type === "keypress" ? m0(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? m0(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  Tz = Ji(Cz),
  Rz = Pn({}, kv, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  a2 = Ji(Rz),
  Pz = Pn({}, Ep, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: mw,
  }),
  Iz = Ji(Pz),
  Lz = Pn({}, Lf, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Oz = Ji(Lz),
  Nz = Pn({}, kv, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Dz = Ji(Nz),
  Fz = [9, 13, 27, 32],
  gw = Ys && "CompositionEvent" in window,
  rh = null;
Ys && "documentMode" in document && (rh = document.documentMode);
var Uz = Ys && "TextEvent" in window && !rh,
  FI = Ys && (!gw || (rh && 8 < rh && 11 >= rh)),
  l2 = " ",
  c2 = !1;
function UI(t, e) {
  switch (t) {
    case "keyup":
      return Fz.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function kI(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Fu = !1;
function kz(t, e) {
  switch (t) {
    case "compositionend":
      return kI(e);
    case "keypress":
      return e.which !== 32 ? null : ((c2 = !0), l2);
    case "textInput":
      return (t = e.data), t === l2 && c2 ? null : t;
    default:
      return null;
  }
}
function zz(t, e) {
  if (Fu)
    return t === "compositionend" || (!gw && UI(t, e))
      ? ((t = DI()), (p0 = hw = Ua = null), (Fu = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return FI && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var Bz = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function u2(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!Bz[t.type] : e === "textarea";
}
function zI(t, e, n, r) {
  gI(r),
    (e = K0(e, "onChange")),
    0 < e.length &&
      ((n = new pw("onChange", "change", null, n, r)),
      t.push({ event: n, listeners: e }));
}
var ih = null,
  Ch = null;
function Hz(t) {
  KI(t, 0);
}
function zv(t) {
  var e = zu(t);
  if (cI(e)) return t;
}
function Vz(t, e) {
  if (t === "change") return e;
}
var BI = !1;
if (Ys) {
  var d1;
  if (Ys) {
    var h1 = "oninput" in document;
    if (!h1) {
      var f2 = document.createElement("div");
      f2.setAttribute("oninput", "return;"),
        (h1 = typeof f2.oninput == "function");
    }
    d1 = h1;
  } else d1 = !1;
  BI = d1 && (!document.documentMode || 9 < document.documentMode);
}
function d2() {
  ih && (ih.detachEvent("onpropertychange", HI), (Ch = ih = null));
}
function HI(t) {
  if (t.propertyName === "value" && zv(Ch)) {
    var e = [];
    zI(e, Ch, t, lw(t)), _I(Hz, e);
  }
}
function Gz(t, e, n) {
  t === "focusin"
    ? (d2(), (ih = e), (Ch = n), ih.attachEvent("onpropertychange", HI))
    : t === "focusout" && d2();
}
function Wz(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return zv(Ch);
}
function jz(t, e) {
  if (t === "click") return zv(e);
}
function $z(t, e) {
  if (t === "input" || t === "change") return zv(e);
}
function Xz(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var Go = typeof Object.is == "function" ? Object.is : Xz;
function Th(t, e) {
  if (Go(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!sS.call(e, i) || !Go(t[i], e[i])) return !1;
  }
  return !0;
}
function h2(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function p2(t, e) {
  var n = h2(t);
  t = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = t + n.textContent.length), t <= e && r >= e))
        return { node: n, offset: e - t };
      t = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = h2(n);
  }
}
function VI(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? VI(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function GI() {
  for (var t = window, e = G0(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = G0(t.document);
  }
  return e;
}
function vw(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function Yz(t) {
  var e = GI(),
    n = t.focusedElem,
    r = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    VI(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && vw(n)) {
      if (
        ((e = r.start),
        (t = r.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var i = n.textContent.length,
          o = Math.min(r.start, i);
        (r = r.end === void 0 ? o : Math.min(r.end, i)),
          !t.extend && o > r && ((i = r), (r = o), (o = i)),
          (i = p2(n, o));
        var s = p2(n, r);
        i &&
          s &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== i.node ||
            t.anchorOffset !== i.offset ||
            t.focusNode !== s.node ||
            t.focusOffset !== s.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          t.removeAllRanges(),
          o > r
            ? (t.addRange(e), t.extend(s.node, s.offset))
            : (e.setEnd(s.node, s.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var qz = Ys && "documentMode" in document && 11 >= document.documentMode,
  Uu = null,
  ES = null,
  oh = null,
  MS = !1;
function m2(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  MS ||
    Uu == null ||
    Uu !== G0(r) ||
    ((r = Uu),
    "selectionStart" in r && vw(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (oh && Th(oh, r)) ||
      ((oh = r),
      (r = K0(ES, "onSelect")),
      0 < r.length &&
        ((e = new pw("onSelect", "select", null, e, n)),
        t.push({ event: e, listeners: r }),
        (e.target = Uu))));
}
function jm(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var ku = {
    animationend: jm("Animation", "AnimationEnd"),
    animationiteration: jm("Animation", "AnimationIteration"),
    animationstart: jm("Animation", "AnimationStart"),
    transitionend: jm("Transition", "TransitionEnd"),
  },
  p1 = {},
  WI = {};
Ys &&
  ((WI = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete ku.animationend.animation,
    delete ku.animationiteration.animation,
    delete ku.animationstart.animation),
  "TransitionEvent" in window || delete ku.transitionend.transition);
function Bv(t) {
  if (p1[t]) return p1[t];
  if (!ku[t]) return t;
  var e = ku[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in WI) return (p1[t] = e[n]);
  return t;
}
var jI = Bv("animationend"),
  $I = Bv("animationiteration"),
  XI = Bv("animationstart"),
  YI = Bv("transitionend"),
  qI = new Map(),
  g2 =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function il(t, e) {
  qI.set(t, e), Ic(e, [t]);
}
for (var m1 = 0; m1 < g2.length; m1++) {
  var g1 = g2[m1],
    Kz = g1.toLowerCase(),
    Zz = g1[0].toUpperCase() + g1.slice(1);
  il(Kz, "on" + Zz);
}
il(jI, "onAnimationEnd");
il($I, "onAnimationIteration");
il(XI, "onAnimationStart");
il("dblclick", "onDoubleClick");
il("focusin", "onFocus");
il("focusout", "onBlur");
il(YI, "onTransitionEnd");
ff("onMouseEnter", ["mouseout", "mouseover"]);
ff("onMouseLeave", ["mouseout", "mouseover"]);
ff("onPointerEnter", ["pointerout", "pointerover"]);
ff("onPointerLeave", ["pointerout", "pointerover"]);
Ic(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Ic(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Ic("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Ic(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Ic(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Ic(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var $d =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Jz = new Set("cancel close invalid load scroll toggle".split(" ").concat($d));
function v2(t, e, n) {
  var r = t.type || "unknown-event";
  (t.currentTarget = n), Kk(r, e, void 0, t), (t.currentTarget = null);
}
function KI(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      i = r.event;
    r = r.listeners;
    e: {
      var o = void 0;
      if (e)
        for (var s = r.length - 1; 0 <= s; s--) {
          var a = r[s],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== o && i.isPropagationStopped())) break e;
          v2(i, a, c), (o = l);
        }
      else
        for (s = 0; s < r.length; s++) {
          if (
            ((a = r[s]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== o && i.isPropagationStopped())
          )
            break e;
          v2(i, a, c), (o = l);
        }
    }
  }
  if (j0) throw ((t = SS), (j0 = !1), (SS = null), t);
}
function gn(t, e) {
  var n = e[IS];
  n === void 0 && (n = e[IS] = new Set());
  var r = t + "__bubble";
  n.has(r) || (ZI(e, t, 2, !1), n.add(r));
}
function v1(t, e, n) {
  var r = 0;
  e && (r |= 4), ZI(n, t, r, e);
}
var $m = "_reactListening" + Math.random().toString(36).slice(2);
function Rh(t) {
  if (!t[$m]) {
    (t[$m] = !0),
      iI.forEach(function (n) {
        n !== "selectionchange" && (Jz.has(n) || v1(n, !1, t), v1(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[$m] || ((e[$m] = !0), v1("selectionchange", !1, e));
  }
}
function ZI(t, e, n, r) {
  switch (NI(e)) {
    case 1:
      var i = dz;
      break;
    case 4:
      i = hz;
      break;
    default:
      i = dw;
  }
  (n = i.bind(null, e, n, t)),
    (i = void 0),
    !_S ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? t.addEventListener(e, n, { capture: !0, passive: i })
        : t.addEventListener(e, n, !0)
      : i !== void 0
      ? t.addEventListener(e, n, { passive: i })
      : t.addEventListener(e, n, !1);
}
function y1(t, e, n, r, i) {
  var o = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var s = r.tag;
      if (s === 3 || s === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (s === 4)
          for (s = r.return; s !== null; ) {
            var l = s.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = s.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            s = s.return;
          }
        for (; a !== null; ) {
          if (((s = Zl(a)), s === null)) return;
          if (((l = s.tag), l === 5 || l === 6)) {
            r = o = s;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  _I(function () {
    var c = o,
      u = lw(n),
      d = [];
    e: {
      var p = qI.get(t);
      if (p !== void 0) {
        var m = pw,
          v = t;
        switch (t) {
          case "keypress":
            if (m0(n) === 0) break e;
          case "keydown":
          case "keyup":
            m = Tz;
            break;
          case "focusin":
            (v = "focus"), (m = f1);
            break;
          case "focusout":
            (v = "blur"), (m = f1);
            break;
          case "beforeblur":
          case "afterblur":
            m = f1;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = o2;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = gz;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = Iz;
            break;
          case jI:
          case $I:
          case XI:
            m = xz;
            break;
          case YI:
            m = Oz;
            break;
          case "scroll":
            m = pz;
            break;
          case "wheel":
            m = Dz;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = Sz;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = a2;
        }
        var _ = (e & 4) !== 0,
          y = !_ && t === "scroll",
          g = _ ? (p !== null ? p + "Capture" : null) : p;
        _ = [];
        for (var x = c, S; x !== null; ) {
          S = x;
          var b = S.stateNode;
          if (
            (S.tag === 5 &&
              b !== null &&
              ((S = b),
              g !== null && ((b = bh(x, g)), b != null && _.push(Ph(x, b, S)))),
            y)
          )
            break;
          x = x.return;
        }
        0 < _.length &&
          ((p = new m(p, v, null, n, u)), d.push({ event: p, listeners: _ }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = t === "mouseover" || t === "pointerover"),
          (m = t === "mouseout" || t === "pointerout"),
          p &&
            n !== yS &&
            (v = n.relatedTarget || n.fromElement) &&
            (Zl(v) || v[qs]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            u.window === u
              ? u
              : (p = u.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((v = n.relatedTarget || n.toElement),
              (m = c),
              (v = v ? Zl(v) : null),
              v !== null &&
                ((y = Lc(v)), v !== y || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((m = null), (v = c)),
          m !== v)
        ) {
          if (
            ((_ = o2),
            (b = "onMouseLeave"),
            (g = "onMouseEnter"),
            (x = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((_ = a2),
              (b = "onPointerLeave"),
              (g = "onPointerEnter"),
              (x = "pointer")),
            (y = m == null ? p : zu(m)),
            (S = v == null ? p : zu(v)),
            (p = new _(b, x + "leave", m, n, u)),
            (p.target = y),
            (p.relatedTarget = S),
            (b = null),
            Zl(u) === c &&
              ((_ = new _(g, x + "enter", v, n, u)),
              (_.target = S),
              (_.relatedTarget = y),
              (b = _)),
            (y = b),
            m && v)
          )
            t: {
              for (_ = m, g = v, x = 0, S = _; S; S = nu(S)) x++;
              for (S = 0, b = g; b; b = nu(b)) S++;
              for (; 0 < x - S; ) (_ = nu(_)), x--;
              for (; 0 < S - x; ) (g = nu(g)), S--;
              for (; x--; ) {
                if (_ === g || (g !== null && _ === g.alternate)) break t;
                (_ = nu(_)), (g = nu(g));
              }
              _ = null;
            }
          else _ = null;
          m !== null && y2(d, p, m, _, !1),
            v !== null && y !== null && y2(d, y, v, _, !0);
        }
      }
      e: {
        if (
          ((p = c ? zu(c) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var C = Vz;
        else if (u2(p))
          if (BI) C = $z;
          else {
            C = Wz;
            var M = Gz;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (C = jz);
        if (C && (C = C(t, c))) {
          zI(d, C, n, u);
          break e;
        }
        M && M(t, p, c),
          t === "focusout" &&
            (M = p._wrapperState) &&
            M.controlled &&
            p.type === "number" &&
            hS(p, "number", p.value);
      }
      switch (((M = c ? zu(c) : window), t)) {
        case "focusin":
          (u2(M) || M.contentEditable === "true") &&
            ((Uu = M), (ES = c), (oh = null));
          break;
        case "focusout":
          oh = ES = Uu = null;
          break;
        case "mousedown":
          MS = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (MS = !1), m2(d, n, u);
          break;
        case "selectionchange":
          if (qz) break;
        case "keydown":
        case "keyup":
          m2(d, n, u);
      }
      var T;
      if (gw)
        e: {
          switch (t) {
            case "compositionstart":
              var P = "onCompositionStart";
              break e;
            case "compositionend":
              P = "onCompositionEnd";
              break e;
            case "compositionupdate":
              P = "onCompositionUpdate";
              break e;
          }
          P = void 0;
        }
      else
        Fu
          ? UI(t, n) && (P = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (P = "onCompositionStart");
      P &&
        (FI &&
          n.locale !== "ko" &&
          (Fu || P !== "onCompositionStart"
            ? P === "onCompositionEnd" && Fu && (T = DI())
            : ((Ua = u),
              (hw = "value" in Ua ? Ua.value : Ua.textContent),
              (Fu = !0))),
        (M = K0(c, P)),
        0 < M.length &&
          ((P = new s2(P, t, null, n, u)),
          d.push({ event: P, listeners: M }),
          T ? (P.data = T) : ((T = kI(n)), T !== null && (P.data = T)))),
        (T = Uz ? kz(t, n) : zz(t, n)) &&
          ((c = K0(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new s2("onBeforeInput", "beforeinput", null, n, u)),
            d.push({ event: u, listeners: c }),
            (u.data = T)));
    }
    KI(d, e);
  });
}
function Ph(t, e, n) {
  return { instance: t, listener: e, currentTarget: n };
}
function K0(t, e) {
  for (var n = e + "Capture", r = []; t !== null; ) {
    var i = t,
      o = i.stateNode;
    i.tag === 5 &&
      o !== null &&
      ((i = o),
      (o = bh(t, n)),
      o != null && r.unshift(Ph(t, o, i)),
      (o = bh(t, e)),
      o != null && r.push(Ph(t, o, i))),
      (t = t.return);
  }
  return r;
}
function nu(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function y2(t, e, n, r, i) {
  for (var o = e._reactName, s = []; n !== null && n !== r; ) {
    var a = n,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      i
        ? ((l = bh(n, o)), l != null && s.unshift(Ph(n, l, a)))
        : i || ((l = bh(n, o)), l != null && s.push(Ph(n, l, a)))),
      (n = n.return);
  }
  s.length !== 0 && t.push({ event: e, listeners: s });
}
var Qz = /\r\n?/g,
  eB = /\u0000|\uFFFD/g;
function x2(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      Qz,
      `
`
    )
    .replace(eB, "");
}
function Xm(t, e, n) {
  if (((e = x2(e)), x2(t) !== e && n)) throw Error(Xe(425));
}
function Z0() {}
var CS = null,
  TS = null;
function RS(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var PS = typeof setTimeout == "function" ? setTimeout : void 0,
  tB = typeof clearTimeout == "function" ? clearTimeout : void 0,
  _2 = typeof Promise == "function" ? Promise : void 0,
  nB =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof _2 < "u"
      ? function (t) {
          return _2.resolve(null).then(t).catch(rB);
        }
      : PS;
function rB(t) {
  setTimeout(function () {
    throw t;
  });
}
function x1(t, e) {
  var n = e,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((t.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          t.removeChild(i), Mh(e);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  Mh(e);
}
function ja(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function S2(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var Of = Math.random().toString(36).slice(2),
  as = "__reactFiber$" + Of,
  Ih = "__reactProps$" + Of,
  qs = "__reactContainer$" + Of,
  IS = "__reactEvents$" + Of,
  iB = "__reactListeners$" + Of,
  oB = "__reactHandles$" + Of;
function Zl(t) {
  var e = t[as];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[qs] || n[as])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = S2(t); t !== null; ) {
          if ((n = t[as])) return n;
          t = S2(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function Mp(t) {
  return (
    (t = t[as] || t[qs]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function zu(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(Xe(33));
}
function Hv(t) {
  return t[Ih] || null;
}
var LS = [],
  Bu = -1;
function ol(t) {
  return { current: t };
}
function vn(t) {
  0 > Bu || ((t.current = LS[Bu]), (LS[Bu] = null), Bu--);
}
function mn(t, e) {
  Bu++, (LS[Bu] = t.current), (t.current = e);
}
var Qa = {},
  Xr = ol(Qa),
  Ai = ol(!1),
  xc = Qa;
function df(t, e) {
  var n = t.type.contextTypes;
  if (!n) return Qa;
  var r = t.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    o;
  for (o in n) i[o] = e[o];
  return (
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function bi(t) {
  return (t = t.childContextTypes), t != null;
}
function J0() {
  vn(Ai), vn(Xr);
}
function A2(t, e, n) {
  if (Xr.current !== Qa) throw Error(Xe(168));
  mn(Xr, e), mn(Ai, n);
}
function JI(t, e, n) {
  var r = t.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(Xe(108, Gk(t) || "Unknown", i));
  return Pn({}, n, r);
}
function Q0(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || Qa),
    (xc = Xr.current),
    mn(Xr, t),
    mn(Ai, Ai.current),
    !0
  );
}
function b2(t, e, n) {
  var r = t.stateNode;
  if (!r) throw Error(Xe(169));
  n
    ? ((t = JI(t, e, xc)),
      (r.__reactInternalMemoizedMergedChildContext = t),
      vn(Ai),
      vn(Xr),
      mn(Xr, t))
    : vn(Ai),
    mn(Ai, n);
}
var Us = null,
  Vv = !1,
  _1 = !1;
function QI(t) {
  Us === null ? (Us = [t]) : Us.push(t);
}
function sB(t) {
  (Vv = !0), QI(t);
}
function sl() {
  if (!_1 && Us !== null) {
    _1 = !0;
    var t = 0,
      e = on;
    try {
      var n = Us;
      for (on = 1; t < n.length; t++) {
        var r = n[t];
        do r = r(!0);
        while (r !== null);
      }
      (Us = null), (Vv = !1);
    } catch (i) {
      throw (Us !== null && (Us = Us.slice(t + 1)), wI(cw, sl), i);
    } finally {
      (on = e), (_1 = !1);
    }
  }
  return null;
}
var Hu = [],
  Vu = 0,
  ev = null,
  tv = 0,
  ho = [],
  po = 0,
  _c = null,
  Hs = 1,
  Vs = "";
function Vl(t, e) {
  (Hu[Vu++] = tv), (Hu[Vu++] = ev), (ev = t), (tv = e);
}
function eL(t, e, n) {
  (ho[po++] = Hs), (ho[po++] = Vs), (ho[po++] = _c), (_c = t);
  var r = Hs;
  t = Vs;
  var i = 32 - zo(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var o = 32 - zo(e) + i;
  if (30 < o) {
    var s = i - (i % 5);
    (o = (r & ((1 << s) - 1)).toString(32)),
      (r >>= s),
      (i -= s),
      (Hs = (1 << (32 - zo(e) + i)) | (n << i) | r),
      (Vs = o + t);
  } else (Hs = (1 << o) | (n << i) | r), (Vs = t);
}
function yw(t) {
  t.return !== null && (Vl(t, 1), eL(t, 1, 0));
}
function xw(t) {
  for (; t === ev; )
    (ev = Hu[--Vu]), (Hu[Vu] = null), (tv = Hu[--Vu]), (Hu[Vu] = null);
  for (; t === _c; )
    (_c = ho[--po]),
      (ho[po] = null),
      (Vs = ho[--po]),
      (ho[po] = null),
      (Hs = ho[--po]),
      (ho[po] = null);
}
var $i = null,
  Wi = null,
  _n = !1,
  Fo = null;
function tL(t, e) {
  var n = go(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function w2(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), ($i = t), (Wi = ja(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), ($i = t), (Wi = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n = _c !== null ? { id: Hs, overflow: Vs } : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = go(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            ($i = t),
            (Wi = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function OS(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function NS(t) {
  if (_n) {
    var e = Wi;
    if (e) {
      var n = e;
      if (!w2(t, e)) {
        if (OS(t)) throw Error(Xe(418));
        e = ja(n.nextSibling);
        var r = $i;
        e && w2(t, e)
          ? tL(r, n)
          : ((t.flags = (t.flags & -4097) | 2), (_n = !1), ($i = t));
      }
    } else {
      if (OS(t)) throw Error(Xe(418));
      (t.flags = (t.flags & -4097) | 2), (_n = !1), ($i = t);
    }
  }
}
function E2(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  $i = t;
}
function Ym(t) {
  if (t !== $i) return !1;
  if (!_n) return E2(t), (_n = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !RS(t.type, t.memoizedProps))),
    e && (e = Wi))
  ) {
    if (OS(t)) throw (nL(), Error(Xe(418)));
    for (; e; ) tL(t, e), (e = ja(e.nextSibling));
  }
  if ((E2(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(Xe(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              Wi = ja(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      Wi = null;
    }
  } else Wi = $i ? ja(t.stateNode.nextSibling) : null;
  return !0;
}
function nL() {
  for (var t = Wi; t; ) t = ja(t.nextSibling);
}
function hf() {
  (Wi = $i = null), (_n = !1);
}
function _w(t) {
  Fo === null ? (Fo = [t]) : Fo.push(t);
}
var aB = ra.ReactCurrentBatchConfig;
function Ad(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(Xe(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(Xe(147, t));
      var i = r,
        o = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === o
        ? e.ref
        : ((e = function (s) {
            var a = i.refs;
            s === null ? delete a[o] : (a[o] = s);
          }),
          (e._stringRef = o),
          e);
    }
    if (typeof t != "string") throw Error(Xe(284));
    if (!n._owner) throw Error(Xe(290, t));
  }
  return t;
}
function qm(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      Xe(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function M2(t) {
  var e = t._init;
  return e(t._payload);
}
function rL(t) {
  function e(g, x) {
    if (t) {
      var S = g.deletions;
      S === null ? ((g.deletions = [x]), (g.flags |= 16)) : S.push(x);
    }
  }
  function n(g, x) {
    if (!t) return null;
    for (; x !== null; ) e(g, x), (x = x.sibling);
    return null;
  }
  function r(g, x) {
    for (g = new Map(); x !== null; )
      x.key !== null ? g.set(x.key, x) : g.set(x.index, x), (x = x.sibling);
    return g;
  }
  function i(g, x) {
    return (g = qa(g, x)), (g.index = 0), (g.sibling = null), g;
  }
  function o(g, x, S) {
    return (
      (g.index = S),
      t
        ? ((S = g.alternate),
          S !== null
            ? ((S = S.index), S < x ? ((g.flags |= 2), x) : S)
            : ((g.flags |= 2), x))
        : ((g.flags |= 1048576), x)
    );
  }
  function s(g) {
    return t && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, x, S, b) {
    return x === null || x.tag !== 6
      ? ((x = C1(S, g.mode, b)), (x.return = g), x)
      : ((x = i(x, S)), (x.return = g), x);
  }
  function l(g, x, S, b) {
    var C = S.type;
    return C === Du
      ? u(g, x, S.props.children, b, S.key)
      : x !== null &&
        (x.elementType === C ||
          (typeof C == "object" &&
            C !== null &&
            C.$$typeof === Pa &&
            M2(C) === x.type))
      ? ((b = i(x, S.props)), (b.ref = Ad(g, x, S)), (b.return = g), b)
      : ((b = A0(S.type, S.key, S.props, null, g.mode, b)),
        (b.ref = Ad(g, x, S)),
        (b.return = g),
        b);
  }
  function c(g, x, S, b) {
    return x === null ||
      x.tag !== 4 ||
      x.stateNode.containerInfo !== S.containerInfo ||
      x.stateNode.implementation !== S.implementation
      ? ((x = T1(S, g.mode, b)), (x.return = g), x)
      : ((x = i(x, S.children || [])), (x.return = g), x);
  }
  function u(g, x, S, b, C) {
    return x === null || x.tag !== 7
      ? ((x = cc(S, g.mode, b, C)), (x.return = g), x)
      : ((x = i(x, S)), (x.return = g), x);
  }
  function d(g, x, S) {
    if ((typeof x == "string" && x !== "") || typeof x == "number")
      return (x = C1("" + x, g.mode, S)), (x.return = g), x;
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case km:
          return (
            (S = A0(x.type, x.key, x.props, null, g.mode, S)),
            (S.ref = Ad(g, null, x)),
            (S.return = g),
            S
          );
        case Nu:
          return (x = T1(x, g.mode, S)), (x.return = g), x;
        case Pa:
          var b = x._init;
          return d(g, b(x._payload), S);
      }
      if (Wd(x) || vd(x))
        return (x = cc(x, g.mode, S, null)), (x.return = g), x;
      qm(g, x);
    }
    return null;
  }
  function p(g, x, S, b) {
    var C = x !== null ? x.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return C !== null ? null : a(g, x, "" + S, b);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case km:
          return S.key === C ? l(g, x, S, b) : null;
        case Nu:
          return S.key === C ? c(g, x, S, b) : null;
        case Pa:
          return (C = S._init), p(g, x, C(S._payload), b);
      }
      if (Wd(S) || vd(S)) return C !== null ? null : u(g, x, S, b, null);
      qm(g, S);
    }
    return null;
  }
  function m(g, x, S, b, C) {
    if ((typeof b == "string" && b !== "") || typeof b == "number")
      return (g = g.get(S) || null), a(x, g, "" + b, C);
    if (typeof b == "object" && b !== null) {
      switch (b.$$typeof) {
        case km:
          return (g = g.get(b.key === null ? S : b.key) || null), l(x, g, b, C);
        case Nu:
          return (g = g.get(b.key === null ? S : b.key) || null), c(x, g, b, C);
        case Pa:
          var M = b._init;
          return m(g, x, S, M(b._payload), C);
      }
      if (Wd(b) || vd(b)) return (g = g.get(S) || null), u(x, g, b, C, null);
      qm(x, b);
    }
    return null;
  }
  function v(g, x, S, b) {
    for (
      var C = null, M = null, T = x, P = (x = 0), R = null;
      T !== null && P < S.length;
      P++
    ) {
      T.index > P ? ((R = T), (T = null)) : (R = T.sibling);
      var E = p(g, T, S[P], b);
      if (E === null) {
        T === null && (T = R);
        break;
      }
      t && T && E.alternate === null && e(g, T),
        (x = o(E, x, P)),
        M === null ? (C = E) : (M.sibling = E),
        (M = E),
        (T = R);
    }
    if (P === S.length) return n(g, T), _n && Vl(g, P), C;
    if (T === null) {
      for (; P < S.length; P++)
        (T = d(g, S[P], b)),
          T !== null &&
            ((x = o(T, x, P)), M === null ? (C = T) : (M.sibling = T), (M = T));
      return _n && Vl(g, P), C;
    }
    for (T = r(g, T); P < S.length; P++)
      (R = m(T, g, P, S[P], b)),
        R !== null &&
          (t && R.alternate !== null && T.delete(R.key === null ? P : R.key),
          (x = o(R, x, P)),
          M === null ? (C = R) : (M.sibling = R),
          (M = R));
    return (
      t &&
        T.forEach(function (O) {
          return e(g, O);
        }),
      _n && Vl(g, P),
      C
    );
  }
  function _(g, x, S, b) {
    var C = vd(S);
    if (typeof C != "function") throw Error(Xe(150));
    if (((S = C.call(S)), S == null)) throw Error(Xe(151));
    for (
      var M = (C = null), T = x, P = (x = 0), R = null, E = S.next();
      T !== null && !E.done;
      P++, E = S.next()
    ) {
      T.index > P ? ((R = T), (T = null)) : (R = T.sibling);
      var O = p(g, T, E.value, b);
      if (O === null) {
        T === null && (T = R);
        break;
      }
      t && T && O.alternate === null && e(g, T),
        (x = o(O, x, P)),
        M === null ? (C = O) : (M.sibling = O),
        (M = O),
        (T = R);
    }
    if (E.done) return n(g, T), _n && Vl(g, P), C;
    if (T === null) {
      for (; !E.done; P++, E = S.next())
        (E = d(g, E.value, b)),
          E !== null &&
            ((x = o(E, x, P)), M === null ? (C = E) : (M.sibling = E), (M = E));
      return _n && Vl(g, P), C;
    }
    for (T = r(g, T); !E.done; P++, E = S.next())
      (E = m(T, g, P, E.value, b)),
        E !== null &&
          (t && E.alternate !== null && T.delete(E.key === null ? P : E.key),
          (x = o(E, x, P)),
          M === null ? (C = E) : (M.sibling = E),
          (M = E));
    return (
      t &&
        T.forEach(function (D) {
          return e(g, D);
        }),
      _n && Vl(g, P),
      C
    );
  }
  function y(g, x, S, b) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === Du &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case km:
          e: {
            for (var C = S.key, M = x; M !== null; ) {
              if (M.key === C) {
                if (((C = S.type), C === Du)) {
                  if (M.tag === 7) {
                    n(g, M.sibling),
                      (x = i(M, S.props.children)),
                      (x.return = g),
                      (g = x);
                    break e;
                  }
                } else if (
                  M.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === Pa &&
                    M2(C) === M.type)
                ) {
                  n(g, M.sibling),
                    (x = i(M, S.props)),
                    (x.ref = Ad(g, M, S)),
                    (x.return = g),
                    (g = x);
                  break e;
                }
                n(g, M);
                break;
              } else e(g, M);
              M = M.sibling;
            }
            S.type === Du
              ? ((x = cc(S.props.children, g.mode, b, S.key)),
                (x.return = g),
                (g = x))
              : ((b = A0(S.type, S.key, S.props, null, g.mode, b)),
                (b.ref = Ad(g, x, S)),
                (b.return = g),
                (g = b));
          }
          return s(g);
        case Nu:
          e: {
            for (M = S.key; x !== null; ) {
              if (x.key === M)
                if (
                  x.tag === 4 &&
                  x.stateNode.containerInfo === S.containerInfo &&
                  x.stateNode.implementation === S.implementation
                ) {
                  n(g, x.sibling),
                    (x = i(x, S.children || [])),
                    (x.return = g),
                    (g = x);
                  break e;
                } else {
                  n(g, x);
                  break;
                }
              else e(g, x);
              x = x.sibling;
            }
            (x = T1(S, g.mode, b)), (x.return = g), (g = x);
          }
          return s(g);
        case Pa:
          return (M = S._init), y(g, x, M(S._payload), b);
      }
      if (Wd(S)) return v(g, x, S, b);
      if (vd(S)) return _(g, x, S, b);
      qm(g, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        x !== null && x.tag === 6
          ? (n(g, x.sibling), (x = i(x, S)), (x.return = g), (g = x))
          : (n(g, x), (x = C1(S, g.mode, b)), (x.return = g), (g = x)),
        s(g))
      : n(g, x);
  }
  return y;
}
var pf = rL(!0),
  iL = rL(!1),
  nv = ol(null),
  rv = null,
  Gu = null,
  Sw = null;
function Aw() {
  Sw = Gu = rv = null;
}
function bw(t) {
  var e = nv.current;
  vn(nv), (t._currentValue = e);
}
function DS(t, e, n) {
  for (; t !== null; ) {
    var r = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function sf(t, e) {
  (rv = t),
    (Sw = Gu = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (_i = !0), (t.firstContext = null));
}
function _o(t) {
  var e = t._currentValue;
  if (Sw !== t)
    if (((t = { context: t, memoizedValue: e, next: null }), Gu === null)) {
      if (rv === null) throw Error(Xe(308));
      (Gu = t), (rv.dependencies = { lanes: 0, firstContext: t });
    } else Gu = Gu.next = t;
  return e;
}
var Jl = null;
function ww(t) {
  Jl === null ? (Jl = [t]) : Jl.push(t);
}
function oL(t, e, n, r) {
  var i = e.interleaved;
  return (
    i === null ? ((n.next = n), ww(e)) : ((n.next = i.next), (i.next = n)),
    (e.interleaved = n),
    Ks(t, r)
  );
}
function Ks(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var Ia = !1;
function Ew(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function sL(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function Ws(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function $a(t, e, n) {
  var r = t.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), Kt & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Ks(t, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), ww(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Ks(t, n)
  );
}
function g0(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), uw(t, n);
  }
}
function C2(t, e) {
  var n = t.updateQueue,
    r = t.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      o = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var s = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        o === null ? (i = o = s) : (o = o.next = s), (n = n.next);
      } while (n !== null);
      o === null ? (i = o = e) : (o = o.next = e);
    } else i = o = e;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: o,
      shared: r.shared,
      effects: r.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function iv(t, e, n, r) {
  var i = t.updateQueue;
  Ia = !1;
  var o = i.firstBaseUpdate,
    s = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), s === null ? (o = c) : (s.next = c), (s = l);
    var u = t.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== s &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (o !== null) {
    var d = i.baseState;
    (s = 0), (u = c = l = null), (a = o);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((r & p) === p) {
        u !== null &&
          (u = u.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = t,
            _ = a;
          switch (((p = e), (m = n), _.tag)) {
            case 1:
              if (((v = _.payload), typeof v == "function")) {
                d = v.call(m, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = _.payload),
                (p = typeof v == "function" ? v.call(m, d, p) : v),
                p == null)
              )
                break e;
              d = Pn({}, d, p);
              break e;
            case 2:
              Ia = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((t.flags |= 64),
          (p = i.effects),
          p === null ? (i.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = m), (l = d)) : (u = u.next = m),
          (s |= p);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (i.lastBaseUpdate = p),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = d),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (s |= i.lane), (i = i.next);
      while (i !== e);
    } else o === null && (i.shared.lanes = 0);
    (Ac |= s), (t.lanes = s), (t.memoizedState = d);
  }
}
function T2(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(Xe(191, i));
        i.call(r);
      }
    }
}
var Cp = {},
  ds = ol(Cp),
  Lh = ol(Cp),
  Oh = ol(Cp);
function Ql(t) {
  if (t === Cp) throw Error(Xe(174));
  return t;
}
function Mw(t, e) {
  switch ((mn(Oh, e), mn(Lh, t), mn(ds, Cp), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : mS(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = mS(e, t));
  }
  vn(ds), mn(ds, e);
}
function mf() {
  vn(ds), vn(Lh), vn(Oh);
}
function aL(t) {
  Ql(Oh.current);
  var e = Ql(ds.current),
    n = mS(e, t.type);
  e !== n && (mn(Lh, t), mn(ds, n));
}
function Cw(t) {
  Lh.current === t && (vn(ds), vn(Lh));
}
var wn = ol(0);
function ov(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var S1 = [];
function Tw() {
  for (var t = 0; t < S1.length; t++)
    S1[t]._workInProgressVersionPrimary = null;
  S1.length = 0;
}
var v0 = ra.ReactCurrentDispatcher,
  A1 = ra.ReactCurrentBatchConfig,
  Sc = 0,
  Rn = null,
  nr = null,
  yr = null,
  sv = !1,
  sh = !1,
  Nh = 0,
  lB = 0;
function kr() {
  throw Error(Xe(321));
}
function Rw(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!Go(t[n], e[n])) return !1;
  return !0;
}
function Pw(t, e, n, r, i, o) {
  if (
    ((Sc = o),
    (Rn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (v0.current = t === null || t.memoizedState === null ? dB : hB),
    (t = n(r, i)),
    sh)
  ) {
    o = 0;
    do {
      if (((sh = !1), (Nh = 0), 25 <= o)) throw Error(Xe(301));
      (o += 1),
        (yr = nr = null),
        (e.updateQueue = null),
        (v0.current = pB),
        (t = n(r, i));
    } while (sh);
  }
  if (
    ((v0.current = av),
    (e = nr !== null && nr.next !== null),
    (Sc = 0),
    (yr = nr = Rn = null),
    (sv = !1),
    e)
  )
    throw Error(Xe(300));
  return t;
}
function Iw() {
  var t = Nh !== 0;
  return (Nh = 0), t;
}
function is() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return yr === null ? (Rn.memoizedState = yr = t) : (yr = yr.next = t), yr;
}
function So() {
  if (nr === null) {
    var t = Rn.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = nr.next;
  var e = yr === null ? Rn.memoizedState : yr.next;
  if (e !== null) (yr = e), (nr = t);
  else {
    if (t === null) throw Error(Xe(310));
    (nr = t),
      (t = {
        memoizedState: nr.memoizedState,
        baseState: nr.baseState,
        baseQueue: nr.baseQueue,
        queue: nr.queue,
        next: null,
      }),
      yr === null ? (Rn.memoizedState = yr = t) : (yr = yr.next = t);
  }
  return yr;
}
function Dh(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function b1(t) {
  var e = So(),
    n = e.queue;
  if (n === null) throw Error(Xe(311));
  n.lastRenderedReducer = t;
  var r = nr,
    i = r.baseQueue,
    o = n.pending;
  if (o !== null) {
    if (i !== null) {
      var s = i.next;
      (i.next = o.next), (o.next = s);
    }
    (r.baseQueue = i = o), (n.pending = null);
  }
  if (i !== null) {
    (o = i.next), (r = r.baseState);
    var a = (s = null),
      l = null,
      c = o;
    do {
      var u = c.lane;
      if ((Sc & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : t(r, c.action));
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (s = r)) : (l = l.next = d),
          (Rn.lanes |= u),
          (Ac |= u);
      }
      c = c.next;
    } while (c !== null && c !== o);
    l === null ? (s = r) : (l.next = a),
      Go(r, e.memoizedState) || (_i = !0),
      (e.memoizedState = r),
      (e.baseState = s),
      (e.baseQueue = l),
      (n.lastRenderedState = r);
  }
  if (((t = n.interleaved), t !== null)) {
    i = t;
    do (o = i.lane), (Rn.lanes |= o), (Ac |= o), (i = i.next);
    while (i !== t);
  } else i === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function w1(t) {
  var e = So(),
    n = e.queue;
  if (n === null) throw Error(Xe(311));
  n.lastRenderedReducer = t;
  var r = n.dispatch,
    i = n.pending,
    o = e.memoizedState;
  if (i !== null) {
    n.pending = null;
    var s = (i = i.next);
    do (o = t(o, s.action)), (s = s.next);
    while (s !== i);
    Go(o, e.memoizedState) || (_i = !0),
      (e.memoizedState = o),
      e.baseQueue === null && (e.baseState = o),
      (n.lastRenderedState = o);
  }
  return [o, r];
}
function lL() {}
function cL(t, e) {
  var n = Rn,
    r = So(),
    i = e(),
    o = !Go(r.memoizedState, i);
  if (
    (o && ((r.memoizedState = i), (_i = !0)),
    (r = r.queue),
    Lw(dL.bind(null, n, r, t), [t]),
    r.getSnapshot !== e || o || (yr !== null && yr.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Fh(9, fL.bind(null, n, r, i, e), void 0, null),
      _r === null)
    )
      throw Error(Xe(349));
    Sc & 30 || uL(n, e, i);
  }
  return i;
}
function uL(t, e, n) {
  (t.flags |= 16384),
    (t = { getSnapshot: e, value: n }),
    (e = Rn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Rn.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function fL(t, e, n, r) {
  (e.value = n), (e.getSnapshot = r), hL(e) && pL(t);
}
function dL(t, e, n) {
  return n(function () {
    hL(e) && pL(t);
  });
}
function hL(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !Go(t, n);
  } catch {
    return !0;
  }
}
function pL(t) {
  var e = Ks(t, 1);
  e !== null && Bo(e, t, 1, -1);
}
function R2(t) {
  var e = is();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Dh,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = fB.bind(null, Rn, t)),
    [e.memoizedState, t]
  );
}
function Fh(t, e, n, r) {
  return (
    (t = { tag: t, create: e, destroy: n, deps: r, next: null }),
    (e = Rn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Rn.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((r = n.next), (n.next = t), (t.next = r), (e.lastEffect = t))),
    t
  );
}
function mL() {
  return So().memoizedState;
}
function y0(t, e, n, r) {
  var i = is();
  (Rn.flags |= t),
    (i.memoizedState = Fh(1 | e, n, void 0, r === void 0 ? null : r));
}
function Gv(t, e, n, r) {
  var i = So();
  r = r === void 0 ? null : r;
  var o = void 0;
  if (nr !== null) {
    var s = nr.memoizedState;
    if (((o = s.destroy), r !== null && Rw(r, s.deps))) {
      i.memoizedState = Fh(e, n, o, r);
      return;
    }
  }
  (Rn.flags |= t), (i.memoizedState = Fh(1 | e, n, o, r));
}
function P2(t, e) {
  return y0(8390656, 8, t, e);
}
function Lw(t, e) {
  return Gv(2048, 8, t, e);
}
function gL(t, e) {
  return Gv(4, 2, t, e);
}
function vL(t, e) {
  return Gv(4, 4, t, e);
}
function yL(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function xL(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), Gv(4, 4, yL.bind(null, e, t), n)
  );
}
function Ow() {}
function _L(t, e) {
  var n = So();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Rw(e, r[1])
    ? r[0]
    : ((n.memoizedState = [t, e]), t);
}
function SL(t, e) {
  var n = So();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Rw(e, r[1])
    ? r[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function AL(t, e, n) {
  return Sc & 21
    ? (Go(n, e) || ((n = CI()), (Rn.lanes |= n), (Ac |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (_i = !0)), (t.memoizedState = n));
}
function cB(t, e) {
  var n = on;
  (on = n !== 0 && 4 > n ? n : 4), t(!0);
  var r = A1.transition;
  A1.transition = {};
  try {
    t(!1), e();
  } finally {
    (on = n), (A1.transition = r);
  }
}
function bL() {
  return So().memoizedState;
}
function uB(t, e, n) {
  var r = Ya(t);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    wL(t))
  )
    EL(e, n);
  else if (((n = oL(t, e, n, r)), n !== null)) {
    var i = ai();
    Bo(n, t, r, i), ML(n, e, r);
  }
}
function fB(t, e, n) {
  var r = Ya(t),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (wL(t)) EL(e, i);
  else {
    var o = t.alternate;
    if (
      t.lanes === 0 &&
      (o === null || o.lanes === 0) &&
      ((o = e.lastRenderedReducer), o !== null)
    )
      try {
        var s = e.lastRenderedState,
          a = o(s, n);
        if (((i.hasEagerState = !0), (i.eagerState = a), Go(a, s))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), ww(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = oL(t, e, i, r)),
      n !== null && ((i = ai()), Bo(n, t, r, i), ML(n, e, r));
  }
}
function wL(t) {
  var e = t.alternate;
  return t === Rn || (e !== null && e === Rn);
}
function EL(t, e) {
  sh = sv = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function ML(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes;
    (r &= t.pendingLanes), (n |= r), (e.lanes = n), uw(t, n);
  }
}
var av = {
    readContext: _o,
    useCallback: kr,
    useContext: kr,
    useEffect: kr,
    useImperativeHandle: kr,
    useInsertionEffect: kr,
    useLayoutEffect: kr,
    useMemo: kr,
    useReducer: kr,
    useRef: kr,
    useState: kr,
    useDebugValue: kr,
    useDeferredValue: kr,
    useTransition: kr,
    useMutableSource: kr,
    useSyncExternalStore: kr,
    useId: kr,
    unstable_isNewReconciler: !1,
  },
  dB = {
    readContext: _o,
    useCallback: function (t, e) {
      return (is().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: _o,
    useEffect: P2,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        y0(4194308, 4, yL.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return y0(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return y0(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = is();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var r = is();
      return (
        (e = n !== void 0 ? n(e) : e),
        (r.memoizedState = r.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (r.queue = t),
        (t = t.dispatch = uB.bind(null, Rn, t)),
        [r.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = is();
      return (t = { current: t }), (e.memoizedState = t);
    },
    useState: R2,
    useDebugValue: Ow,
    useDeferredValue: function (t) {
      return (is().memoizedState = t);
    },
    useTransition: function () {
      var t = R2(!1),
        e = t[0];
      return (t = cB.bind(null, t[1])), (is().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var r = Rn,
        i = is();
      if (_n) {
        if (n === void 0) throw Error(Xe(407));
        n = n();
      } else {
        if (((n = e()), _r === null)) throw Error(Xe(349));
        Sc & 30 || uL(r, e, n);
      }
      i.memoizedState = n;
      var o = { value: n, getSnapshot: e };
      return (
        (i.queue = o),
        P2(dL.bind(null, r, o, t), [t]),
        (r.flags |= 2048),
        Fh(9, fL.bind(null, r, o, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = is(),
        e = _r.identifierPrefix;
      if (_n) {
        var n = Vs,
          r = Hs;
        (n = (r & ~(1 << (32 - zo(r) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = Nh++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = lB++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  hB = {
    readContext: _o,
    useCallback: _L,
    useContext: _o,
    useEffect: Lw,
    useImperativeHandle: xL,
    useInsertionEffect: gL,
    useLayoutEffect: vL,
    useMemo: SL,
    useReducer: b1,
    useRef: mL,
    useState: function () {
      return b1(Dh);
    },
    useDebugValue: Ow,
    useDeferredValue: function (t) {
      var e = So();
      return AL(e, nr.memoizedState, t);
    },
    useTransition: function () {
      var t = b1(Dh)[0],
        e = So().memoizedState;
      return [t, e];
    },
    useMutableSource: lL,
    useSyncExternalStore: cL,
    useId: bL,
    unstable_isNewReconciler: !1,
  },
  pB = {
    readContext: _o,
    useCallback: _L,
    useContext: _o,
    useEffect: Lw,
    useImperativeHandle: xL,
    useInsertionEffect: gL,
    useLayoutEffect: vL,
    useMemo: SL,
    useReducer: w1,
    useRef: mL,
    useState: function () {
      return w1(Dh);
    },
    useDebugValue: Ow,
    useDeferredValue: function (t) {
      var e = So();
      return nr === null ? (e.memoizedState = t) : AL(e, nr.memoizedState, t);
    },
    useTransition: function () {
      var t = w1(Dh)[0],
        e = So().memoizedState;
      return [t, e];
    },
    useMutableSource: lL,
    useSyncExternalStore: cL,
    useId: bL,
    unstable_isNewReconciler: !1,
  };
function Io(t, e) {
  if (t && t.defaultProps) {
    (e = Pn({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
function FS(t, e, n, r) {
  (e = t.memoizedState),
    (n = n(r, e)),
    (n = n == null ? e : Pn({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var Wv = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? Lc(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var r = ai(),
      i = Ya(t),
      o = Ws(r, i);
    (o.payload = e),
      n != null && (o.callback = n),
      (e = $a(t, o, i)),
      e !== null && (Bo(e, t, i, r), g0(e, t, i));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var r = ai(),
      i = Ya(t),
      o = Ws(r, i);
    (o.tag = 1),
      (o.payload = e),
      n != null && (o.callback = n),
      (e = $a(t, o, i)),
      e !== null && (Bo(e, t, i, r), g0(e, t, i));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = ai(),
      r = Ya(t),
      i = Ws(n, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = $a(t, i, r)),
      e !== null && (Bo(e, t, r, n), g0(e, t, r));
  },
};
function I2(t, e, n, r, i, o, s) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(r, o, s)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Th(n, r) || !Th(i, o)
      : !0
  );
}
function CL(t, e, n) {
  var r = !1,
    i = Qa,
    o = e.contextType;
  return (
    typeof o == "object" && o !== null
      ? (o = _o(o))
      : ((i = bi(e) ? xc : Xr.current),
        (r = e.contextTypes),
        (o = (r = r != null) ? df(t, i) : Qa)),
    (e = new e(n, o)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Wv),
    (t.stateNode = e),
    (e._reactInternals = t),
    r &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = i),
      (t.__reactInternalMemoizedMaskedChildContext = o)),
    e
  );
}
function L2(t, e, n, r) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, r),
    e.state !== t && Wv.enqueueReplaceState(e, e.state, null);
}
function US(t, e, n, r) {
  var i = t.stateNode;
  (i.props = n), (i.state = t.memoizedState), (i.refs = {}), Ew(t);
  var o = e.contextType;
  typeof o == "object" && o !== null
    ? (i.context = _o(o))
    : ((o = bi(e) ? xc : Xr.current), (i.context = df(t, o))),
    (i.state = t.memoizedState),
    (o = e.getDerivedStateFromProps),
    typeof o == "function" && (FS(t, e, o, n), (i.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && Wv.enqueueReplaceState(i, i.state, null),
      iv(t, n, i, r),
      (i.state = t.memoizedState)),
    typeof i.componentDidMount == "function" && (t.flags |= 4194308);
}
function gf(t, e) {
  try {
    var n = "",
      r = e;
    do (n += Vk(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (o) {
    i =
      `
Error generating stack: ` +
      o.message +
      `
` +
      o.stack;
  }
  return { value: t, source: e, stack: i, digest: null };
}
function E1(t, e, n) {
  return { value: t, source: null, stack: n ?? null, digest: e ?? null };
}
function kS(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var mB = typeof WeakMap == "function" ? WeakMap : Map;
function TL(t, e, n) {
  (n = Ws(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = e.value;
  return (
    (n.callback = function () {
      cv || ((cv = !0), (YS = r)), kS(t, e);
    }),
    n
  );
}
function RL(t, e, n) {
  (n = Ws(-1, n)), (n.tag = 3);
  var r = t.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        kS(t, e);
      });
  }
  var o = t.stateNode;
  return (
    o !== null &&
      typeof o.componentDidCatch == "function" &&
      (n.callback = function () {
        kS(t, e),
          typeof r != "function" &&
            (Xa === null ? (Xa = new Set([this])) : Xa.add(this));
        var s = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: s !== null ? s : "",
        });
      }),
    n
  );
}
function O2(t, e, n) {
  var r = t.pingCache;
  if (r === null) {
    r = t.pingCache = new mB();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(n) || (i.add(n), (t = RB.bind(null, t, e, n)), e.then(t, t));
}
function N2(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function D2(t, e, n, r, i) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = i), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = Ws(-1, 1)), (e.tag = 2), $a(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var gB = ra.ReactCurrentOwner,
  _i = !1;
function oi(t, e, n, r) {
  e.child = t === null ? iL(e, null, n, r) : pf(e, t.child, n, r);
}
function F2(t, e, n, r, i) {
  n = n.render;
  var o = e.ref;
  return (
    sf(e, i),
    (r = Pw(t, e, n, r, o, i)),
    (n = Iw()),
    t !== null && !_i
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        Zs(t, e, i))
      : (_n && n && yw(e), (e.flags |= 1), oi(t, e, r, i), e.child)
  );
}
function U2(t, e, n, r, i) {
  if (t === null) {
    var o = n.type;
    return typeof o == "function" &&
      !Hw(o) &&
      o.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = o), PL(t, e, o, r, i))
      : ((t = A0(n.type, null, r, e, e.mode, i)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((o = t.child), !(t.lanes & i))) {
    var s = o.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Th), n(s, r) && t.ref === e.ref)
    )
      return Zs(t, e, i);
  }
  return (
    (e.flags |= 1),
    (t = qa(o, r)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function PL(t, e, n, r, i) {
  if (t !== null) {
    var o = t.memoizedProps;
    if (Th(o, r) && t.ref === e.ref)
      if (((_i = !1), (e.pendingProps = r = o), (t.lanes & i) !== 0))
        t.flags & 131072 && (_i = !0);
      else return (e.lanes = t.lanes), Zs(t, e, i);
  }
  return zS(t, e, n, r, i);
}
function IL(t, e, n) {
  var r = e.pendingProps,
    i = r.children,
    o = t !== null ? t.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        mn(ju, Vi),
        (Vi |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = o !== null ? o.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          mn(ju, Vi),
          (Vi |= t),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = o !== null ? o.baseLanes : n),
        mn(ju, Vi),
        (Vi |= r);
    }
  else
    o !== null ? ((r = o.baseLanes | n), (e.memoizedState = null)) : (r = n),
      mn(ju, Vi),
      (Vi |= r);
  return oi(t, e, i, n), e.child;
}
function LL(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function zS(t, e, n, r, i) {
  var o = bi(n) ? xc : Xr.current;
  return (
    (o = df(e, o)),
    sf(e, i),
    (n = Pw(t, e, n, r, o, i)),
    (r = Iw()),
    t !== null && !_i
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~i),
        Zs(t, e, i))
      : (_n && r && yw(e), (e.flags |= 1), oi(t, e, n, i), e.child)
  );
}
function k2(t, e, n, r, i) {
  if (bi(n)) {
    var o = !0;
    Q0(e);
  } else o = !1;
  if ((sf(e, i), e.stateNode === null))
    x0(t, e), CL(e, n, r), US(e, n, r, i), (r = !0);
  else if (t === null) {
    var s = e.stateNode,
      a = e.memoizedProps;
    s.props = a;
    var l = s.context,
      c = n.contextType;
    typeof c == "object" && c !== null
      ? (c = _o(c))
      : ((c = bi(n) ? xc : Xr.current), (c = df(e, c)));
    var u = n.getDerivedStateFromProps,
      d =
        typeof u == "function" ||
        typeof s.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((a !== r || l !== c) && L2(e, s, r, c)),
      (Ia = !1);
    var p = e.memoizedState;
    (s.state = p),
      iv(e, r, s, i),
      (l = e.memoizedState),
      a !== r || p !== l || Ai.current || Ia
        ? (typeof u == "function" && (FS(e, n, u, r), (l = e.memoizedState)),
          (a = Ia || I2(e, n, a, r, p, l, c))
            ? (d ||
                (typeof s.UNSAFE_componentWillMount != "function" &&
                  typeof s.componentWillMount != "function") ||
                (typeof s.componentWillMount == "function" &&
                  s.componentWillMount(),
                typeof s.UNSAFE_componentWillMount == "function" &&
                  s.UNSAFE_componentWillMount()),
              typeof s.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof s.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (s.props = r),
          (s.state = l),
          (s.context = c),
          (r = a))
        : (typeof s.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (s = e.stateNode),
      sL(t, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : Io(e.type, a)),
      (s.props = c),
      (d = e.pendingProps),
      (p = s.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = _o(l))
        : ((l = bi(n) ? xc : Xr.current), (l = df(e, l)));
    var m = n.getDerivedStateFromProps;
    (u =
      typeof m == "function" ||
      typeof s.getSnapshotBeforeUpdate == "function") ||
      (typeof s.UNSAFE_componentWillReceiveProps != "function" &&
        typeof s.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && L2(e, s, r, l)),
      (Ia = !1),
      (p = e.memoizedState),
      (s.state = p),
      iv(e, r, s, i);
    var v = e.memoizedState;
    a !== d || p !== v || Ai.current || Ia
      ? (typeof m == "function" && (FS(e, n, m, r), (v = e.memoizedState)),
        (c = Ia || I2(e, n, c, r, p, v, l) || !1)
          ? (u ||
              (typeof s.UNSAFE_componentWillUpdate != "function" &&
                typeof s.componentWillUpdate != "function") ||
              (typeof s.componentWillUpdate == "function" &&
                s.componentWillUpdate(r, v, l),
              typeof s.UNSAFE_componentWillUpdate == "function" &&
                s.UNSAFE_componentWillUpdate(r, v, l)),
            typeof s.componentDidUpdate == "function" && (e.flags |= 4),
            typeof s.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof s.componentDidUpdate != "function" ||
              (a === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 4),
            typeof s.getSnapshotBeforeUpdate != "function" ||
              (a === t.memoizedProps && p === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = v)),
        (s.props = r),
        (s.state = v),
        (s.context = l),
        (r = c))
      : (typeof s.componentDidUpdate != "function" ||
          (a === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 4),
        typeof s.getSnapshotBeforeUpdate != "function" ||
          (a === t.memoizedProps && p === t.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return BS(t, e, n, r, o, i);
}
function BS(t, e, n, r, i, o) {
  LL(t, e);
  var s = (e.flags & 128) !== 0;
  if (!r && !s) return i && b2(e, n, !1), Zs(t, e, o);
  (r = e.stateNode), (gB.current = e);
  var a =
    s && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    t !== null && s
      ? ((e.child = pf(e, t.child, null, o)), (e.child = pf(e, null, a, o)))
      : oi(t, e, a, o),
    (e.memoizedState = r.state),
    i && b2(e, n, !0),
    e.child
  );
}
function OL(t) {
  var e = t.stateNode;
  e.pendingContext
    ? A2(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && A2(t, e.context, !1),
    Mw(t, e.containerInfo);
}
function z2(t, e, n, r, i) {
  return hf(), _w(i), (e.flags |= 256), oi(t, e, n, r), e.child;
}
var HS = { dehydrated: null, treeContext: null, retryLane: 0 };
function VS(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function NL(t, e, n) {
  var r = e.pendingProps,
    i = wn.current,
    o = !1,
    s = (e.flags & 128) !== 0,
    a;
  if (
    ((a = s) ||
      (a = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((o = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (i |= 1),
    mn(wn, i & 1),
    t === null)
  )
    return (
      NS(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((s = r.children),
          (t = r.fallback),
          o
            ? ((r = e.mode),
              (o = e.child),
              (s = { mode: "hidden", children: s }),
              !(r & 1) && o !== null
                ? ((o.childLanes = 0), (o.pendingProps = s))
                : (o = Xv(s, r, 0, null)),
              (t = cc(t, r, n, null)),
              (o.return = e),
              (t.return = e),
              (o.sibling = t),
              (e.child = o),
              (e.child.memoizedState = VS(n)),
              (e.memoizedState = HS),
              t)
            : Nw(e, s))
    );
  if (((i = t.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return vB(t, e, s, r, a, i, n);
  if (o) {
    (o = r.fallback), (s = e.mode), (i = t.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(s & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = qa(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (o = qa(a, o)) : ((o = cc(o, s, n, null)), (o.flags |= 2)),
      (o.return = e),
      (r.return = e),
      (r.sibling = o),
      (e.child = r),
      (r = o),
      (o = e.child),
      (s = t.child.memoizedState),
      (s =
        s === null
          ? VS(n)
          : {
              baseLanes: s.baseLanes | n,
              cachePool: null,
              transitions: s.transitions,
            }),
      (o.memoizedState = s),
      (o.childLanes = t.childLanes & ~n),
      (e.memoizedState = HS),
      r
    );
  }
  return (
    (o = t.child),
    (t = o.sibling),
    (r = qa(o, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = n),
    (r.return = e),
    (r.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function Nw(t, e) {
  return (
    (e = Xv({ mode: "visible", children: e }, t.mode, 0, null)),
    (e.return = t),
    (t.child = e)
  );
}
function Km(t, e, n, r) {
  return (
    r !== null && _w(r),
    pf(e, t.child, null, n),
    (t = Nw(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function vB(t, e, n, r, i, o, s) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (r = E1(Error(Xe(422)))), Km(t, e, s, r))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((o = r.fallback),
        (i = e.mode),
        (r = Xv({ mode: "visible", children: r.children }, i, 0, null)),
        (o = cc(o, i, s, null)),
        (o.flags |= 2),
        (r.return = e),
        (o.return = e),
        (r.sibling = o),
        (e.child = r),
        e.mode & 1 && pf(e, t.child, null, s),
        (e.child.memoizedState = VS(s)),
        (e.memoizedState = HS),
        o);
  if (!(e.mode & 1)) return Km(t, e, s, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (o = Error(Xe(419))), (r = E1(o, r, void 0)), Km(t, e, s, r)
    );
  }
  if (((a = (s & t.childLanes) !== 0), _i || a)) {
    if (((r = _r), r !== null)) {
      switch (s & -s) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | s) ? 0 : i),
        i !== 0 &&
          i !== o.retryLane &&
          ((o.retryLane = i), Ks(t, i), Bo(r, t, i, -1));
    }
    return Bw(), (r = E1(Error(Xe(421)))), Km(t, e, s, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = PB.bind(null, t)),
      (i._reactRetry = e),
      null)
    : ((t = o.treeContext),
      (Wi = ja(i.nextSibling)),
      ($i = e),
      (_n = !0),
      (Fo = null),
      t !== null &&
        ((ho[po++] = Hs),
        (ho[po++] = Vs),
        (ho[po++] = _c),
        (Hs = t.id),
        (Vs = t.overflow),
        (_c = e)),
      (e = Nw(e, r.children)),
      (e.flags |= 4096),
      e);
}
function B2(t, e, n) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), DS(t.return, e, n);
}
function M1(t, e, n, r, i) {
  var o = t.memoizedState;
  o === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((o.isBackwards = e),
      (o.rendering = null),
      (o.renderingStartTime = 0),
      (o.last = r),
      (o.tail = n),
      (o.tailMode = i));
}
function DL(t, e, n) {
  var r = e.pendingProps,
    i = r.revealOrder,
    o = r.tail;
  if ((oi(t, e, r.children, n), (r = wn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && B2(t, n, e);
        else if (t.tag === 19) B2(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    r &= 1;
  }
  if ((mn(wn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = e.child, i = null; n !== null; )
          (t = n.alternate),
            t !== null && ov(t) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = e.child), (e.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          M1(e, !1, i, n, o);
        break;
      case "backwards":
        for (n = null, i = e.child, e.child = null; i !== null; ) {
          if (((t = i.alternate), t !== null && ov(t) === null)) {
            e.child = i;
            break;
          }
          (t = i.sibling), (i.sibling = n), (n = i), (i = t);
        }
        M1(e, !0, n, null, o);
        break;
      case "together":
        M1(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function x0(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Zs(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (Ac |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(Xe(153));
  if (e.child !== null) {
    for (
      t = e.child, n = qa(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = qa(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function yB(t, e, n) {
  switch (e.tag) {
    case 3:
      OL(e), hf();
      break;
    case 5:
      aL(e);
      break;
    case 1:
      bi(e.type) && Q0(e);
      break;
    case 4:
      Mw(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      mn(nv, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (mn(wn, wn.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? NL(t, e, n)
          : (mn(wn, wn.current & 1),
            (t = Zs(t, e, n)),
            t !== null ? t.sibling : null);
      mn(wn, wn.current & 1);
      break;
    case 19:
      if (((r = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (r) return DL(t, e, n);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        mn(wn, wn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), IL(t, e, n);
  }
  return Zs(t, e, n);
}
var FL, GS, UL, kL;
FL = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
GS = function () {};
UL = function (t, e, n, r) {
  var i = t.memoizedProps;
  if (i !== r) {
    (t = e.stateNode), Ql(ds.current);
    var o = null;
    switch (n) {
      case "input":
        (i = fS(t, i)), (r = fS(t, r)), (o = []);
        break;
      case "select":
        (i = Pn({}, i, { value: void 0 })),
          (r = Pn({}, r, { value: void 0 })),
          (o = []);
        break;
      case "textarea":
        (i = pS(t, i)), (r = pS(t, r)), (o = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (t.onclick = Z0);
    }
    gS(n, r);
    var s;
    n = null;
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === "style") {
          var a = i[c];
          for (s in a) a.hasOwnProperty(s) && (n || (n = {}), (n[s] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Sh.hasOwnProperty(c)
              ? o || (o = [])
              : (o = o || []).push(c, null));
    for (c in r) {
      var l = r[c];
      if (
        ((a = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (s in a)
              !a.hasOwnProperty(s) ||
                (l && l.hasOwnProperty(s)) ||
                (n || (n = {}), (n[s] = ""));
            for (s in l)
              l.hasOwnProperty(s) &&
                a[s] !== l[s] &&
                (n || (n = {}), (n[s] = l[s]));
          } else n || (o || (o = []), o.push(c, n)), (n = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (o = o || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (o = o || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (Sh.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && gn("scroll", t),
                  o || a === l || (o = []))
                : (o = o || []).push(c, l));
    }
    n && (o = o || []).push("style", n);
    var c = o;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
kL = function (t, e, n, r) {
  n !== r && (e.flags |= 4);
};
function bd(t, e) {
  if (!_n)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (r.sibling = null);
    }
}
function zr(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0;
  if (e)
    for (var i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = t),
        (i = i.sibling);
  else
    for (i = t.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = t),
        (i = i.sibling);
  return (t.subtreeFlags |= r), (t.childLanes = n), e;
}
function xB(t, e, n) {
  var r = e.pendingProps;
  switch ((xw(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return zr(e), null;
    case 1:
      return bi(e.type) && J0(), zr(e), null;
    case 3:
      return (
        (r = e.stateNode),
        mf(),
        vn(Ai),
        vn(Xr),
        Tw(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (t === null || t.child === null) &&
          (Ym(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Fo !== null && (ZS(Fo), (Fo = null)))),
        GS(t, e),
        zr(e),
        null
      );
    case 5:
      Cw(e);
      var i = Ql(Oh.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        UL(t, e, n, r, i),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(Xe(166));
          return zr(e), null;
        }
        if (((t = Ql(ds.current)), Ym(e))) {
          (r = e.stateNode), (n = e.type);
          var o = e.memoizedProps;
          switch (((r[as] = e), (r[Ih] = o), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              gn("cancel", r), gn("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              gn("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < $d.length; i++) gn($d[i], r);
              break;
            case "source":
              gn("error", r);
              break;
            case "img":
            case "image":
            case "link":
              gn("error", r), gn("load", r);
              break;
            case "details":
              gn("toggle", r);
              break;
            case "input":
              qC(r, o), gn("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!o.multiple }),
                gn("invalid", r);
              break;
            case "textarea":
              ZC(r, o), gn("invalid", r);
          }
          gS(n, o), (i = null);
          for (var s in o)
            if (o.hasOwnProperty(s)) {
              var a = o[s];
              s === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (o.suppressHydrationWarning !== !0 &&
                      Xm(r.textContent, a, t),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (o.suppressHydrationWarning !== !0 &&
                      Xm(r.textContent, a, t),
                    (i = ["children", "" + a]))
                : Sh.hasOwnProperty(s) &&
                  a != null &&
                  s === "onScroll" &&
                  gn("scroll", r);
            }
          switch (n) {
            case "input":
              zm(r), KC(r, o, !0);
              break;
            case "textarea":
              zm(r), JC(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof o.onClick == "function" && (r.onclick = Z0);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (s = i.nodeType === 9 ? i : i.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = dI(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = s.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof r.is == "string"
                ? (t = s.createElement(n, { is: r.is }))
                : ((t = s.createElement(n)),
                  n === "select" &&
                    ((s = t),
                    r.multiple
                      ? (s.multiple = !0)
                      : r.size && (s.size = r.size)))
              : (t = s.createElementNS(t, n)),
            (t[as] = e),
            (t[Ih] = r),
            FL(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((s = vS(n, r)), n)) {
              case "dialog":
                gn("cancel", t), gn("close", t), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                gn("load", t), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < $d.length; i++) gn($d[i], t);
                i = r;
                break;
              case "source":
                gn("error", t), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                gn("error", t), gn("load", t), (i = r);
                break;
              case "details":
                gn("toggle", t), (i = r);
                break;
              case "input":
                qC(t, r), (i = fS(t, r)), gn("invalid", t);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (t._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = Pn({}, r, { value: void 0 })),
                  gn("invalid", t);
                break;
              case "textarea":
                ZC(t, r), (i = pS(t, r)), gn("invalid", t);
                break;
              default:
                i = r;
            }
            gS(n, i), (a = i);
            for (o in a)
              if (a.hasOwnProperty(o)) {
                var l = a[o];
                o === "style"
                  ? mI(t, l)
                  : o === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && hI(t, l))
                  : o === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && Ah(t, l)
                    : typeof l == "number" && Ah(t, "" + l)
                  : o !== "suppressContentEditableWarning" &&
                    o !== "suppressHydrationWarning" &&
                    o !== "autoFocus" &&
                    (Sh.hasOwnProperty(o)
                      ? l != null && o === "onScroll" && gn("scroll", t)
                      : l != null && iw(t, o, l, s));
              }
            switch (n) {
              case "input":
                zm(t), KC(t, r, !1);
                break;
              case "textarea":
                zm(t), JC(t);
                break;
              case "option":
                r.value != null && t.setAttribute("value", "" + Ja(r.value));
                break;
              case "select":
                (t.multiple = !!r.multiple),
                  (o = r.value),
                  o != null
                    ? tf(t, !!r.multiple, o, !1)
                    : r.defaultValue != null &&
                      tf(t, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (t.onclick = Z0);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return zr(e), null;
    case 6:
      if (t && e.stateNode != null) kL(t, e, t.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(Xe(166));
        if (((n = Ql(Oh.current)), Ql(ds.current), Ym(e))) {
          if (
            ((r = e.stateNode),
            (n = e.memoizedProps),
            (r[as] = e),
            (o = r.nodeValue !== n) && ((t = $i), t !== null))
          )
            switch (t.tag) {
              case 3:
                Xm(r.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  Xm(r.nodeValue, n, (t.mode & 1) !== 0);
            }
          o && (e.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[as] = e),
            (e.stateNode = r);
      }
      return zr(e), null;
    case 13:
      if (
        (vn(wn),
        (r = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (_n && Wi !== null && e.mode & 1 && !(e.flags & 128))
          nL(), hf(), (e.flags |= 98560), (o = !1);
        else if (((o = Ym(e)), r !== null && r.dehydrated !== null)) {
          if (t === null) {
            if (!o) throw Error(Xe(318));
            if (
              ((o = e.memoizedState),
              (o = o !== null ? o.dehydrated : null),
              !o)
            )
              throw Error(Xe(317));
            o[as] = e;
          } else
            hf(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          zr(e), (o = !1);
        } else Fo !== null && (ZS(Fo), (Fo = null)), (o = !0);
        if (!o) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((r = r !== null),
          r !== (t !== null && t.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || wn.current & 1 ? rr === 0 && (rr = 3) : Bw())),
          e.updateQueue !== null && (e.flags |= 4),
          zr(e),
          null);
    case 4:
      return (
        mf(), GS(t, e), t === null && Rh(e.stateNode.containerInfo), zr(e), null
      );
    case 10:
      return bw(e.type._context), zr(e), null;
    case 17:
      return bi(e.type) && J0(), zr(e), null;
    case 19:
      if ((vn(wn), (o = e.memoizedState), o === null)) return zr(e), null;
      if (((r = (e.flags & 128) !== 0), (s = o.rendering), s === null))
        if (r) bd(o, !1);
        else {
          if (rr !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((s = ov(t)), s !== null)) {
                for (
                  e.flags |= 128,
                    bd(o, !1),
                    r = s.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = n,
                    n = e.child;
                  n !== null;

                )
                  (o = n),
                    (t = r),
                    (o.flags &= 14680066),
                    (s = o.alternate),
                    s === null
                      ? ((o.childLanes = 0),
                        (o.lanes = t),
                        (o.child = null),
                        (o.subtreeFlags = 0),
                        (o.memoizedProps = null),
                        (o.memoizedState = null),
                        (o.updateQueue = null),
                        (o.dependencies = null),
                        (o.stateNode = null))
                      : ((o.childLanes = s.childLanes),
                        (o.lanes = s.lanes),
                        (o.child = s.child),
                        (o.subtreeFlags = 0),
                        (o.deletions = null),
                        (o.memoizedProps = s.memoizedProps),
                        (o.memoizedState = s.memoizedState),
                        (o.updateQueue = s.updateQueue),
                        (o.type = s.type),
                        (t = s.dependencies),
                        (o.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return mn(wn, (wn.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          o.tail !== null &&
            $n() > vf &&
            ((e.flags |= 128), (r = !0), bd(o, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((t = ov(s)), t !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              bd(o, !0),
              o.tail === null && o.tailMode === "hidden" && !s.alternate && !_n)
            )
              return zr(e), null;
          } else
            2 * $n() - o.renderingStartTime > vf &&
              n !== 1073741824 &&
              ((e.flags |= 128), (r = !0), bd(o, !1), (e.lanes = 4194304));
        o.isBackwards
          ? ((s.sibling = e.child), (e.child = s))
          : ((n = o.last),
            n !== null ? (n.sibling = s) : (e.child = s),
            (o.last = s));
      }
      return o.tail !== null
        ? ((e = o.tail),
          (o.rendering = e),
          (o.tail = e.sibling),
          (o.renderingStartTime = $n()),
          (e.sibling = null),
          (n = wn.current),
          mn(wn, r ? (n & 1) | 2 : n & 1),
          e)
        : (zr(e), null);
    case 22:
    case 23:
      return (
        zw(),
        (r = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? Vi & 1073741824 && (zr(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : zr(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Xe(156, e.tag));
}
function _B(t, e) {
  switch ((xw(e), e.tag)) {
    case 1:
      return (
        bi(e.type) && J0(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        mf(),
        vn(Ai),
        vn(Xr),
        Tw(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return Cw(e), null;
    case 13:
      if (
        (vn(wn), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Xe(340));
        hf();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return vn(wn), null;
    case 4:
      return mf(), null;
    case 10:
      return bw(e.type._context), null;
    case 22:
    case 23:
      return zw(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Zm = !1,
  jr = !1,
  SB = typeof WeakSet == "function" ? WeakSet : Set,
  lt = null;
function Wu(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        Fn(t, e, r);
      }
    else n.current = null;
}
function WS(t, e, n) {
  try {
    n();
  } catch (r) {
    Fn(t, e, r);
  }
}
var H2 = !1;
function AB(t, e) {
  if (((CS = Y0), (t = GI()), vw(t))) {
    if ("selectionStart" in t)
      var n = { start: t.selectionStart, end: t.selectionEnd };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            o = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, o.nodeType;
          } catch {
            n = null;
            break e;
          }
          var s = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            d = t,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== n || (i !== 0 && d.nodeType !== 3) || (a = s + i),
                d !== o || (r !== 0 && d.nodeType !== 3) || (l = s + r),
                d.nodeType === 3 && (s += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === t) break t;
              if (
                (p === n && ++c === i && (a = s),
                p === o && ++u === r && (l = s),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          n = a === -1 || l === -1 ? null : { start: a, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (
    TS = { focusedElem: t, selectionRange: n }, Y0 = !1, lt = e;
    lt !== null;

  )
    if (((e = lt), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (lt = t);
    else
      for (; lt !== null; ) {
        e = lt;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var _ = v.memoizedProps,
                    y = v.memoizedState,
                    g = e.stateNode,
                    x = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? _ : Io(e.type, _),
                      y
                    );
                  g.__reactInternalSnapshotBeforeUpdate = x;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Xe(163));
            }
        } catch (b) {
          Fn(e, e.return, b);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (lt = t);
          break;
        }
        lt = e.return;
      }
  return (v = H2), (H2 = !1), v;
}
function ah(t, e, n) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & t) === t) {
        var o = i.destroy;
        (i.destroy = void 0), o !== void 0 && WS(e, n, o);
      }
      i = i.next;
    } while (i !== r);
  }
}
function jv(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== e);
  }
}
function jS(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function zL(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), zL(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[as], delete e[Ih], delete e[IS], delete e[iB], delete e[oB])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function BL(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function V2(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || BL(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function $S(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = Z0));
  else if (r !== 4 && ((t = t.child), t !== null))
    for ($S(t, e, n), t = t.sibling; t !== null; ) $S(t, e, n), (t = t.sibling);
}
function XS(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (r !== 4 && ((t = t.child), t !== null))
    for (XS(t, e, n), t = t.sibling; t !== null; ) XS(t, e, n), (t = t.sibling);
}
var Cr = null,
  Oo = !1;
function _a(t, e, n) {
  for (n = n.child; n !== null; ) HL(t, e, n), (n = n.sibling);
}
function HL(t, e, n) {
  if (fs && typeof fs.onCommitFiberUnmount == "function")
    try {
      fs.onCommitFiberUnmount(Uv, n);
    } catch {}
  switch (n.tag) {
    case 5:
      jr || Wu(n, e);
    case 6:
      var r = Cr,
        i = Oo;
      (Cr = null),
        _a(t, e, n),
        (Cr = r),
        (Oo = i),
        Cr !== null &&
          (Oo
            ? ((t = Cr),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Cr.removeChild(n.stateNode));
      break;
    case 18:
      Cr !== null &&
        (Oo
          ? ((t = Cr),
            (n = n.stateNode),
            t.nodeType === 8
              ? x1(t.parentNode, n)
              : t.nodeType === 1 && x1(t, n),
            Mh(t))
          : x1(Cr, n.stateNode));
      break;
    case 4:
      (r = Cr),
        (i = Oo),
        (Cr = n.stateNode.containerInfo),
        (Oo = !0),
        _a(t, e, n),
        (Cr = r),
        (Oo = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !jr &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var o = i,
            s = o.destroy;
          (o = o.tag),
            s !== void 0 && (o & 2 || o & 4) && WS(n, e, s),
            (i = i.next);
        } while (i !== r);
      }
      _a(t, e, n);
      break;
    case 1:
      if (
        !jr &&
        (Wu(n, e),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          Fn(n, e, a);
        }
      _a(t, e, n);
      break;
    case 21:
      _a(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((jr = (r = jr) || n.memoizedState !== null), _a(t, e, n), (jr = r))
        : _a(t, e, n);
      break;
    default:
      _a(t, e, n);
  }
}
function G2(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new SB()),
      e.forEach(function (r) {
        var i = IB.bind(null, t, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function Co(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var o = t,
          s = e,
          a = s;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Cr = a.stateNode), (Oo = !1);
              break e;
            case 3:
              (Cr = a.stateNode.containerInfo), (Oo = !0);
              break e;
            case 4:
              (Cr = a.stateNode.containerInfo), (Oo = !0);
              break e;
          }
          a = a.return;
        }
        if (Cr === null) throw Error(Xe(160));
        HL(o, s, i), (Cr = null), (Oo = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (c) {
        Fn(i, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) VL(e, t), (e = e.sibling);
}
function VL(t, e) {
  var n = t.alternate,
    r = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Co(e, t), rs(t), r & 4)) {
        try {
          ah(3, t, t.return), jv(3, t);
        } catch (_) {
          Fn(t, t.return, _);
        }
        try {
          ah(5, t, t.return);
        } catch (_) {
          Fn(t, t.return, _);
        }
      }
      break;
    case 1:
      Co(e, t), rs(t), r & 512 && n !== null && Wu(n, n.return);
      break;
    case 5:
      if (
        (Co(e, t),
        rs(t),
        r & 512 && n !== null && Wu(n, n.return),
        t.flags & 32)
      ) {
        var i = t.stateNode;
        try {
          Ah(i, "");
        } catch (_) {
          Fn(t, t.return, _);
        }
      }
      if (r & 4 && ((i = t.stateNode), i != null)) {
        var o = t.memoizedProps,
          s = n !== null ? n.memoizedProps : o,
          a = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            a === "input" && o.type === "radio" && o.name != null && uI(i, o),
              vS(a, s);
            var c = vS(a, o);
            for (s = 0; s < l.length; s += 2) {
              var u = l[s],
                d = l[s + 1];
              u === "style"
                ? mI(i, d)
                : u === "dangerouslySetInnerHTML"
                ? hI(i, d)
                : u === "children"
                ? Ah(i, d)
                : iw(i, u, d, c);
            }
            switch (a) {
              case "input":
                dS(i, o);
                break;
              case "textarea":
                fI(i, o);
                break;
              case "select":
                var p = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!o.multiple;
                var m = o.value;
                m != null
                  ? tf(i, !!o.multiple, m, !1)
                  : p !== !!o.multiple &&
                    (o.defaultValue != null
                      ? tf(i, !!o.multiple, o.defaultValue, !0)
                      : tf(i, !!o.multiple, o.multiple ? [] : "", !1));
            }
            i[Ih] = o;
          } catch (_) {
            Fn(t, t.return, _);
          }
      }
      break;
    case 6:
      if ((Co(e, t), rs(t), r & 4)) {
        if (t.stateNode === null) throw Error(Xe(162));
        (i = t.stateNode), (o = t.memoizedProps);
        try {
          i.nodeValue = o;
        } catch (_) {
          Fn(t, t.return, _);
        }
      }
      break;
    case 3:
      if (
        (Co(e, t), rs(t), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          Mh(e.containerInfo);
        } catch (_) {
          Fn(t, t.return, _);
        }
      break;
    case 4:
      Co(e, t), rs(t);
      break;
    case 13:
      Co(e, t),
        rs(t),
        (i = t.child),
        i.flags & 8192 &&
          ((o = i.memoizedState !== null),
          (i.stateNode.isHidden = o),
          !o ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (Uw = $n())),
        r & 4 && G2(t);
      break;
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((jr = (c = jr) || u), Co(e, t), (jr = c)) : Co(e, t),
        rs(t),
        r & 8192)
      ) {
        if (
          ((c = t.memoizedState !== null),
          (t.stateNode.isHidden = c) && !u && t.mode & 1)
        )
          for (lt = t, u = t.child; u !== null; ) {
            for (d = lt = u; lt !== null; ) {
              switch (((p = lt), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  ah(4, p, p.return);
                  break;
                case 1:
                  Wu(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (r = p), (n = p.return);
                    try {
                      (e = r),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (_) {
                      Fn(r, n, _);
                    }
                  }
                  break;
                case 5:
                  Wu(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    j2(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (lt = m)) : j2(d);
            }
            u = u.sibling;
          }
        e: for (u = null, d = t; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                (i = d.stateNode),
                  c
                    ? ((o = i.style),
                      typeof o.setProperty == "function"
                        ? o.setProperty("display", "none", "important")
                        : (o.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (s =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = pI("display", s)));
              } catch (_) {
                Fn(t, t.return, _);
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (_) {
                Fn(t, t.return, _);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === t) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === t) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === t) break e;
            u === d && (u = null), (d = d.return);
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      Co(e, t), rs(t), r & 4 && G2(t);
      break;
    case 21:
      break;
    default:
      Co(e, t), rs(t);
  }
}
function rs(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (BL(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(Xe(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (Ah(i, ""), (r.flags &= -33));
          var o = V2(t);
          XS(t, o, i);
          break;
        case 3:
        case 4:
          var s = r.stateNode.containerInfo,
            a = V2(t);
          $S(t, a, s);
          break;
        default:
          throw Error(Xe(161));
      }
    } catch (l) {
      Fn(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function bB(t, e, n) {
  (lt = t), GL(t);
}
function GL(t, e, n) {
  for (var r = (t.mode & 1) !== 0; lt !== null; ) {
    var i = lt,
      o = i.child;
    if (i.tag === 22 && r) {
      var s = i.memoizedState !== null || Zm;
      if (!s) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || jr;
        a = Zm;
        var c = jr;
        if (((Zm = s), (jr = l) && !c))
          for (lt = i; lt !== null; )
            (s = lt),
              (l = s.child),
              s.tag === 22 && s.memoizedState !== null
                ? $2(i)
                : l !== null
                ? ((l.return = s), (lt = l))
                : $2(i);
        for (; o !== null; ) (lt = o), GL(o), (o = o.sibling);
        (lt = i), (Zm = a), (jr = c);
      }
      W2(t);
    } else
      i.subtreeFlags & 8772 && o !== null ? ((o.return = i), (lt = o)) : W2(t);
  }
}
function W2(t) {
  for (; lt !== null; ) {
    var e = lt;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              jr || jv(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !jr)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : Io(e.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var o = e.updateQueue;
              o !== null && T2(e, o, r);
              break;
            case 3:
              var s = e.updateQueue;
              if (s !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                T2(e, s, n);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (n === null && e.flags & 4) {
                n = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var d = u.dehydrated;
                    d !== null && Mh(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Xe(163));
          }
        jr || (e.flags & 512 && jS(e));
      } catch (p) {
        Fn(e, e.return, p);
      }
    }
    if (e === t) {
      lt = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (lt = n);
      break;
    }
    lt = e.return;
  }
}
function j2(t) {
  for (; lt !== null; ) {
    var e = lt;
    if (e === t) {
      lt = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (lt = n);
      break;
    }
    lt = e.return;
  }
}
function $2(t) {
  for (; lt !== null; ) {
    var e = lt;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            jv(4, e);
          } catch (l) {
            Fn(e, n, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              Fn(e, i, l);
            }
          }
          var o = e.return;
          try {
            jS(e);
          } catch (l) {
            Fn(e, o, l);
          }
          break;
        case 5:
          var s = e.return;
          try {
            jS(e);
          } catch (l) {
            Fn(e, s, l);
          }
      }
    } catch (l) {
      Fn(e, e.return, l);
    }
    if (e === t) {
      lt = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (lt = a);
      break;
    }
    lt = e.return;
  }
}
var wB = Math.ceil,
  lv = ra.ReactCurrentDispatcher,
  Dw = ra.ReactCurrentOwner,
  xo = ra.ReactCurrentBatchConfig,
  Kt = 0,
  _r = null,
  Jn = null,
  Tr = 0,
  Vi = 0,
  ju = ol(0),
  rr = 0,
  Uh = null,
  Ac = 0,
  $v = 0,
  Fw = 0,
  lh = null,
  xi = null,
  Uw = 0,
  vf = 1 / 0,
  Fs = null,
  cv = !1,
  YS = null,
  Xa = null,
  Jm = !1,
  ka = null,
  uv = 0,
  ch = 0,
  qS = null,
  _0 = -1,
  S0 = 0;
function ai() {
  return Kt & 6 ? $n() : _0 !== -1 ? _0 : (_0 = $n());
}
function Ya(t) {
  return t.mode & 1
    ? Kt & 2 && Tr !== 0
      ? Tr & -Tr
      : aB.transition !== null
      ? (S0 === 0 && (S0 = CI()), S0)
      : ((t = on),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : NI(t.type))),
        t)
    : 1;
}
function Bo(t, e, n, r) {
  if (50 < ch) throw ((ch = 0), (qS = null), Error(Xe(185)));
  wp(t, n, r),
    (!(Kt & 2) || t !== _r) &&
      (t === _r && (!(Kt & 2) && ($v |= n), rr === 4 && Da(t, Tr)),
      wi(t, r),
      n === 1 && Kt === 0 && !(e.mode & 1) && ((vf = $n() + 500), Vv && sl()));
}
function wi(t, e) {
  var n = t.callbackNode;
  az(t, e);
  var r = X0(t, t === _r ? Tr : 0);
  if (r === 0)
    n !== null && t2(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = r & -r), t.callbackPriority !== e)) {
    if ((n != null && t2(n), e === 1))
      t.tag === 0 ? sB(X2.bind(null, t)) : QI(X2.bind(null, t)),
        nB(function () {
          !(Kt & 6) && sl();
        }),
        (n = null);
    else {
      switch (TI(r)) {
        case 1:
          n = cw;
          break;
        case 4:
          n = EI;
          break;
        case 16:
          n = $0;
          break;
        case 536870912:
          n = MI;
          break;
        default:
          n = $0;
      }
      n = ZL(n, WL.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function WL(t, e) {
  if (((_0 = -1), (S0 = 0), Kt & 6)) throw Error(Xe(327));
  var n = t.callbackNode;
  if (af() && t.callbackNode !== n) return null;
  var r = X0(t, t === _r ? Tr : 0);
  if (r === 0) return null;
  if (r & 30 || r & t.expiredLanes || e) e = fv(t, r);
  else {
    e = r;
    var i = Kt;
    Kt |= 2;
    var o = $L();
    (_r !== t || Tr !== e) && ((Fs = null), (vf = $n() + 500), lc(t, e));
    do
      try {
        CB();
        break;
      } catch (a) {
        jL(t, a);
      }
    while (!0);
    Aw(),
      (lv.current = o),
      (Kt = i),
      Jn !== null ? (e = 0) : ((_r = null), (Tr = 0), (e = rr));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = AS(t)), i !== 0 && ((r = i), (e = KS(t, i)))), e === 1)
    )
      throw ((n = Uh), lc(t, 0), Da(t, r), wi(t, $n()), n);
    if (e === 6) Da(t, r);
    else {
      if (
        ((i = t.current.alternate),
        !(r & 30) &&
          !EB(i) &&
          ((e = fv(t, r)),
          e === 2 && ((o = AS(t)), o !== 0 && ((r = o), (e = KS(t, o)))),
          e === 1))
      )
        throw ((n = Uh), lc(t, 0), Da(t, r), wi(t, $n()), n);
      switch (((t.finishedWork = i), (t.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(Xe(345));
        case 2:
          Gl(t, xi, Fs);
          break;
        case 3:
          if (
            (Da(t, r), (r & 130023424) === r && ((e = Uw + 500 - $n()), 10 < e))
          ) {
            if (X0(t, 0) !== 0) break;
            if (((i = t.suspendedLanes), (i & r) !== r)) {
              ai(), (t.pingedLanes |= t.suspendedLanes & i);
              break;
            }
            t.timeoutHandle = PS(Gl.bind(null, t, xi, Fs), e);
            break;
          }
          Gl(t, xi, Fs);
          break;
        case 4:
          if ((Da(t, r), (r & 4194240) === r)) break;
          for (e = t.eventTimes, i = -1; 0 < r; ) {
            var s = 31 - zo(r);
            (o = 1 << s), (s = e[s]), s > i && (i = s), (r &= ~o);
          }
          if (
            ((r = i),
            (r = $n() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * wB(r / 1960)) - r),
            10 < r)
          ) {
            t.timeoutHandle = PS(Gl.bind(null, t, xi, Fs), r);
            break;
          }
          Gl(t, xi, Fs);
          break;
        case 5:
          Gl(t, xi, Fs);
          break;
        default:
          throw Error(Xe(329));
      }
    }
  }
  return wi(t, $n()), t.callbackNode === n ? WL.bind(null, t) : null;
}
function KS(t, e) {
  var n = lh;
  return (
    t.current.memoizedState.isDehydrated && (lc(t, e).flags |= 256),
    (t = fv(t, e)),
    t !== 2 && ((e = xi), (xi = n), e !== null && ZS(e)),
    t
  );
}
function ZS(t) {
  xi === null ? (xi = t) : xi.push.apply(xi, t);
}
function EB(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            o = i.getSnapshot;
          i = i.value;
          try {
            if (!Go(o(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Da(t, e) {
  for (
    e &= ~Fw,
      e &= ~$v,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - zo(e),
      r = 1 << n;
    (t[n] = -1), (e &= ~r);
  }
}
function X2(t) {
  if (Kt & 6) throw Error(Xe(327));
  af();
  var e = X0(t, 0);
  if (!(e & 1)) return wi(t, $n()), null;
  var n = fv(t, e);
  if (t.tag !== 0 && n === 2) {
    var r = AS(t);
    r !== 0 && ((e = r), (n = KS(t, r)));
  }
  if (n === 1) throw ((n = Uh), lc(t, 0), Da(t, e), wi(t, $n()), n);
  if (n === 6) throw Error(Xe(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    Gl(t, xi, Fs),
    wi(t, $n()),
    null
  );
}
function kw(t, e) {
  var n = Kt;
  Kt |= 1;
  try {
    return t(e);
  } finally {
    (Kt = n), Kt === 0 && ((vf = $n() + 500), Vv && sl());
  }
}
function bc(t) {
  ka !== null && ka.tag === 0 && !(Kt & 6) && af();
  var e = Kt;
  Kt |= 1;
  var n = xo.transition,
    r = on;
  try {
    if (((xo.transition = null), (on = 1), t)) return t();
  } finally {
    (on = r), (xo.transition = n), (Kt = e), !(Kt & 6) && sl();
  }
}
function zw() {
  (Vi = ju.current), vn(ju);
}
function lc(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), tB(n)), Jn !== null))
    for (n = Jn.return; n !== null; ) {
      var r = n;
      switch ((xw(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && J0();
          break;
        case 3:
          mf(), vn(Ai), vn(Xr), Tw();
          break;
        case 5:
          Cw(r);
          break;
        case 4:
          mf();
          break;
        case 13:
          vn(wn);
          break;
        case 19:
          vn(wn);
          break;
        case 10:
          bw(r.type._context);
          break;
        case 22:
        case 23:
          zw();
      }
      n = n.return;
    }
  if (
    ((_r = t),
    (Jn = t = qa(t.current, null)),
    (Tr = Vi = e),
    (rr = 0),
    (Uh = null),
    (Fw = $v = Ac = 0),
    (xi = lh = null),
    Jl !== null)
  ) {
    for (e = 0; e < Jl.length; e++)
      if (((n = Jl[e]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          o = n.pending;
        if (o !== null) {
          var s = o.next;
          (o.next = i), (r.next = s);
        }
        n.pending = r;
      }
    Jl = null;
  }
  return t;
}
function jL(t, e) {
  do {
    var n = Jn;
    try {
      if ((Aw(), (v0.current = av), sv)) {
        for (var r = Rn.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        sv = !1;
      }
      if (
        ((Sc = 0),
        (yr = nr = Rn = null),
        (sh = !1),
        (Nh = 0),
        (Dw.current = null),
        n === null || n.return === null)
      ) {
        (rr = 1), (Uh = e), (Jn = null);
        break;
      }
      e: {
        var o = t,
          s = n.return,
          a = n,
          l = e;
        if (
          ((e = Tr),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = u.alternate;
            p
              ? ((u.updateQueue = p.updateQueue),
                (u.memoizedState = p.memoizedState),
                (u.lanes = p.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var m = N2(s);
          if (m !== null) {
            (m.flags &= -257),
              D2(m, s, a, o, e),
              m.mode & 1 && O2(o, c, e),
              (e = m),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var _ = new Set();
              _.add(l), (e.updateQueue = _);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              O2(o, c, e), Bw();
              break e;
            }
            l = Error(Xe(426));
          }
        } else if (_n && a.mode & 1) {
          var y = N2(s);
          if (y !== null) {
            !(y.flags & 65536) && (y.flags |= 256),
              D2(y, s, a, o, e),
              _w(gf(l, a));
            break e;
          }
        }
        (o = l = gf(l, a)),
          rr !== 4 && (rr = 2),
          lh === null ? (lh = [o]) : lh.push(o),
          (o = s);
        do {
          switch (o.tag) {
            case 3:
              (o.flags |= 65536), (e &= -e), (o.lanes |= e);
              var g = TL(o, l, e);
              C2(o, g);
              break e;
            case 1:
              a = l;
              var x = o.type,
                S = o.stateNode;
              if (
                !(o.flags & 128) &&
                (typeof x.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (Xa === null || !Xa.has(S))))
              ) {
                (o.flags |= 65536), (e &= -e), (o.lanes |= e);
                var b = RL(o, a, e);
                C2(o, b);
                break e;
              }
          }
          o = o.return;
        } while (o !== null);
      }
      YL(n);
    } catch (C) {
      (e = C), Jn === n && n !== null && (Jn = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function $L() {
  var t = lv.current;
  return (lv.current = av), t === null ? av : t;
}
function Bw() {
  (rr === 0 || rr === 3 || rr === 2) && (rr = 4),
    _r === null || (!(Ac & 268435455) && !($v & 268435455)) || Da(_r, Tr);
}
function fv(t, e) {
  var n = Kt;
  Kt |= 2;
  var r = $L();
  (_r !== t || Tr !== e) && ((Fs = null), lc(t, e));
  do
    try {
      MB();
      break;
    } catch (i) {
      jL(t, i);
    }
  while (!0);
  if ((Aw(), (Kt = n), (lv.current = r), Jn !== null)) throw Error(Xe(261));
  return (_r = null), (Tr = 0), rr;
}
function MB() {
  for (; Jn !== null; ) XL(Jn);
}
function CB() {
  for (; Jn !== null && !Jk(); ) XL(Jn);
}
function XL(t) {
  var e = KL(t.alternate, t, Vi);
  (t.memoizedProps = t.pendingProps),
    e === null ? YL(t) : (Jn = e),
    (Dw.current = null);
}
function YL(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = _B(n, e)), n !== null)) {
        (n.flags &= 32767), (Jn = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (rr = 6), (Jn = null);
        return;
      }
    } else if (((n = xB(n, e, Vi)), n !== null)) {
      Jn = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Jn = e;
      return;
    }
    Jn = e = t;
  } while (e !== null);
  rr === 0 && (rr = 5);
}
function Gl(t, e, n) {
  var r = on,
    i = xo.transition;
  try {
    (xo.transition = null), (on = 1), TB(t, e, n, r);
  } finally {
    (xo.transition = i), (on = r);
  }
  return null;
}
function TB(t, e, n, r) {
  do af();
  while (ka !== null);
  if (Kt & 6) throw Error(Xe(327));
  n = t.finishedWork;
  var i = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(Xe(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var o = n.lanes | n.childLanes;
  if (
    (lz(t, o),
    t === _r && ((Jn = _r = null), (Tr = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Jm ||
      ((Jm = !0),
      ZL($0, function () {
        return af(), null;
      })),
    (o = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || o)
  ) {
    (o = xo.transition), (xo.transition = null);
    var s = on;
    on = 1;
    var a = Kt;
    (Kt |= 4),
      (Dw.current = null),
      AB(t, n),
      VL(n, t),
      Yz(TS),
      (Y0 = !!CS),
      (TS = CS = null),
      (t.current = n),
      bB(n),
      Qk(),
      (Kt = a),
      (on = s),
      (xo.transition = o);
  } else t.current = n;
  if (
    (Jm && ((Jm = !1), (ka = t), (uv = i)),
    (o = t.pendingLanes),
    o === 0 && (Xa = null),
    nz(n.stateNode),
    wi(t, $n()),
    e !== null)
  )
    for (r = t.onRecoverableError, n = 0; n < e.length; n++)
      (i = e[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (cv) throw ((cv = !1), (t = YS), (YS = null), t);
  return (
    uv & 1 && t.tag !== 0 && af(),
    (o = t.pendingLanes),
    o & 1 ? (t === qS ? ch++ : ((ch = 0), (qS = t))) : (ch = 0),
    sl(),
    null
  );
}
function af() {
  if (ka !== null) {
    var t = TI(uv),
      e = xo.transition,
      n = on;
    try {
      if (((xo.transition = null), (on = 16 > t ? 16 : t), ka === null))
        var r = !1;
      else {
        if (((t = ka), (ka = null), (uv = 0), Kt & 6)) throw Error(Xe(331));
        var i = Kt;
        for (Kt |= 4, lt = t.current; lt !== null; ) {
          var o = lt,
            s = o.child;
          if (lt.flags & 16) {
            var a = o.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (lt = c; lt !== null; ) {
                  var u = lt;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ah(8, u, o);
                  }
                  var d = u.child;
                  if (d !== null) (d.return = u), (lt = d);
                  else
                    for (; lt !== null; ) {
                      u = lt;
                      var p = u.sibling,
                        m = u.return;
                      if ((zL(u), u === c)) {
                        lt = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (lt = p);
                        break;
                      }
                      lt = m;
                    }
                }
              }
              var v = o.alternate;
              if (v !== null) {
                var _ = v.child;
                if (_ !== null) {
                  v.child = null;
                  do {
                    var y = _.sibling;
                    (_.sibling = null), (_ = y);
                  } while (_ !== null);
                }
              }
              lt = o;
            }
          }
          if (o.subtreeFlags & 2064 && s !== null) (s.return = o), (lt = s);
          else
            e: for (; lt !== null; ) {
              if (((o = lt), o.flags & 2048))
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    ah(9, o, o.return);
                }
              var g = o.sibling;
              if (g !== null) {
                (g.return = o.return), (lt = g);
                break e;
              }
              lt = o.return;
            }
        }
        var x = t.current;
        for (lt = x; lt !== null; ) {
          s = lt;
          var S = s.child;
          if (s.subtreeFlags & 2064 && S !== null) (S.return = s), (lt = S);
          else
            e: for (s = x; lt !== null; ) {
              if (((a = lt), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      jv(9, a);
                  }
                } catch (C) {
                  Fn(a, a.return, C);
                }
              if (a === s) {
                lt = null;
                break e;
              }
              var b = a.sibling;
              if (b !== null) {
                (b.return = a.return), (lt = b);
                break e;
              }
              lt = a.return;
            }
        }
        if (
          ((Kt = i), sl(), fs && typeof fs.onPostCommitFiberRoot == "function")
        )
          try {
            fs.onPostCommitFiberRoot(Uv, t);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (on = n), (xo.transition = e);
    }
  }
  return !1;
}
function Y2(t, e, n) {
  (e = gf(n, e)),
    (e = TL(t, e, 1)),
    (t = $a(t, e, 1)),
    (e = ai()),
    t !== null && (wp(t, 1, e), wi(t, e));
}
function Fn(t, e, n) {
  if (t.tag === 3) Y2(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Y2(e, t, n);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Xa === null || !Xa.has(r)))
        ) {
          (t = gf(n, t)),
            (t = RL(e, t, 1)),
            (e = $a(e, t, 1)),
            (t = ai()),
            e !== null && (wp(e, 1, t), wi(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function RB(t, e, n) {
  var r = t.pingCache;
  r !== null && r.delete(e),
    (e = ai()),
    (t.pingedLanes |= t.suspendedLanes & n),
    _r === t &&
      (Tr & n) === n &&
      (rr === 4 || (rr === 3 && (Tr & 130023424) === Tr && 500 > $n() - Uw)
        ? lc(t, 0)
        : (Fw |= n)),
    wi(t, e);
}
function qL(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = Vm), (Vm <<= 1), !(Vm & 130023424) && (Vm = 4194304))
      : (e = 1));
  var n = ai();
  (t = Ks(t, e)), t !== null && (wp(t, e, n), wi(t, n));
}
function PB(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), qL(t, n);
}
function IB(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        i = t.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = t.stateNode;
      break;
    default:
      throw Error(Xe(314));
  }
  r !== null && r.delete(e), qL(t, n);
}
var KL;
KL = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || Ai.current) _i = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (_i = !1), yB(t, e, n);
      _i = !!(t.flags & 131072);
    }
  else (_i = !1), _n && e.flags & 1048576 && eL(e, tv, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      x0(t, e), (t = e.pendingProps);
      var i = df(e, Xr.current);
      sf(e, n), (i = Pw(null, e, r, t, i, n));
      var o = Iw();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            bi(r) ? ((o = !0), Q0(e)) : (o = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            Ew(e),
            (i.updater = Wv),
            (e.stateNode = i),
            (i._reactInternals = e),
            US(e, r, t, n),
            (e = BS(null, e, r, !0, o, n)))
          : ((e.tag = 0), _n && o && yw(e), oi(null, e, i, n), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (x0(t, e),
          (t = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = OB(r)),
          (t = Io(r, t)),
          i)
        ) {
          case 0:
            e = zS(null, e, r, t, n);
            break e;
          case 1:
            e = k2(null, e, r, t, n);
            break e;
          case 11:
            e = F2(null, e, r, t, n);
            break e;
          case 14:
            e = U2(null, e, r, Io(r.type, t), n);
            break e;
        }
        throw Error(Xe(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Io(r, i)),
        zS(t, e, r, i, n)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Io(r, i)),
        k2(t, e, r, i, n)
      );
    case 3:
      e: {
        if ((OL(e), t === null)) throw Error(Xe(387));
        (r = e.pendingProps),
          (o = e.memoizedState),
          (i = o.element),
          sL(t, e),
          iv(e, r, null, n);
        var s = e.memoizedState;
        if (((r = s.element), o.isDehydrated))
          if (
            ((o = {
              element: r,
              isDehydrated: !1,
              cache: s.cache,
              pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
              transitions: s.transitions,
            }),
            (e.updateQueue.baseState = o),
            (e.memoizedState = o),
            e.flags & 256)
          ) {
            (i = gf(Error(Xe(423)), e)), (e = z2(t, e, r, n, i));
            break e;
          } else if (r !== i) {
            (i = gf(Error(Xe(424)), e)), (e = z2(t, e, r, n, i));
            break e;
          } else
            for (
              Wi = ja(e.stateNode.containerInfo.firstChild),
                $i = e,
                _n = !0,
                Fo = null,
                n = iL(e, null, r, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((hf(), r === i)) {
            e = Zs(t, e, n);
            break e;
          }
          oi(t, e, r, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        aL(e),
        t === null && NS(e),
        (r = e.type),
        (i = e.pendingProps),
        (o = t !== null ? t.memoizedProps : null),
        (s = i.children),
        RS(r, i) ? (s = null) : o !== null && RS(r, o) && (e.flags |= 32),
        LL(t, e),
        oi(t, e, s, n),
        e.child
      );
    case 6:
      return t === null && NS(e), null;
    case 13:
      return NL(t, e, n);
    case 4:
      return (
        Mw(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        t === null ? (e.child = pf(e, null, r, n)) : oi(t, e, r, n),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Io(r, i)),
        F2(t, e, r, i, n)
      );
    case 7:
      return oi(t, e, e.pendingProps, n), e.child;
    case 8:
      return oi(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return oi(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (o = e.memoizedProps),
          (s = i.value),
          mn(nv, r._currentValue),
          (r._currentValue = s),
          o !== null)
        )
          if (Go(o.value, s)) {
            if (o.children === i.children && !Ai.current) {
              e = Zs(t, e, n);
              break e;
            }
          } else
            for (o = e.child, o !== null && (o.return = e); o !== null; ) {
              var a = o.dependencies;
              if (a !== null) {
                s = o.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (o.tag === 1) {
                      (l = Ws(-1, n & -n)), (l.tag = 2);
                      var c = o.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (o.lanes |= n),
                      (l = o.alternate),
                      l !== null && (l.lanes |= n),
                      DS(o.return, n, e),
                      (a.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (o.tag === 10) s = o.type === e.type ? null : o.child;
              else if (o.tag === 18) {
                if (((s = o.return), s === null)) throw Error(Xe(341));
                (s.lanes |= n),
                  (a = s.alternate),
                  a !== null && (a.lanes |= n),
                  DS(s, n, e),
                  (s = o.sibling);
              } else s = o.child;
              if (s !== null) s.return = o;
              else
                for (s = o; s !== null; ) {
                  if (s === e) {
                    s = null;
                    break;
                  }
                  if (((o = s.sibling), o !== null)) {
                    (o.return = s.return), (s = o);
                    break;
                  }
                  s = s.return;
                }
              o = s;
            }
        oi(t, e, i.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        sf(e, n),
        (i = _o(i)),
        (r = r(i)),
        (e.flags |= 1),
        oi(t, e, r, n),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = Io(r, e.pendingProps)),
        (i = Io(r.type, i)),
        U2(t, e, r, i, n)
      );
    case 15:
      return PL(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Io(r, i)),
        x0(t, e),
        (e.tag = 1),
        bi(r) ? ((t = !0), Q0(e)) : (t = !1),
        sf(e, n),
        CL(e, r, i),
        US(e, r, i, n),
        BS(null, e, r, !0, t, n)
      );
    case 19:
      return DL(t, e, n);
    case 22:
      return IL(t, e, n);
  }
  throw Error(Xe(156, e.tag));
};
function ZL(t, e) {
  return wI(t, e);
}
function LB(t, e, n, r) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function go(t, e, n, r) {
  return new LB(t, e, n, r);
}
function Hw(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function OB(t) {
  if (typeof t == "function") return Hw(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === sw)) return 11;
    if (t === aw) return 14;
  }
  return 2;
}
function qa(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = go(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function A0(t, e, n, r, i, o) {
  var s = 2;
  if (((r = t), typeof t == "function")) Hw(t) && (s = 1);
  else if (typeof t == "string") s = 5;
  else
    e: switch (t) {
      case Du:
        return cc(n.children, i, o, e);
      case ow:
        (s = 8), (i |= 8);
        break;
      case aS:
        return (
          (t = go(12, n, e, i | 2)), (t.elementType = aS), (t.lanes = o), t
        );
      case lS:
        return (t = go(13, n, e, i)), (t.elementType = lS), (t.lanes = o), t;
      case cS:
        return (t = go(19, n, e, i)), (t.elementType = cS), (t.lanes = o), t;
      case aI:
        return Xv(n, i, o, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case oI:
              s = 10;
              break e;
            case sI:
              s = 9;
              break e;
            case sw:
              s = 11;
              break e;
            case aw:
              s = 14;
              break e;
            case Pa:
              (s = 16), (r = null);
              break e;
          }
        throw Error(Xe(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = go(s, n, e, i)), (e.elementType = t), (e.type = r), (e.lanes = o), e
  );
}
function cc(t, e, n, r) {
  return (t = go(7, t, r, e)), (t.lanes = n), t;
}
function Xv(t, e, n, r) {
  return (
    (t = go(22, t, r, e)),
    (t.elementType = aI),
    (t.lanes = n),
    (t.stateNode = { isHidden: !1 }),
    t
  );
}
function C1(t, e, n) {
  return (t = go(6, t, null, e)), (t.lanes = n), t;
}
function T1(t, e, n) {
  return (
    (e = go(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function NB(t, e, n, r, i) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = l1(0)),
    (this.expirationTimes = l1(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = l1(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function Vw(t, e, n, r, i, o, s, a, l) {
  return (
    (t = new NB(t, e, n, a, l)),
    e === 1 ? ((e = 1), o === !0 && (e |= 8)) : (e = 0),
    (o = go(3, null, null, e)),
    (t.current = o),
    (o.stateNode = t),
    (o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    Ew(o),
    t
  );
}
function DB(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Nu,
    key: r == null ? null : "" + r,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function JL(t) {
  if (!t) return Qa;
  t = t._reactInternals;
  e: {
    if (Lc(t) !== t || t.tag !== 1) throw Error(Xe(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (bi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Xe(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (bi(n)) return JI(t, n, e);
  }
  return e;
}
function QL(t, e, n, r, i, o, s, a, l) {
  return (
    (t = Vw(n, r, !0, t, i, o, s, a, l)),
    (t.context = JL(null)),
    (n = t.current),
    (r = ai()),
    (i = Ya(n)),
    (o = Ws(r, i)),
    (o.callback = e ?? null),
    $a(n, o, i),
    (t.current.lanes = i),
    wp(t, i, r),
    wi(t, r),
    t
  );
}
function Yv(t, e, n, r) {
  var i = e.current,
    o = ai(),
    s = Ya(i);
  return (
    (n = JL(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = Ws(o, s)),
    (e.payload = { element: t }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (t = $a(i, e, s)),
    t !== null && (Bo(t, i, s, o), g0(t, i, s)),
    s
  );
}
function dv(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function q2(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function Gw(t, e) {
  q2(t, e), (t = t.alternate) && q2(t, e);
}
function FB() {
  return null;
}
var eO =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function Ww(t) {
  this._internalRoot = t;
}
qv.prototype.render = Ww.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(Xe(409));
  Yv(t, e, null, null);
};
qv.prototype.unmount = Ww.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    bc(function () {
      Yv(null, t, null, null);
    }),
      (e[qs] = null);
  }
};
function qv(t) {
  this._internalRoot = t;
}
qv.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = II();
    t = { blockedOn: null, target: t, priority: e };
    for (var n = 0; n < Na.length && e !== 0 && e < Na[n].priority; n++);
    Na.splice(n, 0, t), n === 0 && OI(t);
  }
};
function jw(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function Kv(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function K2() {}
function UB(t, e, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var o = r;
      r = function () {
        var c = dv(s);
        o.call(c);
      };
    }
    var s = QL(e, r, t, 0, null, !1, !1, "", K2);
    return (
      (t._reactRootContainer = s),
      (t[qs] = s.current),
      Rh(t.nodeType === 8 ? t.parentNode : t),
      bc(),
      s
    );
  }
  for (; (i = t.lastChild); ) t.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var c = dv(l);
      a.call(c);
    };
  }
  var l = Vw(t, 0, !1, null, null, !1, !1, "", K2);
  return (
    (t._reactRootContainer = l),
    (t[qs] = l.current),
    Rh(t.nodeType === 8 ? t.parentNode : t),
    bc(function () {
      Yv(e, l, n, r);
    }),
    l
  );
}
function Zv(t, e, n, r, i) {
  var o = n._reactRootContainer;
  if (o) {
    var s = o;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = dv(s);
        a.call(l);
      };
    }
    Yv(e, s, t, i);
  } else s = UB(n, e, t, i, r);
  return dv(s);
}
RI = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = jd(e.pendingLanes);
        n !== 0 &&
          (uw(e, n | 1), wi(e, $n()), !(Kt & 6) && ((vf = $n() + 500), sl()));
      }
      break;
    case 13:
      bc(function () {
        var r = Ks(t, 1);
        if (r !== null) {
          var i = ai();
          Bo(r, t, 1, i);
        }
      }),
        Gw(t, 1);
  }
};
fw = function (t) {
  if (t.tag === 13) {
    var e = Ks(t, 134217728);
    if (e !== null) {
      var n = ai();
      Bo(e, t, 134217728, n);
    }
    Gw(t, 134217728);
  }
};
PI = function (t) {
  if (t.tag === 13) {
    var e = Ya(t),
      n = Ks(t, e);
    if (n !== null) {
      var r = ai();
      Bo(n, t, e, r);
    }
    Gw(t, e);
  }
};
II = function () {
  return on;
};
LI = function (t, e) {
  var n = on;
  try {
    return (on = t), e();
  } finally {
    on = n;
  }
};
xS = function (t, e, n) {
  switch (e) {
    case "input":
      if ((dS(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var r = n[e];
          if (r !== t && r.form === t.form) {
            var i = Hv(r);
            if (!i) throw Error(Xe(90));
            cI(r), dS(r, i);
          }
        }
      }
      break;
    case "textarea":
      fI(t, n);
      break;
    case "select":
      (e = n.value), e != null && tf(t, !!n.multiple, e, !1);
  }
};
yI = kw;
xI = bc;
var kB = { usingClientEntryPoint: !1, Events: [Mp, zu, Hv, gI, vI, kw] },
  wd = {
    findFiberByHostInstance: Zl,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  zB = {
    bundleType: wd.bundleType,
    version: wd.version,
    rendererPackageName: wd.rendererPackageName,
    rendererConfig: wd.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ra.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = AI(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: wd.findFiberByHostInstance || FB,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Qm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Qm.isDisabled && Qm.supportsFiber)
    try {
      (Uv = Qm.inject(zB)), (fs = Qm);
    } catch {}
}
Zi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = kB;
Zi.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!jw(e)) throw Error(Xe(200));
  return DB(t, e, null, n);
};
Zi.createRoot = function (t, e) {
  if (!jw(t)) throw Error(Xe(299));
  var n = !1,
    r = "",
    i = eO;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = Vw(t, 1, !1, null, null, n, !1, r, i)),
    (t[qs] = e.current),
    Rh(t.nodeType === 8 ? t.parentNode : t),
    new Ww(e)
  );
};
Zi.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(Xe(188))
      : ((t = Object.keys(t).join(",")), Error(Xe(268, t)));
  return (t = AI(e)), (t = t === null ? null : t.stateNode), t;
};
Zi.flushSync = function (t) {
  return bc(t);
};
Zi.hydrate = function (t, e, n) {
  if (!Kv(e)) throw Error(Xe(200));
  return Zv(null, t, e, !0, n);
};
Zi.hydrateRoot = function (t, e, n) {
  if (!jw(t)) throw Error(Xe(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    o = "",
    s = eO;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (s = n.onRecoverableError)),
    (e = QL(e, null, t, 1, n ?? null, i, !1, o, s)),
    (t[qs] = e.current),
    Rh(t),
    r)
  )
    for (t = 0; t < r.length; t++)
      (n = r[t]),
        (i = n._getVersion),
        (i = i(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, i])
          : e.mutableSourceEagerHydrationData.push(n, i);
  return new qv(e);
};
Zi.render = function (t, e, n) {
  if (!Kv(e)) throw Error(Xe(200));
  return Zv(null, t, e, !1, n);
};
Zi.unmountComponentAtNode = function (t) {
  if (!Kv(t)) throw Error(Xe(40));
  return t._reactRootContainer
    ? (bc(function () {
        Zv(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[qs] = null);
        });
      }),
      !0)
    : !1;
};
Zi.unstable_batchedUpdates = kw;
Zi.unstable_renderSubtreeIntoContainer = function (t, e, n, r) {
  if (!Kv(n)) throw Error(Xe(200));
  if (t == null || t._reactInternals === void 0) throw Error(Xe(38));
  return Zv(t, e, n, !1, r);
};
Zi.version = "18.3.1-next-f1338f8080-20240426";
function tO() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(tO);
    } catch (t) {
      console.error(t);
    }
}
tO(), (tI.exports = Zi);
var Jv = tI.exports;
const JS = Ap(Jv),
  BB = G3({ __proto__: null, default: JS }, [Jv]);
var nO,
  Z2 = Jv;
(nO = oS.createRoot = Z2.createRoot), (oS.hydrateRoot = Z2.hydrateRoot);
var rO = { exports: {} },
  iO = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Tp = L;
function HB(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var VB = typeof Object.is == "function" ? Object.is : HB,
  GB = Tp.useSyncExternalStore,
  WB = Tp.useRef,
  jB = Tp.useEffect,
  $B = Tp.useMemo,
  XB = Tp.useDebugValue;
iO.useSyncExternalStoreWithSelector = function (t, e, n, r, i) {
  var o = WB(null);
  if (o.current === null) {
    var s = { hasValue: !1, value: null };
    o.current = s;
  } else s = o.current;
  o = $B(
    function () {
      function l(m) {
        if (!c) {
          if (((c = !0), (u = m), (m = r(m)), i !== void 0 && s.hasValue)) {
            var v = s.value;
            if (i(v, m)) return (d = v);
          }
          return (d = m);
        }
        if (((v = d), VB(u, m))) return v;
        var _ = r(m);
        return i !== void 0 && i(v, _) ? ((u = m), v) : ((u = m), (d = _));
      }
      var c = !1,
        u,
        d,
        p = n === void 0 ? null : n;
      return [
        function () {
          return l(e());
        },
        p === null
          ? void 0
          : function () {
              return l(p());
            },
      ];
    },
    [e, n, r, i]
  );
  var a = GB(t, o[0], o[1]);
  return (
    jB(
      function () {
        (s.hasValue = !0), (s.value = a);
      },
      [a]
    ),
    XB(a),
    a
  );
};
rO.exports = iO;
var YB = rO.exports;
function qB(t) {
  t();
}
function KB() {
  let t = null,
    e = null;
  return {
    clear() {
      (t = null), (e = null);
    },
    notify() {
      qB(() => {
        let n = t;
        for (; n; ) n.callback(), (n = n.next);
      });
    },
    get() {
      const n = [];
      let r = t;
      for (; r; ) n.push(r), (r = r.next);
      return n;
    },
    subscribe(n) {
      let r = !0;
      const i = (e = { callback: n, next: null, prev: e });
      return (
        i.prev ? (i.prev.next = i) : (t = i),
        function () {
          !r ||
            t === null ||
            ((r = !1),
            i.next ? (i.next.prev = i.prev) : (e = i.prev),
            i.prev ? (i.prev.next = i.next) : (t = i.next));
        }
      );
    },
  };
}
var J2 = { notify() {}, get: () => [] };
function ZB(t, e) {
  let n,
    r = J2,
    i = 0,
    o = !1;
  function s(_) {
    u();
    const y = r.subscribe(_);
    let g = !1;
    return () => {
      g || ((g = !0), y(), d());
    };
  }
  function a() {
    r.notify();
  }
  function l() {
    v.onStateChange && v.onStateChange();
  }
  function c() {
    return o;
  }
  function u() {
    i++, n || ((n = t.subscribe(l)), (r = KB()));
  }
  function d() {
    i--, n && i === 0 && (n(), (n = void 0), r.clear(), (r = J2));
  }
  function p() {
    o || ((o = !0), u());
  }
  function m() {
    o && ((o = !1), d());
  }
  const v = {
    addNestedSub: s,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: p,
    tryUnsubscribe: m,
    getListeners: () => r,
  };
  return v;
}
var JB = () =>
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  QB = JB(),
  e5 = () => typeof navigator < "u" && navigator.product === "ReactNative",
  t5 = e5(),
  n5 = () => (QB || t5 ? L.useLayoutEffect : L.useEffect),
  r5 = n5(),
  R1 = Symbol.for("react-redux-context"),
  P1 = typeof globalThis < "u" ? globalThis : {};
function i5() {
  if (!L.createContext) return {};
  const t = P1[R1] ?? (P1[R1] = new Map());
  let e = t.get(L.createContext);
  return e || ((e = L.createContext(null)), t.set(L.createContext, e)), e;
}
var el = i5();
function o5(t) {
  const { children: e, context: n, serverState: r, store: i } = t,
    o = L.useMemo(() => {
      const l = ZB(i);
      return {
        store: i,
        subscription: l,
        getServerState: r ? () => r : void 0,
      };
    }, [i, r]),
    s = L.useMemo(() => i.getState(), [i]);
  r5(() => {
    const { subscription: l } = o;
    return (
      (l.onStateChange = l.notifyNestedSubs),
      l.trySubscribe(),
      s !== i.getState() && l.notifyNestedSubs(),
      () => {
        l.tryUnsubscribe(), (l.onStateChange = void 0);
      }
    );
  }, [o, s]);
  const a = n || el;
  return L.createElement(a.Provider, { value: o }, e);
}
var s5 = o5;
function $w(t = el) {
  return function () {
    return L.useContext(t);
  };
}
var oO = $w();
function sO(t = el) {
  const e = t === el ? oO : $w(t),
    n = () => {
      const { store: r } = e();
      return r;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var a5 = sO();
function l5(t = el) {
  const e = t === el ? a5 : sO(t),
    n = () => e().dispatch;
  return Object.assign(n, { withTypes: () => n }), n;
}
var $o = l5(),
  c5 = (t, e) => t === e;
function u5(t = el) {
  const e = t === el ? oO : $w(t),
    n = (r, i = {}) => {
      const { equalityFn: o = c5 } =
          typeof i == "function" ? { equalityFn: i } : i,
        s = e(),
        { store: a, subscription: l, getServerState: c } = s;
      L.useRef(!0);
      const u = L.useCallback(
          {
            [r.name](p) {
              return r(p);
            },
          }[r.name],
          [r]
        ),
        d = YB.useSyncExternalStoreWithSelector(
          l.addNestedSub,
          a.getState,
          c || a.getState,
          u,
          o
        );
      return L.useDebugValue(d), d;
    };
  return Object.assign(n, { withTypes: () => n }), n;
}
var Mi = u5();
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Qv = "164",
  Wl = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  jl = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  aO = 0,
  QS = 1,
  lO = 2,
  f5 = 3,
  cO = 0,
  ey = 1,
  uh = 2,
  Lo = 3,
  Js = 0,
  li = 1,
  mo = 2,
  js = 0,
  uc = 1,
  eA = 2,
  tA = 3,
  nA = 4,
  uO = 5,
  Fa = 100,
  fO = 101,
  dO = 102,
  hO = 103,
  pO = 104,
  mO = 200,
  gO = 201,
  vO = 202,
  yO = 203,
  hv = 204,
  pv = 205,
  xO = 206,
  _O = 207,
  SO = 208,
  AO = 209,
  bO = 210,
  wO = 211,
  EO = 212,
  MO = 213,
  CO = 214,
  TO = 0,
  RO = 1,
  PO = 2,
  kh = 3,
  IO = 4,
  LO = 5,
  OO = 6,
  NO = 7,
  Rp = 0,
  DO = 1,
  FO = 2,
  hs = 0,
  UO = 1,
  kO = 2,
  zO = 3,
  Xw = 4,
  BO = 5,
  HO = 6,
  VO = 7,
  rA = "attached",
  GO = "detached",
  ty = 300,
  Qs = 301,
  tl = 302,
  zh = 303,
  Bh = 304,
  Nf = 306,
  Hh = 1e3,
  vo = 1001,
  Vh = 1002,
  xr = 1003,
  Yw = 1004,
  d5 = 1004,
  $u = 1005,
  h5 = 1005,
  kn = 1006,
  fh = 1007,
  p5 = 1007,
  ls = 1008,
  m5 = 1008,
  gs = 1009,
  WO = 1010,
  jO = 1011,
  qw = 1012,
  Kw = 1013,
  wc = 1014,
  yo = 1015,
  Pp = 1016,
  Zw = 1017,
  Jw = 1018,
  Df = 1020,
  $O = 35902,
  XO = 1021,
  YO = 1022,
  Si = 1023,
  qO = 1024,
  KO = 1025,
  fc = 1026,
  yf = 1027,
  Qw = 1028,
  eE = 1029,
  ZO = 1030,
  tE = 1031,
  nE = 1033,
  b0 = 33776,
  w0 = 33777,
  E0 = 33778,
  M0 = 33779,
  iA = 35840,
  oA = 35841,
  sA = 35842,
  aA = 35843,
  lA = 36196,
  cA = 37492,
  uA = 37496,
  fA = 37808,
  dA = 37809,
  hA = 37810,
  pA = 37811,
  mA = 37812,
  gA = 37813,
  vA = 37814,
  yA = 37815,
  xA = 37816,
  _A = 37817,
  SA = 37818,
  AA = 37819,
  bA = 37820,
  wA = 37821,
  C0 = 36492,
  EA = 36494,
  MA = 36495,
  JO = 36283,
  CA = 36284,
  TA = 36285,
  RA = 36286,
  QO = 2200,
  eN = 2201,
  tN = 2202,
  Gh = 2300,
  Wh = 2301,
  T0 = 2302,
  ec = 2400,
  tc = 2401,
  jh = 2402,
  ny = 2500,
  rE = 2501,
  g5 = 0,
  v5 = 1,
  y5 = 2,
  nN = 3200,
  iE = 3201,
  al = 0,
  rN = 1,
  zs = "",
  fo = "srgb",
  ia = "srgb-linear",
  ry = "display-p3",
  Ip = "display-p3-linear",
  $h = "linear",
  hn = "srgb",
  Xh = "rec709",
  Yh = "p3",
  x5 = 0,
  $l = 7680,
  _5 = 7681,
  S5 = 7682,
  A5 = 7683,
  b5 = 34055,
  w5 = 34056,
  E5 = 5386,
  M5 = 512,
  C5 = 513,
  T5 = 514,
  R5 = 515,
  P5 = 516,
  I5 = 517,
  L5 = 518,
  PA = 519,
  iN = 512,
  oN = 513,
  sN = 514,
  oE = 515,
  aN = 516,
  lN = 517,
  cN = 518,
  uN = 519,
  qh = 35044,
  O5 = 35048,
  N5 = 35040,
  D5 = 35045,
  F5 = 35049,
  U5 = 35041,
  k5 = 35046,
  z5 = 35050,
  B5 = 35042,
  H5 = "100",
  IA = "300 es",
  cs = 2e3,
  Kh = 2001;
let oa = class {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(n);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
const Br = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Q2 = 1234567;
const dc = Math.PI / 180,
  xf = 180 / Math.PI;
function Xi() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Br[t & 255] +
    Br[(t >> 8) & 255] +
    Br[(t >> 16) & 255] +
    Br[(t >> 24) & 255] +
    "-" +
    Br[e & 255] +
    Br[(e >> 8) & 255] +
    "-" +
    Br[((e >> 16) & 15) | 64] +
    Br[(e >> 24) & 255] +
    "-" +
    Br[(n & 63) | 128] +
    Br[(n >> 8) & 255] +
    "-" +
    Br[(n >> 16) & 255] +
    Br[(n >> 24) & 255] +
    Br[r & 255] +
    Br[(r >> 8) & 255] +
    Br[(r >> 16) & 255] +
    Br[(r >> 24) & 255]
  ).toLowerCase();
}
function Un(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function sE(t, e) {
  return ((t % e) + e) % e;
}
function V5(t, e, n, r, i) {
  return r + ((t - e) * (i - r)) / (n - e);
}
function G5(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0;
}
function dh(t, e, n) {
  return (1 - n) * t + n * e;
}
function W5(t, e, n, r) {
  return dh(t, e, 1 - Math.exp(-n * r));
}
function j5(t, e = 1) {
  return e - Math.abs(sE(t, e * 2) - e);
}
function $5(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * (3 - 2 * t));
}
function X5(t, e, n) {
  return t <= e
    ? 0
    : t >= n
    ? 1
    : ((t = (t - e) / (n - e)), t * t * t * (t * (t * 6 - 15) + 10));
}
function Y5(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function q5(t, e) {
  return t + Math.random() * (e - t);
}
function K5(t) {
  return t * (0.5 - Math.random());
}
function Z5(t) {
  t !== void 0 && (Q2 = t);
  let e = (Q2 += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function J5(t) {
  return t * dc;
}
function Q5(t) {
  return t * xf;
}
function e6(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function t6(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function n6(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function r6(t, e, n, r, i) {
  const o = Math.cos,
    s = Math.sin,
    a = o(n / 2),
    l = s(n / 2),
    c = o((e + r) / 2),
    u = s((e + r) / 2),
    d = o((e - r) / 2),
    p = s((e - r) / 2),
    m = o((r - e) / 2),
    v = s((r - e) / 2);
  switch (i) {
    case "XYX":
      t.set(a * u, l * d, l * p, a * c);
      break;
    case "YZY":
      t.set(l * p, a * u, l * d, a * c);
      break;
    case "ZXZ":
      t.set(l * d, l * p, a * u, a * c);
      break;
    case "XZX":
      t.set(a * u, l * v, l * m, a * c);
      break;
    case "YXY":
      t.set(l * m, a * u, l * v, a * c);
      break;
    case "ZYZ":
      t.set(l * v, l * m, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function si(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Ot(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const i6 = {
  DEG2RAD: dc,
  RAD2DEG: xf,
  generateUUID: Xi,
  clamp: Un,
  euclideanModulo: sE,
  mapLinear: V5,
  inverseLerp: G5,
  lerp: dh,
  damp: W5,
  pingpong: j5,
  smoothstep: $5,
  smootherstep: X5,
  randInt: Y5,
  randFloat: q5,
  randFloatSpread: K5,
  seededRandom: Z5,
  degToRad: J5,
  radToDeg: Q5,
  isPowerOfTwo: e6,
  ceilPowerOfTwo: t6,
  floorPowerOfTwo: n6,
  setQuaternionFromProperEuler: r6,
  normalize: Ot,
  denormalize: si,
};
let ke = class fN {
    constructor(e = 0, n = 0) {
      (fN.prototype.isVector2 = !0), (this.x = e), (this.y = n);
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, n) {
      return (this.x = e), (this.y = n), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setComponent(e, n) {
      switch (e) {
        case 0:
          this.x = n;
          break;
        case 1:
          this.y = n;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), this;
    }
    addVectors(e, n) {
      return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
    }
    addScaledVector(e, n) {
      return (this.x += e.x * n), (this.y += e.y * n), this;
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, n) {
      return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const n = this.x,
        r = this.y,
        i = e.elements;
      return (
        (this.x = i[0] * n + i[3] * r + i[6]),
        (this.y = i[1] * n + i[4] * r + i[7]),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
      );
    }
    clamp(e, n) {
      return (
        (this.x = Math.max(e.x, Math.min(n.x, this.x))),
        (this.y = Math.max(e.y, Math.min(n.y, this.y))),
        this
      );
    }
    clampScalar(e, n) {
      return (
        (this.x = Math.max(e, Math.min(n, this.x))),
        (this.y = Math.max(e, Math.min(n, this.y))),
        this
      );
    }
    clampLength(e, n) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(n, r))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
      const n = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (n === 0) return Math.PI / 2;
      const r = this.dot(e) / n;
      return Math.acos(Un(r, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const n = this.x - e.x,
        r = this.y - e.y;
      return n * n + r * r;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, n) {
      return (
        (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this
      );
    }
    lerpVectors(e, n, r) {
      return (
        (this.x = e.x + (n.x - e.x) * r), (this.y = e.y + (n.y - e.y) * r), this
      );
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, n = 0) {
      return (this.x = e[n]), (this.y = e[n + 1]), this;
    }
    toArray(e = [], n = 0) {
      return (e[n] = this.x), (e[n + 1] = this.y), e;
    }
    fromBufferAttribute(e, n) {
      return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
    }
    rotateAround(e, n) {
      const r = Math.cos(n),
        i = Math.sin(n),
        o = this.x - e.x,
        s = this.y - e.y;
      return (
        (this.x = o * r - s * i + e.x), (this.y = o * i + s * r + e.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  },
  Dt = class dN {
    constructor(e, n, r, i, o, s, a, l, c) {
      (dN.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        e !== void 0 && this.set(e, n, r, i, o, s, a, l, c);
    }
    set(e, n, r, i, o, s, a, l, c) {
      const u = this.elements;
      return (
        (u[0] = e),
        (u[1] = i),
        (u[2] = a),
        (u[3] = n),
        (u[4] = o),
        (u[5] = l),
        (u[6] = r),
        (u[7] = s),
        (u[8] = c),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const n = this.elements,
        r = e.elements;
      return (
        (n[0] = r[0]),
        (n[1] = r[1]),
        (n[2] = r[2]),
        (n[3] = r[3]),
        (n[4] = r[4]),
        (n[5] = r[5]),
        (n[6] = r[6]),
        (n[7] = r[7]),
        (n[8] = r[8]),
        this
      );
    }
    extractBasis(e, n, r) {
      return (
        e.setFromMatrix3Column(this, 0),
        n.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(e) {
      const n = e.elements;
      return (
        this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, n) {
      const r = e.elements,
        i = n.elements,
        o = this.elements,
        s = r[0],
        a = r[3],
        l = r[6],
        c = r[1],
        u = r[4],
        d = r[7],
        p = r[2],
        m = r[5],
        v = r[8],
        _ = i[0],
        y = i[3],
        g = i[6],
        x = i[1],
        S = i[4],
        b = i[7],
        C = i[2],
        M = i[5],
        T = i[8];
      return (
        (o[0] = s * _ + a * x + l * C),
        (o[3] = s * y + a * S + l * M),
        (o[6] = s * g + a * b + l * T),
        (o[1] = c * _ + u * x + d * C),
        (o[4] = c * y + u * S + d * M),
        (o[7] = c * g + u * b + d * T),
        (o[2] = p * _ + m * x + v * C),
        (o[5] = p * y + m * S + v * M),
        (o[8] = p * g + m * b + v * T),
        this
      );
    }
    multiplyScalar(e) {
      const n = this.elements;
      return (
        (n[0] *= e),
        (n[3] *= e),
        (n[6] *= e),
        (n[1] *= e),
        (n[4] *= e),
        (n[7] *= e),
        (n[2] *= e),
        (n[5] *= e),
        (n[8] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        n = e[0],
        r = e[1],
        i = e[2],
        o = e[3],
        s = e[4],
        a = e[5],
        l = e[6],
        c = e[7],
        u = e[8];
      return (
        n * s * u - n * a * c - r * o * u + r * a * l + i * o * c - i * s * l
      );
    }
    invert() {
      const e = this.elements,
        n = e[0],
        r = e[1],
        i = e[2],
        o = e[3],
        s = e[4],
        a = e[5],
        l = e[6],
        c = e[7],
        u = e[8],
        d = u * s - a * c,
        p = a * l - u * o,
        m = c * o - s * l,
        v = n * d + r * p + i * m;
      if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const _ = 1 / v;
      return (
        (e[0] = d * _),
        (e[1] = (i * c - u * r) * _),
        (e[2] = (a * r - i * s) * _),
        (e[3] = p * _),
        (e[4] = (u * n - i * l) * _),
        (e[5] = (i * o - a * n) * _),
        (e[6] = m * _),
        (e[7] = (r * l - c * n) * _),
        (e[8] = (s * n - r * o) * _),
        this
      );
    }
    transpose() {
      let e;
      const n = this.elements;
      return (
        (e = n[1]),
        (n[1] = n[3]),
        (n[3] = e),
        (e = n[2]),
        (n[2] = n[6]),
        (n[6] = e),
        (e = n[5]),
        (n[5] = n[7]),
        (n[7] = e),
        this
      );
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const n = this.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[3]),
        (e[2] = n[6]),
        (e[3] = n[1]),
        (e[4] = n[4]),
        (e[5] = n[7]),
        (e[6] = n[2]),
        (e[7] = n[5]),
        (e[8] = n[8]),
        this
      );
    }
    setUvTransform(e, n, r, i, o, s, a) {
      const l = Math.cos(o),
        c = Math.sin(o);
      return (
        this.set(
          r * l,
          r * c,
          -r * (l * s + c * a) + s + e,
          -i * c,
          i * l,
          -i * (-c * s + l * a) + a + n,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(e, n) {
      return this.premultiply(I1.makeScale(e, n)), this;
    }
    rotate(e) {
      return this.premultiply(I1.makeRotation(-e)), this;
    }
    translate(e, n) {
      return this.premultiply(I1.makeTranslation(e, n)), this;
    }
    makeTranslation(e, n) {
      return (
        e.isVector2
          ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
          : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
        this
      );
    }
    makeRotation(e) {
      const n = Math.cos(e),
        r = Math.sin(e);
      return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this;
    }
    makeScale(e, n) {
      return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
    }
    equals(e) {
      const n = this.elements,
        r = e.elements;
      for (let i = 0; i < 9; i++) if (n[i] !== r[i]) return !1;
      return !0;
    }
    fromArray(e, n = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
      return this;
    }
    toArray(e = [], n = 0) {
      const r = this.elements;
      return (
        (e[n] = r[0]),
        (e[n + 1] = r[1]),
        (e[n + 2] = r[2]),
        (e[n + 3] = r[3]),
        (e[n + 4] = r[4]),
        (e[n + 5] = r[5]),
        (e[n + 6] = r[6]),
        (e[n + 7] = r[7]),
        (e[n + 8] = r[8]),
        e
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
const I1 = new Dt();
function hN(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
const o6 = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Xu(t, e) {
  return new o6[t](e);
}
function Zh(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function pN() {
  const t = Zh("canvas");
  return (t.style.display = "block"), t;
}
const eT = {};
function mN(t) {
  t in eT || ((eT[t] = !0), console.warn(t));
}
const tT = new Dt().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  nT = new Dt().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  eg = {
    [ia]: {
      transfer: $h,
      primaries: Xh,
      toReference: (t) => t,
      fromReference: (t) => t,
    },
    [fo]: {
      transfer: hn,
      primaries: Xh,
      toReference: (t) => t.convertSRGBToLinear(),
      fromReference: (t) => t.convertLinearToSRGB(),
    },
    [Ip]: {
      transfer: $h,
      primaries: Yh,
      toReference: (t) => t.applyMatrix3(nT),
      fromReference: (t) => t.applyMatrix3(tT),
    },
    [ry]: {
      transfer: hn,
      primaries: Yh,
      toReference: (t) => t.convertSRGBToLinear().applyMatrix3(nT),
      fromReference: (t) => t.applyMatrix3(tT).convertLinearToSRGB(),
    },
  },
  s6 = new Set([ia, Ip]),
  rn = {
    enabled: !0,
    _workingColorSpace: ia,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(t) {
      if (!s6.has(t))
        throw new Error(`Unsupported working color space, "${t}".`);
      this._workingColorSpace = t;
    },
    convert: function (t, e, n) {
      if (this.enabled === !1 || e === n || !e || !n) return t;
      const r = eg[e].toReference,
        i = eg[n].fromReference;
      return i(r(t));
    },
    fromWorkingColorSpace: function (t, e) {
      return this.convert(t, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (t, e) {
      return this.convert(t, e, this._workingColorSpace);
    },
    getPrimaries: function (t) {
      return eg[t].primaries;
    },
    getTransfer: function (t) {
      return t === zs ? $h : eg[t].transfer;
    },
  };
function lf(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function L1(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let ru,
  gN = class {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let n;
      if (e instanceof HTMLCanvasElement) n = e;
      else {
        ru === void 0 && (ru = Zh("canvas")),
          (ru.width = e.width),
          (ru.height = e.height);
        const r = ru.getContext("2d");
        e instanceof ImageData
          ? r.putImageData(e, 0, 0)
          : r.drawImage(e, 0, 0, e.width, e.height),
          (n = ru);
      }
      return n.width > 2048 || n.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            e
          ),
          n.toDataURL("image/jpeg", 0.6))
        : n.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (
        (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
      ) {
        const n = Zh("canvas");
        (n.width = e.width), (n.height = e.height);
        const r = n.getContext("2d");
        r.drawImage(e, 0, 0, e.width, e.height);
        const i = r.getImageData(0, 0, e.width, e.height),
          o = i.data;
        for (let s = 0; s < o.length; s++) o[s] = lf(o[s] / 255) * 255;
        return r.putImageData(i, 0, 0), n;
      } else if (e.data) {
        const n = e.data.slice(0);
        for (let r = 0; r < n.length; r++)
          n instanceof Uint8Array || n instanceof Uint8ClampedArray
            ? (n[r] = Math.floor(lf(n[r] / 255) * 255))
            : (n[r] = lf(n[r]));
        return { data: n, width: e.width, height: e.height };
      } else
        return (
          console.warn(
            "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
          ),
          e
        );
    }
  },
  a6 = 0,
  nc = class {
    constructor(e = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: a6++ }),
        (this.uuid = Xi()),
        (this.data = e),
        (this.dataReady = !0),
        (this.version = 0);
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    toJSON(e) {
      const n = e === void 0 || typeof e == "string";
      if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const r = { uuid: this.uuid, url: "" },
        i = this.data;
      if (i !== null) {
        let o;
        if (Array.isArray(i)) {
          o = [];
          for (let s = 0, a = i.length; s < a; s++)
            i[s].isDataTexture ? o.push(O1(i[s].image)) : o.push(O1(i[s]));
        } else o = O1(i);
        r.url = o;
      }
      return n || (e.images[this.uuid] = r), r;
    }
  };
function O1(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? gN.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let l6 = 0,
  lr = class R0 extends oa {
    constructor(
      e = R0.DEFAULT_IMAGE,
      n = R0.DEFAULT_MAPPING,
      r = vo,
      i = vo,
      o = kn,
      s = ls,
      a = Si,
      l = gs,
      c = R0.DEFAULT_ANISOTROPY,
      u = zs
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: l6++ }),
        (this.uuid = Xi()),
        (this.name = ""),
        (this.source = new nc(e)),
        (this.mipmaps = []),
        (this.mapping = n),
        (this.channel = 0),
        (this.wrapS = r),
        (this.wrapT = i),
        (this.magFilter = o),
        (this.minFilter = s),
        (this.anisotropy = c),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = l),
        (this.offset = new ke(0, 0)),
        (this.repeat = new ke(1, 1)),
        (this.center = new ke(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Dt()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.colorSpace = u),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.pmremVersion = 0);
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.source = e.source),
        (this.mipmaps = e.mipmaps.slice(0)),
        (this.mapping = e.mapping),
        (this.channel = e.channel),
        (this.wrapS = e.wrapS),
        (this.wrapT = e.wrapT),
        (this.magFilter = e.magFilter),
        (this.minFilter = e.minFilter),
        (this.anisotropy = e.anisotropy),
        (this.format = e.format),
        (this.internalFormat = e.internalFormat),
        (this.type = e.type),
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        (this.rotation = e.rotation),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this.matrix.copy(e.matrix),
        (this.generateMipmaps = e.generateMipmaps),
        (this.premultiplyAlpha = e.premultiplyAlpha),
        (this.flipY = e.flipY),
        (this.unpackAlignment = e.unpackAlignment),
        (this.colorSpace = e.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(e) {
      const n = e === void 0 || typeof e == "string";
      if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const r = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        n || (e.textures[this.uuid] = r),
        r
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (this.mapping !== ty) return e;
      if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
        switch (this.wrapS) {
          case Hh:
            e.x = e.x - Math.floor(e.x);
            break;
          case vo:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case Vh:
            Math.abs(Math.floor(e.x) % 2) === 1
              ? (e.x = Math.ceil(e.x) - e.x)
              : (e.x = e.x - Math.floor(e.x));
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case Hh:
            e.y = e.y - Math.floor(e.y);
            break;
          case vo:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case Vh:
            Math.abs(Math.floor(e.y) % 2) === 1
              ? (e.y = Math.ceil(e.y) - e.y)
              : (e.y = e.y - Math.floor(e.y));
            break;
        }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
    set needsPMREMUpdate(e) {
      e === !0 && this.pmremVersion++;
    }
  };
lr.DEFAULT_IMAGE = null;
lr.DEFAULT_MAPPING = ty;
lr.DEFAULT_ANISOTROPY = 1;
class tn {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (tn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, r, i) {
    return (this.x = e), (this.y = n), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x),
      (this.y = e.y + n.y),
      (this.z = e.z + n.z),
      (this.w = e.w + n.w),
      this
    );
  }
  addScaledVector(e, n) {
    return (
      (this.x += e.x * n),
      (this.y += e.y * n),
      (this.z += e.z * n),
      (this.w += e.w * n),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x),
      (this.y = e.y - n.y),
      (this.z = e.z - n.z),
      (this.w = e.w - n.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = this.w,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[4] * r + s[8] * i + s[12] * o),
      (this.y = s[1] * n + s[5] * r + s[9] * i + s[13] * o),
      (this.z = s[2] * n + s[6] * r + s[10] * i + s[14] * o),
      (this.w = s[3] * n + s[7] * r + s[11] * i + s[15] * o),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return (
      n < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / n), (this.y = e.y / n), (this.z = e.z / n)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, r, i, o;
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      v = l[9],
      _ = l[2],
      y = l[6],
      g = l[10];
    if (
      Math.abs(u - p) < 0.01 &&
      Math.abs(d - _) < 0.01 &&
      Math.abs(v - y) < 0.01
    ) {
      if (
        Math.abs(u + p) < 0.1 &&
        Math.abs(d + _) < 0.1 &&
        Math.abs(v + y) < 0.1 &&
        Math.abs(c + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (c + 1) / 2,
        b = (m + 1) / 2,
        C = (g + 1) / 2,
        M = (u + p) / 4,
        T = (d + _) / 4,
        P = (v + y) / 4;
      return (
        S > b && S > C
          ? S < 0.01
            ? ((r = 0), (i = 0.707106781), (o = 0.707106781))
            : ((r = Math.sqrt(S)), (i = M / r), (o = T / r))
          : b > C
          ? b < 0.01
            ? ((r = 0.707106781), (i = 0), (o = 0.707106781))
            : ((i = Math.sqrt(b)), (r = M / i), (o = P / i))
          : C < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (o = 0))
          : ((o = Math.sqrt(C)), (r = T / o), (i = P / o)),
        this.set(r, i, o, n),
        this
      );
    }
    let x = Math.sqrt(
      (y - v) * (y - v) + (d - _) * (d - _) + (p - u) * (p - u)
    );
    return (
      Math.abs(x) < 0.001 && (x = 1),
      (this.x = (y - v) / x),
      (this.y = (d - _) / x),
      (this.z = (p - u) / x),
      (this.w = Math.acos((c + m + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      (this.w = Math.max(e.w, Math.min(n.w, this.w))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      (this.w = Math.max(e, Math.min(n, this.w))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      (this.w += (e.w - this.w) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      (this.w = e.w + (n.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return (
      (this.x = e[n]),
      (this.y = e[n + 1]),
      (this.z = e[n + 2]),
      (this.w = e[n + 3]),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this.x),
      (e[n + 1] = this.y),
      (e[n + 2] = this.z),
      (e[n + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)),
      (this.y = e.getY(n)),
      (this.z = e.getZ(n)),
      (this.w = e.getW(n)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class vN extends oa {
  constructor(e = 1, n = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = n),
      (this.depth = 1),
      (this.scissor = new tn(0, 0, e, n)),
      (this.scissorTest = !1),
      (this.viewport = new tn(0, 0, e, n));
    const i = { width: e, height: n, depth: 1 };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: kn,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      r
    );
    const o = new lr(
      i,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (o.flipY = !1),
      (o.generateMipmaps = r.generateMipmaps),
      (o.internalFormat = r.internalFormat),
      (this.textures = []);
    const s = r.count;
    for (let a = 0; a < s; a++)
      (this.textures[a] = o.clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, r = 1) {
    if (this.width !== e || this.height !== n || this.depth !== r) {
      (this.width = e), (this.height = n), (this.depth = r);
      for (let i = 0, o = this.textures.length; i < o; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = n),
          (this.textures[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let r = 0, i = e.textures.length; r < i; r++)
      (this.textures[r] = e.textures[r].clone()),
        (this.textures[r].isRenderTargetTexture = !0);
    const n = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new nc(n)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Wo extends vN {
  constructor(e = 1, n = 1, r = {}) {
    super(e, n, r), (this.isWebGLRenderTarget = !0);
  }
}
class iy extends lr {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = xr),
      (this.minFilter = xr),
      (this.wrapR = vo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class c6 extends Wo {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new iy(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class aE extends lr {
  constructor(e = null, n = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: n, height: r, depth: i }),
      (this.magFilter = xr),
      (this.minFilter = xr),
      (this.wrapR = vo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class u6 extends Wo {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    super(e, n, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new aE(null, e, n, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class $r {
  constructor(e = 0, n = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, n, r, i, o, s, a) {
    let l = r[i + 0],
      c = r[i + 1],
      u = r[i + 2],
      d = r[i + 3];
    const p = o[s + 0],
      m = o[s + 1],
      v = o[s + 2],
      _ = o[s + 3];
    if (a === 0) {
      (e[n + 0] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
      return;
    }
    if (a === 1) {
      (e[n + 0] = p), (e[n + 1] = m), (e[n + 2] = v), (e[n + 3] = _);
      return;
    }
    if (d !== _ || l !== p || c !== m || u !== v) {
      let y = 1 - a;
      const g = l * p + c * m + u * v + d * _,
        x = g >= 0 ? 1 : -1,
        S = 1 - g * g;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S),
          M = Math.atan2(C, g * x);
        (y = Math.sin(y * M) / C), (a = Math.sin(a * M) / C);
      }
      const b = a * x;
      if (
        ((l = l * y + p * b),
        (c = c * y + m * b),
        (u = u * y + v * b),
        (d = d * y + _ * b),
        y === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
        (l *= C), (c *= C), (u *= C), (d *= C);
      }
    }
    (e[n] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
  }
  static multiplyQuaternionsFlat(e, n, r, i, o, s) {
    const a = r[i],
      l = r[i + 1],
      c = r[i + 2],
      u = r[i + 3],
      d = o[s],
      p = o[s + 1],
      m = o[s + 2],
      v = o[s + 3];
    return (
      (e[n] = a * v + u * d + l * m - c * p),
      (e[n + 1] = l * v + u * p + c * d - a * m),
      (e[n + 2] = c * v + u * m + a * p - l * d),
      (e[n + 3] = u * v - a * d - l * p - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, n, r, i) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, n = !0) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(r / 2),
      u = a(i / 2),
      d = a(o / 2),
      p = l(r / 2),
      m = l(i / 2),
      v = l(o / 2);
    switch (s) {
      case "XYZ":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "YXZ":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      case "ZXY":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "ZYX":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      case "YZX":
        (this._x = p * u * d + c * m * v),
          (this._y = c * m * d + p * u * v),
          (this._z = c * u * v - p * m * d),
          (this._w = c * u * d - p * m * v);
        break;
      case "XZY":
        (this._x = p * u * d - c * m * v),
          (this._y = c * m * d - p * u * v),
          (this._z = c * u * v + p * m * d),
          (this._w = c * u * d + p * m * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s
        );
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const r = n / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const n = e.elements,
      r = n[0],
      i = n[4],
      o = n[8],
      s = n[1],
      a = n[5],
      l = n[9],
      c = n[2],
      u = n[6],
      d = n[10],
      p = r + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (u - l) * m),
        (this._y = (o - c) * m),
        (this._z = (s - i) * m);
    } else if (r > a && r > d) {
      const m = 2 * Math.sqrt(1 + r - a - d);
      (this._w = (u - l) / m),
        (this._x = 0.25 * m),
        (this._y = (i + s) / m),
        (this._z = (o + c) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - r - d);
      (this._w = (o - c) / m),
        (this._x = (i + s) / m),
        (this._y = 0.25 * m),
        (this._z = (l + u) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - r - a);
      (this._w = (s - i) / m),
        (this._x = (o + c) / m),
        (this._y = (l + u) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let r = e.dot(n) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * n.z - e.z * n.y),
          (this._y = e.z * n.x - e.x * n.z),
          (this._z = e.x * n.y - e.y * n.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Un(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, n / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const r = e._x,
      i = e._y,
      o = e._z,
      s = e._w,
      a = n._x,
      l = n._y,
      c = n._z,
      u = n._w;
    return (
      (this._x = r * u + s * a + i * c - o * l),
      (this._y = i * u + s * l + o * a - r * c),
      (this._z = o * u + s * c + r * l - i * a),
      (this._w = s * u - r * a - i * l - o * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      o = this._z,
      s = this._w;
    let a = s * e._w + r * e._x + i * e._y + o * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = s), (this._x = r), (this._y = i), (this._z = o), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - n;
      return (
        (this._w = m * s + n * this._w),
        (this._x = m * r + n * this._x),
        (this._y = m * i + n * this._y),
        (this._z = m * o + n * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      d = Math.sin((1 - n) * u) / c,
      p = Math.sin(n * u) / c;
    return (
      (this._w = s * d + this._w * p),
      (this._x = r * d + this._x * p),
      (this._y = i * d + this._y * p),
      (this._z = o * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, n, r) {
    return this.copy(e).slerp(n, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      n = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      o = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, n = 0) {
    return (
      (this._x = e[n]),
      (this._y = e[n + 1]),
      (this._z = e[n + 2]),
      (this._w = e[n + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this._x = e.getX(n)),
      (this._y = e.getY(n)),
      (this._z = e.getZ(n)),
      (this._w = e.getW(n)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ee {
  constructor(e = 0, n = 0, r = 0) {
    (ee.prototype.isVector3 = !0), (this.x = e), (this.y = n), (this.z = r);
  }
  set(e, n, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = n),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x), (this.y = e.y + n.y), (this.z = e.z + n.z), this
    );
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), (this.z += e.z * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x), (this.y = e.y - n.y), (this.z = e.z - n.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, n) {
    return (
      (this.x = e.x * n.x), (this.y = e.y * n.y), (this.z = e.z * n.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(rT.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(rT.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[3] * r + o[6] * i),
      (this.y = o[1] * n + o[4] * r + o[7] * i),
      (this.z = o[2] * n + o[5] * r + o[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements,
      s = 1 / (o[3] * n + o[7] * r + o[11] * i + o[15]);
    return (
      (this.x = (o[0] * n + o[4] * r + o[8] * i + o[12]) * s),
      (this.y = (o[1] * n + o[5] * r + o[9] * i + o[13]) * s),
      (this.z = (o[2] * n + o[6] * r + o[10] * i + o[14]) * s),
      this
    );
  }
  applyQuaternion(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.x,
      s = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (s * i - a * r),
      u = 2 * (a * n - o * i),
      d = 2 * (o * r - s * n);
    return (
      (this.x = n + l * c + s * d - a * u),
      (this.y = r + l * u + a * c - o * d),
      (this.z = i + l * d + o * u - s * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const n = this.x,
      r = this.y,
      i = this.z,
      o = e.elements;
    return (
      (this.x = o[0] * n + o[4] * r + o[8] * i),
      (this.y = o[1] * n + o[5] * r + o[9] * i),
      (this.z = o[2] * n + o[6] * r + o[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      this
    );
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r),
      (this.y = e.y + (n.y - e.y) * r),
      (this.z = e.z + (n.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = n.x,
      a = n.y,
      l = n.z;
    return (
      (this.x = i * l - o * a),
      (this.y = o * s - r * l),
      (this.z = r * a - i * s),
      this
    );
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / n;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return N1.copy(this).projectOnVector(e), this.sub(N1);
  }
  reflect(e) {
    return this.sub(N1.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(Un(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return n * n + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, r) {
    const i = Math.sin(n) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(n) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, r) {
    return (
      (this.x = e * Math.sin(n)), (this.y = r), (this.z = e * Math.cos(n)), this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = n), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), (this.z = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), (e[n + 2] = this.z), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)), (this.y = e.getY(n)), (this.z = e.getZ(n)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      n = Math.random() * 2 - 1,
      r = Math.sqrt(1 - n * n);
    return (
      (this.x = r * Math.cos(e)), (this.y = n), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const N1 = new ee(),
  rT = new $r();
class Rr {
  constructor(
    e = new ee(1 / 0, 1 / 0, 1 / 0),
    n = new ee(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n += 3)
      this.expandByPoint(To.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, r = e.count; n < r; n++)
      this.expandByPoint(To.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = To.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const o = r.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let s = 0, a = o.count; s < a; s++)
          e.isMesh === !0
            ? e.getVertexPosition(s, To)
            : To.fromBufferAttribute(o, s),
            To.applyMatrix4(e.matrixWorld),
            this.expandByPoint(To);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            tg.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            tg.copy(r.boundingBox)),
          tg.applyMatrix4(e.matrixWorld),
          this.union(tg);
    }
    const i = e.children;
    for (let o = 0, s = i.length; o < s; o++) this.expandByObject(i[o], n);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, To),
      To.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let n, r;
    return (
      e.normal.x > 0
        ? ((n = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((n = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((n += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((n += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((n += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((n += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      n <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Ed),
      ng.subVectors(this.max, Ed),
      iu.subVectors(e.a, Ed),
      ou.subVectors(e.b, Ed),
      su.subVectors(e.c, Ed),
      Sa.subVectors(ou, iu),
      Aa.subVectors(su, ou),
      Rl.subVectors(iu, su);
    let n = [
      0,
      -Sa.z,
      Sa.y,
      0,
      -Aa.z,
      Aa.y,
      0,
      -Rl.z,
      Rl.y,
      Sa.z,
      0,
      -Sa.x,
      Aa.z,
      0,
      -Aa.x,
      Rl.z,
      0,
      -Rl.x,
      -Sa.y,
      Sa.x,
      0,
      -Aa.y,
      Aa.x,
      0,
      -Rl.y,
      Rl.x,
      0,
    ];
    return !D1(n, iu, ou, su, ng) ||
      ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !D1(n, iu, ou, su, ng))
      ? !1
      : (rg.crossVectors(Sa, Aa),
        (n = [rg.x, rg.y, rg.z]),
        D1(n, iu, ou, su, ng));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, To).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(To).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ps[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ps[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ps[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ps[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ps[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ps[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ps[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ps[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ps),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ps = [
    new ee(),
    new ee(),
    new ee(),
    new ee(),
    new ee(),
    new ee(),
    new ee(),
    new ee(),
  ],
  To = new ee(),
  tg = new Rr(),
  iu = new ee(),
  ou = new ee(),
  su = new ee(),
  Sa = new ee(),
  Aa = new ee(),
  Rl = new ee(),
  Ed = new ee(),
  ng = new ee(),
  rg = new ee(),
  Pl = new ee();
function D1(t, e, n, r, i) {
  for (let o = 0, s = t.length - 3; o <= s; o += 3) {
    Pl.fromArray(t, o);
    const a =
        i.x * Math.abs(Pl.x) + i.y * Math.abs(Pl.y) + i.z * Math.abs(Pl.z),
      l = e.dot(Pl),
      c = n.dot(Pl),
      u = r.dot(Pl);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const f6 = new Rr(),
  Md = new ee(),
  F1 = new ee();
class Pr {
  constructor(e = new ee(), n = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = n);
  }
  set(e, n) {
    return this.center.copy(e), (this.radius = n), this;
  }
  setFromPoints(e, n) {
    const r = this.center;
    n !== void 0 ? r.copy(n) : f6.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let o = 0, s = e.length; o < s; o++)
      i = Math.max(i, r.distanceToSquared(e[o]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const r = this.center.distanceToSquared(e);
    return (
      n.copy(e),
      r > this.radius * this.radius &&
        (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
      n
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Md.subVectors(e, this.center);
    const n = Md.lengthSq();
    if (n > this.radius * this.radius) {
      const r = Math.sqrt(n),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(Md, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (F1.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Md.copy(e.center).add(F1)),
            this.expandByPoint(Md.copy(e.center).sub(F1))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Is = new ee(),
  U1 = new ee(),
  ig = new ee(),
  ba = new ee(),
  k1 = new ee(),
  og = new ee(),
  z1 = new ee();
class Oc {
  constructor(e = new ee(), n = new ee(0, 0, -1)) {
    (this.origin = e), (this.direction = n);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Is)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const r = n.dot(this.direction);
    return r < 0
      ? n.copy(this.origin)
      : n.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = Is.subVectors(e, this.origin).dot(this.direction);
    return n < 0
      ? this.origin.distanceToSquared(e)
      : (Is.copy(this.origin).addScaledVector(this.direction, n),
        Is.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, r, i) {
    U1.copy(e).add(n).multiplyScalar(0.5),
      ig.copy(n).sub(e).normalize(),
      ba.copy(this.origin).sub(U1);
    const o = e.distanceTo(n) * 0.5,
      s = -this.direction.dot(ig),
      a = ba.dot(this.direction),
      l = -ba.dot(ig),
      c = ba.lengthSq(),
      u = Math.abs(1 - s * s);
    let d, p, m, v;
    if (u > 0)
      if (((d = s * l - a), (p = s * a - l), (v = o * u), d >= 0))
        if (p >= -v)
          if (p <= v) {
            const _ = 1 / u;
            (d *= _),
              (p *= _),
              (m = d * (d + s * p + 2 * a) + p * (s * d + p + 2 * l) + c);
          } else
            (p = o),
              (d = Math.max(0, -(s * p + a))),
              (m = -d * d + p * (p + 2 * l) + c);
        else
          (p = -o),
            (d = Math.max(0, -(s * p + a))),
            (m = -d * d + p * (p + 2 * l) + c);
      else
        p <= -v
          ? ((d = Math.max(0, -(-s * o + a))),
            (p = d > 0 ? -o : Math.min(Math.max(-o, -l), o)),
            (m = -d * d + p * (p + 2 * l) + c))
          : p <= v
          ? ((d = 0),
            (p = Math.min(Math.max(-o, -l), o)),
            (m = p * (p + 2 * l) + c))
          : ((d = Math.max(0, -(s * o + a))),
            (p = d > 0 ? o : Math.min(Math.max(-o, -l), o)),
            (m = -d * d + p * (p + 2 * l) + c));
    else
      (p = s > 0 ? -o : o),
        (d = Math.max(0, -(s * p + a))),
        (m = -d * d + p * (p + 2 * l) + c);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, d),
      i && i.copy(U1).addScaledVector(ig, p),
      m
    );
  }
  intersectSphere(e, n) {
    Is.subVectors(e.center, this.origin);
    const r = Is.dot(this.direction),
      i = Is.dot(Is) - r * r,
      o = e.radius * e.radius;
    if (i > o) return null;
    const s = Math.sqrt(o - i),
      a = r - s,
      l = r + s;
    return l < 0 ? null : a < 0 ? this.at(l, n) : this.at(a, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / n;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, n) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let r, i, o, s, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      c >= 0
        ? ((r = (e.min.x - p.x) * c), (i = (e.max.x - p.x) * c))
        : ((r = (e.max.x - p.x) * c), (i = (e.min.x - p.x) * c)),
      u >= 0
        ? ((o = (e.min.y - p.y) * u), (s = (e.max.y - p.y) * u))
        : ((o = (e.max.y - p.y) * u), (s = (e.min.y - p.y) * u)),
      r > s ||
      o > i ||
      ((o > r || isNaN(r)) && (r = o),
      (s < i || isNaN(i)) && (i = s),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      r > l || a > i) ||
      ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, n)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Is) !== null;
  }
  intersectTriangle(e, n, r, i, o) {
    k1.subVectors(n, e), og.subVectors(r, e), z1.crossVectors(k1, og);
    let s = this.direction.dot(z1),
      a;
    if (s > 0) {
      if (i) return null;
      a = 1;
    } else if (s < 0) (a = -1), (s = -s);
    else return null;
    ba.subVectors(this.origin, e);
    const l = a * this.direction.dot(og.crossVectors(ba, og));
    if (l < 0) return null;
    const c = a * this.direction.dot(k1.cross(ba));
    if (c < 0 || l + c > s) return null;
    const u = -a * ba.dot(z1);
    return u < 0 ? null : this.at(u / s, o);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class wt {
  constructor(e, n, r, i, o, s, a, l, c, u, d, p, m, v, _, y) {
    (wt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, o, s, a, l, c, u, d, p, m, v, _, y);
  }
  set(e, n, r, i, o, s, a, l, c, u, d, p, m, v, _, y) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = n),
      (g[8] = r),
      (g[12] = i),
      (g[1] = o),
      (g[5] = s),
      (g[9] = a),
      (g[13] = l),
      (g[2] = c),
      (g[6] = u),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = v),
      (g[11] = _),
      (g[15] = y),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new wt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      (n[9] = r[9]),
      (n[10] = r[10]),
      (n[11] = r[11]),
      (n[12] = r[12]),
      (n[13] = r[13]),
      (n[14] = r[14]),
      (n[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const n = this.elements,
      r = e.elements;
    return (n[12] = r[12]), (n[13] = r[13]), (n[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return (
      this.set(
        n[0],
        n[3],
        n[6],
        0,
        n[1],
        n[4],
        n[7],
        0,
        n[2],
        n[5],
        n[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      n.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, n, r) {
    return (
      this.set(
        e.x,
        n.x,
        r.x,
        0,
        e.y,
        n.y,
        r.y,
        0,
        e.z,
        n.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const n = this.elements,
      r = e.elements,
      i = 1 / au.setFromMatrixColumn(e, 0).length(),
      o = 1 / au.setFromMatrixColumn(e, 1).length(),
      s = 1 / au.setFromMatrixColumn(e, 2).length();
    return (
      (n[0] = r[0] * i),
      (n[1] = r[1] * i),
      (n[2] = r[2] * i),
      (n[3] = 0),
      (n[4] = r[4] * o),
      (n[5] = r[5] * o),
      (n[6] = r[6] * o),
      (n[7] = 0),
      (n[8] = r[8] * s),
      (n[9] = r[9] * s),
      (n[10] = r[10] * s),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      o = e.z,
      s = Math.cos(r),
      a = Math.sin(r),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(o),
      d = Math.sin(o);
    if (e.order === "XYZ") {
      const p = s * u,
        m = s * d,
        v = a * u,
        _ = a * d;
      (n[0] = l * u),
        (n[4] = -l * d),
        (n[8] = c),
        (n[1] = m + v * c),
        (n[5] = p - _ * c),
        (n[9] = -a * l),
        (n[2] = _ - p * c),
        (n[6] = v + m * c),
        (n[10] = s * l);
    } else if (e.order === "YXZ") {
      const p = l * u,
        m = l * d,
        v = c * u,
        _ = c * d;
      (n[0] = p + _ * a),
        (n[4] = v * a - m),
        (n[8] = s * c),
        (n[1] = s * d),
        (n[5] = s * u),
        (n[9] = -a),
        (n[2] = m * a - v),
        (n[6] = _ + p * a),
        (n[10] = s * l);
    } else if (e.order === "ZXY") {
      const p = l * u,
        m = l * d,
        v = c * u,
        _ = c * d;
      (n[0] = p - _ * a),
        (n[4] = -s * d),
        (n[8] = v + m * a),
        (n[1] = m + v * a),
        (n[5] = s * u),
        (n[9] = _ - p * a),
        (n[2] = -s * c),
        (n[6] = a),
        (n[10] = s * l);
    } else if (e.order === "ZYX") {
      const p = s * u,
        m = s * d,
        v = a * u,
        _ = a * d;
      (n[0] = l * u),
        (n[4] = v * c - m),
        (n[8] = p * c + _),
        (n[1] = l * d),
        (n[5] = _ * c + p),
        (n[9] = m * c - v),
        (n[2] = -c),
        (n[6] = a * l),
        (n[10] = s * l);
    } else if (e.order === "YZX") {
      const p = s * l,
        m = s * c,
        v = a * l,
        _ = a * c;
      (n[0] = l * u),
        (n[4] = _ - p * d),
        (n[8] = v * d + m),
        (n[1] = d),
        (n[5] = s * u),
        (n[9] = -a * u),
        (n[2] = -c * u),
        (n[6] = m * d + v),
        (n[10] = p - _ * d);
    } else if (e.order === "XZY") {
      const p = s * l,
        m = s * c,
        v = a * l,
        _ = a * c;
      (n[0] = l * u),
        (n[4] = -d),
        (n[8] = c * u),
        (n[1] = p * d + _),
        (n[5] = s * u),
        (n[9] = m * d - v),
        (n[2] = v * d - m),
        (n[6] = a * u),
        (n[10] = _ * d + p);
    }
    return (
      (n[3] = 0),
      (n[7] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(d6, e, h6);
  }
  lookAt(e, n, r) {
    const i = this.elements;
    return (
      Ui.subVectors(e, n),
      Ui.lengthSq() === 0 && (Ui.z = 1),
      Ui.normalize(),
      wa.crossVectors(r, Ui),
      wa.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (Ui.x += 1e-4) : (Ui.z += 1e-4),
        Ui.normalize(),
        wa.crossVectors(r, Ui)),
      wa.normalize(),
      sg.crossVectors(Ui, wa),
      (i[0] = wa.x),
      (i[4] = sg.x),
      (i[8] = Ui.x),
      (i[1] = wa.y),
      (i[5] = sg.y),
      (i[9] = Ui.y),
      (i[2] = wa.z),
      (i[6] = sg.z),
      (i[10] = Ui.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      o = this.elements,
      s = r[0],
      a = r[4],
      l = r[8],
      c = r[12],
      u = r[1],
      d = r[5],
      p = r[9],
      m = r[13],
      v = r[2],
      _ = r[6],
      y = r[10],
      g = r[14],
      x = r[3],
      S = r[7],
      b = r[11],
      C = r[15],
      M = i[0],
      T = i[4],
      P = i[8],
      R = i[12],
      E = i[1],
      O = i[5],
      D = i[9],
      N = i[13],
      z = i[2],
      V = i[6],
      G = i[10],
      Y = i[14],
      U = i[3],
      j = i[7],
      W = i[11],
      B = i[15];
    return (
      (o[0] = s * M + a * E + l * z + c * U),
      (o[4] = s * T + a * O + l * V + c * j),
      (o[8] = s * P + a * D + l * G + c * W),
      (o[12] = s * R + a * N + l * Y + c * B),
      (o[1] = u * M + d * E + p * z + m * U),
      (o[5] = u * T + d * O + p * V + m * j),
      (o[9] = u * P + d * D + p * G + m * W),
      (o[13] = u * R + d * N + p * Y + m * B),
      (o[2] = v * M + _ * E + y * z + g * U),
      (o[6] = v * T + _ * O + y * V + g * j),
      (o[10] = v * P + _ * D + y * G + g * W),
      (o[14] = v * R + _ * N + y * Y + g * B),
      (o[3] = x * M + S * E + b * z + C * U),
      (o[7] = x * T + S * O + b * V + C * j),
      (o[11] = x * P + S * D + b * G + C * W),
      (o[15] = x * R + S * N + b * Y + C * B),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[4] *= e),
      (n[8] *= e),
      (n[12] *= e),
      (n[1] *= e),
      (n[5] *= e),
      (n[9] *= e),
      (n[13] *= e),
      (n[2] *= e),
      (n[6] *= e),
      (n[10] *= e),
      (n[14] *= e),
      (n[3] *= e),
      (n[7] *= e),
      (n[11] *= e),
      (n[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[4],
      i = e[8],
      o = e[12],
      s = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      v = e[3],
      _ = e[7],
      y = e[11],
      g = e[15];
    return (
      v *
        (+o * l * d -
          i * c * d -
          o * a * p +
          r * c * p +
          i * a * m -
          r * l * m) +
      _ *
        (+n * l * m -
          n * c * p +
          o * s * p -
          i * s * m +
          i * c * u -
          o * l * u) +
      y *
        (+n * c * d -
          n * a * m -
          o * s * d +
          r * s * m +
          o * a * u -
          r * c * u) +
      g *
        (-i * a * u - n * l * d + n * a * p + i * s * d - r * s * p + r * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let n;
    return (
      (n = e[1]),
      (e[1] = e[4]),
      (e[4] = n),
      (n = e[2]),
      (e[2] = e[8]),
      (e[8] = n),
      (n = e[6]),
      (e[6] = e[9]),
      (e[9] = n),
      (n = e[3]),
      (e[3] = e[12]),
      (e[12] = n),
      (n = e[7]),
      (e[7] = e[13]),
      (e[13] = n),
      (n = e[11]),
      (e[11] = e[14]),
      (e[14] = n),
      this
    );
  }
  setPosition(e, n, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = n), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      v = e[12],
      _ = e[13],
      y = e[14],
      g = e[15],
      x = d * y * c - _ * p * c + _ * l * m - a * y * m - d * l * g + a * p * g,
      S = v * p * c - u * y * c - v * l * m + s * y * m + u * l * g - s * p * g,
      b = u * _ * c - v * d * c + v * a * m - s * _ * m - u * a * g + s * d * g,
      C = v * d * l - u * _ * l - v * a * p + s * _ * p + u * a * y - s * d * y,
      M = n * x + r * S + i * b + o * C;
    if (M === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / M;
    return (
      (e[0] = x * T),
      (e[1] =
        (_ * p * o -
          d * y * o -
          _ * i * m +
          r * y * m +
          d * i * g -
          r * p * g) *
        T),
      (e[2] =
        (a * y * o -
          _ * l * o +
          _ * i * c -
          r * y * c -
          a * i * g +
          r * l * g) *
        T),
      (e[3] =
        (d * l * o -
          a * p * o -
          d * i * c +
          r * p * c +
          a * i * m -
          r * l * m) *
        T),
      (e[4] = S * T),
      (e[5] =
        (u * y * o -
          v * p * o +
          v * i * m -
          n * y * m -
          u * i * g +
          n * p * g) *
        T),
      (e[6] =
        (v * l * o -
          s * y * o -
          v * i * c +
          n * y * c +
          s * i * g -
          n * l * g) *
        T),
      (e[7] =
        (s * p * o -
          u * l * o +
          u * i * c -
          n * p * c -
          s * i * m +
          n * l * m) *
        T),
      (e[8] = b * T),
      (e[9] =
        (v * d * o -
          u * _ * o -
          v * r * m +
          n * _ * m +
          u * r * g -
          n * d * g) *
        T),
      (e[10] =
        (s * _ * o -
          v * a * o +
          v * r * c -
          n * _ * c -
          s * r * g +
          n * a * g) *
        T),
      (e[11] =
        (u * a * o -
          s * d * o -
          u * r * c +
          n * d * c +
          s * r * m -
          n * a * m) *
        T),
      (e[12] = C * T),
      (e[13] =
        (u * _ * i -
          v * d * i +
          v * r * p -
          n * _ * p -
          u * r * y +
          n * d * y) *
        T),
      (e[14] =
        (v * a * i -
          s * _ * i -
          v * r * l +
          n * _ * l +
          s * r * y -
          n * a * y) *
        T),
      (e[15] =
        (s * d * i -
          u * a * i +
          u * r * l -
          n * d * l -
          s * r * p +
          n * a * p) *
        T),
      this
    );
  }
  scale(e) {
    const n = this.elements,
      r = e.x,
      i = e.y,
      o = e.z;
    return (
      (n[0] *= r),
      (n[4] *= i),
      (n[8] *= o),
      (n[1] *= r),
      (n[5] *= i),
      (n[9] *= o),
      (n[2] *= r),
      (n[6] *= i),
      (n[10] *= o),
      (n[3] *= r),
      (n[7] *= i),
      (n[11] *= o),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, r, i));
  }
  makeTranslation(e, n, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -r, 0, 0, r, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, 0, r, 0, 0, 1, 0, 0, -r, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, 0, r, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      o = 1 - r,
      s = e.x,
      a = e.y,
      l = e.z,
      c = o * s,
      u = o * a;
    return (
      this.set(
        c * s + r,
        c * a - i * l,
        c * l + i * a,
        0,
        c * a + i * l,
        u * a + r,
        u * l - i * s,
        0,
        c * l - i * a,
        u * l + i * s,
        o * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, n, r) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, r, i, o, s) {
    return this.set(1, r, o, 0, e, 1, s, 0, n, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, r) {
    const i = this.elements,
      o = n._x,
      s = n._y,
      a = n._z,
      l = n._w,
      c = o + o,
      u = s + s,
      d = a + a,
      p = o * c,
      m = o * u,
      v = o * d,
      _ = s * u,
      y = s * d,
      g = a * d,
      x = l * c,
      S = l * u,
      b = l * d,
      C = r.x,
      M = r.y,
      T = r.z;
    return (
      (i[0] = (1 - (_ + g)) * C),
      (i[1] = (m + b) * C),
      (i[2] = (v - S) * C),
      (i[3] = 0),
      (i[4] = (m - b) * M),
      (i[5] = (1 - (p + g)) * M),
      (i[6] = (y + x) * M),
      (i[7] = 0),
      (i[8] = (v + S) * T),
      (i[9] = (y - x) * T),
      (i[10] = (1 - (p + _)) * T),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, n, r) {
    const i = this.elements;
    let o = au.set(i[0], i[1], i[2]).length();
    const s = au.set(i[4], i[5], i[6]).length(),
      a = au.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Ro.copy(this);
    const c = 1 / o,
      u = 1 / s,
      d = 1 / a;
    return (
      (Ro.elements[0] *= c),
      (Ro.elements[1] *= c),
      (Ro.elements[2] *= c),
      (Ro.elements[4] *= u),
      (Ro.elements[5] *= u),
      (Ro.elements[6] *= u),
      (Ro.elements[8] *= d),
      (Ro.elements[9] *= d),
      (Ro.elements[10] *= d),
      n.setFromRotationMatrix(Ro),
      (r.x = o),
      (r.y = s),
      (r.z = a),
      this
    );
  }
  makePerspective(e, n, r, i, o, s, a = cs) {
    const l = this.elements,
      c = (2 * o) / (n - e),
      u = (2 * o) / (r - i),
      d = (n + e) / (n - e),
      p = (r + i) / (r - i);
    let m, v;
    if (a === cs) (m = -(s + o) / (s - o)), (v = (-2 * s * o) / (s - o));
    else if (a === Kh) (m = -s / (s - o)), (v = (-s * o) / (s - o));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = p),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, n, r, i, o, s, a = cs) {
    const l = this.elements,
      c = 1 / (n - e),
      u = 1 / (r - i),
      d = 1 / (s - o),
      p = (n + e) * c,
      m = (r + i) * u;
    let v, _;
    if (a === cs) (v = (s + o) * d), (_ = -2 * d);
    else if (a === Kh) (v = o * d), (_ = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -p),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = _),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      (e[n + 9] = r[9]),
      (e[n + 10] = r[10]),
      (e[n + 11] = r[11]),
      (e[n + 12] = r[12]),
      (e[n + 13] = r[13]),
      (e[n + 14] = r[14]),
      (e[n + 15] = r[15]),
      e
    );
  }
}
const au = new ee(),
  Ro = new wt(),
  d6 = new ee(0, 0, 0),
  h6 = new ee(1, 1, 1),
  wa = new ee(),
  sg = new ee(),
  Ui = new ee(),
  iT = new wt(),
  oT = new $r();
class qi {
  constructor(e = 0, n = 0, r = 0, i = qi.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, n, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, n = this._order, r = !0) {
    const i = e.elements,
      o = i[0],
      s = i[4],
      a = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      d = i[2],
      p = i[6],
      m = i[10];
    switch (n) {
      case "XYZ":
        (this._y = Math.asin(Un(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-s, o)))
            : ((this._x = Math.atan2(p, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Un(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, o)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Un(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-s, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, o)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Un(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, o)))
            : ((this._x = 0), (this._z = Math.atan2(-s, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Un(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, o)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-Un(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(a, o)))
            : ((this._x = Math.atan2(-u, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            n
        );
    }
    return (this._order = n), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, r) {
    return (
      iT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(iT, n, r)
    );
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return oT.setFromEuler(this), this.setFromQuaternion(oT, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
qi.DEFAULT_ORDER = "XYZ";
class hc {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let p6 = 0;
const sT = new ee(),
  lu = new $r(),
  Ls = new wt(),
  ag = new ee(),
  Cd = new ee(),
  m6 = new ee(),
  g6 = new $r(),
  aT = new ee(1, 0, 0),
  lT = new ee(0, 1, 0),
  cT = new ee(0, 0, 1),
  uT = { type: "added" },
  v6 = { type: "removed" },
  cu = { type: "childadded", child: null },
  B1 = { type: "childremoved", child: null };
class Qt extends oa {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: p6++ }),
      (this.uuid = Xi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Qt.DEFAULT_UP.clone());
    const e = new ee(),
      n = new qi(),
      r = new $r(),
      i = new ee(1, 1, 1);
    function o() {
      r.setFromEuler(n, !1);
    }
    function s() {
      n.setFromQuaternion(r, void 0, !1);
    }
    n._onChange(o),
      r._onChange(s),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: n },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new wt() },
        normalMatrix: { value: new Dt() },
      }),
      (this.matrix = new wt()),
      (this.matrixWorld = new wt()),
      (this.matrixAutoUpdate = Qt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new hc()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return lu.setFromAxisAngle(e, n), this.quaternion.multiply(lu), this;
  }
  rotateOnWorldAxis(e, n) {
    return lu.setFromAxisAngle(e, n), this.quaternion.premultiply(lu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(aT, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(lT, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(cT, e);
  }
  translateOnAxis(e, n) {
    return (
      sT.copy(e).applyQuaternion(this.quaternion),
      this.position.add(sT.multiplyScalar(n)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(aT, e);
  }
  translateY(e) {
    return this.translateOnAxis(lT, e);
  }
  translateZ(e) {
    return this.translateOnAxis(cT, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Ls.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, n, r) {
    e.isVector3 ? ag.copy(e) : ag.set(e, n, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      Cd.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Ls.lookAt(Cd, ag, this.up)
        : Ls.lookAt(ag, Cd, this.up),
      this.quaternion.setFromRotationMatrix(Ls),
      i &&
        (Ls.extractRotation(i.matrixWorld),
        lu.setFromRotationMatrix(Ls),
        this.quaternion.premultiply(lu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(uT),
            (cu.child = e),
            this.dispatchEvent(cu),
            (cu.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const n = this.children.indexOf(e);
    return (
      n !== -1 &&
        ((e.parent = null),
        this.children.splice(n, 1),
        e.dispatchEvent(v6),
        (B1.child = e),
        this.dispatchEvent(B1),
        (B1.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Ls.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Ls.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Ls),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(uT),
      (cu.child = e),
      this.dispatchEvent(cu),
      (cu.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const s = this.children[r].getObjectByProperty(e, n);
      if (s !== void 0) return s;
    }
  }
  getObjectsByProperty(e, n, r = []) {
    this[e] === n && r.push(this);
    const i = this.children;
    for (let o = 0, s = i.length; o < s; o++)
      i[o].getObjectsByProperty(e, n, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cd, e, m6), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cd, g6, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) n[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const n = this.children;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      (o.matrixWorldAutoUpdate === !0 || e === !0) && o.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, n) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      n === !0)
    ) {
      const i = this.children;
      for (let o = 0, s = i.length; o < s; o++) {
        const a = i[o];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string",
      r = {};
    n &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (i.maxGeometryCount = this._maxGeometryCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function o(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            o(e.shapes, d);
          }
        else o(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (o(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(o(e.materials, this.material[l]));
        i.material = a;
      } else i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(o(e.animations, l));
      }
    }
    if (n) {
      const a = s(e.geometries),
        l = s(e.materials),
        c = s(e.textures),
        u = s(e.images),
        d = s(e.shapes),
        p = s(e.skeletons),
        m = s(e.animations),
        v = s(e.nodes);
      a.length > 0 && (r.geometries = a),
        l.length > 0 && (r.materials = l),
        c.length > 0 && (r.textures = c),
        u.length > 0 && (r.images = u),
        d.length > 0 && (r.shapes = d),
        p.length > 0 && (r.skeletons = p),
        m.length > 0 && (r.animations = m),
        v.length > 0 && (r.nodes = v);
    }
    return (r.object = i), r;
    function s(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      n === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Qt.DEFAULT_UP = new ee(0, 1, 0);
Qt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Qt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Po = new ee(),
  Os = new ee(),
  H1 = new ee(),
  Ns = new ee(),
  uu = new ee(),
  fu = new ee(),
  fT = new ee(),
  V1 = new ee(),
  G1 = new ee(),
  W1 = new ee();
class Gi {
  constructor(e = new ee(), n = new ee(), r = new ee()) {
    (this.a = e), (this.b = n), (this.c = r);
  }
  static getNormal(e, n, r, i) {
    i.subVectors(r, n), Po.subVectors(e, n), i.cross(Po);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, n, r, i, o) {
    Po.subVectors(i, n), Os.subVectors(r, n), H1.subVectors(e, n);
    const s = Po.dot(Po),
      a = Po.dot(Os),
      l = Po.dot(H1),
      c = Os.dot(Os),
      u = Os.dot(H1),
      d = s * c - a * a;
    if (d === 0) return o.set(0, 0, 0), null;
    const p = 1 / d,
      m = (c * l - a * u) * p,
      v = (s * u - a * l) * p;
    return o.set(1 - m - v, v, m);
  }
  static containsPoint(e, n, r, i) {
    return this.getBarycoord(e, n, r, i, Ns) === null
      ? !1
      : Ns.x >= 0 && Ns.y >= 0 && Ns.x + Ns.y <= 1;
  }
  static getInterpolation(e, n, r, i, o, s, a, l) {
    return this.getBarycoord(e, n, r, i, Ns) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(o, Ns.x),
        l.addScaledVector(s, Ns.y),
        l.addScaledVector(a, Ns.z),
        l);
  }
  static isFrontFacing(e, n, r, i) {
    return Po.subVectors(r, n), Os.subVectors(e, n), Po.cross(Os).dot(i) < 0;
  }
  set(e, n, r) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, n, r, i) {
    return this.a.copy(e[n]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, n, r, i) {
    return (
      this.a.fromBufferAttribute(e, n),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Po.subVectors(this.c, this.b),
      Os.subVectors(this.a, this.b),
      Po.cross(Os).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Gi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Gi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, r, i, o) {
    return Gi.getInterpolation(e, this.a, this.b, this.c, n, r, i, o);
  }
  containsPoint(e) {
    return Gi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Gi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const r = this.a,
      i = this.b,
      o = this.c;
    let s, a;
    uu.subVectors(i, r), fu.subVectors(o, r), V1.subVectors(e, r);
    const l = uu.dot(V1),
      c = fu.dot(V1);
    if (l <= 0 && c <= 0) return n.copy(r);
    G1.subVectors(e, i);
    const u = uu.dot(G1),
      d = fu.dot(G1);
    if (u >= 0 && d <= u) return n.copy(i);
    const p = l * d - u * c;
    if (p <= 0 && l >= 0 && u <= 0)
      return (s = l / (l - u)), n.copy(r).addScaledVector(uu, s);
    W1.subVectors(e, o);
    const m = uu.dot(W1),
      v = fu.dot(W1);
    if (v >= 0 && m <= v) return n.copy(o);
    const _ = m * c - l * v;
    if (_ <= 0 && c >= 0 && v <= 0)
      return (a = c / (c - v)), n.copy(r).addScaledVector(fu, a);
    const y = u * v - m * d;
    if (y <= 0 && d - u >= 0 && m - v >= 0)
      return (
        fT.subVectors(o, i),
        (a = (d - u) / (d - u + (m - v))),
        n.copy(i).addScaledVector(fT, a)
      );
    const g = 1 / (y + _ + p);
    return (
      (s = _ * g),
      (a = p * g),
      n.copy(r).addScaledVector(uu, s).addScaledVector(fu, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const yN = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ea = { h: 0, s: 0, l: 0 },
  lg = { h: 0, s: 0, l: 0 };
function j1(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
let it = class {
  constructor(e, n, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, n, r)
    );
  }
  set(e, n, r) {
    if (n === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, n, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, n = fo) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      rn.toWorkingColorSpace(this, n),
      this
    );
  }
  setRGB(e, n, r, i = rn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = n),
      (this.b = r),
      rn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, n, r, i = rn.workingColorSpace) {
    if (((e = sE(e, 1)), (n = Un(n, 0, 1)), (r = Un(r, 0, 1)), n === 0))
      this.r = this.g = this.b = r;
    else {
      const o = r <= 0.5 ? r * (1 + n) : r + n - r * n,
        s = 2 * r - o;
      (this.r = j1(s, o, e + 1 / 3)),
        (this.g = j1(s, o, e)),
        (this.b = j1(s, o, e - 1 / 3));
    }
    return rn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, n = fo) {
    function r(o) {
      o !== void 0 &&
        parseFloat(o) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let o;
      const s = i[1],
        a = i[2];
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (o =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(255, parseInt(o[1], 10)) / 255,
                Math.min(255, parseInt(o[2], 10)) / 255,
                Math.min(255, parseInt(o[3], 10)) / 255,
                n
              )
            );
          if (
            (o =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setRGB(
                Math.min(100, parseInt(o[1], 10)) / 100,
                Math.min(100, parseInt(o[2], 10)) / 100,
                Math.min(100, parseInt(o[3], 10)) / 100,
                n
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (o =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(o[4]),
              this.setHSL(
                parseFloat(o[1]) / 360,
                parseFloat(o[2]) / 100,
                parseFloat(o[3]) / 100,
                n
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const o = i[1],
        s = o.length;
      if (s === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (s === 6) return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = fo) {
    const r = yN[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, n)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = lf(e.r)), (this.g = lf(e.g)), (this.b = lf(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = L1(e.r)), (this.g = L1(e.g)), (this.b = L1(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = fo) {
    return (
      rn.fromWorkingColorSpace(Hr.copy(this), e),
      Math.round(Un(Hr.r * 255, 0, 255)) * 65536 +
        Math.round(Un(Hr.g * 255, 0, 255)) * 256 +
        Math.round(Un(Hr.b * 255, 0, 255))
    );
  }
  getHexString(e = fo) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = rn.workingColorSpace) {
    rn.fromWorkingColorSpace(Hr.copy(this), n);
    const r = Hr.r,
      i = Hr.g,
      o = Hr.b,
      s = Math.max(r, i, o),
      a = Math.min(r, i, o);
    let l, c;
    const u = (a + s) / 2;
    if (a === s) (l = 0), (c = 0);
    else {
      const d = s - a;
      switch (((c = u <= 0.5 ? d / (s + a) : d / (2 - s - a)), s)) {
        case r:
          l = (i - o) / d + (i < o ? 6 : 0);
          break;
        case i:
          l = (o - r) / d + 2;
          break;
        case o:
          l = (r - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, n = rn.workingColorSpace) {
    return (
      rn.fromWorkingColorSpace(Hr.copy(this), n),
      (e.r = Hr.r),
      (e.g = Hr.g),
      (e.b = Hr.b),
      e
    );
  }
  getStyle(e = fo) {
    rn.fromWorkingColorSpace(Hr.copy(this), e);
    const n = Hr.r,
      r = Hr.g,
      i = Hr.b;
    return e !== fo
      ? `color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(n * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, n, r) {
    return this.getHSL(Ea), this.setHSL(Ea.h + e, Ea.s + n, Ea.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, n) {
    return (
      (this.r = e.r + n.r), (this.g = e.g + n.g), (this.b = e.b + n.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, n) {
    return (
      (this.r += (e.r - this.r) * n),
      (this.g += (e.g - this.g) * n),
      (this.b += (e.b - this.b) * n),
      this
    );
  }
  lerpColors(e, n, r) {
    return (
      (this.r = e.r + (n.r - e.r) * r),
      (this.g = e.g + (n.g - e.g) * r),
      (this.b = e.b + (n.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, n) {
    this.getHSL(Ea), e.getHSL(lg);
    const r = dh(Ea.h, lg.h, n),
      i = dh(Ea.s, lg.s, n),
      o = dh(Ea.l, lg.l, n);
    return this.setHSL(r, i, o), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const n = this.r,
      r = this.g,
      i = this.b,
      o = e.elements;
    return (
      (this.r = o[0] * n + o[3] * r + o[6] * i),
      (this.g = o[1] * n + o[4] * r + o[7] * i),
      (this.b = o[2] * n + o[5] * r + o[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return (this.r = e[n]), (this.g = e[n + 1]), (this.b = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.r), (e[n + 1] = this.g), (e[n + 2] = this.b), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.r = e.getX(n)), (this.g = e.getY(n)), (this.b = e.getZ(n)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const Hr = new it();
it.NAMES = yN;
let y6 = 0;
class qr extends oa {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: y6++ }),
      (this.uuid = Xi()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = uc),
      (this.side = Js),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = hv),
      (this.blendDst = pv),
      (this.blendEquation = Fa),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new it(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = kh),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = PA),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = $l),
      (this.stencilZFail = $l),
      (this.stencilZPass = $l),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const r = e[n];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${n}' has value of undefined.`
          );
          continue;
        }
        const i = this[n];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[n] = r);
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== uc && (r.blending = this.blending),
      this.side !== Js && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== hv && (r.blendSrc = this.blendSrc),
      this.blendDst !== pv && (r.blendDst = this.blendDst),
      this.blendEquation !== Fa && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== kh && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== PA && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== $l && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== $l && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== $l && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(o) {
      const s = [];
      for (const a in o) {
        const l = o[a];
        delete l.metadata, s.push(l);
      }
      return s;
    }
    if (n) {
      const o = i(e.textures),
        s = i(e.images);
      o.length > 0 && (r.textures = o), s.length > 0 && (r.images = s);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const n = e.clippingPlanes;
    let r = null;
    if (n !== null) {
      const i = n.length;
      r = new Array(i);
      for (let o = 0; o !== i; ++o) r[o] = n[o].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class sa extends qr {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new qi()),
      (this.combine = Rp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Bs = x6();
function x6() {
  const t = new ArrayBuffer(4),
    e = new Float32Array(t),
    n = new Uint32Array(t),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((r[l] = 1024 >> (-c - 14)),
        (r[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((r[l] = (c + 15) << 10),
        (r[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const o = new Uint32Array(2048),
    s = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (o[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) o[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) s[l] = l << 23;
  (s[31] = 1199570944), (s[32] = 2147483648);
  for (let l = 33; l < 63; ++l) s[l] = 2147483648 + ((l - 32) << 23);
  s[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: r,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: s,
    offsetTable: a,
  };
}
function yi(t) {
  Math.abs(t) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (t = Un(t, -65504, 65504)),
    (Bs.floatView[0] = t);
  const e = Bs.uint32View[0],
    n = (e >> 23) & 511;
  return Bs.baseTable[n] + ((e & 8388607) >> Bs.shiftTable[n]);
}
function Xd(t) {
  const e = t >> 10;
  return (
    (Bs.uint32View[0] =
      Bs.mantissaTable[Bs.offsetTable[e] + (t & 1023)] + Bs.exponentTable[e]),
    Bs.floatView[0]
  );
}
const _6 = { toHalfFloat: yi, fromHalfFloat: Xd },
  Kn = new ee(),
  cg = new ke();
class sn {
  constructor(e, n, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.normalized = r),
      (this.usage = qh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = yo),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      mN(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.itemSize), (r *= n.itemSize);
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, r = this.count; n < r; n++)
        cg.fromBufferAttribute(this, n),
          cg.applyMatrix3(e),
          this.setXY(n, cg.x, cg.y);
    else if (this.itemSize === 3)
      for (let n = 0, r = this.count; n < r; n++)
        Kn.fromBufferAttribute(this, n),
          Kn.applyMatrix3(e),
          this.setXYZ(n, Kn.x, Kn.y, Kn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Kn.fromBufferAttribute(this, n),
        Kn.applyMatrix4(e),
        this.setXYZ(n, Kn.x, Kn.y, Kn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Kn.fromBufferAttribute(this, n),
        Kn.applyNormalMatrix(e),
        this.setXYZ(n, Kn.x, Kn.y, Kn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      Kn.fromBufferAttribute(this, n),
        Kn.transformDirection(e),
        this.setXYZ(n, Kn.x, Kn.y, Kn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let r = this.array[e * this.itemSize + n];
    return this.normalized && (r = si(r, this.array)), r;
  }
  setComponent(e, n, r) {
    return (
      this.normalized && (r = Ot(r, this.array)),
      (this.array[e * this.itemSize + n] = r),
      this
    );
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = si(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize] = n),
      this
    );
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = si(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 1] = n),
      this
    );
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = si(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 2] = n),
      this
    );
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = si(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 3] = n),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = Ot(n, this.array)), (r = Ot(r, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array)),
        (o = Ot(o, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = o),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== qh && (e.usage = this.usage),
      e
    );
  }
}
class S6 extends sn {
  constructor(e, n, r) {
    super(new Int8Array(e), n, r);
  }
}
class A6 extends sn {
  constructor(e, n, r) {
    super(new Uint8Array(e), n, r);
  }
}
class b6 extends sn {
  constructor(e, n, r) {
    super(new Uint8ClampedArray(e), n, r);
  }
}
class w6 extends sn {
  constructor(e, n, r) {
    super(new Int16Array(e), n, r);
  }
}
class lE extends sn {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r);
  }
}
class E6 extends sn {
  constructor(e, n, r) {
    super(new Int32Array(e), n, r);
  }
}
class cE extends sn {
  constructor(e, n, r) {
    super(new Uint32Array(e), n, r);
  }
}
class M6 extends sn {
  constructor(e, n, r) {
    super(new Uint16Array(e), n, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let n = Xd(this.array[e * this.itemSize]);
    return this.normalized && (n = si(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize] = yi(n)),
      this
    );
  }
  getY(e) {
    let n = Xd(this.array[e * this.itemSize + 1]);
    return this.normalized && (n = si(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 1] = yi(n)),
      this
    );
  }
  getZ(e) {
    let n = Xd(this.array[e * this.itemSize + 2]);
    return this.normalized && (n = si(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 2] = yi(n)),
      this
    );
  }
  getW(e) {
    let n = Xd(this.array[e * this.itemSize + 3]);
    return this.normalized && (n = si(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.array[e * this.itemSize + 3] = yi(n)),
      this
    );
  }
  setXY(e, n, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = Ot(n, this.array)), (r = Ot(r, this.array))),
      (this.array[e + 0] = yi(n)),
      (this.array[e + 1] = yi(r)),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array))),
      (this.array[e + 0] = yi(n)),
      (this.array[e + 1] = yi(r)),
      (this.array[e + 2] = yi(i)),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array)),
        (o = Ot(o, this.array))),
      (this.array[e + 0] = yi(n)),
      (this.array[e + 1] = yi(r)),
      (this.array[e + 2] = yi(i)),
      (this.array[e + 3] = yi(o)),
      this
    );
  }
}
class dt extends sn {
  constructor(e, n, r) {
    super(new Float32Array(e), n, r);
  }
}
let C6 = 0;
const ao = new wt(),
  $1 = new Qt(),
  du = new ee(),
  ki = new Rr(),
  Td = new Rr(),
  gr = new ee();
class Ut extends oa {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: C6++ }),
      (this.uuid = Xi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (hN(e) ? cE : lE)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return (this.attributes[e] = n), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, r = 0) {
    this.groups.push({ start: e, count: n, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    (this.drawRange.start = e), (this.drawRange.count = n);
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), (n.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const o = new Dt().getNormalMatrix(e);
      r.applyNormalMatrix(o), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return ao.makeRotationFromQuaternion(e), this.applyMatrix4(ao), this;
  }
  rotateX(e) {
    return ao.makeRotationX(e), this.applyMatrix4(ao), this;
  }
  rotateY(e) {
    return ao.makeRotationY(e), this.applyMatrix4(ao), this;
  }
  rotateZ(e) {
    return ao.makeRotationZ(e), this.applyMatrix4(ao), this;
  }
  translate(e, n, r) {
    return ao.makeTranslation(e, n, r), this.applyMatrix4(ao), this;
  }
  scale(e, n, r) {
    return ao.makeScale(e, n, r), this.applyMatrix4(ao), this;
  }
  lookAt(e) {
    return $1.lookAt(e), $1.updateMatrix(), this.applyMatrix4($1.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(du).negate(),
      this.translate(du.x, du.y, du.z),
      this
    );
  }
  setFromPoints(e) {
    const n = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const o = e[r];
      n.push(o.x, o.y, o.z || 0);
    }
    return this.setAttribute("position", new dt(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new ee(-1 / 0, -1 / 0, -1 / 0),
          new ee(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), n))
        for (let r = 0, i = n.length; r < i; r++) {
          const o = n[r];
          ki.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (gr.addVectors(this.boundingBox.min, ki.min),
                this.boundingBox.expandByPoint(gr),
                gr.addVectors(this.boundingBox.max, ki.max),
                this.boundingBox.expandByPoint(gr))
              : (this.boundingBox.expandByPoint(ki.min),
                this.boundingBox.expandByPoint(ki.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pr());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new ee(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((ki.setFromBufferAttribute(e), n))
        for (let o = 0, s = n.length; o < s; o++) {
          const a = n[o];
          Td.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (gr.addVectors(ki.min, Td.min),
                ki.expandByPoint(gr),
                gr.addVectors(ki.max, Td.max),
                ki.expandByPoint(gr))
              : (ki.expandByPoint(Td.min), ki.expandByPoint(Td.max));
        }
      ki.getCenter(r);
      let i = 0;
      for (let o = 0, s = e.count; o < s; o++)
        gr.fromBufferAttribute(e, o),
          (i = Math.max(i, r.distanceToSquared(gr)));
      if (n)
        for (let o = 0, s = n.length; o < s; o++) {
          const a = n[o],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            gr.fromBufferAttribute(a, c),
              l && (du.fromBufferAttribute(e, c), gr.add(du)),
              (i = Math.max(i, r.distanceToSquared(gr)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      n = this.attributes;
    if (
      e === null ||
      n.position === void 0 ||
      n.normal === void 0 ||
      n.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = n.position,
      i = n.normal,
      o = n.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new sn(new Float32Array(4 * r.count), 4));
    const s = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let P = 0; P < r.count; P++) (a[P] = new ee()), (l[P] = new ee());
    const c = new ee(),
      u = new ee(),
      d = new ee(),
      p = new ke(),
      m = new ke(),
      v = new ke(),
      _ = new ee(),
      y = new ee();
    function g(P, R, E) {
      c.fromBufferAttribute(r, P),
        u.fromBufferAttribute(r, R),
        d.fromBufferAttribute(r, E),
        p.fromBufferAttribute(o, P),
        m.fromBufferAttribute(o, R),
        v.fromBufferAttribute(o, E),
        u.sub(c),
        d.sub(c),
        m.sub(p),
        v.sub(p);
      const O = 1 / (m.x * v.y - v.x * m.y);
      isFinite(O) &&
        (_.copy(u)
          .multiplyScalar(v.y)
          .addScaledVector(d, -m.y)
          .multiplyScalar(O),
        y
          .copy(d)
          .multiplyScalar(m.x)
          .addScaledVector(u, -v.x)
          .multiplyScalar(O),
        a[P].add(_),
        a[R].add(_),
        a[E].add(_),
        l[P].add(y),
        l[R].add(y),
        l[E].add(y));
    }
    let x = this.groups;
    x.length === 0 && (x = [{ start: 0, count: e.count }]);
    for (let P = 0, R = x.length; P < R; ++P) {
      const E = x[P],
        O = E.start,
        D = E.count;
      for (let N = O, z = O + D; N < z; N += 3)
        g(e.getX(N + 0), e.getX(N + 1), e.getX(N + 2));
    }
    const S = new ee(),
      b = new ee(),
      C = new ee(),
      M = new ee();
    function T(P) {
      C.fromBufferAttribute(i, P), M.copy(C);
      const R = a[P];
      S.copy(R),
        S.sub(C.multiplyScalar(C.dot(R))).normalize(),
        b.crossVectors(M, R);
      const O = b.dot(l[P]) < 0 ? -1 : 1;
      s.setXYZW(P, S.x, S.y, S.z, O);
    }
    for (let P = 0, R = x.length; P < R; ++P) {
      const E = x[P],
        O = E.start,
        D = E.count;
      for (let N = O, z = O + D; N < z; N += 3)
        T(e.getX(N + 0)), T(e.getX(N + 1)), T(e.getX(N + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      n = this.getAttribute("position");
    if (n !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new sn(new Float32Array(n.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let p = 0, m = r.count; p < m; p++) r.setXYZ(p, 0, 0, 0);
      const i = new ee(),
        o = new ee(),
        s = new ee(),
        a = new ee(),
        l = new ee(),
        c = new ee(),
        u = new ee(),
        d = new ee();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const v = e.getX(p + 0),
            _ = e.getX(p + 1),
            y = e.getX(p + 2);
          i.fromBufferAttribute(n, v),
            o.fromBufferAttribute(n, _),
            s.fromBufferAttribute(n, y),
            u.subVectors(s, o),
            d.subVectors(i, o),
            u.cross(d),
            a.fromBufferAttribute(r, v),
            l.fromBufferAttribute(r, _),
            c.fromBufferAttribute(r, y),
            a.add(u),
            l.add(u),
            c.add(u),
            r.setXYZ(v, a.x, a.y, a.z),
            r.setXYZ(_, l.x, l.y, l.z),
            r.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let p = 0, m = n.count; p < m; p += 3)
          i.fromBufferAttribute(n, p + 0),
            o.fromBufferAttribute(n, p + 1),
            s.fromBufferAttribute(n, p + 2),
            u.subVectors(s, o),
            d.subVectors(i, o),
            u.cross(d),
            r.setXYZ(p + 0, u.x, u.y, u.z),
            r.setXYZ(p + 1, u.x, u.y, u.z),
            r.setXYZ(p + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, r = e.count; n < r; n++)
      gr.fromBufferAttribute(e, n),
        gr.normalize(),
        e.setXYZ(n, gr.x, gr.y, gr.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        d = a.normalized,
        p = new c.constructor(l.length * u);
      let m = 0,
        v = 0;
      for (let _ = 0, y = l.length; _ < y; _++) {
        a.isInterleavedBufferAttribute
          ? (m = l[_] * a.data.stride + a.offset)
          : (m = l[_] * u);
        for (let g = 0; g < u; g++) p[v++] = c[m++];
      }
      return new sn(p, u, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const n = new Ut(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        c = e(l, r);
      n.setAttribute(a, c);
    }
    const o = this.morphAttributes;
    for (const a in o) {
      const l = [],
        c = o[a];
      for (let u = 0, d = c.length; u < d; u++) {
        const p = c[u],
          m = e(p, r);
        l.push(m);
      }
      n.morphAttributes[a] = l;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const s = this.groups;
    for (let a = 0, l = s.length; a < l; a++) {
      const c = s[a];
      n.addGroup(c.start, c.count, c.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null &&
      (e.data.index = {
        type: n.array.constructor.name,
        array: Array.prototype.slice.call(n.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const c = r[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const m = c[d];
        u.push(m.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (o = !0));
    }
    o &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const s = this.groups;
    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const n = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(n));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(n));
    }
    const o = e.morphAttributes;
    for (const c in o) {
      const u = [],
        d = o[c];
      for (let p = 0, m = d.length; p < m; p++) u.push(d[p].clone(n));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const s = e.groups;
    for (let c = 0, u = s.length; c < u; c++) {
      const d = s[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const dT = new wt(),
  Il = new Oc(),
  ug = new Pr(),
  hT = new ee(),
  hu = new ee(),
  pu = new ee(),
  mu = new ee(),
  X1 = new ee(),
  fg = new ee(),
  dg = new ke(),
  hg = new ke(),
  pg = new ke(),
  pT = new ee(),
  mT = new ee(),
  gT = new ee(),
  mg = new ee(),
  gg = new ee();
class Cn extends Qt {
  constructor(e = new Ut(), n = new sa()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const r = this.geometry,
      i = r.attributes.position,
      o = r.morphAttributes.position,
      s = r.morphTargetsRelative;
    n.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (o && a) {
      fg.set(0, 0, 0);
      for (let l = 0, c = o.length; l < c; l++) {
        const u = a[l],
          d = o[l];
        u !== 0 &&
          (X1.fromBufferAttribute(d, e),
          s ? fg.addScaledVector(X1, u) : fg.addScaledVector(X1.sub(n), u));
      }
      n.add(fg);
    }
    return n;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.material,
      o = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      ug.copy(r.boundingSphere),
      ug.applyMatrix4(o),
      Il.copy(e.ray).recast(e.near),
      !(
        ug.containsPoint(Il.origin) === !1 &&
        (Il.intersectSphere(ug, hT) === null ||
          Il.origin.distanceToSquared(hT) > (e.far - e.near) ** 2)
      ) &&
        (dT.copy(o).invert(),
        Il.copy(e.ray).applyMatrix4(dT),
        !(r.boundingBox !== null && Il.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, n, Il)));
  }
  _computeIntersections(e, n, r) {
    let i;
    const o = this.geometry,
      s = this.material,
      a = o.index,
      l = o.attributes.position,
      c = o.attributes.uv,
      u = o.attributes.uv1,
      d = o.attributes.normal,
      p = o.groups,
      m = o.drawRange;
    if (a !== null)
      if (Array.isArray(s))
        for (let v = 0, _ = p.length; v < _; v++) {
          const y = p[v],
            g = s[y.materialIndex],
            x = Math.max(y.start, m.start),
            S = Math.min(
              a.count,
              Math.min(y.start + y.count, m.start + m.count)
            );
          for (let b = x, C = S; b < C; b += 3) {
            const M = a.getX(b),
              T = a.getX(b + 1),
              P = a.getX(b + 2);
            (i = vg(this, g, e, r, c, u, d, M, T, P)),
              i &&
                ((i.faceIndex = Math.floor(b / 3)),
                (i.face.materialIndex = y.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          _ = Math.min(a.count, m.start + m.count);
        for (let y = v, g = _; y < g; y += 3) {
          const x = a.getX(y),
            S = a.getX(y + 1),
            b = a.getX(y + 2);
          (i = vg(this, s, e, r, c, u, d, x, S, b)),
            i && ((i.faceIndex = Math.floor(y / 3)), n.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(s))
        for (let v = 0, _ = p.length; v < _; v++) {
          const y = p[v],
            g = s[y.materialIndex],
            x = Math.max(y.start, m.start),
            S = Math.min(
              l.count,
              Math.min(y.start + y.count, m.start + m.count)
            );
          for (let b = x, C = S; b < C; b += 3) {
            const M = b,
              T = b + 1,
              P = b + 2;
            (i = vg(this, g, e, r, c, u, d, M, T, P)),
              i &&
                ((i.faceIndex = Math.floor(b / 3)),
                (i.face.materialIndex = y.materialIndex),
                n.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          _ = Math.min(l.count, m.start + m.count);
        for (let y = v, g = _; y < g; y += 3) {
          const x = y,
            S = y + 1,
            b = y + 2;
          (i = vg(this, s, e, r, c, u, d, x, S, b)),
            i && ((i.faceIndex = Math.floor(y / 3)), n.push(i));
        }
      }
  }
}
function T6(t, e, n, r, i, o, s, a) {
  let l;
  if (
    (e.side === li
      ? (l = r.intersectTriangle(s, o, i, !0, a))
      : (l = r.intersectTriangle(i, o, s, e.side === Js, a)),
    l === null)
  )
    return null;
  gg.copy(a), gg.applyMatrix4(t.matrixWorld);
  const c = n.ray.origin.distanceTo(gg);
  return c < n.near || c > n.far
    ? null
    : { distance: c, point: gg.clone(), object: t };
}
function vg(t, e, n, r, i, o, s, a, l, c) {
  t.getVertexPosition(a, hu),
    t.getVertexPosition(l, pu),
    t.getVertexPosition(c, mu);
  const u = T6(t, e, n, r, hu, pu, mu, mg);
  if (u) {
    i &&
      (dg.fromBufferAttribute(i, a),
      hg.fromBufferAttribute(i, l),
      pg.fromBufferAttribute(i, c),
      (u.uv = Gi.getInterpolation(mg, hu, pu, mu, dg, hg, pg, new ke()))),
      o &&
        (dg.fromBufferAttribute(o, a),
        hg.fromBufferAttribute(o, l),
        pg.fromBufferAttribute(o, c),
        (u.uv1 = Gi.getInterpolation(mg, hu, pu, mu, dg, hg, pg, new ke()))),
      s &&
        (pT.fromBufferAttribute(s, a),
        mT.fromBufferAttribute(s, l),
        gT.fromBufferAttribute(s, c),
        (u.normal = Gi.getInterpolation(mg, hu, pu, mu, pT, mT, gT, new ee())),
        u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = { a, b: l, c, normal: new ee(), materialIndex: 0 };
    Gi.getNormal(hu, pu, mu, d.normal), (u.face = d);
  }
  return u;
}
class Nc extends Ut {
  constructor(e = 1, n = 1, r = 1, i = 1, o = 1, s = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: r,
        widthSegments: i,
        heightSegments: o,
        depthSegments: s,
      });
    const a = this;
    (i = Math.floor(i)), (o = Math.floor(o)), (s = Math.floor(s));
    const l = [],
      c = [],
      u = [],
      d = [];
    let p = 0,
      m = 0;
    v("z", "y", "x", -1, -1, r, n, e, s, o, 0),
      v("z", "y", "x", 1, -1, r, n, -e, s, o, 1),
      v("x", "z", "y", 1, 1, e, r, n, i, s, 2),
      v("x", "z", "y", 1, -1, e, r, -n, i, s, 3),
      v("x", "y", "z", 1, -1, e, n, r, i, o, 4),
      v("x", "y", "z", -1, -1, e, n, -r, i, o, 5),
      this.setIndex(l),
      this.setAttribute("position", new dt(c, 3)),
      this.setAttribute("normal", new dt(u, 3)),
      this.setAttribute("uv", new dt(d, 2));
    function v(_, y, g, x, S, b, C, M, T, P, R) {
      const E = b / T,
        O = C / P,
        D = b / 2,
        N = C / 2,
        z = M / 2,
        V = T + 1,
        G = P + 1;
      let Y = 0,
        U = 0;
      const j = new ee();
      for (let W = 0; W < G; W++) {
        const B = W * O - N;
        for (let q = 0; q < V; q++) {
          const Z = q * E - D;
          (j[_] = Z * x),
            (j[y] = B * S),
            (j[g] = z),
            c.push(j.x, j.y, j.z),
            (j[_] = 0),
            (j[y] = 0),
            (j[g] = M > 0 ? 1 : -1),
            u.push(j.x, j.y, j.z),
            d.push(q / T),
            d.push(1 - W / P),
            (Y += 1);
        }
      }
      for (let W = 0; W < P; W++)
        for (let B = 0; B < T; B++) {
          const q = p + B + V * W,
            Z = p + B + V * (W + 1),
            H = p + (B + 1) + V * (W + 1),
            X = p + (B + 1) + V * W;
          l.push(q, Z, X), l.push(Z, H, X), (U += 6);
        }
      a.addGroup(m, U, R), (m += U), (p += Y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Nc(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function _f(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const r in t[n]) {
      const i = t[n][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[n][r] = null))
          : (e[n][r] = i.clone())
        : Array.isArray(i)
        ? (e[n][r] = i.slice())
        : (e[n][r] = i);
    }
  }
  return e;
}
function ii(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const r = _f(t[n]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function R6(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t[n].clone());
  return e;
}
function xN(t) {
  const e = t.getRenderTarget();
  return e === null
    ? t.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : rn.workingColorSpace;
}
const uE = { clone: _f, merge: ii };
var P6 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  I6 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class jo extends qr {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = P6),
      (this.fragmentShader = I6),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = _f(e.uniforms)),
      (this.uniformsGroups = R6(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    (n.glslVersion = this.glslVersion), (n.uniforms = {});
    for (const i in this.uniforms) {
      const s = this.uniforms[i].value;
      s && s.isTexture
        ? (n.uniforms[i] = { type: "t", value: s.toJSON(e).uuid })
        : s && s.isColor
        ? (n.uniforms[i] = { type: "c", value: s.getHex() })
        : s && s.isVector2
        ? (n.uniforms[i] = { type: "v2", value: s.toArray() })
        : s && s.isVector3
        ? (n.uniforms[i] = { type: "v3", value: s.toArray() })
        : s && s.isVector4
        ? (n.uniforms[i] = { type: "v4", value: s.toArray() })
        : s && s.isMatrix3
        ? (n.uniforms[i] = { type: "m3", value: s.toArray() })
        : s && s.isMatrix4
        ? (n.uniforms[i] = { type: "m4", value: s.toArray() })
        : (n.uniforms[i] = { value: s });
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines),
      (n.vertexShader = this.vertexShader),
      (n.fragmentShader = this.fragmentShader),
      (n.lights = this.lights),
      (n.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (n.extensions = r), n;
  }
}
class Lp extends Qt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new wt()),
      (this.projectionMatrix = new wt()),
      (this.projectionMatrixInverse = new wt()),
      (this.coordinateSystem = cs);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ma = new ee(),
  vT = new ke(),
  yT = new ke();
class En extends Lp {
  constructor(e = 50, n = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = n),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const n = (0.5 * this.getFilmHeight()) / e;
    (this.fov = xf * 2 * Math.atan(n)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(dc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return xf * 2 * Math.atan(Math.tan(dc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, n, r) {
    Ma.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(Ma.x, Ma.y).multiplyScalar(-e / Ma.z),
      Ma.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(Ma.x, Ma.y).multiplyScalar(-e / Ma.z);
  }
  getViewSize(e, n) {
    return this.getViewBounds(e, vT, yT), n.subVectors(yT, vT);
  }
  setViewOffset(e, n, r, i, o, s) {
    (this.aspect = e / n),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = (e * Math.tan(dc * 0.5 * this.fov)) / this.zoom,
      r = 2 * n,
      i = this.aspect * r,
      o = -0.5 * i;
    const s = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = s.fullWidth,
        c = s.fullHeight;
      (o += (s.offsetX * i) / l),
        (n -= (s.offsetY * r) / c),
        (i *= s.width / l),
        (r *= s.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (o += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        o,
        o + i,
        n,
        n - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.fov = this.fov),
      (n.object.zoom = this.zoom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      (n.object.focus = this.focus),
      (n.object.aspect = this.aspect),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      (n.object.filmGauge = this.filmGauge),
      (n.object.filmOffset = this.filmOffset),
      n
    );
  }
}
const gu = -90,
  vu = 1;
class _N extends Qt {
  constructor(e, n, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new En(gu, vu, e, n);
    (i.layers = this.layers), this.add(i);
    const o = new En(gu, vu, e, n);
    (o.layers = this.layers), this.add(o);
    const s = new En(gu, vu, e, n);
    (s.layers = this.layers), this.add(s);
    const a = new En(gu, vu, e, n);
    (a.layers = this.layers), this.add(a);
    const l = new En(gu, vu, e, n);
    (l.layers = this.layers), this.add(l);
    const c = new En(gu, vu, e, n);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      n = this.children.concat(),
      [r, i, o, s, a, l] = n;
    for (const c of n) this.remove(c);
    if (e === cs)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Kh)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, 1, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of n) this.add(c), c.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [o, s, a, l, c, u] = this.children,
      d = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(n, o),
      e.setRenderTarget(r, 1, i),
      e.render(n, s),
      e.setRenderTarget(r, 2, i),
      e.render(n, a),
      e.setRenderTarget(r, 3, i),
      e.render(n, l),
      e.setRenderTarget(r, 4, i),
      e.render(n, c),
      (r.texture.generateMipmaps = _),
      e.setRenderTarget(r, 5, i),
      e.render(n, u),
      e.setRenderTarget(d, p, m),
      (e.xr.enabled = v),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class Op extends lr {
  constructor(e, n, r, i, o, s, a, l, c, u) {
    (e = e !== void 0 ? e : []),
      (n = n !== void 0 ? n : Qs),
      super(e, n, r, i, o, s, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class SN extends Wo {
  constructor(e = 1, n = {}) {
    super(e, e, n), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new Op(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : kn);
  }
  fromEquirectangularTexture(e, n) {
    (this.texture.type = n.type),
      (this.texture.colorSpace = n.colorSpace),
      (this.texture.generateMipmaps = n.generateMipmaps),
      (this.texture.minFilter = n.minFilter),
      (this.texture.magFilter = n.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Nc(5, 5, 5),
      o = new jo({
        name: "CubemapFromEquirect",
        uniforms: _f(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: li,
        blending: js,
      });
    o.uniforms.tEquirect.value = n;
    const s = new Cn(i, o),
      a = n.minFilter;
    return (
      n.minFilter === ls && (n.minFilter = kn),
      new _N(1, 10, this).update(e, s),
      (n.minFilter = a),
      s.geometry.dispose(),
      s.material.dispose(),
      this
    );
  }
  clear(e, n, r, i) {
    const o = e.getRenderTarget();
    for (let s = 0; s < 6; s++) e.setRenderTarget(this, s), e.clear(n, r, i);
    e.setRenderTarget(o);
  }
}
const Y1 = new ee(),
  L6 = new ee(),
  O6 = new Dt();
class ks {
  constructor(e = new ee(1, 0, 0), n = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = n);
  }
  set(e, n) {
    return this.normal.copy(e), (this.constant = n), this;
  }
  setComponents(e, n, r, i) {
    return this.normal.set(e, n, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), (this.constant = -n.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, n, r) {
    const i = Y1.subVectors(r, n).cross(L6.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const r = e.delta(Y1),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(r, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (n < 0 && r > 0) || (r < 0 && n > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const r = n || O6.getNormalMatrix(e),
      i = this.coplanarPoint(Y1).applyMatrix4(e),
      o = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(o)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ll = new Pr(),
  yg = new ee();
class Np {
  constructor(
    e = new ks(),
    n = new ks(),
    r = new ks(),
    i = new ks(),
    o = new ks(),
    s = new ks()
  ) {
    this.planes = [e, n, r, i, o, s];
  }
  set(e, n, r, i, o, s) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(n),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(o),
      a[5].copy(s),
      this
    );
  }
  copy(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) n[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, n = cs) {
    const r = this.planes,
      i = e.elements,
      o = i[0],
      s = i[1],
      a = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = i[6],
      p = i[7],
      m = i[8],
      v = i[9],
      _ = i[10],
      y = i[11],
      g = i[12],
      x = i[13],
      S = i[14],
      b = i[15];
    if (
      (r[0].setComponents(l - o, p - c, y - m, b - g).normalize(),
      r[1].setComponents(l + o, p + c, y + m, b + g).normalize(),
      r[2].setComponents(l + s, p + u, y + v, b + x).normalize(),
      r[3].setComponents(l - s, p - u, y - v, b - x).normalize(),
      r[4].setComponents(l - a, p - d, y - _, b - S).normalize(),
      n === cs)
    )
      r[5].setComponents(l + a, p + d, y + _, b + S).normalize();
    else if (n === Kh) r[5].setComponents(a, d, _, S).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          n
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ll.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(),
        Ll.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ll);
  }
  intersectsSprite(e) {
    return (
      Ll.center.set(0, 0, 0),
      (Ll.radius = 0.7071067811865476),
      Ll.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ll)
    );
  }
  intersectsSphere(e) {
    const n = this.planes,
      r = e.center,
      i = -e.radius;
    for (let o = 0; o < 6; o++) if (n[o].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = n[r];
      if (
        ((yg.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (yg.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (yg.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(yg) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let r = 0; r < 6; r++) if (n[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function AN() {
  let t = null,
    e = !1,
    n = null,
    r = null;
  function i(o, s) {
    n(o, s), (r = t.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((r = t.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (o) {
      n = o;
    },
    setContext: function (o) {
      t = o;
    },
  };
}
function N6(t) {
  const e = new WeakMap();
  function n(a, l) {
    const c = a.array,
      u = a.usage,
      d = c.byteLength,
      p = t.createBuffer();
    t.bindBuffer(l, p), t.bufferData(l, c, u), a.onUploadCallback();
    let m;
    if (c instanceof Float32Array) m = t.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (m = t.HALF_FLOAT) : (m = t.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) m = t.SHORT;
    else if (c instanceof Uint32Array) m = t.UNSIGNED_INT;
    else if (c instanceof Int32Array) m = t.INT;
    else if (c instanceof Int8Array) m = t.BYTE;
    else if (c instanceof Uint8Array) m = t.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) m = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: p,
      type: m,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: d,
    };
  }
  function r(a, l, c) {
    const u = l.array,
      d = l._updateRange,
      p = l.updateRanges;
    if (
      (t.bindBuffer(c, a),
      d.count === -1 && p.length === 0 && t.bufferSubData(c, 0, u),
      p.length !== 0)
    ) {
      for (let m = 0, v = p.length; m < v; m++) {
        const _ = p[m];
        t.bufferSubData(c, _.start * u.BYTES_PER_ELEMENT, u, _.start, _.count);
      }
      l.clearUpdateRanges();
    }
    d.count !== -1 &&
      (t.bufferSubData(c, d.offset * u.BYTES_PER_ELEMENT, u, d.offset, d.count),
      (d.count = -1)),
      l.onUploadCallback();
  }
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function o(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (t.deleteBuffer(l.buffer), e.delete(a));
  }
  function s(a, l) {
    if (a.isGLBufferAttribute) {
      const u = e.get(a);
      (!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    a.isInterleavedBufferAttribute && (a = a.data);
    const c = e.get(a);
    if (c === void 0) e.set(a, n(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(c.buffer, a, l), (c.version = a.version);
    }
  }
  return { get: i, remove: o, update: s };
}
class aa extends Ut {
  constructor(e = 1, n = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        widthSegments: r,
        heightSegments: i,
      });
    const o = e / 2,
      s = n / 2,
      a = Math.floor(r),
      l = Math.floor(i),
      c = a + 1,
      u = l + 1,
      d = e / a,
      p = n / l,
      m = [],
      v = [],
      _ = [],
      y = [];
    for (let g = 0; g < u; g++) {
      const x = g * p - s;
      for (let S = 0; S < c; S++) {
        const b = S * d - o;
        v.push(b, -x, 0), _.push(0, 0, 1), y.push(S / a), y.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let x = 0; x < a; x++) {
        const S = x + c * g,
          b = x + c * (g + 1),
          C = x + 1 + c * (g + 1),
          M = x + 1 + c * g;
        m.push(S, b, M), m.push(b, C, M);
      }
    this.setIndex(m),
      this.setAttribute("position", new dt(v, 3)),
      this.setAttribute("normal", new dt(_, 3)),
      this.setAttribute("uv", new dt(y, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new aa(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var D6 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  F6 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  U6 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  k6 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  z6 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  B6 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  H6 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  V6 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  G6 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  W6 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  j6 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  $6 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  X6 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Y6 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  q6 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  K6 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  Z6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  J6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Q6 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  e8 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  t8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  n8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  r8 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  i8 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  o8 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  s8 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  a8 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  l8 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  c8 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  u8 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  f8 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  d8 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  h8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  p8 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  m8 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  g8 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  v8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  y8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  x8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  _8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  S8 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  A8 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  b8 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  w8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  E8 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  M8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  C8 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  T8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  R8 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  P8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  I8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  L8 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  O8 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  N8 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  D8 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  F8 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  U8 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  k8 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  z8 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  B8 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  H8 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  V8 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  G8 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  W8 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  j8 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  $8 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  X8 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Y8 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  q8 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  K8 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  Z8 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  J8 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Q8 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  eH = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  tH = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  nH = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  rH = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  iH = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  oH = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  sH = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  aH = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  lH = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  cH = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  uH = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  fH = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dH = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  hH = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  pH = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  mH = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  gH = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,
  vH = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  yH = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  xH = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  _H = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  SH = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  AH = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  bH = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  wH = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  EH = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  MH = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  CH = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  TH = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  RH = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  PH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  IH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  LH = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  OH = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const NH = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  DH = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  FH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  UH = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  kH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  zH = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  BH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  HH = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  VH = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  GH = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  WH = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  jH = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  $H = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  XH = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  YH = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  qH = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  KH = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  ZH = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  JH = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  QH = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  eV = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  tV = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  nV = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  rV = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  iV = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  oV = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  sV = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  aV = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  lV = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  cV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  uV = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fV = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  dV = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  hV = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Lt = {
    alphahash_fragment: D6,
    alphahash_pars_fragment: F6,
    alphamap_fragment: U6,
    alphamap_pars_fragment: k6,
    alphatest_fragment: z6,
    alphatest_pars_fragment: B6,
    aomap_fragment: H6,
    aomap_pars_fragment: V6,
    batching_pars_vertex: G6,
    batching_vertex: W6,
    begin_vertex: j6,
    beginnormal_vertex: $6,
    bsdfs: X6,
    iridescence_fragment: Y6,
    bumpmap_pars_fragment: q6,
    clipping_planes_fragment: K6,
    clipping_planes_pars_fragment: Z6,
    clipping_planes_pars_vertex: J6,
    clipping_planes_vertex: Q6,
    color_fragment: e8,
    color_pars_fragment: t8,
    color_pars_vertex: n8,
    color_vertex: r8,
    common: i8,
    cube_uv_reflection_fragment: o8,
    defaultnormal_vertex: s8,
    displacementmap_pars_vertex: a8,
    displacementmap_vertex: l8,
    emissivemap_fragment: c8,
    emissivemap_pars_fragment: u8,
    colorspace_fragment: f8,
    colorspace_pars_fragment: d8,
    envmap_fragment: h8,
    envmap_common_pars_fragment: p8,
    envmap_pars_fragment: m8,
    envmap_pars_vertex: g8,
    envmap_physical_pars_fragment: C8,
    envmap_vertex: v8,
    fog_vertex: y8,
    fog_pars_vertex: x8,
    fog_fragment: _8,
    fog_pars_fragment: S8,
    gradientmap_pars_fragment: A8,
    lightmap_pars_fragment: b8,
    lights_lambert_fragment: w8,
    lights_lambert_pars_fragment: E8,
    lights_pars_begin: M8,
    lights_toon_fragment: T8,
    lights_toon_pars_fragment: R8,
    lights_phong_fragment: P8,
    lights_phong_pars_fragment: I8,
    lights_physical_fragment: L8,
    lights_physical_pars_fragment: O8,
    lights_fragment_begin: N8,
    lights_fragment_maps: D8,
    lights_fragment_end: F8,
    logdepthbuf_fragment: U8,
    logdepthbuf_pars_fragment: k8,
    logdepthbuf_pars_vertex: z8,
    logdepthbuf_vertex: B8,
    map_fragment: H8,
    map_pars_fragment: V8,
    map_particle_fragment: G8,
    map_particle_pars_fragment: W8,
    metalnessmap_fragment: j8,
    metalnessmap_pars_fragment: $8,
    morphinstance_vertex: X8,
    morphcolor_vertex: Y8,
    morphnormal_vertex: q8,
    morphtarget_pars_vertex: K8,
    morphtarget_vertex: Z8,
    normal_fragment_begin: J8,
    normal_fragment_maps: Q8,
    normal_pars_fragment: eH,
    normal_pars_vertex: tH,
    normal_vertex: nH,
    normalmap_pars_fragment: rH,
    clearcoat_normal_fragment_begin: iH,
    clearcoat_normal_fragment_maps: oH,
    clearcoat_pars_fragment: sH,
    iridescence_pars_fragment: aH,
    opaque_fragment: lH,
    packing: cH,
    premultiplied_alpha_fragment: uH,
    project_vertex: fH,
    dithering_fragment: dH,
    dithering_pars_fragment: hH,
    roughnessmap_fragment: pH,
    roughnessmap_pars_fragment: mH,
    shadowmap_pars_fragment: gH,
    shadowmap_pars_vertex: vH,
    shadowmap_vertex: yH,
    shadowmask_pars_fragment: xH,
    skinbase_vertex: _H,
    skinning_pars_vertex: SH,
    skinning_vertex: AH,
    skinnormal_vertex: bH,
    specularmap_fragment: wH,
    specularmap_pars_fragment: EH,
    tonemapping_fragment: MH,
    tonemapping_pars_fragment: CH,
    transmission_fragment: TH,
    transmission_pars_fragment: RH,
    uv_pars_fragment: PH,
    uv_pars_vertex: IH,
    uv_vertex: LH,
    worldpos_vertex: OH,
    background_vert: NH,
    background_frag: DH,
    backgroundCube_vert: FH,
    backgroundCube_frag: UH,
    cube_vert: kH,
    cube_frag: zH,
    depth_vert: BH,
    depth_frag: HH,
    distanceRGBA_vert: VH,
    distanceRGBA_frag: GH,
    equirect_vert: WH,
    equirect_frag: jH,
    linedashed_vert: $H,
    linedashed_frag: XH,
    meshbasic_vert: YH,
    meshbasic_frag: qH,
    meshlambert_vert: KH,
    meshlambert_frag: ZH,
    meshmatcap_vert: JH,
    meshmatcap_frag: QH,
    meshnormal_vert: eV,
    meshnormal_frag: tV,
    meshphong_vert: nV,
    meshphong_frag: rV,
    meshphysical_vert: iV,
    meshphysical_frag: oV,
    meshtoon_vert: sV,
    meshtoon_frag: aV,
    points_vert: lV,
    points_frag: cV,
    shadow_vert: uV,
    shadow_frag: fV,
    sprite_vert: dV,
    sprite_frag: hV,
  },
  et = {
    common: {
      diffuse: { value: new it(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Dt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Dt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Dt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Dt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Dt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Dt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Dt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Dt() },
      normalScale: { value: new ke(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Dt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Dt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Dt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Dt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new it(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new it(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Dt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Dt() },
    },
    sprite: {
      diffuse: { value: new it(16777215) },
      opacity: { value: 1 },
      center: { value: new ke(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Dt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Dt() },
      alphaTest: { value: 0 },
    },
  },
  Uo = {
    basic: {
      uniforms: ii([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.fog,
      ]),
      vertexShader: Lt.meshbasic_vert,
      fragmentShader: Lt.meshbasic_frag,
    },
    lambert: {
      uniforms: ii([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        et.lights,
        { emissive: { value: new it(0) } },
      ]),
      vertexShader: Lt.meshlambert_vert,
      fragmentShader: Lt.meshlambert_frag,
    },
    phong: {
      uniforms: ii([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new it(0) },
          specular: { value: new it(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Lt.meshphong_vert,
      fragmentShader: Lt.meshphong_frag,
    },
    standard: {
      uniforms: ii([
        et.common,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.roughnessmap,
        et.metalnessmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new it(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Lt.meshphysical_vert,
      fragmentShader: Lt.meshphysical_frag,
    },
    toon: {
      uniforms: ii([
        et.common,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.gradientmap,
        et.fog,
        et.lights,
        { emissive: { value: new it(0) } },
      ]),
      vertexShader: Lt.meshtoon_vert,
      fragmentShader: Lt.meshtoon_frag,
    },
    matcap: {
      uniforms: ii([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Lt.meshmatcap_vert,
      fragmentShader: Lt.meshmatcap_frag,
    },
    points: {
      uniforms: ii([et.points, et.fog]),
      vertexShader: Lt.points_vert,
      fragmentShader: Lt.points_frag,
    },
    dashed: {
      uniforms: ii([
        et.common,
        et.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Lt.linedashed_vert,
      fragmentShader: Lt.linedashed_frag,
    },
    depth: {
      uniforms: ii([et.common, et.displacementmap]),
      vertexShader: Lt.depth_vert,
      fragmentShader: Lt.depth_frag,
    },
    normal: {
      uniforms: ii([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Lt.meshnormal_vert,
      fragmentShader: Lt.meshnormal_frag,
    },
    sprite: {
      uniforms: ii([et.sprite, et.fog]),
      vertexShader: Lt.sprite_vert,
      fragmentShader: Lt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Dt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Lt.background_vert,
      fragmentShader: Lt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Dt() },
      },
      vertexShader: Lt.backgroundCube_vert,
      fragmentShader: Lt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Lt.cube_vert,
      fragmentShader: Lt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Lt.equirect_vert,
      fragmentShader: Lt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: ii([
        et.common,
        et.displacementmap,
        {
          referencePosition: { value: new ee() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Lt.distanceRGBA_vert,
      fragmentShader: Lt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: ii([
        et.lights,
        et.fog,
        { color: { value: new it(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Lt.shadow_vert,
      fragmentShader: Lt.shadow_frag,
    },
  };
Uo.physical = {
  uniforms: ii([
    Uo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Dt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Dt() },
      clearcoatNormalScale: { value: new ke(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Dt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Dt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Dt() },
      sheen: { value: 0 },
      sheenColor: { value: new it(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Dt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Dt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Dt() },
      transmissionSamplerSize: { value: new ke() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Dt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new it(0) },
      specularColor: { value: new it(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Dt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Dt() },
      anisotropyVector: { value: new ke() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Dt() },
    },
  ]),
  vertexShader: Lt.meshphysical_vert,
  fragmentShader: Lt.meshphysical_frag,
};
const xg = { r: 0, b: 0, g: 0 },
  Ol = new qi(),
  pV = new wt();
function mV(t, e, n, r, i, o, s) {
  const a = new it(0);
  let l = o === !0 ? 0 : 1,
    c,
    u,
    d = null,
    p = 0,
    m = null;
  function v(x) {
    let S = x.isScene === !0 ? x.background : null;
    return (
      S && S.isTexture && (S = (x.backgroundBlurriness > 0 ? n : e).get(S)), S
    );
  }
  function _(x) {
    let S = !1;
    const b = v(x);
    b === null ? g(a, l) : b && b.isColor && (g(b, 1), (S = !0));
    const C = t.xr.getEnvironmentBlendMode();
    C === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, s)
      : C === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, s),
      (t.autoClear || S) &&
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil);
  }
  function y(x, S) {
    const b = v(S);
    b && (b.isCubeTexture || b.mapping === Nf)
      ? (u === void 0 &&
          ((u = new Cn(
            new Nc(1, 1, 1),
            new jo({
              name: "BackgroundCubeMaterial",
              uniforms: _f(Uo.backgroundCube.uniforms),
              vertexShader: Uo.backgroundCube.vertexShader,
              fragmentShader: Uo.backgroundCube.fragmentShader,
              side: li,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (C, M, T) {
            this.matrixWorld.copyPosition(T.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(u)),
        Ol.copy(S.backgroundRotation),
        (Ol.x *= -1),
        (Ol.y *= -1),
        (Ol.z *= -1),
        b.isCubeTexture &&
          b.isRenderTargetTexture === !1 &&
          ((Ol.y *= -1), (Ol.z *= -1)),
        (u.material.uniforms.envMap.value = b),
        (u.material.uniforms.flipEnvMap.value =
          b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          S.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          pV.makeRotationFromEuler(Ol)
        ),
        (u.material.toneMapped = rn.getTransfer(b.colorSpace) !== hn),
        (d !== b || p !== b.version || m !== t.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (d = b),
          (p = b.version),
          (m = t.toneMapping)),
        u.layers.enableAll(),
        x.unshift(u, u.geometry, u.material, 0, 0, null))
      : b &&
        b.isTexture &&
        (c === void 0 &&
          ((c = new Cn(
            new aa(2, 2),
            new jo({
              name: "BackgroundMaterial",
              uniforms: _f(Uo.background.uniforms),
              vertexShader: Uo.background.vertexShader,
              fragmentShader: Uo.background.fragmentShader,
              side: Js,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(c)),
        (c.material.uniforms.t2D.value = b),
        (c.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        (c.material.toneMapped = rn.getTransfer(b.colorSpace) !== hn),
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(b.matrix),
        (d !== b || p !== b.version || m !== t.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (d = b),
          (p = b.version),
          (m = t.toneMapping)),
        c.layers.enableAll(),
        x.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(x, S) {
    x.getRGB(xg, xN(t)), r.buffers.color.setClear(xg.r, xg.g, xg.b, S, s);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (x, S = 1) {
      a.set(x), (l = S), g(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (x) {
      (l = x), g(a, l);
    },
    render: _,
    addToRenderList: y,
  };
}
function gV(t, e) {
  const n = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    r = {},
    i = p(null);
  let o = i,
    s = !1;
  function a(E, O, D, N, z) {
    let V = !1;
    const G = d(N, D, O);
    o !== G && ((o = G), c(o.object)),
      (V = m(E, N, D, z)),
      V && v(E, N, D, z),
      z !== null && e.update(z, t.ELEMENT_ARRAY_BUFFER),
      (V || s) &&
        ((s = !1),
        b(E, O, D, N),
        z !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(z).buffer));
  }
  function l() {
    return t.createVertexArray();
  }
  function c(E) {
    return t.bindVertexArray(E);
  }
  function u(E) {
    return t.deleteVertexArray(E);
  }
  function d(E, O, D) {
    const N = D.wireframe === !0;
    let z = r[E.id];
    z === void 0 && ((z = {}), (r[E.id] = z));
    let V = z[O.id];
    V === void 0 && ((V = {}), (z[O.id] = V));
    let G = V[N];
    return G === void 0 && ((G = p(l())), (V[N] = G)), G;
  }
  function p(E) {
    const O = [],
      D = [],
      N = [];
    for (let z = 0; z < n; z++) (O[z] = 0), (D[z] = 0), (N[z] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: O,
      enabledAttributes: D,
      attributeDivisors: N,
      object: E,
      attributes: {},
      index: null,
    };
  }
  function m(E, O, D, N) {
    const z = o.attributes,
      V = O.attributes;
    let G = 0;
    const Y = D.getAttributes();
    for (const U in Y)
      if (Y[U].location >= 0) {
        const W = z[U];
        let B = V[U];
        if (
          (B === void 0 &&
            (U === "instanceMatrix" &&
              E.instanceMatrix &&
              (B = E.instanceMatrix),
            U === "instanceColor" && E.instanceColor && (B = E.instanceColor)),
          W === void 0 || W.attribute !== B || (B && W.data !== B.data))
        )
          return !0;
        G++;
      }
    return o.attributesNum !== G || o.index !== N;
  }
  function v(E, O, D, N) {
    const z = {},
      V = O.attributes;
    let G = 0;
    const Y = D.getAttributes();
    for (const U in Y)
      if (Y[U].location >= 0) {
        let W = V[U];
        W === void 0 &&
          (U === "instanceMatrix" && E.instanceMatrix && (W = E.instanceMatrix),
          U === "instanceColor" && E.instanceColor && (W = E.instanceColor));
        const B = {};
        (B.attribute = W), W && W.data && (B.data = W.data), (z[U] = B), G++;
      }
    (o.attributes = z), (o.attributesNum = G), (o.index = N);
  }
  function _() {
    const E = o.newAttributes;
    for (let O = 0, D = E.length; O < D; O++) E[O] = 0;
  }
  function y(E) {
    g(E, 0);
  }
  function g(E, O) {
    const D = o.newAttributes,
      N = o.enabledAttributes,
      z = o.attributeDivisors;
    (D[E] = 1),
      N[E] === 0 && (t.enableVertexAttribArray(E), (N[E] = 1)),
      z[E] !== O && (t.vertexAttribDivisor(E, O), (z[E] = O));
  }
  function x() {
    const E = o.newAttributes,
      O = o.enabledAttributes;
    for (let D = 0, N = O.length; D < N; D++)
      O[D] !== E[D] && (t.disableVertexAttribArray(D), (O[D] = 0));
  }
  function S(E, O, D, N, z, V, G) {
    G === !0
      ? t.vertexAttribIPointer(E, O, D, z, V)
      : t.vertexAttribPointer(E, O, D, N, z, V);
  }
  function b(E, O, D, N) {
    _();
    const z = N.attributes,
      V = D.getAttributes(),
      G = O.defaultAttributeValues;
    for (const Y in V) {
      const U = V[Y];
      if (U.location >= 0) {
        let j = z[Y];
        if (
          (j === void 0 &&
            (Y === "instanceMatrix" &&
              E.instanceMatrix &&
              (j = E.instanceMatrix),
            Y === "instanceColor" && E.instanceColor && (j = E.instanceColor)),
          j !== void 0)
        ) {
          const W = j.normalized,
            B = j.itemSize,
            q = e.get(j);
          if (q === void 0) continue;
          const Z = q.buffer,
            H = q.type,
            X = q.bytesPerElement,
            ne = H === t.INT || H === t.UNSIGNED_INT || j.gpuType === Kw;
          if (j.isInterleavedBufferAttribute) {
            const oe = j.data,
              ue = oe.stride,
              Ie = j.offset;
            if (oe.isInstancedInterleavedBuffer) {
              for (let te = 0; te < U.locationSize; te++)
                g(U.location + te, oe.meshPerAttribute);
              E.isInstancedMesh !== !0 &&
                N._maxInstanceCount === void 0 &&
                (N._maxInstanceCount = oe.meshPerAttribute * oe.count);
            } else
              for (let te = 0; te < U.locationSize; te++) y(U.location + te);
            t.bindBuffer(t.ARRAY_BUFFER, Z);
            for (let te = 0; te < U.locationSize; te++)
              S(
                U.location + te,
                B / U.locationSize,
                H,
                W,
                ue * X,
                (Ie + (B / U.locationSize) * te) * X,
                ne
              );
          } else {
            if (j.isInstancedBufferAttribute) {
              for (let oe = 0; oe < U.locationSize; oe++)
                g(U.location + oe, j.meshPerAttribute);
              E.isInstancedMesh !== !0 &&
                N._maxInstanceCount === void 0 &&
                (N._maxInstanceCount = j.meshPerAttribute * j.count);
            } else
              for (let oe = 0; oe < U.locationSize; oe++) y(U.location + oe);
            t.bindBuffer(t.ARRAY_BUFFER, Z);
            for (let oe = 0; oe < U.locationSize; oe++)
              S(
                U.location + oe,
                B / U.locationSize,
                H,
                W,
                B * X,
                (B / U.locationSize) * oe * X,
                ne
              );
          }
        } else if (G !== void 0) {
          const W = G[Y];
          if (W !== void 0)
            switch (W.length) {
              case 2:
                t.vertexAttrib2fv(U.location, W);
                break;
              case 3:
                t.vertexAttrib3fv(U.location, W);
                break;
              case 4:
                t.vertexAttrib4fv(U.location, W);
                break;
              default:
                t.vertexAttrib1fv(U.location, W);
            }
        }
      }
    }
    x();
  }
  function C() {
    P();
    for (const E in r) {
      const O = r[E];
      for (const D in O) {
        const N = O[D];
        for (const z in N) u(N[z].object), delete N[z];
        delete O[D];
      }
      delete r[E];
    }
  }
  function M(E) {
    if (r[E.id] === void 0) return;
    const O = r[E.id];
    for (const D in O) {
      const N = O[D];
      for (const z in N) u(N[z].object), delete N[z];
      delete O[D];
    }
    delete r[E.id];
  }
  function T(E) {
    for (const O in r) {
      const D = r[O];
      if (D[E.id] === void 0) continue;
      const N = D[E.id];
      for (const z in N) u(N[z].object), delete N[z];
      delete D[E.id];
    }
  }
  function P() {
    R(), (s = !0), o !== i && ((o = i), c(o.object));
  }
  function R() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: a,
    reset: P,
    resetDefaultState: R,
    dispose: C,
    releaseStatesOfGeometry: M,
    releaseStatesOfProgram: T,
    initAttributes: _,
    enableAttribute: y,
    disableUnusedAttributes: x,
  };
}
function vV(t, e, n) {
  let r;
  function i(c) {
    r = c;
  }
  function o(c, u) {
    t.drawArrays(r, c, u), n.update(u, r, 1);
  }
  function s(c, u, d) {
    d !== 0 && (t.drawArraysInstanced(r, c, u, d), n.update(u, r, d));
  }
  function a(c, u, d) {
    if (d === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null) for (let m = 0; m < d; m++) this.render(c[m], u[m]);
    else {
      p.multiDrawArraysWEBGL(r, c, 0, u, 0, d);
      let m = 0;
      for (let v = 0; v < d; v++) m += u[v];
      n.update(m, r, 1);
    }
  }
  function l(c, u, d, p) {
    if (d === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let v = 0; v < c.length; v++) s(c[v], u[v], p[v]);
    else {
      m.multiDrawArraysInstancedWEBGL(r, c, 0, u, 0, p, 0, d);
      let v = 0;
      for (let _ = 0; _ < d; _++) v += u[_];
      for (let _ = 0; _ < p.length; _++) n.update(v, r, p[_]);
    }
  }
  (this.setMode = i),
    (this.render = o),
    (this.renderInstances = s),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function yV(t, e, n, r) {
  let i;
  function o() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const M = e.get("EXT_texture_filter_anisotropic");
      i = t.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(M) {
    return !(
      M !== Si &&
      r.convert(M) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(M) {
    const T =
      M === Pp &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      M !== gs &&
      r.convert(M) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) &&
      M !== yo &&
      !T
    );
  }
  function l(M) {
    if (M === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      M = "mediump";
    }
    return M === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = n.precision !== void 0 ? n.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead."
    ),
    (c = u));
  const d = n.logarithmicDepthBuffer === !0,
    p = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    m = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    v = t.getParameter(t.MAX_TEXTURE_SIZE),
    _ = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    y = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    g = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    x = t.getParameter(t.MAX_VARYING_VECTORS),
    S = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    b = m > 0,
    C = t.getParameter(t.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: o,
    getMaxPrecision: l,
    textureFormatReadable: s,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: d,
    maxTextures: p,
    maxVertexTextures: m,
    maxTextureSize: v,
    maxCubemapSize: _,
    maxAttributes: y,
    maxVertexUniforms: g,
    maxVaryings: x,
    maxFragmentUniforms: S,
    vertexTextures: b,
    maxSamples: C,
  };
}
function xV(t) {
  const e = this;
  let n = null,
    r = 0,
    i = !1,
    o = !1;
  const s = new ks(),
    a = new Dt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || r !== 0 || i;
      return (i = p), (r = d.length), m;
    }),
    (this.beginShadows = function () {
      (o = !0), u(null);
    }),
    (this.endShadows = function () {
      o = !1;
    }),
    (this.setGlobalState = function (d, p) {
      n = u(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const v = d.clippingPlanes,
        _ = d.clipIntersection,
        y = d.clipShadows,
        g = t.get(d);
      if (!i || v === null || v.length === 0 || (o && !y)) o ? u(null) : c();
      else {
        const x = o ? 0 : r,
          S = x * 4;
        let b = g.clippingState || null;
        (l.value = b), (b = u(v, p, S, m));
        for (let C = 0; C !== S; ++C) b[C] = n[C];
        (g.clippingState = b),
          (this.numIntersection = _ ? this.numPlanes : 0),
          (this.numPlanes += x);
      }
    });
  function c() {
    l.value !== n && ((l.value = n), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function u(d, p, m, v) {
    const _ = d !== null ? d.length : 0;
    let y = null;
    if (_ !== 0) {
      if (((y = l.value), v !== !0 || y === null)) {
        const g = m + _ * 4,
          x = p.matrixWorldInverse;
        a.getNormalMatrix(x),
          (y === null || y.length < g) && (y = new Float32Array(g));
        for (let S = 0, b = m; S !== _; ++S, b += 4)
          s.copy(d[S]).applyMatrix4(x, a),
            s.normal.toArray(y, b),
            (y[b + 3] = s.constant);
      }
      (l.value = y), (l.needsUpdate = !0);
    }
    return (e.numPlanes = _), (e.numIntersection = 0), y;
  }
}
function _V(t) {
  let e = new WeakMap();
  function n(s, a) {
    return a === zh ? (s.mapping = Qs) : a === Bh && (s.mapping = tl), s;
  }
  function r(s) {
    if (s && s.isTexture) {
      const a = s.mapping;
      if (a === zh || a === Bh)
        if (e.has(s)) {
          const l = e.get(s).texture;
          return n(l, s.mapping);
        } else {
          const l = s.image;
          if (l && l.height > 0) {
            const c = new SN(l.height);
            return (
              c.fromEquirectangularTexture(t, s),
              e.set(s, c),
              s.addEventListener("dispose", i),
              n(c.texture, s.mapping)
            );
          } else return null;
        }
    }
    return s;
  }
  function i(s) {
    const a = s.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function o() {
    e = new WeakMap();
  }
  return { get: r, dispose: o };
}
class ps extends Lp {
  constructor(e = -1, n = 1, r = 1, i = -1, o = 0.1, s = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = n),
      (this.top = r),
      (this.bottom = i),
      (this.near = o),
      (this.far = s),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, n, r, i, o, s) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = o),
      (this.view.height = s),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      n = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let o = r - e,
      s = r + e,
      a = i + n,
      l = i - n;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (o += c * this.view.offsetX),
        (s = o + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      o,
      s,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.zoom = this.zoom),
      (n.object.left = this.left),
      (n.object.right = this.right),
      (n.object.top = this.top),
      (n.object.bottom = this.bottom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      n
    );
  }
}
const Yu = 4,
  xT = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  ql = 20,
  q1 = new ps(),
  _T = new it();
let K1 = null,
  Z1 = 0,
  J1 = 0,
  Q1 = !1;
const Xl = (1 + Math.sqrt(5)) / 2,
  yu = 1 / Xl,
  ST = [
    new ee(-Xl, yu, 0),
    new ee(Xl, yu, 0),
    new ee(-yu, 0, Xl),
    new ee(yu, 0, Xl),
    new ee(0, Xl, -yu),
    new ee(0, Xl, yu),
    new ee(-1, 1, -1),
    new ee(1, 1, -1),
    new ee(-1, 1, 1),
    new ee(1, 1, 1),
  ];
class LA {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, r = 0.1, i = 100) {
    (K1 = this._renderer.getRenderTarget()),
      (Z1 = this._renderer.getActiveCubeFace()),
      (J1 = this._renderer.getActiveMipmapLevel()),
      (Q1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const o = this._allocateTargets();
    return (
      (o.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, o),
      n > 0 && this._blur(o, 0, 0, n),
      this._applyPMREM(o),
      this._cleanup(o),
      o
    );
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = wT()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = bT()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(K1, Z1, J1),
      (this._renderer.xr.enabled = Q1),
      (e.scissorTest = !1),
      _g(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === Qs || e.mapping === tl
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (K1 = this._renderer.getRenderTarget()),
      (Z1 = this._renderer.getActiveCubeFace()),
      (J1 = this._renderer.getActiveMipmapLevel()),
      (Q1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = n || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      n = 4 * this._cubeSize,
      r = {
        magFilter: kn,
        minFilter: kn,
        generateMipmaps: !1,
        type: Pp,
        format: Si,
        colorSpace: ia,
        depthBuffer: !1,
      },
      i = AT(e, n, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== n
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = AT(e, n, r));
      const { _lodMax: o } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = SV(o)),
        (this._blurMaterial = AV(o, e, n));
    }
    return i;
  }
  _compileMaterial(e) {
    const n = new Cn(this._lodPlanes[0], e);
    this._renderer.compile(n, q1);
  }
  _sceneToCubeUV(e, n, r, i) {
    const a = new En(90, 1, n, r),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      p = u.toneMapping;
    u.getClearColor(_T), (u.toneMapping = hs), (u.autoClear = !1);
    const m = new sa({
        name: "PMREM.Background",
        side: li,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new Cn(new Nc(), m);
    let _ = !1;
    const y = e.background;
    y
      ? y.isColor && (m.color.copy(y), (e.background = null), (_ = !0))
      : (m.color.copy(_T), (_ = !0));
    for (let g = 0; g < 6; g++) {
      const x = g % 3;
      x === 0
        ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0))
        : x === 1
        ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0))
        : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g]));
      const S = this._cubeSize;
      _g(i, x * S, g > 2 ? S : 0, S, S),
        u.setRenderTarget(i),
        _ && u.render(v, a),
        u.render(e, a);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (u.toneMapping = p),
      (u.autoClear = d),
      (e.background = y);
  }
  _textureToCubeUV(e, n) {
    const r = this._renderer,
      i = e.mapping === Qs || e.mapping === tl;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = wT()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = bT());
    const o = i ? this._cubemapMaterial : this._equirectMaterial,
      s = new Cn(this._lodPlanes[0], o),
      a = o.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    _g(n, 0, 0, 3 * l, 2 * l), r.setRenderTarget(n), r.render(s, q1);
  }
  _applyPMREM(e) {
    const n = this._renderer,
      r = n.autoClear;
    n.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const s = Math.sqrt(
          this._sigmas[o] * this._sigmas[o] -
            this._sigmas[o - 1] * this._sigmas[o - 1]
        ),
        a = ST[(i - o - 1) % ST.length];
      this._blur(e, o - 1, o, s, a);
    }
    n.autoClear = r;
  }
  _blur(e, n, r, i, o) {
    const s = this._pingPongRenderTarget;
    this._halfBlur(e, s, n, r, i, "latitudinal", o),
      this._halfBlur(s, e, r, r, i, "longitudinal", o);
  }
  _halfBlur(e, n, r, i, o, s, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    s !== "latitudinal" &&
      s !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      d = new Cn(this._lodPlanes[i], c),
      p = c.uniforms,
      m = this._sizeLods[r] - 1,
      v = isFinite(o) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * ql - 1),
      _ = o / v,
      y = isFinite(o) ? 1 + Math.floor(u * _) : ql;
    y > ql &&
      console.warn(
        `sigmaRadians, ${o}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${ql}`
      );
    const g = [];
    let x = 0;
    for (let T = 0; T < ql; ++T) {
      const P = T / _,
        R = Math.exp((-P * P) / 2);
      g.push(R), T === 0 ? (x += R) : T < y && (x += 2 * R);
    }
    for (let T = 0; T < g.length; T++) g[T] = g[T] / x;
    (p.envMap.value = e.texture),
      (p.samples.value = y),
      (p.weights.value = g),
      (p.latitudinal.value = s === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: S } = this;
    (p.dTheta.value = v), (p.mipInt.value = S - r);
    const b = this._sizeLods[i],
      C = 3 * b * (i > S - Yu ? i - S + Yu : 0),
      M = 4 * (this._cubeSize - b);
    _g(n, C, M, 3 * b, 2 * b), l.setRenderTarget(n), l.render(d, q1);
  }
}
function SV(t) {
  const e = [],
    n = [],
    r = [];
  let i = t;
  const o = t - Yu + 1 + xT.length;
  for (let s = 0; s < o; s++) {
    const a = Math.pow(2, i);
    n.push(a);
    let l = 1 / a;
    s > t - Yu ? (l = xT[s - t + Yu - 1]) : s === 0 && (l = 0), r.push(l);
    const c = 1 / (a - 2),
      u = -c,
      d = 1 + c,
      p = [u, u, d, u, d, d, u, u, d, d, u, d],
      m = 6,
      v = 6,
      _ = 3,
      y = 2,
      g = 1,
      x = new Float32Array(_ * v * m),
      S = new Float32Array(y * v * m),
      b = new Float32Array(g * v * m);
    for (let M = 0; M < m; M++) {
      const T = ((M % 3) * 2) / 3 - 1,
        P = M > 2 ? 0 : -1,
        R = [
          T,
          P,
          0,
          T + 2 / 3,
          P,
          0,
          T + 2 / 3,
          P + 1,
          0,
          T,
          P,
          0,
          T + 2 / 3,
          P + 1,
          0,
          T,
          P + 1,
          0,
        ];
      x.set(R, _ * v * M), S.set(p, y * v * M);
      const E = [M, M, M, M, M, M];
      b.set(E, g * v * M);
    }
    const C = new Ut();
    C.setAttribute("position", new sn(x, _)),
      C.setAttribute("uv", new sn(S, y)),
      C.setAttribute("faceIndex", new sn(b, g)),
      e.push(C),
      i > Yu && i--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: r };
}
function AT(t, e, n) {
  const r = new Wo(t, e, n);
  return (
    (r.texture.mapping = Nf),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function _g(t, e, n, r, i) {
  t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i);
}
function AV(t, e, n) {
  const r = new Float32Array(ql),
    i = new ee(0, 1, 0);
  return new jo({
    name: "SphericalGaussianBlur",
    defines: {
      n: ql,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: fE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function bT() {
  return new jo({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: fE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function wT() {
  return new jo({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: fE(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: js,
    depthTest: !1,
    depthWrite: !1,
  });
}
function fE() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function bV(t) {
  let e = new WeakMap(),
    n = null;
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === zh || l === Bh,
        u = l === Qs || l === tl;
      if (c || u) {
        let d = e.get(a);
        const p = d !== void 0 ? d.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== p)
          return (
            n === null && (n = new LA(t)),
            (d = c ? n.fromEquirectangular(a, d) : n.fromCubemap(a, d)),
            (d.texture.pmremVersion = a.pmremVersion),
            e.set(a, d),
            d.texture
          );
        if (d !== void 0) return d.texture;
        {
          const m = a.image;
          return (c && m && m.height > 0) || (u && m && i(m))
            ? (n === null && (n = new LA(t)),
              (d = c ? n.fromEquirectangular(a) : n.fromCubemap(a)),
              (d.texture.pmremVersion = a.pmremVersion),
              e.set(a, d),
              a.addEventListener("dispose", o),
              d.texture)
            : null;
        }
      }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function o(a) {
    const l = a.target;
    l.removeEventListener("dispose", o);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function s() {
    (e = new WeakMap()), n !== null && (n.dispose(), (n = null));
  }
  return { get: r, dispose: s };
}
function wV(t) {
  const e = {};
  function n(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = t.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return n(r) !== null;
    },
    init: function () {
      n("EXT_color_buffer_float"),
        n("WEBGL_clip_cull_distance"),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("WEBGL_multisampled_render_to_texture"),
        n("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = n(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function EV(t, e, n, r) {
  const i = {},
    o = new WeakMap();
  function s(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    for (const v in p.morphAttributes) {
      const _ = p.morphAttributes[v];
      for (let y = 0, g = _.length; y < g; y++) e.remove(_[y]);
    }
    p.removeEventListener("dispose", s), delete i[p.id];
    const m = o.get(p);
    m && (e.remove(m), o.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      n.memory.geometries--;
  }
  function a(d, p) {
    return (
      i[p.id] === !0 ||
        (p.addEventListener("dispose", s),
        (i[p.id] = !0),
        n.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const v in p) e.update(p[v], t.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const v in m) {
      const _ = m[v];
      for (let y = 0, g = _.length; y < g; y++) e.update(_[y], t.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const p = [],
      m = d.index,
      v = d.attributes.position;
    let _ = 0;
    if (m !== null) {
      const x = m.array;
      _ = m.version;
      for (let S = 0, b = x.length; S < b; S += 3) {
        const C = x[S + 0],
          M = x[S + 1],
          T = x[S + 2];
        p.push(C, M, M, T, T, C);
      }
    } else if (v !== void 0) {
      const x = v.array;
      _ = v.version;
      for (let S = 0, b = x.length / 3 - 1; S < b; S += 3) {
        const C = S + 0,
          M = S + 1,
          T = S + 2;
        p.push(C, M, M, T, T, C);
      }
    } else return;
    const y = new (hN(p) ? cE : lE)(p, 1);
    y.version = _;
    const g = o.get(d);
    g && e.remove(g), o.set(d, y);
  }
  function u(d) {
    const p = o.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && c(d);
    } else c(d);
    return o.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function MV(t, e, n) {
  let r;
  function i(p) {
    r = p;
  }
  let o, s;
  function a(p) {
    (o = p.type), (s = p.bytesPerElement);
  }
  function l(p, m) {
    t.drawElements(r, m, o, p * s), n.update(m, r, 1);
  }
  function c(p, m, v) {
    v !== 0 && (t.drawElementsInstanced(r, m, o, p * s, v), n.update(m, r, v));
  }
  function u(p, m, v) {
    if (v === 0) return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null) for (let y = 0; y < v; y++) this.render(p[y] / s, m[y]);
    else {
      _.multiDrawElementsWEBGL(r, m, 0, o, p, 0, v);
      let y = 0;
      for (let g = 0; g < v; g++) y += m[g];
      n.update(y, r, 1);
    }
  }
  function d(p, m, v, _) {
    if (v === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null) for (let g = 0; g < p.length; g++) c(p[g] / s, m[g], _[g]);
    else {
      y.multiDrawElementsInstancedWEBGL(r, m, 0, o, p, 0, _, 0, v);
      let g = 0;
      for (let x = 0; x < v; x++) g += m[x];
      for (let x = 0; x < _.length; x++) n.update(g, r, _[x]);
    }
  }
  (this.setMode = i),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = d);
}
function CV(t) {
  const e = { geometries: 0, textures: 0 },
    n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(o, s, a) {
    switch ((n.calls++, s)) {
      case t.TRIANGLES:
        n.triangles += a * (o / 3);
        break;
      case t.LINES:
        n.lines += a * (o / 2);
        break;
      case t.LINE_STRIP:
        n.lines += a * (o - 1);
        break;
      case t.LINE_LOOP:
        n.lines += a * o;
        break;
      case t.POINTS:
        n.points += a * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", s);
        break;
    }
  }
  function i() {
    (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function TV(t, e, n) {
  const r = new WeakMap(),
    i = new tn();
  function o(s, a, l) {
    const c = s.morphTargetInfluences,
      u =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      d = u !== void 0 ? u.length : 0;
    let p = r.get(a);
    if (p === void 0 || p.count !== d) {
      let E = function () {
        P.dispose(), r.delete(a), a.removeEventListener("dispose", E);
      };
      var m = E;
      p !== void 0 && p.texture.dispose();
      const v = a.morphAttributes.position !== void 0,
        _ = a.morphAttributes.normal !== void 0,
        y = a.morphAttributes.color !== void 0,
        g = a.morphAttributes.position || [],
        x = a.morphAttributes.normal || [],
        S = a.morphAttributes.color || [];
      let b = 0;
      v === !0 && (b = 1), _ === !0 && (b = 2), y === !0 && (b = 3);
      let C = a.attributes.position.count * b,
        M = 1;
      C > e.maxTextureSize &&
        ((M = Math.ceil(C / e.maxTextureSize)), (C = e.maxTextureSize));
      const T = new Float32Array(C * M * 4 * d),
        P = new iy(T, C, M, d);
      (P.type = yo), (P.needsUpdate = !0);
      const R = b * 4;
      for (let O = 0; O < d; O++) {
        const D = g[O],
          N = x[O],
          z = S[O],
          V = C * M * 4 * O;
        for (let G = 0; G < D.count; G++) {
          const Y = G * R;
          v === !0 &&
            (i.fromBufferAttribute(D, G),
            (T[V + Y + 0] = i.x),
            (T[V + Y + 1] = i.y),
            (T[V + Y + 2] = i.z),
            (T[V + Y + 3] = 0)),
            _ === !0 &&
              (i.fromBufferAttribute(N, G),
              (T[V + Y + 4] = i.x),
              (T[V + Y + 5] = i.y),
              (T[V + Y + 6] = i.z),
              (T[V + Y + 7] = 0)),
            y === !0 &&
              (i.fromBufferAttribute(z, G),
              (T[V + Y + 8] = i.x),
              (T[V + Y + 9] = i.y),
              (T[V + Y + 10] = i.z),
              (T[V + Y + 11] = z.itemSize === 4 ? i.w : 1));
        }
      }
      (p = { count: d, texture: P, size: new ke(C, M) }),
        r.set(a, p),
        a.addEventListener("dispose", E);
    }
    if (s.isInstancedMesh === !0 && s.morphTexture !== null)
      l.getUniforms().setValue(t, "morphTexture", s.morphTexture, n);
    else {
      let v = 0;
      for (let y = 0; y < c.length; y++) v += c[y];
      const _ = a.morphTargetsRelative ? 1 : 1 - v;
      l.getUniforms().setValue(t, "morphTargetBaseInfluence", _),
        l.getUniforms().setValue(t, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(t, "morphTargetsTexture", p.texture, n),
      l.getUniforms().setValue(t, "morphTargetsTextureSize", p.size);
  }
  return { update: o };
}
function RV(t, e, n, r) {
  let i = new WeakMap();
  function o(l) {
    const c = r.render.frame,
      u = l.geometry,
      d = e.get(l, u);
    if (
      (i.get(d) !== c && (e.update(d), i.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== c &&
          (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
          i.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      i.get(p) !== c && (p.update(), i.set(p, c));
    }
    return d;
  }
  function s() {
    i = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      n.remove(c.instanceMatrix),
      c.instanceColor !== null && n.remove(c.instanceColor);
  }
  return { update: o, dispose: s };
}
class dE extends lr {
  constructor(e, n, r, i, o, s, a, l, c, u) {
    if (((u = u !== void 0 ? u : fc), u !== fc && u !== yf))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && u === fc && (r = wc),
      r === void 0 && u === yf && (r = Df),
      super(null, i, o, s, a, l, u, r, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: n }),
      (this.magFilter = a !== void 0 ? a : xr),
      (this.minFilter = l !== void 0 ? l : xr),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (n.compareFunction = this.compareFunction),
      n
    );
  }
}
const bN = new lr(),
  wN = new dE(1, 1);
wN.compareFunction = oE;
const EN = new iy(),
  MN = new aE(),
  CN = new Op(),
  ET = [],
  MT = [],
  CT = new Float32Array(16),
  TT = new Float32Array(9),
  RT = new Float32Array(4);
function Ff(t, e, n) {
  const r = t[0];
  if (r <= 0 || r > 0) return t;
  const i = e * n;
  let o = ET[i];
  if ((o === void 0 && ((o = new Float32Array(i)), (ET[i] = o)), e !== 0)) {
    r.toArray(o, 0);
    for (let s = 1, a = 0; s !== e; ++s) (a += n), t[s].toArray(o, a);
  }
  return o;
}
function ir(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, r = t.length; n < r; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function or(t, e) {
  for (let n = 0, r = e.length; n < r; n++) t[n] = e[n];
}
function oy(t, e) {
  let n = MT[e];
  n === void 0 && ((n = new Int32Array(e)), (MT[e] = n));
  for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
  return n;
}
function PV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function IV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (ir(n, e)) return;
    t.uniform2fv(this.addr, e), or(n, e);
  }
}
function LV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (ir(n, e)) return;
    t.uniform3fv(this.addr, e), or(n, e);
  }
}
function OV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (ir(n, e)) return;
    t.uniform4fv(this.addr, e), or(n, e);
  }
}
function NV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ir(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), or(n, e);
  } else {
    if (ir(n, r)) return;
    RT.set(r), t.uniformMatrix2fv(this.addr, !1, RT), or(n, r);
  }
}
function DV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ir(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), or(n, e);
  } else {
    if (ir(n, r)) return;
    TT.set(r), t.uniformMatrix3fv(this.addr, !1, TT), or(n, r);
  }
}
function FV(t, e) {
  const n = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (ir(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), or(n, e);
  } else {
    if (ir(n, r)) return;
    CT.set(r), t.uniformMatrix4fv(this.addr, !1, CT), or(n, r);
  }
}
function UV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function kV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (ir(n, e)) return;
    t.uniform2iv(this.addr, e), or(n, e);
  }
}
function zV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (ir(n, e)) return;
    t.uniform3iv(this.addr, e), or(n, e);
  }
}
function BV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (ir(n, e)) return;
    t.uniform4iv(this.addr, e), or(n, e);
  }
}
function HV(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function VV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (ir(n, e)) return;
    t.uniform2uiv(this.addr, e), or(n, e);
  }
}
function GV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (ir(n, e)) return;
    t.uniform3uiv(this.addr, e), or(n, e);
  }
}
function WV(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (ir(n, e)) return;
    t.uniform4uiv(this.addr, e), or(n, e);
  }
}
function jV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i));
  const o = this.type === t.SAMPLER_2D_SHADOW ? wN : bN;
  n.setTexture2D(e || o, i);
}
function $V(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture3D(e || MN, i);
}
function XV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTextureCube(e || CN, i);
}
function YV(t, e, n) {
  const r = this.cache,
    i = n.allocateTextureUnit();
  r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
    n.setTexture2DArray(e || EN, i);
}
function qV(t) {
  switch (t) {
    case 5126:
      return PV;
    case 35664:
      return IV;
    case 35665:
      return LV;
    case 35666:
      return OV;
    case 35674:
      return NV;
    case 35675:
      return DV;
    case 35676:
      return FV;
    case 5124:
    case 35670:
      return UV;
    case 35667:
    case 35671:
      return kV;
    case 35668:
    case 35672:
      return zV;
    case 35669:
    case 35673:
      return BV;
    case 5125:
      return HV;
    case 36294:
      return VV;
    case 36295:
      return GV;
    case 36296:
      return WV;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return jV;
    case 35679:
    case 36299:
    case 36307:
      return $V;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return XV;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return YV;
  }
}
function KV(t, e) {
  t.uniform1fv(this.addr, e);
}
function ZV(t, e) {
  const n = Ff(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function JV(t, e) {
  const n = Ff(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function QV(t, e) {
  const n = Ff(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function eG(t, e) {
  const n = Ff(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function tG(t, e) {
  const n = Ff(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function nG(t, e) {
  const n = Ff(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function rG(t, e) {
  t.uniform1iv(this.addr, e);
}
function iG(t, e) {
  t.uniform2iv(this.addr, e);
}
function oG(t, e) {
  t.uniform3iv(this.addr, e);
}
function sG(t, e) {
  t.uniform4iv(this.addr, e);
}
function aG(t, e) {
  t.uniform1uiv(this.addr, e);
}
function lG(t, e) {
  t.uniform2uiv(this.addr, e);
}
function cG(t, e) {
  t.uniform3uiv(this.addr, e);
}
function uG(t, e) {
  t.uniform4uiv(this.addr, e);
}
function fG(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = oy(n, i);
  ir(r, o) || (t.uniform1iv(this.addr, o), or(r, o));
  for (let s = 0; s !== i; ++s) n.setTexture2D(e[s] || bN, o[s]);
}
function dG(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = oy(n, i);
  ir(r, o) || (t.uniform1iv(this.addr, o), or(r, o));
  for (let s = 0; s !== i; ++s) n.setTexture3D(e[s] || MN, o[s]);
}
function hG(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = oy(n, i);
  ir(r, o) || (t.uniform1iv(this.addr, o), or(r, o));
  for (let s = 0; s !== i; ++s) n.setTextureCube(e[s] || CN, o[s]);
}
function pG(t, e, n) {
  const r = this.cache,
    i = e.length,
    o = oy(n, i);
  ir(r, o) || (t.uniform1iv(this.addr, o), or(r, o));
  for (let s = 0; s !== i; ++s) n.setTexture2DArray(e[s] || EN, o[s]);
}
function mG(t) {
  switch (t) {
    case 5126:
      return KV;
    case 35664:
      return ZV;
    case 35665:
      return JV;
    case 35666:
      return QV;
    case 35674:
      return eG;
    case 35675:
      return tG;
    case 35676:
      return nG;
    case 5124:
    case 35670:
      return rG;
    case 35667:
    case 35671:
      return iG;
    case 35668:
    case 35672:
      return oG;
    case 35669:
    case 35673:
      return sG;
    case 5125:
      return aG;
    case 36294:
      return lG;
    case 36295:
      return cG;
    case 36296:
      return uG;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return fG;
    case 35679:
    case 36299:
    case 36307:
      return dG;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return hG;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return pG;
  }
}
class gG {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.setValue = qV(n.type));
  }
}
class vG {
  constructor(e, n, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = n.type),
      (this.size = n.size),
      (this.setValue = mG(n.type));
  }
}
class yG {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, n, r) {
    const i = this.seq;
    for (let o = 0, s = i.length; o !== s; ++o) {
      const a = i[o];
      a.setValue(e, n[a.id], r);
    }
  }
}
const e_ = /(\w+)(\])?(\[|\.)?/g;
function PT(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function xG(t, e, n) {
  const r = t.name,
    i = r.length;
  for (e_.lastIndex = 0; ; ) {
    const o = e_.exec(r),
      s = e_.lastIndex;
    let a = o[1];
    const l = o[2] === "]",
      c = o[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && s + 2 === i))) {
      PT(n, c === void 0 ? new gG(a, t, e) : new vG(a, t, e));
      break;
    } else {
      let d = n.map[a];
      d === void 0 && ((d = new yG(a)), PT(n, d)), (n = d);
    }
  }
}
class P0 {
  constructor(e, n) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const o = e.getActiveUniform(n, i),
        s = e.getUniformLocation(n, o.name);
      xG(o, s, this);
    }
  }
  setValue(e, n, r, i) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, r, i);
  }
  setOptional(e, n, r) {
    const i = n[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, n, r, i) {
    for (let o = 0, s = n.length; o !== s; ++o) {
      const a = n[o],
        l = r[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, n) {
    const r = [];
    for (let i = 0, o = e.length; i !== o; ++i) {
      const s = e[i];
      s.id in n && r.push(s);
    }
    return r;
  }
}
function IT(t, e, n) {
  const r = t.createShader(e);
  return t.shaderSource(r, n), t.compileShader(r), r;
}
const _G = 37297;
let SG = 0;
function AG(t, e) {
  const n = t.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    o = Math.min(e + 6, n.length);
  for (let s = i; s < o; s++) {
    const a = s + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${n[s]}`);
  }
  return r.join(`
`);
}
function bG(t) {
  const e = rn.getPrimaries(rn.workingColorSpace),
    n = rn.getPrimaries(t);
  let r;
  switch (
    (e === n
      ? (r = "")
      : e === Yh && n === Xh
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === Xh && n === Yh && (r = "LinearSRGBToLinearDisplayP3"),
    t)
  ) {
    case ia:
    case Ip:
      return [r, "LinearTransferOETF"];
    case fo:
    case ry:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", t),
        [r, "LinearTransferOETF"]
      );
  }
}
function LT(t, e, n) {
  const r = t.getShaderParameter(e, t.COMPILE_STATUS),
    i = t.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(i);
  if (o) {
    const s = parseInt(o[1]);
    return (
      n.toUpperCase() +
      `

` +
      i +
      `

` +
      AG(t.getShaderSource(e), s)
    );
  } else return i;
}
function wG(t, e) {
  const n = bG(e);
  return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
}
function EG(t, e) {
  let n;
  switch (e) {
    case UO:
      n = "Linear";
      break;
    case kO:
      n = "Reinhard";
      break;
    case zO:
      n = "OptimizedCineon";
      break;
    case Xw:
      n = "ACESFilmic";
      break;
    case HO:
      n = "AgX";
      break;
    case VO:
      n = "Neutral";
      break;
    case BO:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function MG(t) {
  return [
    t.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Yd).join(`
`);
}
function CG(t) {
  const e = [];
  for (const n in t) {
    const r = t[n];
    r !== !1 && e.push("#define " + n + " " + r);
  }
  return e.join(`
`);
}
function TG(t, e) {
  const n = {},
    r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const o = t.getActiveAttrib(e, i),
      s = o.name;
    let a = 1;
    o.type === t.FLOAT_MAT2 && (a = 2),
      o.type === t.FLOAT_MAT3 && (a = 3),
      o.type === t.FLOAT_MAT4 && (a = 4),
      (n[s] = {
        type: o.type,
        location: t.getAttribLocation(e, s),
        locationSize: a,
      });
  }
  return n;
}
function Yd(t) {
  return t !== "";
}
function OT(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function NT(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const RG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function OA(t) {
  return t.replace(RG, IG);
}
const PG = new Map();
function IG(t, e) {
  let n = Lt[e];
  if (n === void 0) {
    const r = PG.get(e);
    if (r !== void 0)
      (n = Lt[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return OA(n);
}
const LG =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function DT(t) {
  return t.replace(LG, OG);
}
function OG(t, e, n, r) {
  let i = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + o + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, o);
  return i;
}
function FT(t) {
  let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;
  return (
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function NG(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === ey
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === uh
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === Lo && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function DG(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case Qs:
      case tl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Nf:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function FG(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case tl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function UG(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case Rp:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case DO:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case FO:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function kG(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
    texelHeight: r,
    maxMip: n,
  };
}
function zG(t, e, n, r) {
  const i = t.getContext(),
    o = n.defines;
  let s = n.vertexShader,
    a = n.fragmentShader;
  const l = NG(n),
    c = DG(n),
    u = FG(n),
    d = UG(n),
    p = kG(n),
    m = MG(n),
    v = CG(o),
    _ = i.createProgram();
  let y,
    g,
    x = n.glslVersion
      ? "#version " +
        n.glslVersion +
        `
`
      : "";
  n.isRawShaderMaterial
    ? ((y = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
      ].filter(Yd).join(`
`)),
      y.length > 0 &&
        (y += `
`),
      (g = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
      ].filter(Yd).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((y = [
        FT(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
        n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        n.batching ? "#define USE_BATCHING" : "",
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.mapUv ? "#define MAP_UV " + n.mapUv : "",
        n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
        n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
        n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
        n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
        n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
        n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
        n.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
          : "",
        n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
        n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
        n.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
          : "",
        n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
        n.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
          : "",
        n.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
          : "",
        n.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
          : "",
        n.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
          : "",
        n.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
          : "",
        n.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
          : "",
        n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
        n.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
          : "",
        n.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
          : "",
        n.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
          : "",
        n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && n.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphColors ? "#define USE_MORPHCOLORS" : "",
        n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
        n.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
          : "",
        n.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Yd).join(`
`)),
      (g = [
        FT(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        v,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + c : "",
        n.envMap ? "#define " + u : "",
        n.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.dispersion ? "#define USE_DISPERSION" : "",
        n.iridescence ? "#define USE_IRIDESCENCE" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        n.toneMapping !== hs ? "#define TONE_MAPPING" : "",
        n.toneMapping !== hs ? Lt.tonemapping_pars_fragment : "",
        n.toneMapping !== hs ? EG("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        n.opaque ? "#define OPAQUE" : "",
        Lt.colorspace_pars_fragment,
        wG("linearToOutputTexel", n.outputColorSpace),
        n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        `
`,
      ].filter(Yd).join(`
`))),
    (s = OA(s)),
    (s = OT(s, n)),
    (s = NT(s, n)),
    (a = OA(a)),
    (a = OT(a, n)),
    (a = NT(a, n)),
    (s = DT(s)),
    (a = DT(a)),
    n.isRawShaderMaterial !== !0 &&
      ((x = `#version 300 es
`),
      (y =
        [
          m,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        y),
      (g =
        [
          "#define varying in",
          n.glslVersion === IA
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === IA ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const S = x + y + s,
    b = x + g + a,
    C = IT(i, i.VERTEX_SHADER, S),
    M = IT(i, i.FRAGMENT_SHADER, b);
  i.attachShader(_, C),
    i.attachShader(_, M),
    n.index0AttributeName !== void 0
      ? i.bindAttribLocation(_, 0, n.index0AttributeName)
      : n.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"),
    i.linkProgram(_);
  function T(O) {
    if (t.debug.checkShaderErrors) {
      const D = i.getProgramInfoLog(_).trim(),
        N = i.getShaderInfoLog(C).trim(),
        z = i.getShaderInfoLog(M).trim();
      let V = !0,
        G = !0;
      if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
        if (((V = !1), typeof t.debug.onShaderError == "function"))
          t.debug.onShaderError(i, _, C, M);
        else {
          const Y = LT(i, C, "vertex"),
            U = LT(i, M, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(_, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              O.name +
              `
Material Type: ` +
              O.type +
              `

Program Info Log: ` +
              D +
              `
` +
              Y +
              `
` +
              U
          );
        }
      else
        D !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", D)
          : (N === "" || z === "") && (G = !1);
      G &&
        (O.diagnostics = {
          runnable: V,
          programLog: D,
          vertexShader: { log: N, prefix: y },
          fragmentShader: { log: z, prefix: g },
        });
    }
    i.deleteShader(C), i.deleteShader(M), (P = new P0(i, _)), (R = TG(i, _));
  }
  let P;
  this.getUniforms = function () {
    return P === void 0 && T(this), P;
  };
  let R;
  this.getAttributes = function () {
    return R === void 0 && T(this), R;
  };
  let E = n.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return E === !1 && (E = i.getProgramParameter(_, _G)), E;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(_),
        (this.program = void 0);
    }),
    (this.type = n.shaderType),
    (this.name = n.shaderName),
    (this.id = SG++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = _),
    (this.vertexShader = C),
    (this.fragmentShader = M),
    this
  );
}
let BG = 0;
class HG {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const n = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(n),
      o = this._getShaderStage(r),
      s = this._getShaderCacheForMaterial(e);
    return (
      s.has(i) === !1 && (s.add(i), i.usedTimes++),
      s.has(o) === !1 && (s.add(o), o.usedTimes++),
      this
    );
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const r of n)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let r = n.get(e);
    return r === void 0 && ((r = new Set()), n.set(e, r)), r;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let r = n.get(e);
    return r === void 0 && ((r = new VG(e)), n.set(e, r)), r;
  }
}
class VG {
  constructor(e) {
    (this.id = BG++), (this.code = e), (this.usedTimes = 0);
  }
}
function GG(t, e, n, r, i, o, s) {
  const a = new hc(),
    l = new HG(),
    c = new Set(),
    u = [],
    d = i.logarithmicDepthBuffer,
    p = i.vertexTextures;
  let m = i.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function _(R) {
    return c.add(R), R === 0 ? "uv" : `uv${R}`;
  }
  function y(R, E, O, D, N) {
    const z = D.fog,
      V = N.geometry,
      G = R.isMeshStandardMaterial ? D.environment : null,
      Y = (R.isMeshStandardMaterial ? n : e).get(R.envMap || G),
      U = Y && Y.mapping === Nf ? Y.image.height : null,
      j = v[R.type];
    R.precision !== null &&
      ((m = i.getMaxPrecision(R.precision)),
      m !== R.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          R.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const W =
        V.morphAttributes.position ||
        V.morphAttributes.normal ||
        V.morphAttributes.color,
      B = W !== void 0 ? W.length : 0;
    let q = 0;
    V.morphAttributes.position !== void 0 && (q = 1),
      V.morphAttributes.normal !== void 0 && (q = 2),
      V.morphAttributes.color !== void 0 && (q = 3);
    let Z, H, X, ne;
    if (j) {
      const Ze = Uo[j];
      (Z = Ze.vertexShader), (H = Ze.fragmentShader);
    } else
      (Z = R.vertexShader),
        (H = R.fragmentShader),
        l.update(R),
        (X = l.getVertexShaderID(R)),
        (ne = l.getFragmentShaderID(R));
    const oe = t.getRenderTarget(),
      ue = N.isInstancedMesh === !0,
      Ie = N.isBatchedMesh === !0,
      te = !!R.map,
      ge = !!R.matcap,
      ie = !!Y,
      pe = !!R.aoMap,
      de = !!R.lightMap,
      Ee = !!R.bumpMap,
      he = !!R.normalMap,
      Ce = !!R.displacementMap,
      _e = !!R.emissiveMap,
      $ = !!R.metalnessMap,
      k = !!R.roughnessMap,
      J = R.anisotropy > 0,
      fe = R.clearcoat > 0,
      le = R.dispersion > 0,
      ce = R.iridescence > 0,
      we = R.sheen > 0,
      Be = R.transmission > 0,
      Me = J && !!R.anisotropyMap,
      Ge = fe && !!R.clearcoatMap,
      Le = fe && !!R.clearcoatNormalMap,
      je = fe && !!R.clearcoatRoughnessMap,
      Je = ce && !!R.iridescenceMap,
      Ye = ce && !!R.iridescenceThicknessMap,
      De = we && !!R.sheenColorMap,
      ze = we && !!R.sheenRoughnessMap,
      Ve = !!R.specularMap,
      ae = !!R.specularColorMap,
      be = !!R.specularIntensityMap,
      se = Be && !!R.transmissionMap,
      Ae = Be && !!R.thicknessMap,
      ye = !!R.gradientMap,
      He = !!R.alphaMap,
      qe = R.alphaTest > 0,
      at = !!R.alphaHash,
      st = !!R.extensions;
    let ht = hs;
    R.toneMapped &&
      (oe === null || oe.isXRRenderTarget === !0) &&
      (ht = t.toneMapping);
    const pt = {
      shaderID: j,
      shaderType: R.type,
      shaderName: R.name,
      vertexShader: Z,
      fragmentShader: H,
      defines: R.defines,
      customVertexShaderID: X,
      customFragmentShaderID: ne,
      isRawShaderMaterial: R.isRawShaderMaterial === !0,
      glslVersion: R.glslVersion,
      precision: m,
      batching: Ie,
      instancing: ue,
      instancingColor: ue && N.instanceColor !== null,
      instancingMorph: ue && N.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        oe === null
          ? t.outputColorSpace
          : oe.isXRRenderTarget === !0
          ? oe.texture.colorSpace
          : ia,
      alphaToCoverage: !!R.alphaToCoverage,
      map: te,
      matcap: ge,
      envMap: ie,
      envMapMode: ie && Y.mapping,
      envMapCubeUVHeight: U,
      aoMap: pe,
      lightMap: de,
      bumpMap: Ee,
      normalMap: he,
      displacementMap: p && Ce,
      emissiveMap: _e,
      normalMapObjectSpace: he && R.normalMapType === rN,
      normalMapTangentSpace: he && R.normalMapType === al,
      metalnessMap: $,
      roughnessMap: k,
      anisotropy: J,
      anisotropyMap: Me,
      clearcoat: fe,
      clearcoatMap: Ge,
      clearcoatNormalMap: Le,
      clearcoatRoughnessMap: je,
      dispersion: le,
      iridescence: ce,
      iridescenceMap: Je,
      iridescenceThicknessMap: Ye,
      sheen: we,
      sheenColorMap: De,
      sheenRoughnessMap: ze,
      specularMap: Ve,
      specularColorMap: ae,
      specularIntensityMap: be,
      transmission: Be,
      transmissionMap: se,
      thicknessMap: Ae,
      gradientMap: ye,
      opaque:
        R.transparent === !1 && R.blending === uc && R.alphaToCoverage === !1,
      alphaMap: He,
      alphaTest: qe,
      alphaHash: at,
      combine: R.combine,
      mapUv: te && _(R.map.channel),
      aoMapUv: pe && _(R.aoMap.channel),
      lightMapUv: de && _(R.lightMap.channel),
      bumpMapUv: Ee && _(R.bumpMap.channel),
      normalMapUv: he && _(R.normalMap.channel),
      displacementMapUv: Ce && _(R.displacementMap.channel),
      emissiveMapUv: _e && _(R.emissiveMap.channel),
      metalnessMapUv: $ && _(R.metalnessMap.channel),
      roughnessMapUv: k && _(R.roughnessMap.channel),
      anisotropyMapUv: Me && _(R.anisotropyMap.channel),
      clearcoatMapUv: Ge && _(R.clearcoatMap.channel),
      clearcoatNormalMapUv: Le && _(R.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: je && _(R.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Je && _(R.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ye && _(R.iridescenceThicknessMap.channel),
      sheenColorMapUv: De && _(R.sheenColorMap.channel),
      sheenRoughnessMapUv: ze && _(R.sheenRoughnessMap.channel),
      specularMapUv: Ve && _(R.specularMap.channel),
      specularColorMapUv: ae && _(R.specularColorMap.channel),
      specularIntensityMapUv: be && _(R.specularIntensityMap.channel),
      transmissionMapUv: se && _(R.transmissionMap.channel),
      thicknessMapUv: Ae && _(R.thicknessMap.channel),
      alphaMapUv: He && _(R.alphaMap.channel),
      vertexTangents: !!V.attributes.tangent && (he || J),
      vertexColors: R.vertexColors,
      vertexAlphas:
        R.vertexColors === !0 &&
        !!V.attributes.color &&
        V.attributes.color.itemSize === 4,
      pointsUvs: N.isPoints === !0 && !!V.attributes.uv && (te || He),
      fog: !!z,
      useFog: R.fog === !0,
      fogExp2: !!z && z.isFogExp2,
      flatShading: R.flatShading === !0,
      sizeAttenuation: R.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: N.isSkinnedMesh === !0,
      morphTargets: V.morphAttributes.position !== void 0,
      morphNormals: V.morphAttributes.normal !== void 0,
      morphColors: V.morphAttributes.color !== void 0,
      morphTargetsCount: B,
      morphTextureStride: q,
      numDirLights: E.directional.length,
      numPointLights: E.point.length,
      numSpotLights: E.spot.length,
      numSpotLightMaps: E.spotLightMap.length,
      numRectAreaLights: E.rectArea.length,
      numHemiLights: E.hemi.length,
      numDirLightShadows: E.directionalShadowMap.length,
      numPointLightShadows: E.pointShadowMap.length,
      numSpotLightShadows: E.spotShadowMap.length,
      numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
      numLightProbes: E.numLightProbes,
      numClippingPlanes: s.numPlanes,
      numClipIntersection: s.numIntersection,
      dithering: R.dithering,
      shadowMapEnabled: t.shadowMap.enabled && O.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: ht,
      useLegacyLights: t._useLegacyLights,
      decodeVideoTexture:
        te &&
        R.map.isVideoTexture === !0 &&
        rn.getTransfer(R.map.colorSpace) === hn,
      premultipliedAlpha: R.premultipliedAlpha,
      doubleSided: R.side === mo,
      flipSided: R.side === li,
      useDepthPacking: R.depthPacking >= 0,
      depthPacking: R.depthPacking || 0,
      index0AttributeName: R.index0AttributeName,
      extensionClipCullDistance:
        st &&
        R.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        st && R.extensions.multiDraw === !0 && r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: R.customProgramCacheKey(),
    };
    return (
      (pt.vertexUv1s = c.has(1)),
      (pt.vertexUv2s = c.has(2)),
      (pt.vertexUv3s = c.has(3)),
      c.clear(),
      pt
    );
  }
  function g(R) {
    const E = [];
    if (
      (R.shaderID
        ? E.push(R.shaderID)
        : (E.push(R.customVertexShaderID), E.push(R.customFragmentShaderID)),
      R.defines !== void 0)
    )
      for (const O in R.defines) E.push(O), E.push(R.defines[O]);
    return (
      R.isRawShaderMaterial === !1 &&
        (x(E, R), S(E, R), E.push(t.outputColorSpace)),
      E.push(R.customProgramCacheKey),
      E.join()
    );
  }
  function x(R, E) {
    R.push(E.precision),
      R.push(E.outputColorSpace),
      R.push(E.envMapMode),
      R.push(E.envMapCubeUVHeight),
      R.push(E.mapUv),
      R.push(E.alphaMapUv),
      R.push(E.lightMapUv),
      R.push(E.aoMapUv),
      R.push(E.bumpMapUv),
      R.push(E.normalMapUv),
      R.push(E.displacementMapUv),
      R.push(E.emissiveMapUv),
      R.push(E.metalnessMapUv),
      R.push(E.roughnessMapUv),
      R.push(E.anisotropyMapUv),
      R.push(E.clearcoatMapUv),
      R.push(E.clearcoatNormalMapUv),
      R.push(E.clearcoatRoughnessMapUv),
      R.push(E.iridescenceMapUv),
      R.push(E.iridescenceThicknessMapUv),
      R.push(E.sheenColorMapUv),
      R.push(E.sheenRoughnessMapUv),
      R.push(E.specularMapUv),
      R.push(E.specularColorMapUv),
      R.push(E.specularIntensityMapUv),
      R.push(E.transmissionMapUv),
      R.push(E.thicknessMapUv),
      R.push(E.combine),
      R.push(E.fogExp2),
      R.push(E.sizeAttenuation),
      R.push(E.morphTargetsCount),
      R.push(E.morphAttributeCount),
      R.push(E.numDirLights),
      R.push(E.numPointLights),
      R.push(E.numSpotLights),
      R.push(E.numSpotLightMaps),
      R.push(E.numHemiLights),
      R.push(E.numRectAreaLights),
      R.push(E.numDirLightShadows),
      R.push(E.numPointLightShadows),
      R.push(E.numSpotLightShadows),
      R.push(E.numSpotLightShadowsWithMaps),
      R.push(E.numLightProbes),
      R.push(E.shadowMapType),
      R.push(E.toneMapping),
      R.push(E.numClippingPlanes),
      R.push(E.numClipIntersection),
      R.push(E.depthPacking);
  }
  function S(R, E) {
    a.disableAll(),
      E.supportsVertexTextures && a.enable(0),
      E.instancing && a.enable(1),
      E.instancingColor && a.enable(2),
      E.instancingMorph && a.enable(3),
      E.matcap && a.enable(4),
      E.envMap && a.enable(5),
      E.normalMapObjectSpace && a.enable(6),
      E.normalMapTangentSpace && a.enable(7),
      E.clearcoat && a.enable(8),
      E.iridescence && a.enable(9),
      E.alphaTest && a.enable(10),
      E.vertexColors && a.enable(11),
      E.vertexAlphas && a.enable(12),
      E.vertexUv1s && a.enable(13),
      E.vertexUv2s && a.enable(14),
      E.vertexUv3s && a.enable(15),
      E.vertexTangents && a.enable(16),
      E.anisotropy && a.enable(17),
      E.alphaHash && a.enable(18),
      E.batching && a.enable(19),
      E.dispersion && a.enable(20),
      R.push(a.mask),
      a.disableAll(),
      E.fog && a.enable(0),
      E.useFog && a.enable(1),
      E.flatShading && a.enable(2),
      E.logarithmicDepthBuffer && a.enable(3),
      E.skinning && a.enable(4),
      E.morphTargets && a.enable(5),
      E.morphNormals && a.enable(6),
      E.morphColors && a.enable(7),
      E.premultipliedAlpha && a.enable(8),
      E.shadowMapEnabled && a.enable(9),
      E.useLegacyLights && a.enable(10),
      E.doubleSided && a.enable(11),
      E.flipSided && a.enable(12),
      E.useDepthPacking && a.enable(13),
      E.dithering && a.enable(14),
      E.transmission && a.enable(15),
      E.sheen && a.enable(16),
      E.opaque && a.enable(17),
      E.pointsUvs && a.enable(18),
      E.decodeVideoTexture && a.enable(19),
      E.alphaToCoverage && a.enable(20),
      R.push(a.mask);
  }
  function b(R) {
    const E = v[R.type];
    let O;
    if (E) {
      const D = Uo[E];
      O = uE.clone(D.uniforms);
    } else O = R.uniforms;
    return O;
  }
  function C(R, E) {
    let O;
    for (let D = 0, N = u.length; D < N; D++) {
      const z = u[D];
      if (z.cacheKey === E) {
        (O = z), ++O.usedTimes;
        break;
      }
    }
    return O === void 0 && ((O = new zG(t, E, R, o)), u.push(O)), O;
  }
  function M(R) {
    if (--R.usedTimes === 0) {
      const E = u.indexOf(R);
      (u[E] = u[u.length - 1]), u.pop(), R.destroy();
    }
  }
  function T(R) {
    l.remove(R);
  }
  function P() {
    l.dispose();
  }
  return {
    getParameters: y,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: C,
    releaseProgram: M,
    releaseShaderCache: T,
    programs: u,
    dispose: P,
  };
}
function WG() {
  let t = new WeakMap();
  function e(o) {
    let s = t.get(o);
    return s === void 0 && ((s = {}), t.set(o, s)), s;
  }
  function n(o) {
    t.delete(o);
  }
  function r(o, s, a) {
    t.get(o)[s] = a;
  }
  function i() {
    t = new WeakMap();
  }
  return { get: e, remove: n, update: r, dispose: i };
}
function jG(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function UT(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function kT() {
  const t = [];
  let e = 0;
  const n = [],
    r = [],
    i = [];
  function o() {
    (e = 0), (n.length = 0), (r.length = 0), (i.length = 0);
  }
  function s(d, p, m, v, _, y) {
    let g = t[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: _,
            group: y,
          }),
          (t[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = v),
          (g.renderOrder = d.renderOrder),
          (g.z = _),
          (g.group = y)),
      e++,
      g
    );
  }
  function a(d, p, m, v, _, y) {
    const g = s(d, p, m, v, _, y);
    m.transmission > 0
      ? r.push(g)
      : m.transparent === !0
      ? i.push(g)
      : n.push(g);
  }
  function l(d, p, m, v, _, y) {
    const g = s(d, p, m, v, _, y);
    m.transmission > 0
      ? r.unshift(g)
      : m.transparent === !0
      ? i.unshift(g)
      : n.unshift(g);
  }
  function c(d, p) {
    n.length > 1 && n.sort(d || jG),
      r.length > 1 && r.sort(p || UT),
      i.length > 1 && i.sort(p || UT);
  }
  function u() {
    for (let d = e, p = t.length; d < p; d++) {
      const m = t[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: r,
    transparent: i,
    init: o,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function $G() {
  let t = new WeakMap();
  function e(r, i) {
    const o = t.get(r);
    let s;
    return (
      o === void 0
        ? ((s = new kT()), t.set(r, [s]))
        : i >= o.length
        ? ((s = new kT()), o.push(s))
        : (s = o[i]),
      s
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
function XG() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new ee(), color: new it() };
          break;
        case "SpotLight":
          n = {
            position: new ee(),
            direction: new ee(),
            color: new it(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new ee(), color: new it(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = {
            direction: new ee(),
            skyColor: new it(),
            groundColor: new it(),
          };
          break;
        case "RectAreaLight":
          n = {
            color: new it(),
            position: new ee(),
            halfWidth: new ee(),
            halfHeight: new ee(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function YG() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ke(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let qG = 0;
function KG(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function ZG(t) {
  const e = new XG(),
    n = YG(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) r.probe.push(new ee());
  const i = new ee(),
    o = new wt(),
    s = new wt();
  function a(c, u) {
    let d = 0,
      p = 0,
      m = 0;
    for (let O = 0; O < 9; O++) r.probe[O].set(0, 0, 0);
    let v = 0,
      _ = 0,
      y = 0,
      g = 0,
      x = 0,
      S = 0,
      b = 0,
      C = 0,
      M = 0,
      T = 0,
      P = 0;
    c.sort(KG);
    const R = u === !0 ? Math.PI : 1;
    for (let O = 0, D = c.length; O < D; O++) {
      const N = c[O],
        z = N.color,
        V = N.intensity,
        G = N.distance,
        Y = N.shadow && N.shadow.map ? N.shadow.map.texture : null;
      if (N.isAmbientLight)
        (d += z.r * V * R), (p += z.g * V * R), (m += z.b * V * R);
      else if (N.isLightProbe) {
        for (let U = 0; U < 9; U++)
          r.probe[U].addScaledVector(N.sh.coefficients[U], V);
        P++;
      } else if (N.isDirectionalLight) {
        const U = e.get(N);
        if (
          (U.color.copy(N.color).multiplyScalar(N.intensity * R), N.castShadow)
        ) {
          const j = N.shadow,
            W = n.get(N);
          (W.shadowBias = j.bias),
            (W.shadowNormalBias = j.normalBias),
            (W.shadowRadius = j.radius),
            (W.shadowMapSize = j.mapSize),
            (r.directionalShadow[v] = W),
            (r.directionalShadowMap[v] = Y),
            (r.directionalShadowMatrix[v] = N.shadow.matrix),
            S++;
        }
        (r.directional[v] = U), v++;
      } else if (N.isSpotLight) {
        const U = e.get(N);
        U.position.setFromMatrixPosition(N.matrixWorld),
          U.color.copy(z).multiplyScalar(V * R),
          (U.distance = G),
          (U.coneCos = Math.cos(N.angle)),
          (U.penumbraCos = Math.cos(N.angle * (1 - N.penumbra))),
          (U.decay = N.decay),
          (r.spot[y] = U);
        const j = N.shadow;
        if (
          (N.map &&
            ((r.spotLightMap[M] = N.map),
            M++,
            j.updateMatrices(N),
            N.castShadow && T++),
          (r.spotLightMatrix[y] = j.matrix),
          N.castShadow)
        ) {
          const W = n.get(N);
          (W.shadowBias = j.bias),
            (W.shadowNormalBias = j.normalBias),
            (W.shadowRadius = j.radius),
            (W.shadowMapSize = j.mapSize),
            (r.spotShadow[y] = W),
            (r.spotShadowMap[y] = Y),
            C++;
        }
        y++;
      } else if (N.isRectAreaLight) {
        const U = e.get(N);
        U.color.copy(z).multiplyScalar(V),
          U.halfWidth.set(N.width * 0.5, 0, 0),
          U.halfHeight.set(0, N.height * 0.5, 0),
          (r.rectArea[g] = U),
          g++;
      } else if (N.isPointLight) {
        const U = e.get(N);
        if (
          (U.color.copy(N.color).multiplyScalar(N.intensity * R),
          (U.distance = N.distance),
          (U.decay = N.decay),
          N.castShadow)
        ) {
          const j = N.shadow,
            W = n.get(N);
          (W.shadowBias = j.bias),
            (W.shadowNormalBias = j.normalBias),
            (W.shadowRadius = j.radius),
            (W.shadowMapSize = j.mapSize),
            (W.shadowCameraNear = j.camera.near),
            (W.shadowCameraFar = j.camera.far),
            (r.pointShadow[_] = W),
            (r.pointShadowMap[_] = Y),
            (r.pointShadowMatrix[_] = N.shadow.matrix),
            b++;
        }
        (r.point[_] = U), _++;
      } else if (N.isHemisphereLight) {
        const U = e.get(N);
        U.skyColor.copy(N.color).multiplyScalar(V * R),
          U.groundColor.copy(N.groundColor).multiplyScalar(V * R),
          (r.hemi[x] = U),
          x++;
      }
    }
    g > 0 &&
      (t.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = et.LTC_FLOAT_1), (r.rectAreaLTC2 = et.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = et.LTC_HALF_1), (r.rectAreaLTC2 = et.LTC_HALF_2))),
      (r.ambient[0] = d),
      (r.ambient[1] = p),
      (r.ambient[2] = m);
    const E = r.hash;
    (E.directionalLength !== v ||
      E.pointLength !== _ ||
      E.spotLength !== y ||
      E.rectAreaLength !== g ||
      E.hemiLength !== x ||
      E.numDirectionalShadows !== S ||
      E.numPointShadows !== b ||
      E.numSpotShadows !== C ||
      E.numSpotMaps !== M ||
      E.numLightProbes !== P) &&
      ((r.directional.length = v),
      (r.spot.length = y),
      (r.rectArea.length = g),
      (r.point.length = _),
      (r.hemi.length = x),
      (r.directionalShadow.length = S),
      (r.directionalShadowMap.length = S),
      (r.pointShadow.length = b),
      (r.pointShadowMap.length = b),
      (r.spotShadow.length = C),
      (r.spotShadowMap.length = C),
      (r.directionalShadowMatrix.length = S),
      (r.pointShadowMatrix.length = b),
      (r.spotLightMatrix.length = C + M - T),
      (r.spotLightMap.length = M),
      (r.numSpotLightShadowsWithMaps = T),
      (r.numLightProbes = P),
      (E.directionalLength = v),
      (E.pointLength = _),
      (E.spotLength = y),
      (E.rectAreaLength = g),
      (E.hemiLength = x),
      (E.numDirectionalShadows = S),
      (E.numPointShadows = b),
      (E.numSpotShadows = C),
      (E.numSpotMaps = M),
      (E.numLightProbes = P),
      (r.version = qG++));
  }
  function l(c, u) {
    let d = 0,
      p = 0,
      m = 0,
      v = 0,
      _ = 0;
    const y = u.matrixWorldInverse;
    for (let g = 0, x = c.length; g < x; g++) {
      const S = c[g];
      if (S.isDirectionalLight) {
        const b = r.directional[d];
        b.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          b.direction.sub(i),
          b.direction.transformDirection(y),
          d++;
      } else if (S.isSpotLight) {
        const b = r.spot[m];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(y),
          b.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          b.direction.sub(i),
          b.direction.transformDirection(y),
          m++;
      } else if (S.isRectAreaLight) {
        const b = r.rectArea[v];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(y),
          s.identity(),
          o.copy(S.matrixWorld),
          o.premultiply(y),
          s.extractRotation(o),
          b.halfWidth.set(S.width * 0.5, 0, 0),
          b.halfHeight.set(0, S.height * 0.5, 0),
          b.halfWidth.applyMatrix4(s),
          b.halfHeight.applyMatrix4(s),
          v++;
      } else if (S.isPointLight) {
        const b = r.point[p];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(y),
          p++;
      } else if (S.isHemisphereLight) {
        const b = r.hemi[_];
        b.direction.setFromMatrixPosition(S.matrixWorld),
          b.direction.transformDirection(y),
          _++;
      }
    }
  }
  return { setup: a, setupView: l, state: r };
}
function zT(t) {
  const e = new ZG(t),
    n = [],
    r = [];
  function i(u) {
    (c.camera = u), (n.length = 0), (r.length = 0);
  }
  function o(u) {
    n.push(u);
  }
  function s(u) {
    r.push(u);
  }
  function a(u) {
    e.setup(n, u);
  }
  function l(u) {
    e.setupView(n, u);
  }
  const c = {
    lightsArray: n,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: o,
    pushShadow: s,
  };
}
function JG(t) {
  let e = new WeakMap();
  function n(i, o = 0) {
    const s = e.get(i);
    let a;
    return (
      s === void 0
        ? ((a = new zT(t)), e.set(i, [a]))
        : o >= s.length
        ? ((a = new zT(t)), s.push(a))
        : (a = s[o]),
      a
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: n, dispose: r };
}
class sy extends qr {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = nN),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class ay extends qr {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const QG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  eW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function tW(t, e, n) {
  let r = new Np();
  const i = new ke(),
    o = new ke(),
    s = new tn(),
    a = new sy({ depthPacking: iE }),
    l = new ay(),
    c = {},
    u = n.maxTextureSize,
    d = { [Js]: li, [li]: Js, [mo]: mo },
    p = new jo({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ke() },
        radius: { value: 4 },
      },
      vertexShader: QG,
      fragmentShader: eW,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new Ut();
  v.setAttribute(
    "position",
    new sn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const _ = new Cn(v, p),
    y = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = ey);
  let g = this.type;
  this.render = function (M, T, P) {
    if (
      y.enabled === !1 ||
      (y.autoUpdate === !1 && y.needsUpdate === !1) ||
      M.length === 0
    )
      return;
    const R = t.getRenderTarget(),
      E = t.getActiveCubeFace(),
      O = t.getActiveMipmapLevel(),
      D = t.state;
    D.setBlending(js),
      D.buffers.color.setClear(1, 1, 1, 1),
      D.buffers.depth.setTest(!0),
      D.setScissorTest(!1);
    const N = g !== Lo && this.type === Lo,
      z = g === Lo && this.type !== Lo;
    for (let V = 0, G = M.length; V < G; V++) {
      const Y = M[V],
        U = Y.shadow;
      if (U === void 0) {
        console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
        continue;
      }
      if (U.autoUpdate === !1 && U.needsUpdate === !1) continue;
      i.copy(U.mapSize);
      const j = U.getFrameExtents();
      if (
        (i.multiply(j),
        o.copy(U.mapSize),
        (i.x > u || i.y > u) &&
          (i.x > u &&
            ((o.x = Math.floor(u / j.x)),
            (i.x = o.x * j.x),
            (U.mapSize.x = o.x)),
          i.y > u &&
            ((o.y = Math.floor(u / j.y)),
            (i.y = o.y * j.y),
            (U.mapSize.y = o.y))),
        U.map === null || N === !0 || z === !0)
      ) {
        const B = this.type !== Lo ? { minFilter: xr, magFilter: xr } : {};
        U.map !== null && U.map.dispose(),
          (U.map = new Wo(i.x, i.y, B)),
          (U.map.texture.name = Y.name + ".shadowMap"),
          U.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(U.map), t.clear();
      const W = U.getViewportCount();
      for (let B = 0; B < W; B++) {
        const q = U.getViewport(B);
        s.set(o.x * q.x, o.y * q.y, o.x * q.z, o.y * q.w),
          D.viewport(s),
          U.updateMatrices(Y, B),
          (r = U.getFrustum()),
          b(T, P, U.camera, Y, this.type);
      }
      U.isPointLightShadow !== !0 && this.type === Lo && x(U, P),
        (U.needsUpdate = !1);
    }
    (g = this.type), (y.needsUpdate = !1), t.setRenderTarget(R, E, O);
  };
  function x(M, T) {
    const P = e.update(_);
    p.defines.VSM_SAMPLES !== M.blurSamples &&
      ((p.defines.VSM_SAMPLES = M.blurSamples),
      (m.defines.VSM_SAMPLES = M.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      M.mapPass === null && (M.mapPass = new Wo(i.x, i.y)),
      (p.uniforms.shadow_pass.value = M.map.texture),
      (p.uniforms.resolution.value = M.mapSize),
      (p.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.mapPass),
      t.clear(),
      t.renderBufferDirect(T, null, P, p, _, null),
      (m.uniforms.shadow_pass.value = M.mapPass.texture),
      (m.uniforms.resolution.value = M.mapSize),
      (m.uniforms.radius.value = M.radius),
      t.setRenderTarget(M.map),
      t.clear(),
      t.renderBufferDirect(T, null, P, m, _, null);
  }
  function S(M, T, P, R) {
    let E = null;
    const O =
      P.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
    if (O !== void 0) E = O;
    else if (
      ((E = P.isPointLight === !0 ? l : a),
      (t.localClippingEnabled &&
        T.clipShadows === !0 &&
        Array.isArray(T.clippingPlanes) &&
        T.clippingPlanes.length !== 0) ||
        (T.displacementMap && T.displacementScale !== 0) ||
        (T.alphaMap && T.alphaTest > 0) ||
        (T.map && T.alphaTest > 0))
    ) {
      const D = E.uuid,
        N = T.uuid;
      let z = c[D];
      z === void 0 && ((z = {}), (c[D] = z));
      let V = z[N];
      V === void 0 &&
        ((V = E.clone()), (z[N] = V), T.addEventListener("dispose", C)),
        (E = V);
    }
    if (
      ((E.visible = T.visible),
      (E.wireframe = T.wireframe),
      R === Lo
        ? (E.side = T.shadowSide !== null ? T.shadowSide : T.side)
        : (E.side = T.shadowSide !== null ? T.shadowSide : d[T.side]),
      (E.alphaMap = T.alphaMap),
      (E.alphaTest = T.alphaTest),
      (E.map = T.map),
      (E.clipShadows = T.clipShadows),
      (E.clippingPlanes = T.clippingPlanes),
      (E.clipIntersection = T.clipIntersection),
      (E.displacementMap = T.displacementMap),
      (E.displacementScale = T.displacementScale),
      (E.displacementBias = T.displacementBias),
      (E.wireframeLinewidth = T.wireframeLinewidth),
      (E.linewidth = T.linewidth),
      P.isPointLight === !0 && E.isMeshDistanceMaterial === !0)
    ) {
      const D = t.properties.get(E);
      D.light = P;
    }
    return E;
  }
  function b(M, T, P, R, E) {
    if (M.visible === !1) return;
    if (
      M.layers.test(T.layers) &&
      (M.isMesh || M.isLine || M.isPoints) &&
      (M.castShadow || (M.receiveShadow && E === Lo)) &&
      (!M.frustumCulled || r.intersectsObject(M))
    ) {
      M.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, M.matrixWorld);
      const N = e.update(M),
        z = M.material;
      if (Array.isArray(z)) {
        const V = N.groups;
        for (let G = 0, Y = V.length; G < Y; G++) {
          const U = V[G],
            j = z[U.materialIndex];
          if (j && j.visible) {
            const W = S(M, j, R, E);
            M.onBeforeShadow(t, M, T, P, N, W, U),
              t.renderBufferDirect(P, null, N, W, M, U),
              M.onAfterShadow(t, M, T, P, N, W, U);
          }
        }
      } else if (z.visible) {
        const V = S(M, z, R, E);
        M.onBeforeShadow(t, M, T, P, N, V, null),
          t.renderBufferDirect(P, null, N, V, M, null),
          M.onAfterShadow(t, M, T, P, N, V, null);
      }
    }
    const D = M.children;
    for (let N = 0, z = D.length; N < z; N++) b(D[N], T, P, R, E);
  }
  function C(M) {
    M.target.removeEventListener("dispose", C);
    for (const P in c) {
      const R = c[P],
        E = M.target.uuid;
      E in R && (R[E].dispose(), delete R[E]);
    }
  }
}
function nW(t) {
  function e() {
    let se = !1;
    const Ae = new tn();
    let ye = null;
    const He = new tn(0, 0, 0, 0);
    return {
      setMask: function (qe) {
        ye !== qe && !se && (t.colorMask(qe, qe, qe, qe), (ye = qe));
      },
      setLocked: function (qe) {
        se = qe;
      },
      setClear: function (qe, at, st, ht, pt) {
        pt === !0 && ((qe *= ht), (at *= ht), (st *= ht)),
          Ae.set(qe, at, st, ht),
          He.equals(Ae) === !1 && (t.clearColor(qe, at, st, ht), He.copy(Ae));
      },
      reset: function () {
        (se = !1), (ye = null), He.set(-1, 0, 0, 0);
      },
    };
  }
  function n() {
    let se = !1,
      Ae = null,
      ye = null,
      He = null;
    return {
      setTest: function (qe) {
        qe ? ne(t.DEPTH_TEST) : oe(t.DEPTH_TEST);
      },
      setMask: function (qe) {
        Ae !== qe && !se && (t.depthMask(qe), (Ae = qe));
      },
      setFunc: function (qe) {
        if (ye !== qe) {
          switch (qe) {
            case TO:
              t.depthFunc(t.NEVER);
              break;
            case RO:
              t.depthFunc(t.ALWAYS);
              break;
            case PO:
              t.depthFunc(t.LESS);
              break;
            case kh:
              t.depthFunc(t.LEQUAL);
              break;
            case IO:
              t.depthFunc(t.EQUAL);
              break;
            case LO:
              t.depthFunc(t.GEQUAL);
              break;
            case OO:
              t.depthFunc(t.GREATER);
              break;
            case NO:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          ye = qe;
        }
      },
      setLocked: function (qe) {
        se = qe;
      },
      setClear: function (qe) {
        He !== qe && (t.clearDepth(qe), (He = qe));
      },
      reset: function () {
        (se = !1), (Ae = null), (ye = null), (He = null);
      },
    };
  }
  function r() {
    let se = !1,
      Ae = null,
      ye = null,
      He = null,
      qe = null,
      at = null,
      st = null,
      ht = null,
      pt = null;
    return {
      setTest: function (Ze) {
        se || (Ze ? ne(t.STENCIL_TEST) : oe(t.STENCIL_TEST));
      },
      setMask: function (Ze) {
        Ae !== Ze && !se && (t.stencilMask(Ze), (Ae = Ze));
      },
      setFunc: function (Ze, Mt, Rt) {
        (ye !== Ze || He !== Mt || qe !== Rt) &&
          (t.stencilFunc(Ze, Mt, Rt), (ye = Ze), (He = Mt), (qe = Rt));
      },
      setOp: function (Ze, Mt, Rt) {
        (at !== Ze || st !== Mt || ht !== Rt) &&
          (t.stencilOp(Ze, Mt, Rt), (at = Ze), (st = Mt), (ht = Rt));
      },
      setLocked: function (Ze) {
        se = Ze;
      },
      setClear: function (Ze) {
        pt !== Ze && (t.clearStencil(Ze), (pt = Ze));
      },
      reset: function () {
        (se = !1),
          (Ae = null),
          (ye = null),
          (He = null),
          (qe = null),
          (at = null),
          (st = null),
          (ht = null),
          (pt = null);
      },
    };
  }
  const i = new e(),
    o = new n(),
    s = new r(),
    a = new WeakMap(),
    l = new WeakMap();
  let c = {},
    u = {},
    d = new WeakMap(),
    p = [],
    m = null,
    v = !1,
    _ = null,
    y = null,
    g = null,
    x = null,
    S = null,
    b = null,
    C = null,
    M = new it(0, 0, 0),
    T = 0,
    P = !1,
    R = null,
    E = null,
    O = null,
    D = null,
    N = null;
  const z = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = !1,
    G = 0;
  const Y = t.getParameter(t.VERSION);
  Y.indexOf("WebGL") !== -1
    ? ((G = parseFloat(/^WebGL (\d)/.exec(Y)[1])), (V = G >= 1))
    : Y.indexOf("OpenGL ES") !== -1 &&
      ((G = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1])), (V = G >= 2));
  let U = null,
    j = {};
  const W = t.getParameter(t.SCISSOR_BOX),
    B = t.getParameter(t.VIEWPORT),
    q = new tn().fromArray(W),
    Z = new tn().fromArray(B);
  function H(se, Ae, ye, He) {
    const qe = new Uint8Array(4),
      at = t.createTexture();
    t.bindTexture(se, at),
      t.texParameteri(se, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(se, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let st = 0; st < ye; st++)
      se === t.TEXTURE_3D || se === t.TEXTURE_2D_ARRAY
        ? t.texImage3D(Ae, 0, t.RGBA, 1, 1, He, 0, t.RGBA, t.UNSIGNED_BYTE, qe)
        : t.texImage2D(
            Ae + st,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            qe
          );
    return at;
  }
  const X = {};
  (X[t.TEXTURE_2D] = H(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (X[t.TEXTURE_CUBE_MAP] = H(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (X[t.TEXTURE_2D_ARRAY] = H(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
    (X[t.TEXTURE_3D] = H(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    o.setClear(1),
    s.setClear(0),
    ne(t.DEPTH_TEST),
    o.setFunc(kh),
    Ee(!1),
    he(QS),
    ne(t.CULL_FACE),
    pe(js);
  function ne(se) {
    c[se] !== !0 && (t.enable(se), (c[se] = !0));
  }
  function oe(se) {
    c[se] !== !1 && (t.disable(se), (c[se] = !1));
  }
  function ue(se, Ae) {
    return u[se] !== Ae
      ? (t.bindFramebuffer(se, Ae),
        (u[se] = Ae),
        se === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = Ae),
        se === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = Ae),
        !0)
      : !1;
  }
  function Ie(se, Ae) {
    let ye = p,
      He = !1;
    if (se) {
      (ye = d.get(Ae)), ye === void 0 && ((ye = []), d.set(Ae, ye));
      const qe = se.textures;
      if (ye.length !== qe.length || ye[0] !== t.COLOR_ATTACHMENT0) {
        for (let at = 0, st = qe.length; at < st; at++)
          ye[at] = t.COLOR_ATTACHMENT0 + at;
        (ye.length = qe.length), (He = !0);
      }
    } else ye[0] !== t.BACK && ((ye[0] = t.BACK), (He = !0));
    He && t.drawBuffers(ye);
  }
  function te(se) {
    return m !== se ? (t.useProgram(se), (m = se), !0) : !1;
  }
  const ge = {
    [Fa]: t.FUNC_ADD,
    [fO]: t.FUNC_SUBTRACT,
    [dO]: t.FUNC_REVERSE_SUBTRACT,
  };
  (ge[hO] = t.MIN), (ge[pO] = t.MAX);
  const ie = {
    [mO]: t.ZERO,
    [gO]: t.ONE,
    [vO]: t.SRC_COLOR,
    [hv]: t.SRC_ALPHA,
    [bO]: t.SRC_ALPHA_SATURATE,
    [SO]: t.DST_COLOR,
    [xO]: t.DST_ALPHA,
    [yO]: t.ONE_MINUS_SRC_COLOR,
    [pv]: t.ONE_MINUS_SRC_ALPHA,
    [AO]: t.ONE_MINUS_DST_COLOR,
    [_O]: t.ONE_MINUS_DST_ALPHA,
    [wO]: t.CONSTANT_COLOR,
    [EO]: t.ONE_MINUS_CONSTANT_COLOR,
    [MO]: t.CONSTANT_ALPHA,
    [CO]: t.ONE_MINUS_CONSTANT_ALPHA,
  };
  function pe(se, Ae, ye, He, qe, at, st, ht, pt, Ze) {
    if (se === js) {
      v === !0 && (oe(t.BLEND), (v = !1));
      return;
    }
    if ((v === !1 && (ne(t.BLEND), (v = !0)), se !== uO)) {
      if (se !== _ || Ze !== P) {
        if (
          ((y !== Fa || S !== Fa) &&
            (t.blendEquation(t.FUNC_ADD), (y = Fa), (S = Fa)),
          Ze)
        )
          switch (se) {
            case uc:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case eA:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case tA:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case nA:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", se);
              break;
          }
        else
          switch (se) {
            case uc:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case eA:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case tA:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case nA:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", se);
              break;
          }
        (g = null),
          (x = null),
          (b = null),
          (C = null),
          M.set(0, 0, 0),
          (T = 0),
          (_ = se),
          (P = Ze);
      }
      return;
    }
    (qe = qe || Ae),
      (at = at || ye),
      (st = st || He),
      (Ae !== y || qe !== S) &&
        (t.blendEquationSeparate(ge[Ae], ge[qe]), (y = Ae), (S = qe)),
      (ye !== g || He !== x || at !== b || st !== C) &&
        (t.blendFuncSeparate(ie[ye], ie[He], ie[at], ie[st]),
        (g = ye),
        (x = He),
        (b = at),
        (C = st)),
      (ht.equals(M) === !1 || pt !== T) &&
        (t.blendColor(ht.r, ht.g, ht.b, pt), M.copy(ht), (T = pt)),
      (_ = se),
      (P = !1);
  }
  function de(se, Ae) {
    se.side === mo ? oe(t.CULL_FACE) : ne(t.CULL_FACE);
    let ye = se.side === li;
    Ae && (ye = !ye),
      Ee(ye),
      se.blending === uc && se.transparent === !1
        ? pe(js)
        : pe(
            se.blending,
            se.blendEquation,
            se.blendSrc,
            se.blendDst,
            se.blendEquationAlpha,
            se.blendSrcAlpha,
            se.blendDstAlpha,
            se.blendColor,
            se.blendAlpha,
            se.premultipliedAlpha
          ),
      o.setFunc(se.depthFunc),
      o.setTest(se.depthTest),
      o.setMask(se.depthWrite),
      i.setMask(se.colorWrite);
    const He = se.stencilWrite;
    s.setTest(He),
      He &&
        (s.setMask(se.stencilWriteMask),
        s.setFunc(se.stencilFunc, se.stencilRef, se.stencilFuncMask),
        s.setOp(se.stencilFail, se.stencilZFail, se.stencilZPass)),
      _e(se.polygonOffset, se.polygonOffsetFactor, se.polygonOffsetUnits),
      se.alphaToCoverage === !0
        ? ne(t.SAMPLE_ALPHA_TO_COVERAGE)
        : oe(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ee(se) {
    R !== se && (se ? t.frontFace(t.CW) : t.frontFace(t.CCW), (R = se));
  }
  function he(se) {
    se !== aO
      ? (ne(t.CULL_FACE),
        se !== E &&
          (se === QS
            ? t.cullFace(t.BACK)
            : se === lO
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : oe(t.CULL_FACE),
      (E = se);
  }
  function Ce(se) {
    se !== O && (V && t.lineWidth(se), (O = se));
  }
  function _e(se, Ae, ye) {
    se
      ? (ne(t.POLYGON_OFFSET_FILL),
        (D !== Ae || N !== ye) && (t.polygonOffset(Ae, ye), (D = Ae), (N = ye)))
      : oe(t.POLYGON_OFFSET_FILL);
  }
  function $(se) {
    se ? ne(t.SCISSOR_TEST) : oe(t.SCISSOR_TEST);
  }
  function k(se) {
    se === void 0 && (se = t.TEXTURE0 + z - 1),
      U !== se && (t.activeTexture(se), (U = se));
  }
  function J(se, Ae, ye) {
    ye === void 0 && (U === null ? (ye = t.TEXTURE0 + z - 1) : (ye = U));
    let He = j[ye];
    He === void 0 && ((He = { type: void 0, texture: void 0 }), (j[ye] = He)),
      (He.type !== se || He.texture !== Ae) &&
        (U !== ye && (t.activeTexture(ye), (U = ye)),
        t.bindTexture(se, Ae || X[se]),
        (He.type = se),
        (He.texture = Ae));
  }
  function fe() {
    const se = j[U];
    se !== void 0 &&
      se.type !== void 0 &&
      (t.bindTexture(se.type, null), (se.type = void 0), (se.texture = void 0));
  }
  function le() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function ce() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function we() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Be() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Me() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Ge() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Le() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function je() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Je() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function Ye() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (se) {
      console.error("THREE.WebGLState:", se);
    }
  }
  function De(se) {
    q.equals(se) === !1 && (t.scissor(se.x, se.y, se.z, se.w), q.copy(se));
  }
  function ze(se) {
    Z.equals(se) === !1 && (t.viewport(se.x, se.y, se.z, se.w), Z.copy(se));
  }
  function Ve(se, Ae) {
    let ye = l.get(Ae);
    ye === void 0 && ((ye = new WeakMap()), l.set(Ae, ye));
    let He = ye.get(se);
    He === void 0 &&
      ((He = t.getUniformBlockIndex(Ae, se.name)), ye.set(se, He));
  }
  function ae(se, Ae) {
    const He = l.get(Ae).get(se);
    a.get(Ae) !== He &&
      (t.uniformBlockBinding(Ae, He, se.__bindingPointIndex), a.set(Ae, He));
  }
  function be() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
      t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (c = {}),
      (U = null),
      (j = {}),
      (u = {}),
      (d = new WeakMap()),
      (p = []),
      (m = null),
      (v = !1),
      (_ = null),
      (y = null),
      (g = null),
      (x = null),
      (S = null),
      (b = null),
      (C = null),
      (M = new it(0, 0, 0)),
      (T = 0),
      (P = !1),
      (R = null),
      (E = null),
      (O = null),
      (D = null),
      (N = null),
      q.set(0, 0, t.canvas.width, t.canvas.height),
      Z.set(0, 0, t.canvas.width, t.canvas.height),
      i.reset(),
      o.reset(),
      s.reset();
  }
  return {
    buffers: { color: i, depth: o, stencil: s },
    enable: ne,
    disable: oe,
    bindFramebuffer: ue,
    drawBuffers: Ie,
    useProgram: te,
    setBlending: pe,
    setMaterial: de,
    setFlipSided: Ee,
    setCullFace: he,
    setLineWidth: Ce,
    setPolygonOffset: _e,
    setScissorTest: $,
    activeTexture: k,
    bindTexture: J,
    unbindTexture: fe,
    compressedTexImage2D: le,
    compressedTexImage3D: ce,
    texImage2D: Je,
    texImage3D: Ye,
    updateUBOMapping: Ve,
    uniformBlockBinding: ae,
    texStorage2D: Le,
    texStorage3D: je,
    texSubImage2D: we,
    texSubImage3D: Be,
    compressedTexSubImage2D: Me,
    compressedTexSubImage3D: Ge,
    scissor: De,
    viewport: ze,
    reset: be,
  };
}
function rW(t, e, n, r, i, o, s) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new ke(),
    u = new WeakMap();
  let d;
  const p = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function v($, k) {
    return m ? new OffscreenCanvas($, k) : Zh("canvas");
  }
  function _($, k, J) {
    let fe = 1;
    const le = _e($);
    if (
      ((le.width > J || le.height > J) &&
        (fe = J / Math.max(le.width, le.height)),
      fe < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && $ instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && $ instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && $ instanceof VideoFrame)
      ) {
        const ce = Math.floor(fe * le.width),
          we = Math.floor(fe * le.height);
        d === void 0 && (d = v(ce, we));
        const Be = k ? v(ce, we) : d;
        return (
          (Be.width = ce),
          (Be.height = we),
          Be.getContext("2d").drawImage($, 0, 0, ce, we),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              le.width +
              "x" +
              le.height +
              ") to (" +
              ce +
              "x" +
              we +
              ")."
          ),
          Be
        );
      } else
        return (
          "data" in $ &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                le.width +
                "x" +
                le.height +
                ")."
            ),
          $
        );
    return $;
  }
  function y($) {
    return $.generateMipmaps && $.minFilter !== xr && $.minFilter !== kn;
  }
  function g($) {
    t.generateMipmap($);
  }
  function x($, k, J, fe, le = !1) {
    if ($ !== null) {
      if (t[$] !== void 0) return t[$];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          $ +
          "'"
      );
    }
    let ce = k;
    if (
      (k === t.RED &&
        (J === t.FLOAT && (ce = t.R32F),
        J === t.HALF_FLOAT && (ce = t.R16F),
        J === t.UNSIGNED_BYTE && (ce = t.R8)),
      k === t.RED_INTEGER &&
        (J === t.UNSIGNED_BYTE && (ce = t.R8UI),
        J === t.UNSIGNED_SHORT && (ce = t.R16UI),
        J === t.UNSIGNED_INT && (ce = t.R32UI),
        J === t.BYTE && (ce = t.R8I),
        J === t.SHORT && (ce = t.R16I),
        J === t.INT && (ce = t.R32I)),
      k === t.RG &&
        (J === t.FLOAT && (ce = t.RG32F),
        J === t.HALF_FLOAT && (ce = t.RG16F),
        J === t.UNSIGNED_BYTE && (ce = t.RG8)),
      k === t.RG_INTEGER &&
        (J === t.UNSIGNED_BYTE && (ce = t.RG8UI),
        J === t.UNSIGNED_SHORT && (ce = t.RG16UI),
        J === t.UNSIGNED_INT && (ce = t.RG32UI),
        J === t.BYTE && (ce = t.RG8I),
        J === t.SHORT && (ce = t.RG16I),
        J === t.INT && (ce = t.RG32I)),
      k === t.RGB && J === t.UNSIGNED_INT_5_9_9_9_REV && (ce = t.RGB9_E5),
      k === t.RGBA)
    ) {
      const we = le ? $h : rn.getTransfer(fe);
      J === t.FLOAT && (ce = t.RGBA32F),
        J === t.HALF_FLOAT && (ce = t.RGBA16F),
        J === t.UNSIGNED_BYTE && (ce = we === hn ? t.SRGB8_ALPHA8 : t.RGBA8),
        J === t.UNSIGNED_SHORT_4_4_4_4 && (ce = t.RGBA4),
        J === t.UNSIGNED_SHORT_5_5_5_1 && (ce = t.RGB5_A1);
    }
    return (
      (ce === t.R16F ||
        ce === t.R32F ||
        ce === t.RG16F ||
        ce === t.RG32F ||
        ce === t.RGBA16F ||
        ce === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      ce
    );
  }
  function S($, k) {
    return y($) === !0 ||
      ($.isFramebufferTexture && $.minFilter !== xr && $.minFilter !== kn)
      ? Math.log2(Math.max(k.width, k.height)) + 1
      : $.mipmaps !== void 0 && $.mipmaps.length > 0
      ? $.mipmaps.length
      : $.isCompressedTexture && Array.isArray($.image)
      ? k.mipmaps.length
      : 1;
  }
  function b($) {
    const k = $.target;
    k.removeEventListener("dispose", b), M(k), k.isVideoTexture && u.delete(k);
  }
  function C($) {
    const k = $.target;
    k.removeEventListener("dispose", C), P(k);
  }
  function M($) {
    const k = r.get($);
    if (k.__webglInit === void 0) return;
    const J = $.source,
      fe = p.get(J);
    if (fe) {
      const le = fe[k.__cacheKey];
      le.usedTimes--,
        le.usedTimes === 0 && T($),
        Object.keys(fe).length === 0 && p.delete(J);
    }
    r.remove($);
  }
  function T($) {
    const k = r.get($);
    t.deleteTexture(k.__webglTexture);
    const J = $.source,
      fe = p.get(J);
    delete fe[k.__cacheKey], s.memory.textures--;
  }
  function P($) {
    const k = r.get($);
    if (($.depthTexture && $.depthTexture.dispose(), $.isWebGLCubeRenderTarget))
      for (let fe = 0; fe < 6; fe++) {
        if (Array.isArray(k.__webglFramebuffer[fe]))
          for (let le = 0; le < k.__webglFramebuffer[fe].length; le++)
            t.deleteFramebuffer(k.__webglFramebuffer[fe][le]);
        else t.deleteFramebuffer(k.__webglFramebuffer[fe]);
        k.__webglDepthbuffer && t.deleteRenderbuffer(k.__webglDepthbuffer[fe]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let fe = 0; fe < k.__webglFramebuffer.length; fe++)
          t.deleteFramebuffer(k.__webglFramebuffer[fe]);
      else t.deleteFramebuffer(k.__webglFramebuffer);
      if (
        (k.__webglDepthbuffer && t.deleteRenderbuffer(k.__webglDepthbuffer),
        k.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(k.__webglMultisampledFramebuffer),
        k.__webglColorRenderbuffer)
      )
        for (let fe = 0; fe < k.__webglColorRenderbuffer.length; fe++)
          k.__webglColorRenderbuffer[fe] &&
            t.deleteRenderbuffer(k.__webglColorRenderbuffer[fe]);
      k.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const J = $.textures;
    for (let fe = 0, le = J.length; fe < le; fe++) {
      const ce = r.get(J[fe]);
      ce.__webglTexture &&
        (t.deleteTexture(ce.__webglTexture), s.memory.textures--),
        r.remove(J[fe]);
    }
    r.remove($);
  }
  let R = 0;
  function E() {
    R = 0;
  }
  function O() {
    const $ = R;
    return (
      $ >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            $ +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (R += 1),
      $
    );
  }
  function D($) {
    const k = [];
    return (
      k.push($.wrapS),
      k.push($.wrapT),
      k.push($.wrapR || 0),
      k.push($.magFilter),
      k.push($.minFilter),
      k.push($.anisotropy),
      k.push($.internalFormat),
      k.push($.format),
      k.push($.type),
      k.push($.generateMipmaps),
      k.push($.premultiplyAlpha),
      k.push($.flipY),
      k.push($.unpackAlignment),
      k.push($.colorSpace),
      k.join()
    );
  }
  function N($, k) {
    const J = r.get($);
    if (
      ($.isVideoTexture && he($),
      $.isRenderTargetTexture === !1 &&
        $.version > 0 &&
        J.__version !== $.version)
    ) {
      const fe = $.image;
      if (fe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (fe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        q(J, $, k);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, J.__webglTexture, t.TEXTURE0 + k);
  }
  function z($, k) {
    const J = r.get($);
    if ($.version > 0 && J.__version !== $.version) {
      q(J, $, k);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, J.__webglTexture, t.TEXTURE0 + k);
  }
  function V($, k) {
    const J = r.get($);
    if ($.version > 0 && J.__version !== $.version) {
      q(J, $, k);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, J.__webglTexture, t.TEXTURE0 + k);
  }
  function G($, k) {
    const J = r.get($);
    if ($.version > 0 && J.__version !== $.version) {
      Z(J, $, k);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, J.__webglTexture, t.TEXTURE0 + k);
  }
  const Y = { [Hh]: t.REPEAT, [vo]: t.CLAMP_TO_EDGE, [Vh]: t.MIRRORED_REPEAT },
    U = {
      [xr]: t.NEAREST,
      [Yw]: t.NEAREST_MIPMAP_NEAREST,
      [$u]: t.NEAREST_MIPMAP_LINEAR,
      [kn]: t.LINEAR,
      [fh]: t.LINEAR_MIPMAP_NEAREST,
      [ls]: t.LINEAR_MIPMAP_LINEAR,
    },
    j = {
      [iN]: t.NEVER,
      [uN]: t.ALWAYS,
      [oN]: t.LESS,
      [oE]: t.LEQUAL,
      [sN]: t.EQUAL,
      [cN]: t.GEQUAL,
      [aN]: t.GREATER,
      [lN]: t.NOTEQUAL,
    };
  function W($, k) {
    if (
      (k.type === yo &&
        e.has("OES_texture_float_linear") === !1 &&
        (k.magFilter === kn ||
          k.magFilter === fh ||
          k.magFilter === $u ||
          k.magFilter === ls ||
          k.minFilter === kn ||
          k.minFilter === fh ||
          k.minFilter === $u ||
          k.minFilter === ls) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      t.texParameteri($, t.TEXTURE_WRAP_S, Y[k.wrapS]),
      t.texParameteri($, t.TEXTURE_WRAP_T, Y[k.wrapT]),
      ($ === t.TEXTURE_3D || $ === t.TEXTURE_2D_ARRAY) &&
        t.texParameteri($, t.TEXTURE_WRAP_R, Y[k.wrapR]),
      t.texParameteri($, t.TEXTURE_MAG_FILTER, U[k.magFilter]),
      t.texParameteri($, t.TEXTURE_MIN_FILTER, U[k.minFilter]),
      k.compareFunction &&
        (t.texParameteri($, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri($, t.TEXTURE_COMPARE_FUNC, j[k.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        k.magFilter === xr ||
        (k.minFilter !== $u && k.minFilter !== ls) ||
        (k.type === yo && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (k.anisotropy > 1 || r.get(k).__currentAnisotropy) {
        const J = e.get("EXT_texture_filter_anisotropic");
        t.texParameterf(
          $,
          J.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(k.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(k).__currentAnisotropy = k.anisotropy);
      }
    }
  }
  function B($, k) {
    let J = !1;
    $.__webglInit === void 0 &&
      (($.__webglInit = !0), k.addEventListener("dispose", b));
    const fe = k.source;
    let le = p.get(fe);
    le === void 0 && ((le = {}), p.set(fe, le));
    const ce = D(k);
    if (ce !== $.__cacheKey) {
      le[ce] === void 0 &&
        ((le[ce] = { texture: t.createTexture(), usedTimes: 0 }),
        s.memory.textures++,
        (J = !0)),
        le[ce].usedTimes++;
      const we = le[$.__cacheKey];
      we !== void 0 &&
        (le[$.__cacheKey].usedTimes--, we.usedTimes === 0 && T(k)),
        ($.__cacheKey = ce),
        ($.__webglTexture = le[ce].texture);
    }
    return J;
  }
  function q($, k, J) {
    let fe = t.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) &&
      (fe = t.TEXTURE_2D_ARRAY),
      k.isData3DTexture && (fe = t.TEXTURE_3D);
    const le = B($, k),
      ce = k.source;
    n.bindTexture(fe, $.__webglTexture, t.TEXTURE0 + J);
    const we = r.get(ce);
    if (ce.version !== we.__version || le === !0) {
      n.activeTexture(t.TEXTURE0 + J);
      const Be = rn.getPrimaries(rn.workingColorSpace),
        Me = k.colorSpace === zs ? null : rn.getPrimaries(k.colorSpace),
        Ge =
          k.colorSpace === zs || Be === Me ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, k.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, k.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ge);
      let Le = _(k.image, !1, i.maxTextureSize);
      Le = Ce(k, Le);
      const je = o.convert(k.format, k.colorSpace),
        Je = o.convert(k.type);
      let Ye = x(k.internalFormat, je, Je, k.colorSpace, k.isVideoTexture);
      W(fe, k);
      let De;
      const ze = k.mipmaps,
        Ve = k.isVideoTexture !== !0,
        ae = we.__version === void 0 || le === !0,
        be = ce.dataReady,
        se = S(k, Le);
      if (k.isDepthTexture)
        (Ye = t.DEPTH_COMPONENT16),
          k.type === yo
            ? (Ye = t.DEPTH_COMPONENT32F)
            : k.type === wc
            ? (Ye = t.DEPTH_COMPONENT24)
            : k.type === Df && (Ye = t.DEPTH24_STENCIL8),
          ae &&
            (Ve
              ? n.texStorage2D(t.TEXTURE_2D, 1, Ye, Le.width, Le.height)
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  Ye,
                  Le.width,
                  Le.height,
                  0,
                  je,
                  Je,
                  null
                ));
      else if (k.isDataTexture)
        if (ze.length > 0) {
          Ve &&
            ae &&
            n.texStorage2D(t.TEXTURE_2D, se, Ye, ze[0].width, ze[0].height);
          for (let Ae = 0, ye = ze.length; Ae < ye; Ae++)
            (De = ze[Ae]),
              Ve
                ? be &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    Ae,
                    0,
                    0,
                    De.width,
                    De.height,
                    je,
                    Je,
                    De.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    Ae,
                    Ye,
                    De.width,
                    De.height,
                    0,
                    je,
                    Je,
                    De.data
                  );
          k.generateMipmaps = !1;
        } else
          Ve
            ? (ae && n.texStorage2D(t.TEXTURE_2D, se, Ye, Le.width, Le.height),
              be &&
                n.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Le.width,
                  Le.height,
                  je,
                  Je,
                  Le.data
                ))
            : n.texImage2D(
                t.TEXTURE_2D,
                0,
                Ye,
                Le.width,
                Le.height,
                0,
                je,
                Je,
                Le.data
              );
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          Ve &&
            ae &&
            n.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              se,
              Ye,
              ze[0].width,
              ze[0].height,
              Le.depth
            );
          for (let Ae = 0, ye = ze.length; Ae < ye; Ae++)
            (De = ze[Ae]),
              k.format !== Si
                ? je !== null
                  ? Ve
                    ? be &&
                      n.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        Ae,
                        0,
                        0,
                        0,
                        De.width,
                        De.height,
                        Le.depth,
                        je,
                        De.data,
                        0,
                        0
                      )
                    : n.compressedTexImage3D(
                        t.TEXTURE_2D_ARRAY,
                        Ae,
                        Ye,
                        De.width,
                        De.height,
                        Le.depth,
                        0,
                        De.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ve
                ? be &&
                  n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    Ae,
                    0,
                    0,
                    0,
                    De.width,
                    De.height,
                    Le.depth,
                    je,
                    Je,
                    De.data
                  )
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    Ae,
                    Ye,
                    De.width,
                    De.height,
                    Le.depth,
                    0,
                    je,
                    Je,
                    De.data
                  );
        } else {
          Ve &&
            ae &&
            n.texStorage2D(t.TEXTURE_2D, se, Ye, ze[0].width, ze[0].height);
          for (let Ae = 0, ye = ze.length; Ae < ye; Ae++)
            (De = ze[Ae]),
              k.format !== Si
                ? je !== null
                  ? Ve
                    ? be &&
                      n.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        Ae,
                        0,
                        0,
                        De.width,
                        De.height,
                        je,
                        De.data
                      )
                    : n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        Ae,
                        Ye,
                        De.width,
                        De.height,
                        0,
                        De.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ve
                ? be &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    Ae,
                    0,
                    0,
                    De.width,
                    De.height,
                    je,
                    Je,
                    De.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    Ae,
                    Ye,
                    De.width,
                    De.height,
                    0,
                    je,
                    Je,
                    De.data
                  );
        }
      else if (k.isDataArrayTexture)
        Ve
          ? (ae &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                se,
                Ye,
                Le.width,
                Le.height,
                Le.depth
              ),
            be &&
              n.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Le.width,
                Le.height,
                Le.depth,
                je,
                Je,
                Le.data
              ))
          : n.texImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              Ye,
              Le.width,
              Le.height,
              Le.depth,
              0,
              je,
              Je,
              Le.data
            );
      else if (k.isData3DTexture)
        Ve
          ? (ae &&
              n.texStorage3D(
                t.TEXTURE_3D,
                se,
                Ye,
                Le.width,
                Le.height,
                Le.depth
              ),
            be &&
              n.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Le.width,
                Le.height,
                Le.depth,
                je,
                Je,
                Le.data
              ))
          : n.texImage3D(
              t.TEXTURE_3D,
              0,
              Ye,
              Le.width,
              Le.height,
              Le.depth,
              0,
              je,
              Je,
              Le.data
            );
      else if (k.isFramebufferTexture) {
        if (ae)
          if (Ve) n.texStorage2D(t.TEXTURE_2D, se, Ye, Le.width, Le.height);
          else {
            let Ae = Le.width,
              ye = Le.height;
            for (let He = 0; He < se; He++)
              n.texImage2D(t.TEXTURE_2D, He, Ye, Ae, ye, 0, je, Je, null),
                (Ae >>= 1),
                (ye >>= 1);
          }
      } else if (ze.length > 0) {
        if (Ve && ae) {
          const Ae = _e(ze[0]);
          n.texStorage2D(t.TEXTURE_2D, se, Ye, Ae.width, Ae.height);
        }
        for (let Ae = 0, ye = ze.length; Ae < ye; Ae++)
          (De = ze[Ae]),
            Ve
              ? be && n.texSubImage2D(t.TEXTURE_2D, Ae, 0, 0, je, Je, De)
              : n.texImage2D(t.TEXTURE_2D, Ae, Ye, je, Je, De);
        k.generateMipmaps = !1;
      } else if (Ve) {
        if (ae) {
          const Ae = _e(Le);
          n.texStorage2D(t.TEXTURE_2D, se, Ye, Ae.width, Ae.height);
        }
        be && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, je, Je, Le);
      } else n.texImage2D(t.TEXTURE_2D, 0, Ye, je, Je, Le);
      y(k) && g(fe), (we.__version = ce.version), k.onUpdate && k.onUpdate(k);
    }
    $.__version = k.version;
  }
  function Z($, k, J) {
    if (k.image.length !== 6) return;
    const fe = B($, k),
      le = k.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, $.__webglTexture, t.TEXTURE0 + J);
    const ce = r.get(le);
    if (le.version !== ce.__version || fe === !0) {
      n.activeTexture(t.TEXTURE0 + J);
      const we = rn.getPrimaries(rn.workingColorSpace),
        Be = k.colorSpace === zs ? null : rn.getPrimaries(k.colorSpace),
        Me =
          k.colorSpace === zs || we === Be ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, k.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, k.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Me);
      const Ge = k.isCompressedTexture || k.image[0].isCompressedTexture,
        Le = k.image[0] && k.image[0].isDataTexture,
        je = [];
      for (let ye = 0; ye < 6; ye++)
        !Ge && !Le
          ? (je[ye] = _(k.image[ye], !0, i.maxCubemapSize))
          : (je[ye] = Le ? k.image[ye].image : k.image[ye]),
          (je[ye] = Ce(k, je[ye]));
      const Je = je[0],
        Ye = o.convert(k.format, k.colorSpace),
        De = o.convert(k.type),
        ze = x(k.internalFormat, Ye, De, k.colorSpace),
        Ve = k.isVideoTexture !== !0,
        ae = ce.__version === void 0 || fe === !0,
        be = le.dataReady;
      let se = S(k, Je);
      W(t.TEXTURE_CUBE_MAP, k);
      let Ae;
      if (Ge) {
        Ve &&
          ae &&
          n.texStorage2D(t.TEXTURE_CUBE_MAP, se, ze, Je.width, Je.height);
        for (let ye = 0; ye < 6; ye++) {
          Ae = je[ye].mipmaps;
          for (let He = 0; He < Ae.length; He++) {
            const qe = Ae[He];
            k.format !== Si
              ? Ye !== null
                ? Ve
                  ? be &&
                    n.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      He,
                      0,
                      0,
                      qe.width,
                      qe.height,
                      Ye,
                      qe.data
                    )
                  : n.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      He,
                      ze,
                      qe.width,
                      qe.height,
                      0,
                      qe.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Ve
              ? be &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  He,
                  0,
                  0,
                  qe.width,
                  qe.height,
                  Ye,
                  De,
                  qe.data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  He,
                  ze,
                  qe.width,
                  qe.height,
                  0,
                  Ye,
                  De,
                  qe.data
                );
          }
        }
      } else {
        if (((Ae = k.mipmaps), Ve && ae)) {
          Ae.length > 0 && se++;
          const ye = _e(je[0]);
          n.texStorage2D(t.TEXTURE_CUBE_MAP, se, ze, ye.width, ye.height);
        }
        for (let ye = 0; ye < 6; ye++)
          if (Le) {
            Ve
              ? be &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  je[ye].width,
                  je[ye].height,
                  Ye,
                  De,
                  je[ye].data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  ze,
                  je[ye].width,
                  je[ye].height,
                  0,
                  Ye,
                  De,
                  je[ye].data
                );
            for (let He = 0; He < Ae.length; He++) {
              const at = Ae[He].image[ye].image;
              Ve
                ? be &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    He + 1,
                    0,
                    0,
                    at.width,
                    at.height,
                    Ye,
                    De,
                    at.data
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    He + 1,
                    ze,
                    at.width,
                    at.height,
                    0,
                    Ye,
                    De,
                    at.data
                  );
            }
          } else {
            Ve
              ? be &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  Ye,
                  De,
                  je[ye]
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  ze,
                  Ye,
                  De,
                  je[ye]
                );
            for (let He = 0; He < Ae.length; He++) {
              const qe = Ae[He];
              Ve
                ? be &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    He + 1,
                    0,
                    0,
                    Ye,
                    De,
                    qe.image[ye]
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    He + 1,
                    ze,
                    Ye,
                    De,
                    qe.image[ye]
                  );
            }
          }
      }
      y(k) && g(t.TEXTURE_CUBE_MAP),
        (ce.__version = le.version),
        k.onUpdate && k.onUpdate(k);
    }
    $.__version = k.version;
  }
  function H($, k, J, fe, le, ce) {
    const we = o.convert(J.format, J.colorSpace),
      Be = o.convert(J.type),
      Me = x(J.internalFormat, we, Be, J.colorSpace);
    if (!r.get(k).__hasExternalTextures) {
      const Le = Math.max(1, k.width >> ce),
        je = Math.max(1, k.height >> ce);
      le === t.TEXTURE_3D || le === t.TEXTURE_2D_ARRAY
        ? n.texImage3D(le, ce, Me, Le, je, k.depth, 0, we, Be, null)
        : n.texImage2D(le, ce, Me, Le, je, 0, we, Be, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, $),
      Ee(k)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            fe,
            le,
            r.get(J).__webglTexture,
            0,
            de(k)
          )
        : (le === t.TEXTURE_2D ||
            (le >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              le <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            fe,
            le,
            r.get(J).__webglTexture,
            ce
          ),
      n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function X($, k, J) {
    if (
      (t.bindRenderbuffer(t.RENDERBUFFER, $), k.depthBuffer && !k.stencilBuffer)
    ) {
      let fe = t.DEPTH_COMPONENT24;
      if (J || Ee(k)) {
        const le = k.depthTexture;
        le &&
          le.isDepthTexture &&
          (le.type === yo
            ? (fe = t.DEPTH_COMPONENT32F)
            : le.type === wc && (fe = t.DEPTH_COMPONENT24));
        const ce = de(k);
        Ee(k)
          ? a.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              ce,
              fe,
              k.width,
              k.height
            )
          : t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              ce,
              fe,
              k.width,
              k.height
            );
      } else t.renderbufferStorage(t.RENDERBUFFER, fe, k.width, k.height);
      t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        $
      );
    } else if (k.depthBuffer && k.stencilBuffer) {
      const fe = de(k);
      J && Ee(k) === !1
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            fe,
            t.DEPTH24_STENCIL8,
            k.width,
            k.height
          )
        : Ee(k)
        ? a.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            fe,
            t.DEPTH24_STENCIL8,
            k.width,
            k.height
          )
        : t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            k.width,
            k.height
          ),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          $
        );
    } else {
      const fe = k.textures;
      for (let le = 0; le < fe.length; le++) {
        const ce = fe[le],
          we = o.convert(ce.format, ce.colorSpace),
          Be = o.convert(ce.type),
          Me = x(ce.internalFormat, we, Be, ce.colorSpace),
          Ge = de(k);
        J && Ee(k) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              Ge,
              Me,
              k.width,
              k.height
            )
          : Ee(k)
          ? a.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              Ge,
              Me,
              k.width,
              k.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, Me, k.width, k.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function ne($, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (n.bindFramebuffer(t.FRAMEBUFFER, $),
      !(k.depthTexture && k.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(k.depthTexture).__webglTexture ||
      k.depthTexture.image.width !== k.width ||
      k.depthTexture.image.height !== k.height) &&
      ((k.depthTexture.image.width = k.width),
      (k.depthTexture.image.height = k.height),
      (k.depthTexture.needsUpdate = !0)),
      N(k.depthTexture, 0);
    const fe = r.get(k.depthTexture).__webglTexture,
      le = de(k);
    if (k.depthTexture.format === fc)
      Ee(k)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            fe,
            0,
            le
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            fe,
            0
          );
    else if (k.depthTexture.format === yf)
      Ee(k)
        ? a.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            fe,
            0,
            le
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            fe,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function oe($) {
    const k = r.get($),
      J = $.isWebGLCubeRenderTarget === !0;
    if ($.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (J)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      ne(k.__webglFramebuffer, $);
    } else if (J) {
      k.__webglDepthbuffer = [];
      for (let fe = 0; fe < 6; fe++)
        n.bindFramebuffer(t.FRAMEBUFFER, k.__webglFramebuffer[fe]),
          (k.__webglDepthbuffer[fe] = t.createRenderbuffer()),
          X(k.__webglDepthbuffer[fe], $, !1);
    } else
      n.bindFramebuffer(t.FRAMEBUFFER, k.__webglFramebuffer),
        (k.__webglDepthbuffer = t.createRenderbuffer()),
        X(k.__webglDepthbuffer, $, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function ue($, k, J) {
    const fe = r.get($);
    k !== void 0 &&
      H(
        fe.__webglFramebuffer,
        $,
        $.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      J !== void 0 && oe($);
  }
  function Ie($) {
    const k = $.texture,
      J = r.get($),
      fe = r.get(k);
    $.addEventListener("dispose", C);
    const le = $.textures,
      ce = $.isWebGLCubeRenderTarget === !0,
      we = le.length > 1;
    if (
      (we ||
        (fe.__webglTexture === void 0 &&
          (fe.__webglTexture = t.createTexture()),
        (fe.__version = k.version),
        s.memory.textures++),
      ce)
    ) {
      J.__webglFramebuffer = [];
      for (let Be = 0; Be < 6; Be++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          J.__webglFramebuffer[Be] = [];
          for (let Me = 0; Me < k.mipmaps.length; Me++)
            J.__webglFramebuffer[Be][Me] = t.createFramebuffer();
        } else J.__webglFramebuffer[Be] = t.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        J.__webglFramebuffer = [];
        for (let Be = 0; Be < k.mipmaps.length; Be++)
          J.__webglFramebuffer[Be] = t.createFramebuffer();
      } else J.__webglFramebuffer = t.createFramebuffer();
      if (we)
        for (let Be = 0, Me = le.length; Be < Me; Be++) {
          const Ge = r.get(le[Be]);
          Ge.__webglTexture === void 0 &&
            ((Ge.__webglTexture = t.createTexture()), s.memory.textures++);
        }
      if ($.samples > 0 && Ee($) === !1) {
        (J.__webglMultisampledFramebuffer = t.createFramebuffer()),
          (J.__webglColorRenderbuffer = []),
          n.bindFramebuffer(t.FRAMEBUFFER, J.__webglMultisampledFramebuffer);
        for (let Be = 0; Be < le.length; Be++) {
          const Me = le[Be];
          (J.__webglColorRenderbuffer[Be] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, J.__webglColorRenderbuffer[Be]);
          const Ge = o.convert(Me.format, Me.colorSpace),
            Le = o.convert(Me.type),
            je = x(
              Me.internalFormat,
              Ge,
              Le,
              Me.colorSpace,
              $.isXRRenderTarget === !0
            ),
            Je = de($);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Je,
            je,
            $.width,
            $.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + Be,
              t.RENDERBUFFER,
              J.__webglColorRenderbuffer[Be]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          $.depthBuffer &&
            ((J.__webglDepthRenderbuffer = t.createRenderbuffer()),
            X(J.__webglDepthRenderbuffer, $, !0)),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (ce) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, fe.__webglTexture),
        W(t.TEXTURE_CUBE_MAP, k);
      for (let Be = 0; Be < 6; Be++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let Me = 0; Me < k.mipmaps.length; Me++)
            H(
              J.__webglFramebuffer[Be][Me],
              $,
              k,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
              Me
            );
        else
          H(
            J.__webglFramebuffer[Be],
            $,
            k,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + Be,
            0
          );
      y(k) && g(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (we) {
      for (let Be = 0, Me = le.length; Be < Me; Be++) {
        const Ge = le[Be],
          Le = r.get(Ge);
        n.bindTexture(t.TEXTURE_2D, Le.__webglTexture),
          W(t.TEXTURE_2D, Ge),
          H(
            J.__webglFramebuffer,
            $,
            Ge,
            t.COLOR_ATTACHMENT0 + Be,
            t.TEXTURE_2D,
            0
          ),
          y(Ge) && g(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Be = t.TEXTURE_2D;
      if (
        (($.isWebGL3DRenderTarget || $.isWebGLArrayRenderTarget) &&
          (Be = $.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
        n.bindTexture(Be, fe.__webglTexture),
        W(Be, k),
        k.mipmaps && k.mipmaps.length > 0)
      )
        for (let Me = 0; Me < k.mipmaps.length; Me++)
          H(J.__webglFramebuffer[Me], $, k, t.COLOR_ATTACHMENT0, Be, Me);
      else H(J.__webglFramebuffer, $, k, t.COLOR_ATTACHMENT0, Be, 0);
      y(k) && g(Be), n.unbindTexture();
    }
    $.depthBuffer && oe($);
  }
  function te($) {
    const k = $.textures;
    for (let J = 0, fe = k.length; J < fe; J++) {
      const le = k[J];
      if (y(le)) {
        const ce = $.isWebGLCubeRenderTarget
            ? t.TEXTURE_CUBE_MAP
            : t.TEXTURE_2D,
          we = r.get(le).__webglTexture;
        n.bindTexture(ce, we), g(ce), n.unbindTexture();
      }
    }
  }
  const ge = [],
    ie = [];
  function pe($) {
    if ($.samples > 0) {
      if (Ee($) === !1) {
        const k = $.textures,
          J = $.width,
          fe = $.height;
        let le = t.COLOR_BUFFER_BIT;
        const ce = $.stencilBuffer
            ? t.DEPTH_STENCIL_ATTACHMENT
            : t.DEPTH_ATTACHMENT,
          we = r.get($),
          Be = k.length > 1;
        if (Be)
          for (let Me = 0; Me < k.length; Me++)
            n.bindFramebuffer(t.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + Me,
                t.RENDERBUFFER,
                null
              ),
              n.bindFramebuffer(t.FRAMEBUFFER, we.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + Me,
                t.TEXTURE_2D,
                null,
                0
              );
        n.bindFramebuffer(
          t.READ_FRAMEBUFFER,
          we.__webglMultisampledFramebuffer
        ),
          n.bindFramebuffer(t.DRAW_FRAMEBUFFER, we.__webglFramebuffer);
        for (let Me = 0; Me < k.length; Me++) {
          if (
            ($.resolveDepthBuffer &&
              ($.depthBuffer && (le |= t.DEPTH_BUFFER_BIT),
              $.stencilBuffer &&
                $.resolveStencilBuffer &&
                (le |= t.STENCIL_BUFFER_BIT)),
            Be)
          ) {
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              we.__webglColorRenderbuffer[Me]
            );
            const Ge = r.get(k[Me]).__webglTexture;
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              Ge,
              0
            );
          }
          t.blitFramebuffer(0, 0, J, fe, 0, 0, J, fe, le, t.NEAREST),
            l === !0 &&
              ((ge.length = 0),
              (ie.length = 0),
              ge.push(t.COLOR_ATTACHMENT0 + Me),
              $.depthBuffer &&
                $.resolveDepthBuffer === !1 &&
                (ge.push(ce),
                ie.push(ce),
                t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, ie)),
              t.invalidateFramebuffer(t.READ_FRAMEBUFFER, ge));
        }
        if (
          (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
          n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
          Be)
        )
          for (let Me = 0; Me < k.length; Me++) {
            n.bindFramebuffer(t.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + Me,
                t.RENDERBUFFER,
                we.__webglColorRenderbuffer[Me]
              );
            const Ge = r.get(k[Me]).__webglTexture;
            n.bindFramebuffer(t.FRAMEBUFFER, we.__webglFramebuffer),
              t.framebufferTexture2D(
                t.DRAW_FRAMEBUFFER,
                t.COLOR_ATTACHMENT0 + Me,
                t.TEXTURE_2D,
                Ge,
                0
              );
          }
        n.bindFramebuffer(
          t.DRAW_FRAMEBUFFER,
          we.__webglMultisampledFramebuffer
        );
      } else if ($.depthBuffer && $.resolveDepthBuffer === !1 && l) {
        const k = $.stencilBuffer
          ? t.DEPTH_STENCIL_ATTACHMENT
          : t.DEPTH_ATTACHMENT;
        t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function de($) {
    return Math.min(i.maxSamples, $.samples);
  }
  function Ee($) {
    const k = r.get($);
    return (
      $.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      k.__useRenderToTexture !== !1
    );
  }
  function he($) {
    const k = s.render.frame;
    u.get($) !== k && (u.set($, k), $.update());
  }
  function Ce($, k) {
    const J = $.colorSpace,
      fe = $.format,
      le = $.type;
    return (
      $.isCompressedTexture === !0 ||
        $.isVideoTexture === !0 ||
        (J !== ia &&
          J !== zs &&
          (rn.getTransfer(J) === hn
            ? (fe !== Si || le !== gs) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                J
              ))),
      k
    );
  }
  function _e($) {
    return (
      typeof HTMLImageElement < "u" && $ instanceof HTMLImageElement
        ? ((c.width = $.naturalWidth || $.width),
          (c.height = $.naturalHeight || $.height))
        : typeof VideoFrame < "u" && $ instanceof VideoFrame
        ? ((c.width = $.displayWidth), (c.height = $.displayHeight))
        : ((c.width = $.width), (c.height = $.height)),
      c
    );
  }
  (this.allocateTextureUnit = O),
    (this.resetTextureUnits = E),
    (this.setTexture2D = N),
    (this.setTexture2DArray = z),
    (this.setTexture3D = V),
    (this.setTextureCube = G),
    (this.rebindTextures = ue),
    (this.setupRenderTarget = Ie),
    (this.updateRenderTargetMipmap = te),
    (this.updateMultisampleRenderTarget = pe),
    (this.setupDepthRenderbuffer = oe),
    (this.setupFrameBufferTexture = H),
    (this.useMultisampledRTT = Ee);
}
function TN(t, e) {
  function n(r, i = zs) {
    let o;
    const s = rn.getTransfer(i);
    if (r === gs) return t.UNSIGNED_BYTE;
    if (r === Zw) return t.UNSIGNED_SHORT_4_4_4_4;
    if (r === Jw) return t.UNSIGNED_SHORT_5_5_5_1;
    if (r === $O) return t.UNSIGNED_INT_5_9_9_9_REV;
    if (r === WO) return t.BYTE;
    if (r === jO) return t.SHORT;
    if (r === qw) return t.UNSIGNED_SHORT;
    if (r === Kw) return t.INT;
    if (r === wc) return t.UNSIGNED_INT;
    if (r === yo) return t.FLOAT;
    if (r === Pp) return t.HALF_FLOAT;
    if (r === XO) return t.ALPHA;
    if (r === YO) return t.RGB;
    if (r === Si) return t.RGBA;
    if (r === qO) return t.LUMINANCE;
    if (r === KO) return t.LUMINANCE_ALPHA;
    if (r === fc) return t.DEPTH_COMPONENT;
    if (r === yf) return t.DEPTH_STENCIL;
    if (r === Qw) return t.RED;
    if (r === eE) return t.RED_INTEGER;
    if (r === ZO) return t.RG;
    if (r === tE) return t.RG_INTEGER;
    if (r === nE) return t.RGBA_INTEGER;
    if (r === b0 || r === w0 || r === E0 || r === M0)
      if (s === hn)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (r === b0) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === w0) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === E0) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === M0) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === b0) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === w0) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === E0) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === M0) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === iA || r === oA || r === sA || r === aA)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === iA) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === oA) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === sA) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === aA) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === lA || r === cA || r === uA)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (r === lA || r === cA)
          return s === hn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (r === uA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === fA ||
      r === dA ||
      r === hA ||
      r === pA ||
      r === mA ||
      r === gA ||
      r === vA ||
      r === yA ||
      r === xA ||
      r === _A ||
      r === SA ||
      r === AA ||
      r === bA ||
      r === wA
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (r === fA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === dA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === hA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === pA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === mA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === gA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === vA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === yA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === xA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === _A)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === SA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === AA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === bA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === wA)
          return s === hn
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === C0 || r === EA || r === MA)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (r === C0)
          return s === hn
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === EA) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === MA) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === JO || r === CA || r === TA || r === RA)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (r === C0) return o.COMPRESSED_RED_RGTC1_EXT;
        if (r === CA) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === TA) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === RA) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === Df ? t.UNSIGNED_INT_24_8 : t[r] !== void 0 ? t[r] : null;
  }
  return { convert: n };
}
class RN extends En {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
let qu = class extends Qt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
};
const iW = { type: "move" };
class t_ {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new qu()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new qu()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new ee()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new ee())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new qu()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new ee()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new ee())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n) for (const r of e.hand.values()) this._getHandJoint(n, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, n, r) {
    let i = null,
      o = null,
      s = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        s = !0;
        for (const _ of e.hand.values()) {
          const y = n.getJointPose(_, r),
            g = this._getHandJoint(c, _);
          y !== null &&
            (g.matrix.fromArray(y.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = y.radius)),
            (g.visible = y !== null);
        }
        const u = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          p = u.position.distanceTo(d.position),
          m = 0.02,
          v = 0.005;
        c.inputState.pinching && p > m + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            p <= m - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((o = n.getPose(e.gripSpace, r)),
          o !== null &&
            (l.matrix.fromArray(o.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            o.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(o.linearVelocity))
              : (l.hasLinearVelocity = !1),
            o.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(o.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = n.getPose(e.targetRaySpace, r)),
        i === null && o !== null && (i = o),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(iW)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = o !== null),
      c !== null && (c.visible = s !== null),
      this
    );
  }
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const r = new qu();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[n.jointName] = r),
        e.add(r);
    }
    return e.joints[n.jointName];
  }
}
const oW = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  sW = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class aW {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, n, r) {
    if (this.texture === null) {
      const i = new lr(),
        o = e.properties.get(i);
      (o.__webglTexture = n.texture),
        (n.depthNear != r.depthNear || n.depthFar != r.depthFar) &&
          ((this.depthNear = n.depthNear), (this.depthFar = n.depthFar)),
        (this.texture = i);
    }
  }
  render(e, n) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const r = n.cameras[0].viewport,
          i = new jo({
            vertexShader: oW,
            fragmentShader: sW,
            uniforms: {
              depthColor: { value: this.texture },
              depthWidth: { value: r.z },
              depthHeight: { value: r.w },
            },
          });
        this.mesh = new Cn(new aa(20, 20), i);
      }
      e.render(this.mesh, n);
    }
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
}
class lW extends oa {
  constructor(e, n) {
    super();
    const r = this;
    let i = null,
      o = 1,
      s = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      d = null,
      p = null,
      m = null,
      v = null;
    const _ = new aW(),
      y = n.getContextAttributes();
    let g = null,
      x = null;
    const S = [],
      b = [],
      C = new ke();
    let M = null;
    const T = new En();
    T.layers.enable(1), (T.viewport = new tn());
    const P = new En();
    P.layers.enable(2), (P.viewport = new tn());
    const R = [T, P],
      E = new RN();
    E.layers.enable(1), E.layers.enable(2);
    let O = null,
      D = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (H) {
        let X = S[H];
        return (
          X === void 0 && ((X = new t_()), (S[H] = X)), X.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (H) {
        let X = S[H];
        return X === void 0 && ((X = new t_()), (S[H] = X)), X.getGripSpace();
      }),
      (this.getHand = function (H) {
        let X = S[H];
        return X === void 0 && ((X = new t_()), (S[H] = X)), X.getHandSpace();
      });
    function N(H) {
      const X = b.indexOf(H.inputSource);
      if (X === -1) return;
      const ne = S[X];
      ne !== void 0 &&
        (ne.update(H.inputSource, H.frame, c || s),
        ne.dispatchEvent({ type: H.type, data: H.inputSource }));
    }
    function z() {
      i.removeEventListener("select", N),
        i.removeEventListener("selectstart", N),
        i.removeEventListener("selectend", N),
        i.removeEventListener("squeeze", N),
        i.removeEventListener("squeezestart", N),
        i.removeEventListener("squeezeend", N),
        i.removeEventListener("end", z),
        i.removeEventListener("inputsourceschange", V);
      for (let H = 0; H < S.length; H++) {
        const X = b[H];
        X !== null && ((b[H] = null), S[H].disconnect(X));
      }
      (O = null),
        (D = null),
        _.reset(),
        e.setRenderTarget(g),
        (m = null),
        (p = null),
        (d = null),
        (i = null),
        (x = null),
        Z.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(M),
        e.setSize(C.width, C.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (H) {
      (o = H),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (H) {
        (a = H),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || s;
      }),
      (this.setReferenceSpace = function (H) {
        c = H;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (H) {
        if (((i = H), i !== null)) {
          if (
            ((g = e.getRenderTarget()),
            i.addEventListener("select", N),
            i.addEventListener("selectstart", N),
            i.addEventListener("selectend", N),
            i.addEventListener("squeeze", N),
            i.addEventListener("squeezestart", N),
            i.addEventListener("squeezeend", N),
            i.addEventListener("end", z),
            i.addEventListener("inputsourceschange", V),
            y.xrCompatible !== !0 && (await n.makeXRCompatible()),
            (M = e.getPixelRatio()),
            e.getSize(C),
            i.renderState.layers === void 0)
          ) {
            const X = {
              antialias: y.antialias,
              alpha: !0,
              depth: y.depth,
              stencil: y.stencil,
              framebufferScaleFactor: o,
            };
            (m = new XRWebGLLayer(i, n, X)),
              i.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (x = new Wo(m.framebufferWidth, m.framebufferHeight, {
                format: Si,
                type: gs,
                colorSpace: e.outputColorSpace,
                stencilBuffer: y.stencil,
              }));
          } else {
            let X = null,
              ne = null,
              oe = null;
            y.depth &&
              ((oe = y.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (X = y.stencil ? yf : fc),
              (ne = y.stencil ? Df : wc));
            const ue = {
              colorFormat: n.RGBA8,
              depthFormat: oe,
              scaleFactor: o,
            };
            (d = new XRWebGLBinding(i, n)),
              (p = d.createProjectionLayer(ue)),
              i.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (x = new Wo(p.textureWidth, p.textureHeight, {
                format: Si,
                type: gs,
                depthTexture: new dE(
                  p.textureWidth,
                  p.textureHeight,
                  ne,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  X
                ),
                stencilBuffer: y.stencil,
                colorSpace: e.outputColorSpace,
                samples: y.antialias ? 4 : 0,
                resolveDepthBuffer: p.ignoreDepthValues === !1,
              }));
          }
          (x.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (s = await i.requestReferenceSpace(a)),
            Z.setContext(i),
            Z.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function V(H) {
      for (let X = 0; X < H.removed.length; X++) {
        const ne = H.removed[X],
          oe = b.indexOf(ne);
        oe >= 0 && ((b[oe] = null), S[oe].disconnect(ne));
      }
      for (let X = 0; X < H.added.length; X++) {
        const ne = H.added[X];
        let oe = b.indexOf(ne);
        if (oe === -1) {
          for (let Ie = 0; Ie < S.length; Ie++)
            if (Ie >= b.length) {
              b.push(ne), (oe = Ie);
              break;
            } else if (b[Ie] === null) {
              (b[Ie] = ne), (oe = Ie);
              break;
            }
          if (oe === -1) break;
        }
        const ue = S[oe];
        ue && ue.connect(ne);
      }
    }
    const G = new ee(),
      Y = new ee();
    function U(H, X, ne) {
      G.setFromMatrixPosition(X.matrixWorld),
        Y.setFromMatrixPosition(ne.matrixWorld);
      const oe = G.distanceTo(Y),
        ue = X.projectionMatrix.elements,
        Ie = ne.projectionMatrix.elements,
        te = ue[14] / (ue[10] - 1),
        ge = ue[14] / (ue[10] + 1),
        ie = (ue[9] + 1) / ue[5],
        pe = (ue[9] - 1) / ue[5],
        de = (ue[8] - 1) / ue[0],
        Ee = (Ie[8] + 1) / Ie[0],
        he = te * de,
        Ce = te * Ee,
        _e = oe / (-de + Ee),
        $ = _e * -de;
      X.matrixWorld.decompose(H.position, H.quaternion, H.scale),
        H.translateX($),
        H.translateZ(_e),
        H.matrixWorld.compose(H.position, H.quaternion, H.scale),
        H.matrixWorldInverse.copy(H.matrixWorld).invert();
      const k = te + _e,
        J = ge + _e,
        fe = he - $,
        le = Ce + (oe - $),
        ce = ((ie * ge) / J) * k,
        we = ((pe * ge) / J) * k;
      H.projectionMatrix.makePerspective(fe, le, ce, we, k, J),
        H.projectionMatrixInverse.copy(H.projectionMatrix).invert();
    }
    function j(H, X) {
      X === null
        ? H.matrixWorld.copy(H.matrix)
        : H.matrixWorld.multiplyMatrices(X.matrixWorld, H.matrix),
        H.matrixWorldInverse.copy(H.matrixWorld).invert();
    }
    this.updateCamera = function (H) {
      if (i === null) return;
      _.texture !== null && ((H.near = _.depthNear), (H.far = _.depthFar)),
        (E.near = P.near = T.near = H.near),
        (E.far = P.far = T.far = H.far),
        (O !== E.near || D !== E.far) &&
          (i.updateRenderState({ depthNear: E.near, depthFar: E.far }),
          (O = E.near),
          (D = E.far),
          (T.near = O),
          (T.far = D),
          (P.near = O),
          (P.far = D),
          T.updateProjectionMatrix(),
          P.updateProjectionMatrix(),
          H.updateProjectionMatrix());
      const X = H.parent,
        ne = E.cameras;
      j(E, X);
      for (let oe = 0; oe < ne.length; oe++) j(ne[oe], X);
      ne.length === 2
        ? U(E, T, P)
        : E.projectionMatrix.copy(T.projectionMatrix),
        W(H, E, X);
    };
    function W(H, X, ne) {
      ne === null
        ? H.matrix.copy(X.matrixWorld)
        : (H.matrix.copy(ne.matrixWorld),
          H.matrix.invert(),
          H.matrix.multiply(X.matrixWorld)),
        H.matrix.decompose(H.position, H.quaternion, H.scale),
        H.updateMatrixWorld(!0),
        H.projectionMatrix.copy(X.projectionMatrix),
        H.projectionMatrixInverse.copy(X.projectionMatrixInverse),
        H.isPerspectiveCamera &&
          ((H.fov = xf * 2 * Math.atan(1 / H.projectionMatrix.elements[5])),
          (H.zoom = 1));
    }
    (this.getCamera = function () {
      return E;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (H) {
        (l = H),
          p !== null && (p.fixedFoveation = H),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = H);
      }),
      (this.hasDepthSensing = function () {
        return _.texture !== null;
      });
    let B = null;
    function q(H, X) {
      if (((u = X.getViewerPose(c || s)), (v = X), u !== null)) {
        const ne = u.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(x, m.framebuffer),
          e.setRenderTarget(x));
        let oe = !1;
        ne.length !== E.cameras.length && ((E.cameras.length = 0), (oe = !0));
        for (let Ie = 0; Ie < ne.length; Ie++) {
          const te = ne[Ie];
          let ge = null;
          if (m !== null) ge = m.getViewport(te);
          else {
            const pe = d.getViewSubImage(p, te);
            (ge = pe.viewport),
              Ie === 0 &&
                (e.setRenderTargetTextures(
                  x,
                  pe.colorTexture,
                  p.ignoreDepthValues ? void 0 : pe.depthStencilTexture
                ),
                e.setRenderTarget(x));
          }
          let ie = R[Ie];
          ie === void 0 &&
            ((ie = new En()),
            ie.layers.enable(Ie),
            (ie.viewport = new tn()),
            (R[Ie] = ie)),
            ie.matrix.fromArray(te.transform.matrix),
            ie.matrix.decompose(ie.position, ie.quaternion, ie.scale),
            ie.projectionMatrix.fromArray(te.projectionMatrix),
            ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert(),
            ie.viewport.set(ge.x, ge.y, ge.width, ge.height),
            Ie === 0 &&
              (E.matrix.copy(ie.matrix),
              E.matrix.decompose(E.position, E.quaternion, E.scale)),
            oe === !0 && E.cameras.push(ie);
        }
        const ue = i.enabledFeatures;
        if (ue && ue.includes("depth-sensing")) {
          const Ie = d.getDepthInformation(ne[0]);
          Ie && Ie.isValid && Ie.texture && _.init(e, Ie, i.renderState);
        }
      }
      for (let ne = 0; ne < S.length; ne++) {
        const oe = b[ne],
          ue = S[ne];
        oe !== null && ue !== void 0 && ue.update(oe, X, c || s);
      }
      _.render(e, E),
        B && B(H, X),
        X.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: X }),
        (v = null);
    }
    const Z = new AN();
    Z.setAnimationLoop(q),
      (this.setAnimationLoop = function (H) {
        B = H;
      }),
      (this.dispose = function () {});
  }
}
const Nl = new qi(),
  cW = new wt();
function uW(t, e) {
  function n(y, g) {
    y.matrixAutoUpdate === !0 && y.updateMatrix(), g.value.copy(y.matrix);
  }
  function r(y, g) {
    g.color.getRGB(y.fogColor.value, xN(t)),
      g.isFog
        ? ((y.fogNear.value = g.near), (y.fogFar.value = g.far))
        : g.isFogExp2 && (y.fogDensity.value = g.density);
  }
  function i(y, g, x, S, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? o(y, g)
      : g.isMeshToonMaterial
      ? (o(y, g), d(y, g))
      : g.isMeshPhongMaterial
      ? (o(y, g), u(y, g))
      : g.isMeshStandardMaterial
      ? (o(y, g), p(y, g), g.isMeshPhysicalMaterial && m(y, g, b))
      : g.isMeshMatcapMaterial
      ? (o(y, g), v(y, g))
      : g.isMeshDepthMaterial
      ? o(y, g)
      : g.isMeshDistanceMaterial
      ? (o(y, g), _(y, g))
      : g.isMeshNormalMaterial
      ? o(y, g)
      : g.isLineBasicMaterial
      ? (s(y, g), g.isLineDashedMaterial && a(y, g))
      : g.isPointsMaterial
      ? l(y, g, x, S)
      : g.isSpriteMaterial
      ? c(y, g)
      : g.isShadowMaterial
      ? (y.color.value.copy(g.color), (y.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function o(y, g) {
    (y.opacity.value = g.opacity),
      g.color && y.diffuse.value.copy(g.color),
      g.emissive &&
        y.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((y.map.value = g.map), n(g.map, y.mapTransform)),
      g.alphaMap &&
        ((y.alphaMap.value = g.alphaMap), n(g.alphaMap, y.alphaMapTransform)),
      g.bumpMap &&
        ((y.bumpMap.value = g.bumpMap),
        n(g.bumpMap, y.bumpMapTransform),
        (y.bumpScale.value = g.bumpScale),
        g.side === li && (y.bumpScale.value *= -1)),
      g.normalMap &&
        ((y.normalMap.value = g.normalMap),
        n(g.normalMap, y.normalMapTransform),
        y.normalScale.value.copy(g.normalScale),
        g.side === li && y.normalScale.value.negate()),
      g.displacementMap &&
        ((y.displacementMap.value = g.displacementMap),
        n(g.displacementMap, y.displacementMapTransform),
        (y.displacementScale.value = g.displacementScale),
        (y.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((y.emissiveMap.value = g.emissiveMap),
        n(g.emissiveMap, y.emissiveMapTransform)),
      g.specularMap &&
        ((y.specularMap.value = g.specularMap),
        n(g.specularMap, y.specularMapTransform)),
      g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
    const x = e.get(g),
      S = x.envMap,
      b = x.envMapRotation;
    if (
      (S &&
        ((y.envMap.value = S),
        Nl.copy(b),
        (Nl.x *= -1),
        (Nl.y *= -1),
        (Nl.z *= -1),
        S.isCubeTexture &&
          S.isRenderTargetTexture === !1 &&
          ((Nl.y *= -1), (Nl.z *= -1)),
        y.envMapRotation.value.setFromMatrix4(cW.makeRotationFromEuler(Nl)),
        (y.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (y.reflectivity.value = g.reflectivity),
        (y.ior.value = g.ior),
        (y.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      y.lightMap.value = g.lightMap;
      const C = t._useLegacyLights === !0 ? Math.PI : 1;
      (y.lightMapIntensity.value = g.lightMapIntensity * C),
        n(g.lightMap, y.lightMapTransform);
    }
    g.aoMap &&
      ((y.aoMap.value = g.aoMap),
      (y.aoMapIntensity.value = g.aoMapIntensity),
      n(g.aoMap, y.aoMapTransform));
  }
  function s(y, g) {
    y.diffuse.value.copy(g.color),
      (y.opacity.value = g.opacity),
      g.map && ((y.map.value = g.map), n(g.map, y.mapTransform));
  }
  function a(y, g) {
    (y.dashSize.value = g.dashSize),
      (y.totalSize.value = g.dashSize + g.gapSize),
      (y.scale.value = g.scale);
  }
  function l(y, g, x, S) {
    y.diffuse.value.copy(g.color),
      (y.opacity.value = g.opacity),
      (y.size.value = g.size * x),
      (y.scale.value = S * 0.5),
      g.map && ((y.map.value = g.map), n(g.map, y.uvTransform)),
      g.alphaMap &&
        ((y.alphaMap.value = g.alphaMap), n(g.alphaMap, y.alphaMapTransform)),
      g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function c(y, g) {
    y.diffuse.value.copy(g.color),
      (y.opacity.value = g.opacity),
      (y.rotation.value = g.rotation),
      g.map && ((y.map.value = g.map), n(g.map, y.mapTransform)),
      g.alphaMap &&
        ((y.alphaMap.value = g.alphaMap), n(g.alphaMap, y.alphaMapTransform)),
      g.alphaTest > 0 && (y.alphaTest.value = g.alphaTest);
  }
  function u(y, g) {
    y.specular.value.copy(g.specular),
      (y.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(y, g) {
    g.gradientMap && (y.gradientMap.value = g.gradientMap);
  }
  function p(y, g) {
    (y.metalness.value = g.metalness),
      g.metalnessMap &&
        ((y.metalnessMap.value = g.metalnessMap),
        n(g.metalnessMap, y.metalnessMapTransform)),
      (y.roughness.value = g.roughness),
      g.roughnessMap &&
        ((y.roughnessMap.value = g.roughnessMap),
        n(g.roughnessMap, y.roughnessMapTransform)),
      g.envMap && (y.envMapIntensity.value = g.envMapIntensity);
  }
  function m(y, g, x) {
    (y.ior.value = g.ior),
      g.sheen > 0 &&
        (y.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (y.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((y.sheenColorMap.value = g.sheenColorMap),
          n(g.sheenColorMap, y.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((y.sheenRoughnessMap.value = g.sheenRoughnessMap),
          n(g.sheenRoughnessMap, y.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((y.clearcoat.value = g.clearcoat),
        (y.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((y.clearcoatMap.value = g.clearcoatMap),
          n(g.clearcoatMap, y.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((y.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          n(g.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((y.clearcoatNormalMap.value = g.clearcoatNormalMap),
          n(g.clearcoatNormalMap, y.clearcoatNormalMapTransform),
          y.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === li && y.clearcoatNormalScale.value.negate())),
      g.dispersion > 0 && (y.dispersion.value = g.dispersion),
      g.iridescence > 0 &&
        ((y.iridescence.value = g.iridescence),
        (y.iridescenceIOR.value = g.iridescenceIOR),
        (y.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (y.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((y.iridescenceMap.value = g.iridescenceMap),
          n(g.iridescenceMap, y.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((y.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          n(g.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((y.transmission.value = g.transmission),
        (y.transmissionSamplerMap.value = x.texture),
        y.transmissionSamplerSize.value.set(x.width, x.height),
        g.transmissionMap &&
          ((y.transmissionMap.value = g.transmissionMap),
          n(g.transmissionMap, y.transmissionMapTransform)),
        (y.thickness.value = g.thickness),
        g.thicknessMap &&
          ((y.thicknessMap.value = g.thicknessMap),
          n(g.thicknessMap, y.thicknessMapTransform)),
        (y.attenuationDistance.value = g.attenuationDistance),
        y.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (y.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((y.anisotropyMap.value = g.anisotropyMap),
          n(g.anisotropyMap, y.anisotropyMapTransform))),
      (y.specularIntensity.value = g.specularIntensity),
      y.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((y.specularColorMap.value = g.specularColorMap),
        n(g.specularColorMap, y.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((y.specularIntensityMap.value = g.specularIntensityMap),
        n(g.specularIntensityMap, y.specularIntensityMapTransform));
  }
  function v(y, g) {
    g.matcap && (y.matcap.value = g.matcap);
  }
  function _(y, g) {
    const x = e.get(g).light;
    y.referencePosition.value.setFromMatrixPosition(x.matrixWorld),
      (y.nearDistance.value = x.shadow.camera.near),
      (y.farDistance.value = x.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function fW(t, e, n, r) {
  let i = {},
    o = {},
    s = [];
  const a = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(x, S) {
    const b = S.program;
    r.uniformBlockBinding(x, b);
  }
  function c(x, S) {
    let b = i[x.id];
    b === void 0 &&
      (v(x), (b = u(x)), (i[x.id] = b), x.addEventListener("dispose", y));
    const C = S.program;
    r.updateUBOMapping(x, C);
    const M = e.render.frame;
    o[x.id] !== M && (p(x), (o[x.id] = M));
  }
  function u(x) {
    const S = d();
    x.__bindingPointIndex = S;
    const b = t.createBuffer(),
      C = x.__size,
      M = x.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, b),
      t.bufferData(t.UNIFORM_BUFFER, C, M),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, S, b),
      b
    );
  }
  function d() {
    for (let x = 0; x < a; x++) if (s.indexOf(x) === -1) return s.push(x), x;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(x) {
    const S = i[x.id],
      b = x.uniforms,
      C = x.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, S);
    for (let M = 0, T = b.length; M < T; M++) {
      const P = Array.isArray(b[M]) ? b[M] : [b[M]];
      for (let R = 0, E = P.length; R < E; R++) {
        const O = P[R];
        if (m(O, M, R, C) === !0) {
          const D = O.__offset,
            N = Array.isArray(O.value) ? O.value : [O.value];
          let z = 0;
          for (let V = 0; V < N.length; V++) {
            const G = N[V],
              Y = _(G);
            typeof G == "number" || typeof G == "boolean"
              ? ((O.__data[0] = G),
                t.bufferSubData(t.UNIFORM_BUFFER, D + z, O.__data))
              : G.isMatrix3
              ? ((O.__data[0] = G.elements[0]),
                (O.__data[1] = G.elements[1]),
                (O.__data[2] = G.elements[2]),
                (O.__data[3] = 0),
                (O.__data[4] = G.elements[3]),
                (O.__data[5] = G.elements[4]),
                (O.__data[6] = G.elements[5]),
                (O.__data[7] = 0),
                (O.__data[8] = G.elements[6]),
                (O.__data[9] = G.elements[7]),
                (O.__data[10] = G.elements[8]),
                (O.__data[11] = 0))
              : (G.toArray(O.__data, z),
                (z += Y.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          t.bufferSubData(t.UNIFORM_BUFFER, D, O.__data);
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function m(x, S, b, C) {
    const M = x.value,
      T = S + "_" + b;
    if (C[T] === void 0)
      return (
        typeof M == "number" || typeof M == "boolean"
          ? (C[T] = M)
          : (C[T] = M.clone()),
        !0
      );
    {
      const P = C[T];
      if (typeof M == "number" || typeof M == "boolean") {
        if (P !== M) return (C[T] = M), !0;
      } else if (P.equals(M) === !1) return P.copy(M), !0;
    }
    return !1;
  }
  function v(x) {
    const S = x.uniforms;
    let b = 0;
    const C = 16;
    for (let T = 0, P = S.length; T < P; T++) {
      const R = Array.isArray(S[T]) ? S[T] : [S[T]];
      for (let E = 0, O = R.length; E < O; E++) {
        const D = R[E],
          N = Array.isArray(D.value) ? D.value : [D.value];
        for (let z = 0, V = N.length; z < V; z++) {
          const G = N[z],
            Y = _(G),
            U = b % C;
          U !== 0 && C - U < Y.boundary && (b += C - U),
            (D.__data = new Float32Array(
              Y.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (D.__offset = b),
            (b += Y.storage);
        }
      }
    }
    const M = b % C;
    return M > 0 && (b += C - M), (x.__size = b), (x.__cache = {}), this;
  }
  function _(x) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof x == "number" || typeof x == "boolean"
        ? ((S.boundary = 4), (S.storage = 4))
        : x.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : x.isVector3 || x.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : x.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : x.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : x.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : x.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            x
          ),
      S
    );
  }
  function y(x) {
    const S = x.target;
    S.removeEventListener("dispose", y);
    const b = s.indexOf(S.__bindingPointIndex);
    s.splice(b, 1), t.deleteBuffer(i[S.id]), delete i[S.id], delete o[S.id];
  }
  function g() {
    for (const x in i) t.deleteBuffer(i[x]);
    (s = []), (i = {}), (o = {});
  }
  return { bind: l, update: c, dispose: g };
}
class PN {
  constructor(e = {}) {
    const {
      canvas: n = pN(),
      context: r = null,
      depth: i = !0,
      stencil: o = !1,
      alpha: s = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      p = r.getContextAttributes().alpha;
    } else p = s;
    const m = new Uint32Array(4),
      v = new Int32Array(4);
    let _ = null,
      y = null;
    const g = [],
      x = [];
    (this.domElement = n),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = fo),
      (this._useLegacyLights = !1),
      (this.toneMapping = hs),
      (this.toneMappingExposure = 1);
    const S = this;
    let b = !1,
      C = 0,
      M = 0,
      T = null,
      P = -1,
      R = null;
    const E = new tn(),
      O = new tn();
    let D = null;
    const N = new it(0);
    let z = 0,
      V = n.width,
      G = n.height,
      Y = 1,
      U = null,
      j = null;
    const W = new tn(0, 0, V, G),
      B = new tn(0, 0, V, G);
    let q = !1;
    const Z = new Np();
    let H = !1,
      X = !1;
    const ne = new wt(),
      oe = new ee(),
      ue = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ie() {
      return T === null ? Y : 1;
    }
    let te = r;
    function ge(K, Se) {
      return n.getContext(K, Se);
    }
    try {
      const K = {
        alpha: !0,
        depth: i,
        stencil: o,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in n &&
          n.setAttribute("data-engine", `three.js r${Qv}`),
        n.addEventListener("webglcontextlost", se, !1),
        n.addEventListener("webglcontextrestored", Ae, !1),
        n.addEventListener("webglcontextcreationerror", ye, !1),
        te === null)
      ) {
        const Se = "webgl2";
        if (((te = ge(Se, K)), te === null))
          throw ge(Se)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (K) {
      throw (console.error("THREE.WebGLRenderer: " + K.message), K);
    }
    let ie,
      pe,
      de,
      Ee,
      he,
      Ce,
      _e,
      $,
      k,
      J,
      fe,
      le,
      ce,
      we,
      Be,
      Me,
      Ge,
      Le,
      je,
      Je,
      Ye,
      De,
      ze,
      Ve;
    function ae() {
      (ie = new wV(te)),
        ie.init(),
        (De = new TN(te, ie)),
        (pe = new yV(te, ie, e, De)),
        (de = new nW(te)),
        (Ee = new CV(te)),
        (he = new WG()),
        (Ce = new rW(te, ie, de, he, pe, De, Ee)),
        (_e = new _V(S)),
        ($ = new bV(S)),
        (k = new N6(te)),
        (ze = new gV(te, k)),
        (J = new EV(te, k, Ee, ze)),
        (fe = new RV(te, J, k, Ee)),
        (je = new TV(te, pe, Ce)),
        (Me = new xV(he)),
        (le = new GG(S, _e, $, ie, pe, ze, Me)),
        (ce = new uW(S, he)),
        (we = new $G()),
        (Be = new JG(ie)),
        (Le = new mV(S, _e, $, de, fe, p, l)),
        (Ge = new tW(S, fe, pe)),
        (Ve = new fW(te, Ee, pe, de)),
        (Je = new vV(te, ie, Ee)),
        (Ye = new MV(te, ie, Ee)),
        (Ee.programs = le.programs),
        (S.capabilities = pe),
        (S.extensions = ie),
        (S.properties = he),
        (S.renderLists = we),
        (S.shadowMap = Ge),
        (S.state = de),
        (S.info = Ee);
    }
    ae();
    const be = new lW(S, te);
    (this.xr = be),
      (this.getContext = function () {
        return te;
      }),
      (this.getContextAttributes = function () {
        return te.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const K = ie.get("WEBGL_lose_context");
        K && K.loseContext();
      }),
      (this.forceContextRestore = function () {
        const K = ie.get("WEBGL_lose_context");
        K && K.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Y;
      }),
      (this.setPixelRatio = function (K) {
        K !== void 0 && ((Y = K), this.setSize(V, G, !1));
      }),
      (this.getSize = function (K) {
        return K.set(V, G);
      }),
      (this.setSize = function (K, Se, Oe = !0) {
        if (be.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (V = K),
          (G = Se),
          (n.width = Math.floor(K * Y)),
          (n.height = Math.floor(Se * Y)),
          Oe === !0 &&
            ((n.style.width = K + "px"), (n.style.height = Se + "px")),
          this.setViewport(0, 0, K, Se);
      }),
      (this.getDrawingBufferSize = function (K) {
        return K.set(V * Y, G * Y).floor();
      }),
      (this.setDrawingBufferSize = function (K, Se, Oe) {
        (V = K),
          (G = Se),
          (Y = Oe),
          (n.width = Math.floor(K * Oe)),
          (n.height = Math.floor(Se * Oe)),
          this.setViewport(0, 0, K, Se);
      }),
      (this.getCurrentViewport = function (K) {
        return K.copy(E);
      }),
      (this.getViewport = function (K) {
        return K.copy(W);
      }),
      (this.setViewport = function (K, Se, Oe, Te) {
        K.isVector4 ? W.set(K.x, K.y, K.z, K.w) : W.set(K, Se, Oe, Te),
          de.viewport(E.copy(W).multiplyScalar(Y).round());
      }),
      (this.getScissor = function (K) {
        return K.copy(B);
      }),
      (this.setScissor = function (K, Se, Oe, Te) {
        K.isVector4 ? B.set(K.x, K.y, K.z, K.w) : B.set(K, Se, Oe, Te),
          de.scissor(O.copy(B).multiplyScalar(Y).round());
      }),
      (this.getScissorTest = function () {
        return q;
      }),
      (this.setScissorTest = function (K) {
        de.setScissorTest((q = K));
      }),
      (this.setOpaqueSort = function (K) {
        U = K;
      }),
      (this.setTransparentSort = function (K) {
        j = K;
      }),
      (this.getClearColor = function (K) {
        return K.copy(Le.getClearColor());
      }),
      (this.setClearColor = function () {
        Le.setClearColor.apply(Le, arguments);
      }),
      (this.getClearAlpha = function () {
        return Le.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Le.setClearAlpha.apply(Le, arguments);
      }),
      (this.clear = function (K = !0, Se = !0, Oe = !0) {
        let Te = 0;
        if (K) {
          let Re = !1;
          if (T !== null) {
            const Qe = T.texture.format;
            Re = Qe === nE || Qe === tE || Qe === eE;
          }
          if (Re) {
            const Qe = T.texture.type,
              ct =
                Qe === gs ||
                Qe === wc ||
                Qe === qw ||
                Qe === Df ||
                Qe === Zw ||
                Qe === Jw,
              nt = Le.getClearColor(),
              xt = Le.getClearAlpha(),
              Ct = nt.r,
              $e = nt.g,
              Et = nt.b;
            ct
              ? ((m[0] = Ct),
                (m[1] = $e),
                (m[2] = Et),
                (m[3] = xt),
                te.clearBufferuiv(te.COLOR, 0, m))
              : ((v[0] = Ct),
                (v[1] = $e),
                (v[2] = Et),
                (v[3] = xt),
                te.clearBufferiv(te.COLOR, 0, v));
          } else Te |= te.COLOR_BUFFER_BIT;
        }
        Se && (Te |= te.DEPTH_BUFFER_BIT),
          Oe &&
            ((Te |= te.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          te.clear(Te);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", se, !1),
          n.removeEventListener("webglcontextrestored", Ae, !1),
          n.removeEventListener("webglcontextcreationerror", ye, !1),
          we.dispose(),
          Be.dispose(),
          he.dispose(),
          _e.dispose(),
          $.dispose(),
          fe.dispose(),
          ze.dispose(),
          Ve.dispose(),
          le.dispose(),
          be.dispose(),
          be.removeEventListener("sessionstart", Ze),
          be.removeEventListener("sessionend", Mt),
          Rt.stop();
      });
    function se(K) {
      K.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (b = !0);
    }
    function Ae() {
      console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
      const K = Ee.autoReset,
        Se = Ge.enabled,
        Oe = Ge.autoUpdate,
        Te = Ge.needsUpdate,
        Re = Ge.type;
      ae(),
        (Ee.autoReset = K),
        (Ge.enabled = Se),
        (Ge.autoUpdate = Oe),
        (Ge.needsUpdate = Te),
        (Ge.type = Re);
    }
    function ye(K) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        K.statusMessage
      );
    }
    function He(K) {
      const Se = K.target;
      Se.removeEventListener("dispose", He), qe(Se);
    }
    function qe(K) {
      at(K), he.remove(K);
    }
    function at(K) {
      const Se = he.get(K).programs;
      Se !== void 0 &&
        (Se.forEach(function (Oe) {
          le.releaseProgram(Oe);
        }),
        K.isShaderMaterial && le.releaseShaderCache(K));
    }
    this.renderBufferDirect = function (K, Se, Oe, Te, Re, Qe) {
      Se === null && (Se = ue);
      const ct = Re.isMesh && Re.matrixWorld.determinant() < 0,
        nt = Vt(K, Se, Oe, Te, Re);
      de.setMaterial(Te, ct);
      let xt = Oe.index,
        Ct = 1;
      if (Te.wireframe === !0) {
        if (((xt = J.getWireframeAttribute(Oe)), xt === void 0)) return;
        Ct = 2;
      }
      const $e = Oe.drawRange,
        Et = Oe.attributes.position;
      let dn = $e.start * Ct,
        cn = ($e.start + $e.count) * Ct;
      Qe !== null &&
        ((dn = Math.max(dn, Qe.start * Ct)),
        (cn = Math.min(cn, (Qe.start + Qe.count) * Ct))),
        xt !== null
          ? ((dn = Math.max(dn, 0)), (cn = Math.min(cn, xt.count)))
          : Et != null &&
            ((dn = Math.max(dn, 0)), (cn = Math.min(cn, Et.count)));
      const Xn = cn - dn;
      if (Xn < 0 || Xn === 1 / 0) return;
      ze.setup(Re, Te, nt, Oe, xt);
      let Lr,
        Nt = Je;
      if (
        (xt !== null && ((Lr = k.get(xt)), (Nt = Ye), Nt.setIndex(Lr)),
        Re.isMesh)
      )
        Te.wireframe === !0
          ? (de.setLineWidth(Te.wireframeLinewidth * Ie()),
            Nt.setMode(te.LINES))
          : Nt.setMode(te.TRIANGLES);
      else if (Re.isLine) {
        let vt = Te.linewidth;
        vt === void 0 && (vt = 1),
          de.setLineWidth(vt * Ie()),
          Re.isLineSegments
            ? Nt.setMode(te.LINES)
            : Re.isLineLoop
            ? Nt.setMode(te.LINE_LOOP)
            : Nt.setMode(te.LINE_STRIP);
      } else
        Re.isPoints
          ? Nt.setMode(te.POINTS)
          : Re.isSprite && Nt.setMode(te.TRIANGLES);
      if (Re.isBatchedMesh)
        Re._multiDrawInstances !== null
          ? Nt.renderMultiDrawInstances(
              Re._multiDrawStarts,
              Re._multiDrawCounts,
              Re._multiDrawCount,
              Re._multiDrawInstances
            )
          : Nt.renderMultiDraw(
              Re._multiDrawStarts,
              Re._multiDrawCounts,
              Re._multiDrawCount
            );
      else if (Re.isInstancedMesh) Nt.renderInstances(dn, Xn, Re.count);
      else if (Oe.isInstancedBufferGeometry) {
        const vt =
            Oe._maxInstanceCount !== void 0 ? Oe._maxInstanceCount : 1 / 0,
          Wt = Math.min(Oe.instanceCount, vt);
        Nt.renderInstances(dn, Xn, Wt);
      } else Nt.render(dn, Xn);
    };
    function st(K, Se, Oe) {
      K.transparent === !0 && K.side === mo && K.forceSinglePass === !1
        ? ((K.side = li),
          (K.needsUpdate = !0),
          ur(K, Se, Oe),
          (K.side = Js),
          (K.needsUpdate = !0),
          ur(K, Se, Oe),
          (K.side = mo))
        : ur(K, Se, Oe);
    }
    (this.compile = function (K, Se, Oe = null) {
      Oe === null && (Oe = K),
        (y = Be.get(Oe)),
        y.init(Se),
        x.push(y),
        Oe.traverseVisible(function (Re) {
          Re.isLight &&
            Re.layers.test(Se.layers) &&
            (y.pushLight(Re), Re.castShadow && y.pushShadow(Re));
        }),
        K !== Oe &&
          K.traverseVisible(function (Re) {
            Re.isLight &&
              Re.layers.test(Se.layers) &&
              (y.pushLight(Re), Re.castShadow && y.pushShadow(Re));
          }),
        y.setupLights(S._useLegacyLights);
      const Te = new Set();
      return (
        K.traverse(function (Re) {
          const Qe = Re.material;
          if (Qe)
            if (Array.isArray(Qe))
              for (let ct = 0; ct < Qe.length; ct++) {
                const nt = Qe[ct];
                st(nt, Oe, Re), Te.add(nt);
              }
            else st(Qe, Oe, Re), Te.add(Qe);
        }),
        x.pop(),
        (y = null),
        Te
      );
    }),
      (this.compileAsync = function (K, Se, Oe = null) {
        const Te = this.compile(K, Se, Oe);
        return new Promise((Re) => {
          function Qe() {
            if (
              (Te.forEach(function (ct) {
                he.get(ct).currentProgram.isReady() && Te.delete(ct);
              }),
              Te.size === 0)
            ) {
              Re(K);
              return;
            }
            setTimeout(Qe, 10);
          }
          ie.get("KHR_parallel_shader_compile") !== null
            ? Qe()
            : setTimeout(Qe, 10);
        });
      });
    let ht = null;
    function pt(K) {
      ht && ht(K);
    }
    function Ze() {
      Rt.stop();
    }
    function Mt() {
      Rt.start();
    }
    const Rt = new AN();
    Rt.setAnimationLoop(pt),
      typeof self < "u" && Rt.setContext(self),
      (this.setAnimationLoop = function (K) {
        (ht = K), be.setAnimationLoop(K), K === null ? Rt.stop() : Rt.start();
      }),
      be.addEventListener("sessionstart", Ze),
      be.addEventListener("sessionend", Mt),
      (this.render = function (K, Se) {
        if (Se !== void 0 && Se.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (b === !0) return;
        K.matrixWorldAutoUpdate === !0 && K.updateMatrixWorld(),
          Se.parent === null &&
            Se.matrixWorldAutoUpdate === !0 &&
            Se.updateMatrixWorld(),
          be.enabled === !0 &&
            be.isPresenting === !0 &&
            (be.cameraAutoUpdate === !0 && be.updateCamera(Se),
            (Se = be.getCamera())),
          K.isScene === !0 && K.onBeforeRender(S, K, Se, T),
          (y = Be.get(K, x.length)),
          y.init(Se),
          x.push(y),
          ne.multiplyMatrices(Se.projectionMatrix, Se.matrixWorldInverse),
          Z.setFromProjectionMatrix(ne),
          (X = this.localClippingEnabled),
          (H = Me.init(this.clippingPlanes, X)),
          (_ = we.get(K, g.length)),
          _.init(),
          g.push(_),
          Yt(K, Se, 0, S.sortObjects),
          _.finish(),
          S.sortObjects === !0 && _.sort(U, j);
        const Oe =
          be.enabled === !1 ||
          be.isPresenting === !1 ||
          be.hasDepthSensing() === !1;
        Oe && Le.addToRenderList(_, K),
          this.info.render.frame++,
          H === !0 && Me.beginShadows();
        const Te = y.state.shadowsArray;
        Ge.render(Te, K, Se),
          H === !0 && Me.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Re = _.opaque,
          Qe = _.transmissive;
        if ((y.setupLights(S._useLegacyLights), Se.isArrayCamera)) {
          const ct = Se.cameras;
          if (Qe.length > 0)
            for (let nt = 0, xt = ct.length; nt < xt; nt++) {
              const Ct = ct[nt];
              Qn(Re, Qe, K, Ct);
            }
          Oe && Le.render(K);
          for (let nt = 0, xt = ct.length; nt < xt; nt++) {
            const Ct = ct[nt];
            en(_, K, Ct, Ct.viewport);
          }
        } else
          Qe.length > 0 && Qn(Re, Qe, K, Se), Oe && Le.render(K), en(_, K, Se);
        T !== null &&
          (Ce.updateMultisampleRenderTarget(T), Ce.updateRenderTargetMipmap(T)),
          K.isScene === !0 && K.onAfterRender(S, K, Se),
          ze.resetDefaultState(),
          (P = -1),
          (R = null),
          x.pop(),
          x.length > 0
            ? ((y = x[x.length - 1]),
              H === !0 && Me.setGlobalState(S.clippingPlanes, y.state.camera))
            : (y = null),
          g.pop(),
          g.length > 0 ? (_ = g[g.length - 1]) : (_ = null);
      });
    function Yt(K, Se, Oe, Te) {
      if (K.visible === !1) return;
      if (K.layers.test(Se.layers)) {
        if (K.isGroup) Oe = K.renderOrder;
        else if (K.isLOD) K.autoUpdate === !0 && K.update(Se);
        else if (K.isLight) y.pushLight(K), K.castShadow && y.pushShadow(K);
        else if (K.isSprite) {
          if (!K.frustumCulled || Z.intersectsSprite(K)) {
            Te && oe.setFromMatrixPosition(K.matrixWorld).applyMatrix4(ne);
            const ct = fe.update(K),
              nt = K.material;
            nt.visible && _.push(K, ct, nt, Oe, oe.z, null);
          }
        } else if (
          (K.isMesh || K.isLine || K.isPoints) &&
          (!K.frustumCulled || Z.intersectsObject(K))
        ) {
          const ct = fe.update(K),
            nt = K.material;
          if (
            (Te &&
              (K.boundingSphere !== void 0
                ? (K.boundingSphere === null && K.computeBoundingSphere(),
                  oe.copy(K.boundingSphere.center))
                : (ct.boundingSphere === null && ct.computeBoundingSphere(),
                  oe.copy(ct.boundingSphere.center)),
              oe.applyMatrix4(K.matrixWorld).applyMatrix4(ne)),
            Array.isArray(nt))
          ) {
            const xt = ct.groups;
            for (let Ct = 0, $e = xt.length; Ct < $e; Ct++) {
              const Et = xt[Ct],
                dn = nt[Et.materialIndex];
              dn && dn.visible && _.push(K, ct, dn, Oe, oe.z, Et);
            }
          } else nt.visible && _.push(K, ct, nt, Oe, oe.z, null);
        }
      }
      const Qe = K.children;
      for (let ct = 0, nt = Qe.length; ct < nt; ct++) Yt(Qe[ct], Se, Oe, Te);
    }
    function en(K, Se, Oe, Te) {
      const Re = K.opaque,
        Qe = K.transmissive,
        ct = K.transparent;
      y.setupLightsView(Oe),
        H === !0 && Me.setGlobalState(S.clippingPlanes, Oe),
        Te && de.viewport(E.copy(Te)),
        Re.length > 0 && cr(Re, Se, Oe),
        Qe.length > 0 && cr(Qe, Se, Oe),
        ct.length > 0 && cr(ct, Se, Oe),
        de.buffers.depth.setTest(!0),
        de.buffers.depth.setMask(!0),
        de.buffers.color.setMask(!0),
        de.setPolygonOffset(!1);
    }
    function Qn(K, Se, Oe, Te) {
      if ((Oe.isScene === !0 ? Oe.overrideMaterial : null) !== null) return;
      y.state.transmissionRenderTarget[Te.id] === void 0 &&
        (y.state.transmissionRenderTarget[Te.id] = new Wo(1, 1, {
          generateMipmaps: !0,
          type:
            ie.has("EXT_color_buffer_half_float") ||
            ie.has("EXT_color_buffer_float")
              ? Pp
              : gs,
          minFilter: ls,
          samples: 4,
          stencilBuffer: o,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
        }));
      const Qe = y.state.transmissionRenderTarget[Te.id],
        ct = Te.viewport || E;
      Qe.setSize(ct.z, ct.w);
      const nt = S.getRenderTarget();
      S.setRenderTarget(Qe),
        S.getClearColor(N),
        (z = S.getClearAlpha()),
        z < 1 && S.setClearColor(16777215, 0.5),
        S.clear();
      const xt = S.toneMapping;
      S.toneMapping = hs;
      const Ct = Te.viewport;
      if (
        (Te.viewport !== void 0 && (Te.viewport = void 0),
        y.setupLightsView(Te),
        H === !0 && Me.setGlobalState(S.clippingPlanes, Te),
        cr(K, Oe, Te),
        Ce.updateMultisampleRenderTarget(Qe),
        Ce.updateRenderTargetMipmap(Qe),
        ie.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let $e = !1;
        for (let Et = 0, dn = Se.length; Et < dn; Et++) {
          const cn = Se[Et],
            Xn = cn.object,
            Lr = cn.geometry,
            Nt = cn.material,
            vt = cn.group;
          if (Nt.side === mo && Xn.layers.test(Te.layers)) {
            const Wt = Nt.side;
            (Nt.side = li),
              (Nt.needsUpdate = !0),
              $t(Xn, Oe, Te, Lr, Nt, vt),
              (Nt.side = Wt),
              (Nt.needsUpdate = !0),
              ($e = !0);
          }
        }
        $e === !0 &&
          (Ce.updateMultisampleRenderTarget(Qe),
          Ce.updateRenderTargetMipmap(Qe));
      }
      S.setRenderTarget(nt),
        S.setClearColor(N, z),
        Ct !== void 0 && (Te.viewport = Ct),
        (S.toneMapping = xt);
    }
    function cr(K, Se, Oe) {
      const Te = Se.isScene === !0 ? Se.overrideMaterial : null;
      for (let Re = 0, Qe = K.length; Re < Qe; Re++) {
        const ct = K[Re],
          nt = ct.object,
          xt = ct.geometry,
          Ct = Te === null ? ct.material : Te,
          $e = ct.group;
        nt.layers.test(Oe.layers) && $t(nt, Se, Oe, xt, Ct, $e);
      }
    }
    function $t(K, Se, Oe, Te, Re, Qe) {
      K.onBeforeRender(S, Se, Oe, Te, Re, Qe),
        K.modelViewMatrix.multiplyMatrices(
          Oe.matrixWorldInverse,
          K.matrixWorld
        ),
        K.normalMatrix.getNormalMatrix(K.modelViewMatrix),
        Re.onBeforeRender(S, Se, Oe, Te, K, Qe),
        Re.transparent === !0 && Re.side === mo && Re.forceSinglePass === !1
          ? ((Re.side = li),
            (Re.needsUpdate = !0),
            S.renderBufferDirect(Oe, Se, Te, Re, K, Qe),
            (Re.side = Js),
            (Re.needsUpdate = !0),
            S.renderBufferDirect(Oe, Se, Te, Re, K, Qe),
            (Re.side = mo))
          : S.renderBufferDirect(Oe, Se, Te, Re, K, Qe),
        K.onAfterRender(S, Se, Oe, Te, Re, Qe);
    }
    function ur(K, Se, Oe) {
      Se.isScene !== !0 && (Se = ue);
      const Te = he.get(K),
        Re = y.state.lights,
        Qe = y.state.shadowsArray,
        ct = Re.state.version,
        nt = le.getParameters(K, Re.state, Qe, Se, Oe),
        xt = le.getProgramCacheKey(nt);
      let Ct = Te.programs;
      (Te.environment = K.isMeshStandardMaterial ? Se.environment : null),
        (Te.fog = Se.fog),
        (Te.envMap = (K.isMeshStandardMaterial ? $ : _e).get(
          K.envMap || Te.environment
        )),
        (Te.envMapRotation =
          Te.environment !== null && K.envMap === null
            ? Se.environmentRotation
            : K.envMapRotation),
        Ct === void 0 &&
          (K.addEventListener("dispose", He),
          (Ct = new Map()),
          (Te.programs = Ct));
      let $e = Ct.get(xt);
      if ($e !== void 0) {
        if (Te.currentProgram === $e && Te.lightsStateVersion === ct)
          return Xt(K, nt), $e;
      } else
        (nt.uniforms = le.getUniforms(K)),
          K.onBuild(Oe, nt, S),
          K.onBeforeCompile(nt, S),
          ($e = le.acquireProgram(nt, xt)),
          Ct.set(xt, $e),
          (Te.uniforms = nt.uniforms);
      const Et = Te.uniforms;
      return (
        ((!K.isShaderMaterial && !K.isRawShaderMaterial) ||
          K.clipping === !0) &&
          (Et.clippingPlanes = Me.uniform),
        Xt(K, nt),
        (Te.needsLights = br(K)),
        (Te.lightsStateVersion = ct),
        Te.needsLights &&
          ((Et.ambientLightColor.value = Re.state.ambient),
          (Et.lightProbe.value = Re.state.probe),
          (Et.directionalLights.value = Re.state.directional),
          (Et.directionalLightShadows.value = Re.state.directionalShadow),
          (Et.spotLights.value = Re.state.spot),
          (Et.spotLightShadows.value = Re.state.spotShadow),
          (Et.rectAreaLights.value = Re.state.rectArea),
          (Et.ltc_1.value = Re.state.rectAreaLTC1),
          (Et.ltc_2.value = Re.state.rectAreaLTC2),
          (Et.pointLights.value = Re.state.point),
          (Et.pointLightShadows.value = Re.state.pointShadow),
          (Et.hemisphereLights.value = Re.state.hemi),
          (Et.directionalShadowMap.value = Re.state.directionalShadowMap),
          (Et.directionalShadowMatrix.value = Re.state.directionalShadowMatrix),
          (Et.spotShadowMap.value = Re.state.spotShadowMap),
          (Et.spotLightMatrix.value = Re.state.spotLightMatrix),
          (Et.spotLightMap.value = Re.state.spotLightMap),
          (Et.pointShadowMap.value = Re.state.pointShadowMap),
          (Et.pointShadowMatrix.value = Re.state.pointShadowMatrix)),
        (Te.currentProgram = $e),
        (Te.uniformsList = null),
        $e
      );
    }
    function fr(K) {
      if (K.uniformsList === null) {
        const Se = K.currentProgram.getUniforms();
        K.uniformsList = P0.seqWithValue(Se.seq, K.uniforms);
      }
      return K.uniformsList;
    }
    function Xt(K, Se) {
      const Oe = he.get(K);
      (Oe.outputColorSpace = Se.outputColorSpace),
        (Oe.batching = Se.batching),
        (Oe.instancing = Se.instancing),
        (Oe.instancingColor = Se.instancingColor),
        (Oe.instancingMorph = Se.instancingMorph),
        (Oe.skinning = Se.skinning),
        (Oe.morphTargets = Se.morphTargets),
        (Oe.morphNormals = Se.morphNormals),
        (Oe.morphColors = Se.morphColors),
        (Oe.morphTargetsCount = Se.morphTargetsCount),
        (Oe.numClippingPlanes = Se.numClippingPlanes),
        (Oe.numIntersection = Se.numClipIntersection),
        (Oe.vertexAlphas = Se.vertexAlphas),
        (Oe.vertexTangents = Se.vertexTangents),
        (Oe.toneMapping = Se.toneMapping);
    }
    function Vt(K, Se, Oe, Te, Re) {
      Se.isScene !== !0 && (Se = ue), Ce.resetTextureUnits();
      const Qe = Se.fog,
        ct = Te.isMeshStandardMaterial ? Se.environment : null,
        nt =
          T === null
            ? S.outputColorSpace
            : T.isXRRenderTarget === !0
            ? T.texture.colorSpace
            : ia,
        xt = (Te.isMeshStandardMaterial ? $ : _e).get(Te.envMap || ct),
        Ct =
          Te.vertexColors === !0 &&
          !!Oe.attributes.color &&
          Oe.attributes.color.itemSize === 4,
        $e = !!Oe.attributes.tangent && (!!Te.normalMap || Te.anisotropy > 0),
        Et = !!Oe.morphAttributes.position,
        dn = !!Oe.morphAttributes.normal,
        cn = !!Oe.morphAttributes.color;
      let Xn = hs;
      Te.toneMapped &&
        (T === null || T.isXRRenderTarget === !0) &&
        (Xn = S.toneMapping);
      const Lr =
          Oe.morphAttributes.position ||
          Oe.morphAttributes.normal ||
          Oe.morphAttributes.color,
        Nt = Lr !== void 0 ? Lr.length : 0,
        vt = he.get(Te),
        Wt = y.state.lights;
      if (H === !0 && (X === !0 || K !== R)) {
        const er = K === R && Te.id === P;
        Me.setState(Te, K, er);
      }
      let _t = !1;
      Te.version === vt.__version
        ? ((vt.needsLights && vt.lightsStateVersion !== Wt.state.version) ||
            vt.outputColorSpace !== nt ||
            (Re.isBatchedMesh && vt.batching === !1) ||
            (!Re.isBatchedMesh && vt.batching === !0) ||
            (Re.isInstancedMesh && vt.instancing === !1) ||
            (!Re.isInstancedMesh && vt.instancing === !0) ||
            (Re.isSkinnedMesh && vt.skinning === !1) ||
            (!Re.isSkinnedMesh && vt.skinning === !0) ||
            (Re.isInstancedMesh &&
              vt.instancingColor === !0 &&
              Re.instanceColor === null) ||
            (Re.isInstancedMesh &&
              vt.instancingColor === !1 &&
              Re.instanceColor !== null) ||
            (Re.isInstancedMesh &&
              vt.instancingMorph === !0 &&
              Re.morphTexture === null) ||
            (Re.isInstancedMesh &&
              vt.instancingMorph === !1 &&
              Re.morphTexture !== null) ||
            vt.envMap !== xt ||
            (Te.fog === !0 && vt.fog !== Qe) ||
            (vt.numClippingPlanes !== void 0 &&
              (vt.numClippingPlanes !== Me.numPlanes ||
                vt.numIntersection !== Me.numIntersection)) ||
            vt.vertexAlphas !== Ct ||
            vt.vertexTangents !== $e ||
            vt.morphTargets !== Et ||
            vt.morphNormals !== dn ||
            vt.morphColors !== cn ||
            vt.toneMapping !== Xn ||
            vt.morphTargetsCount !== Nt) &&
          (_t = !0)
        : ((_t = !0), (vt.__version = Te.version));
      let zn = vt.currentProgram;
      _t === !0 && (zn = ur(Te, Se, Re));
      let Ln = !1,
        yn = !1,
        hi = !1;
      const nn = zn.getUniforms(),
        un = vt.uniforms;
      if (
        (de.useProgram(zn.program) && ((Ln = !0), (yn = !0), (hi = !0)),
        Te.id !== P && ((P = Te.id), (yn = !0)),
        Ln || R !== K)
      ) {
        nn.setValue(te, "projectionMatrix", K.projectionMatrix),
          nn.setValue(te, "viewMatrix", K.matrixWorldInverse);
        const er = nn.map.cameraPosition;
        er !== void 0 &&
          er.setValue(te, oe.setFromMatrixPosition(K.matrixWorld)),
          pe.logarithmicDepthBuffer &&
            nn.setValue(
              te,
              "logDepthBufFC",
              2 / (Math.log(K.far + 1) / Math.LN2)
            ),
          (Te.isMeshPhongMaterial ||
            Te.isMeshToonMaterial ||
            Te.isMeshLambertMaterial ||
            Te.isMeshBasicMaterial ||
            Te.isMeshStandardMaterial ||
            Te.isShaderMaterial) &&
            nn.setValue(te, "isOrthographic", K.isOrthographicCamera === !0),
          R !== K && ((R = K), (yn = !0), (hi = !0));
      }
      if (Re.isSkinnedMesh) {
        nn.setOptional(te, Re, "bindMatrix"),
          nn.setOptional(te, Re, "bindMatrixInverse");
        const er = Re.skeleton;
        er &&
          (er.boneTexture === null && er.computeBoneTexture(),
          nn.setValue(te, "boneTexture", er.boneTexture, Ce));
      }
      Re.isBatchedMesh &&
        (nn.setOptional(te, Re, "batchingTexture"),
        nn.setValue(te, "batchingTexture", Re._matricesTexture, Ce));
      const Kr = Oe.morphAttributes;
      if (
        ((Kr.position !== void 0 ||
          Kr.normal !== void 0 ||
          Kr.color !== void 0) &&
          je.update(Re, Oe, zn),
        (yn || vt.receiveShadow !== Re.receiveShadow) &&
          ((vt.receiveShadow = Re.receiveShadow),
          nn.setValue(te, "receiveShadow", Re.receiveShadow)),
        Te.isMeshGouraudMaterial &&
          Te.envMap !== null &&
          ((un.envMap.value = xt),
          (un.flipEnvMap.value =
            xt.isCubeTexture && xt.isRenderTargetTexture === !1 ? -1 : 1)),
        Te.isMeshStandardMaterial &&
          Te.envMap === null &&
          Se.environment !== null &&
          (un.envMapIntensity.value = Se.environmentIntensity),
        yn &&
          (nn.setValue(te, "toneMappingExposure", S.toneMappingExposure),
          vt.needsLights && In(un, hi),
          Qe && Te.fog === !0 && ce.refreshFogUniforms(un, Qe),
          ce.refreshMaterialUniforms(
            un,
            Te,
            Y,
            G,
            y.state.transmissionRenderTarget[K.id]
          ),
          P0.upload(te, fr(vt), un, Ce)),
        Te.isShaderMaterial &&
          Te.uniformsNeedUpdate === !0 &&
          (P0.upload(te, fr(vt), un, Ce), (Te.uniformsNeedUpdate = !1)),
        Te.isSpriteMaterial && nn.setValue(te, "center", Re.center),
        nn.setValue(te, "modelViewMatrix", Re.modelViewMatrix),
        nn.setValue(te, "normalMatrix", Re.normalMatrix),
        nn.setValue(te, "modelMatrix", Re.matrixWorld),
        Te.isShaderMaterial || Te.isRawShaderMaterial)
      ) {
        const er = Te.uniformsGroups;
        for (let qo = 0, Ko = er.length; qo < Ko; qo++) {
          const Or = er[qo];
          Ve.update(Or, zn), Ve.bind(Or, zn);
        }
      }
      return zn;
    }
    function In(K, Se) {
      (K.ambientLightColor.needsUpdate = Se),
        (K.lightProbe.needsUpdate = Se),
        (K.directionalLights.needsUpdate = Se),
        (K.directionalLightShadows.needsUpdate = Se),
        (K.pointLights.needsUpdate = Se),
        (K.pointLightShadows.needsUpdate = Se),
        (K.spotLights.needsUpdate = Se),
        (K.spotLightShadows.needsUpdate = Se),
        (K.rectAreaLights.needsUpdate = Se),
        (K.hemisphereLights.needsUpdate = Se);
    }
    function br(K) {
      return (
        K.isMeshLambertMaterial ||
        K.isMeshToonMaterial ||
        K.isMeshPhongMaterial ||
        K.isMeshStandardMaterial ||
        K.isShadowMaterial ||
        (K.isShaderMaterial && K.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return C;
    }),
      (this.getActiveMipmapLevel = function () {
        return M;
      }),
      (this.getRenderTarget = function () {
        return T;
      }),
      (this.setRenderTargetTextures = function (K, Se, Oe) {
        (he.get(K.texture).__webglTexture = Se),
          (he.get(K.depthTexture).__webglTexture = Oe);
        const Te = he.get(K);
        (Te.__hasExternalTextures = !0),
          (Te.__autoAllocateDepthBuffer = Oe === void 0),
          Te.__autoAllocateDepthBuffer ||
            (ie.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (Te.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (K, Se) {
        const Oe = he.get(K);
        (Oe.__webglFramebuffer = Se),
          (Oe.__useDefaultFramebuffer = Se === void 0);
      }),
      (this.setRenderTarget = function (K, Se = 0, Oe = 0) {
        (T = K), (C = Se), (M = Oe);
        let Te = !0,
          Re = null,
          Qe = !1,
          ct = !1;
        if (K) {
          const xt = he.get(K);
          xt.__useDefaultFramebuffer !== void 0
            ? (de.bindFramebuffer(te.FRAMEBUFFER, null), (Te = !1))
            : xt.__webglFramebuffer === void 0
            ? Ce.setupRenderTarget(K)
            : xt.__hasExternalTextures &&
              Ce.rebindTextures(
                K,
                he.get(K.texture).__webglTexture,
                he.get(K.depthTexture).__webglTexture
              );
          const Ct = K.texture;
          (Ct.isData3DTexture ||
            Ct.isDataArrayTexture ||
            Ct.isCompressedArrayTexture) &&
            (ct = !0);
          const $e = he.get(K).__webglFramebuffer;
          K.isWebGLCubeRenderTarget
            ? (Array.isArray($e[Se]) ? (Re = $e[Se][Oe]) : (Re = $e[Se]),
              (Qe = !0))
            : K.samples > 0 && Ce.useMultisampledRTT(K) === !1
            ? (Re = he.get(K).__webglMultisampledFramebuffer)
            : Array.isArray($e)
            ? (Re = $e[Oe])
            : (Re = $e),
            E.copy(K.viewport),
            O.copy(K.scissor),
            (D = K.scissorTest);
        } else
          E.copy(W).multiplyScalar(Y).floor(),
            O.copy(B).multiplyScalar(Y).floor(),
            (D = q);
        if (
          (de.bindFramebuffer(te.FRAMEBUFFER, Re) &&
            Te &&
            de.drawBuffers(K, Re),
          de.viewport(E),
          de.scissor(O),
          de.setScissorTest(D),
          Qe)
        ) {
          const xt = he.get(K.texture);
          te.framebufferTexture2D(
            te.FRAMEBUFFER,
            te.COLOR_ATTACHMENT0,
            te.TEXTURE_CUBE_MAP_POSITIVE_X + Se,
            xt.__webglTexture,
            Oe
          );
        } else if (ct) {
          const xt = he.get(K.texture),
            Ct = Se || 0;
          te.framebufferTextureLayer(
            te.FRAMEBUFFER,
            te.COLOR_ATTACHMENT0,
            xt.__webglTexture,
            Oe || 0,
            Ct
          );
        }
        P = -1;
      }),
      (this.readRenderTargetPixels = function (K, Se, Oe, Te, Re, Qe, ct) {
        if (!(K && K.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let nt = he.get(K).__webglFramebuffer;
        if ((K.isWebGLCubeRenderTarget && ct !== void 0 && (nt = nt[ct]), nt)) {
          de.bindFramebuffer(te.FRAMEBUFFER, nt);
          try {
            const xt = K.texture,
              Ct = xt.format,
              $e = xt.type;
            if (!pe.textureFormatReadable(Ct)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!pe.textureTypeReadable($e)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            Se >= 0 &&
              Se <= K.width - Te &&
              Oe >= 0 &&
              Oe <= K.height - Re &&
              te.readPixels(Se, Oe, Te, Re, De.convert(Ct), De.convert($e), Qe);
          } finally {
            const xt = T !== null ? he.get(T).__webglFramebuffer : null;
            de.bindFramebuffer(te.FRAMEBUFFER, xt);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (K, Se, Oe = 0) {
        const Te = Math.pow(2, -Oe),
          Re = Math.floor(Se.image.width * Te),
          Qe = Math.floor(Se.image.height * Te);
        Ce.setTexture2D(Se, 0),
          te.copyTexSubImage2D(te.TEXTURE_2D, Oe, 0, 0, K.x, K.y, Re, Qe),
          de.unbindTexture();
      }),
      (this.copyTextureToTexture = function (K, Se, Oe, Te = 0) {
        const Re = Se.image.width,
          Qe = Se.image.height,
          ct = De.convert(Oe.format),
          nt = De.convert(Oe.type);
        Ce.setTexture2D(Oe, 0),
          te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL, Oe.flipY),
          te.pixelStorei(
            te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Oe.premultiplyAlpha
          ),
          te.pixelStorei(te.UNPACK_ALIGNMENT, Oe.unpackAlignment),
          Se.isDataTexture
            ? te.texSubImage2D(
                te.TEXTURE_2D,
                Te,
                K.x,
                K.y,
                Re,
                Qe,
                ct,
                nt,
                Se.image.data
              )
            : Se.isCompressedTexture
            ? te.compressedTexSubImage2D(
                te.TEXTURE_2D,
                Te,
                K.x,
                K.y,
                Se.mipmaps[0].width,
                Se.mipmaps[0].height,
                ct,
                Se.mipmaps[0].data
              )
            : te.texSubImage2D(te.TEXTURE_2D, Te, K.x, K.y, ct, nt, Se.image),
          Te === 0 && Oe.generateMipmaps && te.generateMipmap(te.TEXTURE_2D),
          de.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (K, Se, Oe, Te, Re = 0) {
        const Qe = K.max.x - K.min.x,
          ct = K.max.y - K.min.y,
          nt = K.max.z - K.min.z,
          xt = De.convert(Te.format),
          Ct = De.convert(Te.type);
        let $e;
        if (Te.isData3DTexture) Ce.setTexture3D(Te, 0), ($e = te.TEXTURE_3D);
        else if (Te.isDataArrayTexture || Te.isCompressedArrayTexture)
          Ce.setTexture2DArray(Te, 0), ($e = te.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL, Te.flipY),
          te.pixelStorei(
            te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Te.premultiplyAlpha
          ),
          te.pixelStorei(te.UNPACK_ALIGNMENT, Te.unpackAlignment);
        const Et = te.getParameter(te.UNPACK_ROW_LENGTH),
          dn = te.getParameter(te.UNPACK_IMAGE_HEIGHT),
          cn = te.getParameter(te.UNPACK_SKIP_PIXELS),
          Xn = te.getParameter(te.UNPACK_SKIP_ROWS),
          Lr = te.getParameter(te.UNPACK_SKIP_IMAGES),
          Nt = Oe.isCompressedTexture ? Oe.mipmaps[Re] : Oe.image;
        te.pixelStorei(te.UNPACK_ROW_LENGTH, Nt.width),
          te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, Nt.height),
          te.pixelStorei(te.UNPACK_SKIP_PIXELS, K.min.x),
          te.pixelStorei(te.UNPACK_SKIP_ROWS, K.min.y),
          te.pixelStorei(te.UNPACK_SKIP_IMAGES, K.min.z),
          Oe.isDataTexture || Oe.isData3DTexture
            ? te.texSubImage3D(
                $e,
                Re,
                Se.x,
                Se.y,
                Se.z,
                Qe,
                ct,
                nt,
                xt,
                Ct,
                Nt.data
              )
            : Te.isCompressedArrayTexture
            ? te.compressedTexSubImage3D(
                $e,
                Re,
                Se.x,
                Se.y,
                Se.z,
                Qe,
                ct,
                nt,
                xt,
                Nt.data
              )
            : te.texSubImage3D(
                $e,
                Re,
                Se.x,
                Se.y,
                Se.z,
                Qe,
                ct,
                nt,
                xt,
                Ct,
                Nt
              ),
          te.pixelStorei(te.UNPACK_ROW_LENGTH, Et),
          te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, dn),
          te.pixelStorei(te.UNPACK_SKIP_PIXELS, cn),
          te.pixelStorei(te.UNPACK_SKIP_ROWS, Xn),
          te.pixelStorei(te.UNPACK_SKIP_IMAGES, Lr),
          Re === 0 && Te.generateMipmaps && te.generateMipmap($e),
          de.unbindTexture();
      }),
      (this.initTexture = function (K) {
        K.isCubeTexture
          ? Ce.setTextureCube(K, 0)
          : K.isData3DTexture
          ? Ce.setTexture3D(K, 0)
          : K.isDataArrayTexture || K.isCompressedArrayTexture
          ? Ce.setTexture2DArray(K, 0)
          : Ce.setTexture2D(K, 0),
          de.unbindTexture();
      }),
      (this.resetState = function () {
        (C = 0), (M = 0), (T = null), de.reset(), ze.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return cs;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    (n.drawingBufferColorSpace = e === ry ? "display-p3" : "srgb"),
      (n.unpackColorSpace =
        rn.workingColorSpace === Ip ? "display-p3" : "srgb");
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class ly {
  constructor(e, n = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new it(e)),
      (this.density = n);
  }
  clone() {
    return new ly(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class cy {
  constructor(e, n = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new it(e)),
      (this.near = n),
      (this.far = r);
  }
  clone() {
    return new cy(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class hE extends Qt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new qi()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new qi()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.fog !== null && (n.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (n.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (n.object.backgroundIntensity = this.backgroundIntensity),
      (n.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (n.object.environmentIntensity = this.environmentIntensity),
      (n.object.environmentRotation = this.environmentRotation.toArray()),
      n
    );
  }
}
class uy {
  constructor(e, n) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.usage = qh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Xi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      mN(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, n, r) {
    (e *= this.stride), (r *= n.stride);
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = n.array[r + i];
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const n = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(n, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Xi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const ri = new ee();
class Ec {
  constructor(e, n, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = n),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let n = 0, r = this.data.count; n < r; n++)
      ri.fromBufferAttribute(this, n),
        ri.applyMatrix4(e),
        this.setXYZ(n, ri.x, ri.y, ri.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, r = this.count; n < r; n++)
      ri.fromBufferAttribute(this, n),
        ri.applyNormalMatrix(e),
        this.setXYZ(n, ri.x, ri.y, ri.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, r = this.count; n < r; n++)
      ri.fromBufferAttribute(this, n),
        ri.transformDirection(e),
        this.setXYZ(n, ri.x, ri.y, ri.z);
    return this;
  }
  getComponent(e, n) {
    let r = this.array[e * this.data.stride + this.offset + n];
    return this.normalized && (r = si(r, this.array)), r;
  }
  setComponent(e, n, r) {
    return (
      this.normalized && (r = Ot(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + n] = r),
      this
    );
  }
  setX(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = n),
      this
    );
  }
  setY(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = n),
      this
    );
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = n),
      this
    );
  }
  setW(e, n) {
    return (
      this.normalized && (n = Ot(n, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = n),
      this
    );
  }
  getX(e) {
    let n = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (n = si(n, this.array)), n;
  }
  getY(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (n = si(n, this.array)), n;
  }
  getZ(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (n = si(n, this.array)), n;
  }
  getW(e) {
    let n = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (n = si(n, this.array)), n;
  }
  setXY(e, n, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((n = Ot(n, this.array)), (r = Ot(r, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, n, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, n, r, i, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((n = Ot(n, this.array)),
        (r = Ot(r, this.array)),
        (i = Ot(i, this.array)),
        (o = Ot(o, this.array))),
      (this.data.array[e + 0] = n),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = o),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o]);
      }
      return new sn(
        new this.array.constructor(n),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Ec(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const n = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++) n.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: n,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class pE extends qr {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let xu;
const Rd = new ee(),
  _u = new ee(),
  Su = new ee(),
  Au = new ke(),
  Pd = new ke(),
  IN = new wt(),
  Sg = new ee(),
  Id = new ee(),
  Ag = new ee(),
  BT = new ke(),
  n_ = new ke(),
  HT = new ke();
class LN extends Qt {
  constructor(e = new pE()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), xu === void 0)
    ) {
      xu = new Ut();
      const n = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new uy(n, 5);
      xu.setIndex([0, 1, 2, 0, 2, 3]),
        xu.setAttribute("position", new Ec(r, 3, 0, !1)),
        xu.setAttribute("uv", new Ec(r, 2, 3, !1));
    }
    (this.geometry = xu), (this.material = e), (this.center = new ke(0.5, 0.5));
  }
  raycast(e, n) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _u.setFromMatrixScale(this.matrixWorld),
      IN.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Su.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _u.multiplyScalar(-Su.z);
    const r = this.material.rotation;
    let i, o;
    r !== 0 && ((o = Math.cos(r)), (i = Math.sin(r)));
    const s = this.center;
    bg(Sg.set(-0.5, -0.5, 0), Su, s, _u, i, o),
      bg(Id.set(0.5, -0.5, 0), Su, s, _u, i, o),
      bg(Ag.set(0.5, 0.5, 0), Su, s, _u, i, o),
      BT.set(0, 0),
      n_.set(1, 0),
      HT.set(1, 1);
    let a = e.ray.intersectTriangle(Sg, Id, Ag, !1, Rd);
    if (
      a === null &&
      (bg(Id.set(-0.5, 0.5, 0), Su, s, _u, i, o),
      n_.set(0, 1),
      (a = e.ray.intersectTriangle(Sg, Ag, Id, !1, Rd)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Rd);
    l < e.near ||
      l > e.far ||
      n.push({
        distance: l,
        point: Rd.clone(),
        uv: Gi.getInterpolation(Rd, Sg, Id, Ag, BT, n_, HT, new ke()),
        face: null,
        object: this,
      });
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function bg(t, e, n, r, i, o) {
  Au.subVectors(t, n).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((Pd.x = o * Au.x - i * Au.y), (Pd.y = i * Au.x + o * Au.y))
      : Pd.copy(Au),
    t.copy(e),
    (t.x += Pd.x),
    (t.y += Pd.y),
    t.applyMatrix4(IN);
}
const wg = new ee(),
  VT = new ee();
class ON extends Qt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const n = e.levels;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = n[r];
      this.addLevel(o.object.clone(), o.distance, o.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, n = 0, r = 0) {
    n = Math.abs(n);
    const i = this.levels;
    let o;
    for (o = 0; o < i.length && !(n < i[o].distance); o++);
    return (
      i.splice(o, 0, { distance: n, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const n = this.levels;
    if (n.length > 0) {
      let r, i;
      for (r = 1, i = n.length; r < i; r++) {
        let o = n[r].distance;
        if ((n[r].object.visible && (o -= o * n[r].hysteresis), e < o)) break;
      }
      return n[r - 1].object;
    }
    return null;
  }
  raycast(e, n) {
    if (this.levels.length > 0) {
      wg.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(wg);
      this.getObjectForDistance(i).raycast(e, n);
    }
  }
  update(e) {
    const n = this.levels;
    if (n.length > 1) {
      wg.setFromMatrixPosition(e.matrixWorld),
        VT.setFromMatrixPosition(this.matrixWorld);
      const r = wg.distanceTo(VT) / e.zoom;
      n[0].object.visible = !0;
      let i, o;
      for (i = 1, o = n.length; i < o; i++) {
        let s = n[i].distance;
        if ((n[i].object.visible && (s -= s * n[i].hysteresis), r >= s))
          (n[i - 1].object.visible = !1), (n[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < o; i++) n[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const n = super.toJSON(e);
    this.autoUpdate === !1 && (n.object.autoUpdate = !1),
      (n.object.levels = []);
    const r = this.levels;
    for (let i = 0, o = r.length; i < o; i++) {
      const s = r[i];
      n.object.levels.push({
        object: s.object.uuid,
        distance: s.distance,
        hysteresis: s.hysteresis,
      });
    }
    return n;
  }
}
const GT = new ee(),
  WT = new tn(),
  jT = new tn(),
  dW = new ee(),
  $T = new wt(),
  Eg = new ee(),
  r_ = new Pr(),
  XT = new wt(),
  i_ = new Oc();
class NN extends Cn {
  constructor(e, n) {
    super(e, n),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = rA),
      (this.bindMatrix = new wt()),
      (this.bindMatrixInverse = new wt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Rr()),
      this.boundingBox.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, Eg), this.boundingBox.expandByPoint(Eg);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Pr()),
      this.boundingSphere.makeEmpty();
    const n = e.getAttribute("position");
    for (let r = 0; r < n.count; r++)
      this.getVertexPosition(r, Eg), this.boundingSphere.expandByPoint(Eg);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, n) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      r_.copy(this.boundingSphere),
      r_.applyMatrix4(i),
      e.ray.intersectsSphere(r_) !== !1 &&
        (XT.copy(i).invert(),
        i_.copy(e.ray).applyMatrix4(XT),
        !(
          this.boundingBox !== null && i_.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, n, i_)));
  }
  getVertexPosition(e, n) {
    return super.getVertexPosition(e, n), this.applyBoneTransform(e, n), n;
  }
  bind(e, n) {
    (this.skeleton = e),
      n === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (n = this.matrixWorld)),
      this.bindMatrix.copy(n),
      this.bindMatrixInverse.copy(n).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new tn(),
      n = this.geometry.attributes.skinWeight;
    for (let r = 0, i = n.count; r < i; r++) {
      e.fromBufferAttribute(n, r);
      const o = 1 / e.manhattanLength();
      o !== 1 / 0 ? e.multiplyScalar(o) : e.set(1, 0, 0, 0),
        n.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === rA
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === GO
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, n) {
    const r = this.skeleton,
      i = this.geometry;
    WT.fromBufferAttribute(i.attributes.skinIndex, e),
      jT.fromBufferAttribute(i.attributes.skinWeight, e),
      GT.copy(n).applyMatrix4(this.bindMatrix),
      n.set(0, 0, 0);
    for (let o = 0; o < 4; o++) {
      const s = jT.getComponent(o);
      if (s !== 0) {
        const a = WT.getComponent(o);
        $T.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          n.addScaledVector(dW.copy(GT).applyMatrix4($T), s);
      }
    }
    return n.applyMatrix4(this.bindMatrixInverse);
  }
}
class mE extends Qt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Ka extends lr {
  constructor(e = null, n = 1, r = 1, i, o, s, a, l, c = xr, u = xr, d, p) {
    super(null, s, a, l, c, u, i, o, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: n, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const YT = new wt(),
  hW = new wt();
class fy {
  constructor(e = [], n = []) {
    (this.uuid = Xi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = n),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      n = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), n.length === 0))
      this.calculateInverses();
    else if (e.length !== n.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new wt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = new wt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      n = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let o = 0, s = e.length; o < s; o++) {
      const a = e[o] ? e[o].matrixWorld : hW;
      YT.multiplyMatrices(a, n[o]), YT.toArray(r, o * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new fy(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4);
    n.set(this.boneMatrices);
    const r = new Ka(n, e, e, Si, yo);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = n),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let n = 0, r = this.bones.length; n < r; n++) {
      const i = this.bones[n];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, n) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const o = e.bones[r];
      let s = n[o];
      s === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", o),
        (s = new mE())),
        this.bones.push(s),
        this.boneInverses.push(new wt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const n = this.bones,
      r = this.boneInverses;
    for (let i = 0, o = n.length; i < o; i++) {
      const s = n[i];
      e.bones.push(s.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Mc extends sn {
  constructor(e, n, r, i = 1) {
    super(e, n, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const bu = new wt(),
  qT = new wt(),
  Mg = [],
  KT = new Rr(),
  pW = new wt(),
  Ld = new Cn(),
  Od = new Pr();
class DN extends Cn {
  constructor(e, n, r) {
    super(e, n),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Mc(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, pW);
  }
  computeBoundingBox() {
    const e = this.geometry,
      n = this.count;
    this.boundingBox === null && (this.boundingBox = new Rr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, bu),
        KT.copy(e.boundingBox).applyMatrix4(bu),
        this.boundingBox.union(KT);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      n = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Pr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < n; r++)
      this.getMatrixAt(r, bu),
        Od.copy(e.boundingSphere).applyMatrix4(bu),
        this.boundingSphere.union(Od);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, n) {
    n.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, n) {
    n.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, n) {
    const r = n.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      o = r.length + 1,
      s = e * o + 1;
    for (let a = 0; a < r.length; a++) r[a] = i[s + a];
  }
  raycast(e, n) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((Ld.geometry = this.geometry),
      (Ld.material = this.material),
      Ld.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Od.copy(this.boundingSphere),
        Od.applyMatrix4(r),
        e.ray.intersectsSphere(Od) !== !1))
    )
      for (let o = 0; o < i; o++) {
        this.getMatrixAt(o, bu),
          qT.multiplyMatrices(r, bu),
          (Ld.matrixWorld = qT),
          Ld.raycast(e, Mg);
        for (let s = 0, a = Mg.length; s < a; s++) {
          const l = Mg[s];
          (l.instanceId = o), (l.object = this), n.push(l);
        }
        Mg.length = 0;
      }
  }
  setColorAt(e, n) {
    this.instanceColor === null &&
      (this.instanceColor = new Mc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      n.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, n) {
    n.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, n) {
    const r = n.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Ka(
        new Float32Array(i * this.count),
        i,
        this.count,
        Qw,
        yo
      ));
    const o = this.morphTexture.source.data.data;
    let s = 0;
    for (let c = 0; c < r.length; c++) s += r[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
      l = i * e;
    (o[l] = a), o.set(r, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function mW(t, e) {
  return t.z - e.z;
}
function gW(t, e) {
  return e.z - t.z;
}
class vW {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, n) {
    const r = this.pool,
      i = this.list;
    this.index >= r.length && r.push({ start: -1, count: -1, z: -1 });
    const o = r[this.index];
    i.push(o),
      this.index++,
      (o.start = e.start),
      (o.count = e.count),
      (o.z = n);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const wu = "batchId",
  Ca = new wt(),
  ZT = new wt(),
  yW = new wt(),
  JT = new wt(),
  o_ = new Np(),
  Cg = new Rr(),
  Dl = new Pr(),
  Nd = new ee(),
  s_ = new vW(),
  Vr = new Cn(),
  Tg = [];
function xW(t, e, n = 0) {
  const r = e.itemSize;
  if (
    t.isInterleavedBufferAttribute ||
    t.array.constructor !== e.array.constructor
  ) {
    const i = t.count;
    for (let o = 0; o < i; o++)
      for (let s = 0; s < r; s++)
        e.setComponent(o + n, s, t.getComponent(o, s));
  } else e.array.set(t.array, n * r);
  e.needsUpdate = !0;
}
class FN extends Cn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, n, r = n * 2, i) {
    super(new Ut(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = n),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const n = new Float32Array(e * e * 4),
      r = new Ka(n, e, e, Si, yo);
    this._matricesTexture = r;
  }
  _initializeGeometry(e) {
    const n = this.geometry,
      r = this._maxVertexCount,
      i = this._maxGeometryCount,
      o = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a),
          { array: c, itemSize: u, normalized: d } = l,
          p = new c.constructor(r * u),
          m = new sn(p, u, d);
        n.setAttribute(a, m);
      }
      if (e.getIndex() !== null) {
        const a = r > 65536 ? new Uint32Array(o) : new Uint16Array(o);
        n.setIndex(new sn(a, 1));
      }
      const s = i > 65536 ? new Uint32Array(r) : new Uint16Array(r);
      n.setAttribute(wu, new sn(s, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(wu))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${wu}"`);
    const n = this.geometry;
    if (!!e.getIndex() != !!n.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in n.attributes) {
      if (r === wu) continue;
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        o = n.getAttribute(r);
      if (i.itemSize !== o.itemSize || i.normalized !== o.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rr());
    const e = this._geometryCount,
      n = this.boundingBox,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, Ca),
        this.getBoundingBoxAt(i, Cg).applyMatrix4(Ca),
        n.union(Cg));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Pr());
    const e = this._geometryCount,
      n = this.boundingSphere,
      r = this._active;
    n.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, Ca),
        this.getBoundingSphereAt(i, Dl).applyMatrix4(Ca),
        n.union(Dl));
  }
  addGeometry(e, n = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let o = null;
    const s = this._reservedRanges,
      a = this._drawRanges,
      l = this._bounds;
    this._geometryCount !== 0 && (o = s[s.length - 1]),
      n === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = n),
      o === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = o.vertexStart + o.vertexCount);
    const c = e.getIndex(),
      u = c !== null;
    if (
      (u &&
        (r === -1 ? (i.indexCount = c.count) : (i.indexCount = r),
        o === null
          ? (i.indexStart = 0)
          : (i.indexStart = o.indexStart + o.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const d = this._visibility,
      p = this._active,
      m = this._matricesTexture,
      v = this._matricesTexture.image.data;
    d.push(!0), p.push(!0);
    const _ = this._geometryCount;
    this._geometryCount++,
      yW.toArray(v, _ * 16),
      (m.needsUpdate = !0),
      s.push(i),
      a.push({ start: u ? i.indexStart : i.vertexStart, count: -1 }),
      l.push({
        boxInitialized: !1,
        box: new Rr(),
        sphereInitialized: !1,
        sphere: new Pr(),
      });
    const y = this.geometry.getAttribute(wu);
    for (let g = 0; g < i.vertexCount; g++) y.setX(i.vertexStart + g, _);
    return (y.needsUpdate = !0), this.setGeometryAt(_, e), _;
  }
  setGeometryAt(e, n) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(n);
    const r = this.geometry,
      i = r.getIndex() !== null,
      o = r.getIndex(),
      s = n.getIndex(),
      a = this._reservedRanges[e];
    if (
      (i && s.count > a.indexCount) ||
      n.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = a.vertexStart,
      c = a.vertexCount;
    for (const m in r.attributes) {
      if (m === wu) continue;
      const v = n.getAttribute(m),
        _ = r.getAttribute(m);
      xW(v, _, l);
      const y = v.itemSize;
      for (let g = v.count, x = c; g < x; g++) {
        const S = l + g;
        for (let b = 0; b < y; b++) _.setComponent(S, b, 0);
      }
      (_.needsUpdate = !0), _.addUpdateRange(l * y, c * y);
    }
    if (i) {
      const m = a.indexStart;
      for (let v = 0; v < s.count; v++) o.setX(m + v, l + s.getX(v));
      for (let v = s.count, _ = a.indexCount; v < _; v++) o.setX(m + v, l);
      (o.needsUpdate = !0), o.addUpdateRange(m, a.indexCount);
    }
    const u = this._bounds[e];
    n.boundingBox !== null
      ? (u.box.copy(n.boundingBox), (u.boxInitialized = !0))
      : (u.boxInitialized = !1),
      n.boundingSphere !== null
        ? (u.sphere.copy(n.boundingSphere), (u.sphereInitialized = !0))
        : (u.sphereInitialized = !1);
    const d = this._drawRanges[e],
      p = n.getAttribute("position");
    return (d.count = i ? s.count : p.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const n = this._active;
    return e >= n.length || n[e] === !1
      ? this
      : ((n[e] = !1), (this._visibilityChanged = !0), this);
  }
  getInstanceCountAt(e) {
    return this._multiDrawInstances === null
      ? null
      : this._multiDrawInstances[e];
  }
  setInstanceCountAt(e, n) {
    return (
      this._multiDrawInstances === null &&
        (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(
          1
        )),
      (this._multiDrawInstances[e] = n),
      e
    );
  }
  getBoundingBoxAt(e, n) {
    if (this._active[e] === !1) return null;
    const i = this._bounds[e],
      o = i.box,
      s = this.geometry;
    if (i.boxInitialized === !1) {
      o.makeEmpty();
      const a = s.index,
        l = s.attributes.position,
        c = this._drawRanges[e];
      for (let u = c.start, d = c.start + c.count; u < d; u++) {
        let p = u;
        a && (p = a.getX(p)), o.expandByPoint(Nd.fromBufferAttribute(l, p));
      }
      i.boxInitialized = !0;
    }
    return n.copy(o), n;
  }
  getBoundingSphereAt(e, n) {
    if (this._active[e] === !1) return null;
    const i = this._bounds[e],
      o = i.sphere,
      s = this.geometry;
    if (i.sphereInitialized === !1) {
      o.makeEmpty(), this.getBoundingBoxAt(e, Cg), Cg.getCenter(o.center);
      const a = s.index,
        l = s.attributes.position,
        c = this._drawRanges[e];
      let u = 0;
      for (let d = c.start, p = c.start + c.count; d < p; d++) {
        let m = d;
        a && (m = a.getX(m)),
          Nd.fromBufferAttribute(l, m),
          (u = Math.max(u, o.center.distanceToSquared(Nd)));
      }
      (o.radius = Math.sqrt(u)), (i.sphereInitialized = !0);
    }
    return n.copy(o), n;
  }
  setMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture,
      o = this._matricesTexture.image.data,
      s = this._geometryCount;
    return e >= s || r[e] === !1
      ? this
      : (n.toArray(o, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, n) {
    const r = this._active,
      i = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || r[e] === !1 ? null : n.fromArray(i, e * 16);
  }
  setVisibleAt(e, n) {
    const r = this._visibility,
      i = this._active,
      o = this._geometryCount;
    return e >= o || i[e] === !1 || r[e] === n
      ? this
      : ((r[e] = n), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const n = this._visibility,
      r = this._active,
      i = this._geometryCount;
    return e >= i || r[e] === !1 ? !1 : n[e];
  }
  raycast(e, n) {
    const r = this._visibility,
      i = this._active,
      o = this._drawRanges,
      s = this._geometryCount,
      a = this.matrixWorld,
      l = this.geometry;
    (Vr.material = this.material),
      (Vr.geometry.index = l.index),
      (Vr.geometry.attributes = l.attributes),
      Vr.geometry.boundingBox === null && (Vr.geometry.boundingBox = new Rr()),
      Vr.geometry.boundingSphere === null &&
        (Vr.geometry.boundingSphere = new Pr());
    for (let c = 0; c < s; c++) {
      if (!r[c] || !i[c]) continue;
      const u = o[c];
      Vr.geometry.setDrawRange(u.start, u.count),
        this.getMatrixAt(c, Vr.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(c, Vr.geometry.boundingBox),
        this.getBoundingSphereAt(c, Vr.geometry.boundingSphere),
        Vr.raycast(e, Tg);
      for (let d = 0, p = Tg.length; d < p; d++) {
        const m = Tg[d];
        (m.object = this), (m.batchId = c), n.push(m);
      }
      Tg.length = 0;
    }
    (Vr.material = null),
      (Vr.geometry.index = null),
      (Vr.geometry.attributes = {}),
      Vr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((n) => ({ ...n }))),
      (this._reservedRanges = e._reservedRanges.map((n) => ({ ...n }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((n) => ({
        boxInitialized: n.boxInitialized,
        box: n.box.clone(),
        sphereInitialized: n.sphereInitialized,
        sphere: n.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, n, r, i, o) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const s = i.getIndex(),
      a = s === null ? 1 : s.array.BYTES_PER_ELEMENT,
      l = this._active,
      c = this._visibility,
      u = this._multiDrawStarts,
      d = this._multiDrawCounts,
      p = this._drawRanges,
      m = this.perObjectFrustumCulled;
    m &&
      (JT.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      o_.setFromProjectionMatrix(JT, e.coordinateSystem));
    let v = 0;
    if (this.sortObjects) {
      ZT.copy(this.matrixWorld).invert(),
        Nd.setFromMatrixPosition(r.matrixWorld).applyMatrix4(ZT);
      for (let g = 0, x = c.length; g < x; g++)
        if (c[g] && l[g]) {
          this.getMatrixAt(g, Ca),
            this.getBoundingSphereAt(g, Dl).applyMatrix4(Ca);
          let S = !1;
          if ((m && (S = !o_.intersectsSphere(Dl)), !S)) {
            const b = Nd.distanceTo(Dl.center);
            s_.push(p[g], b);
          }
        }
      const _ = s_.list,
        y = this.customSort;
      y === null ? _.sort(o.transparent ? gW : mW) : y.call(this, _, r);
      for (let g = 0, x = _.length; g < x; g++) {
        const S = _[g];
        (u[v] = S.start * a), (d[v] = S.count), v++;
      }
      s_.reset();
    } else
      for (let _ = 0, y = c.length; _ < y; _++)
        if (c[_] && l[_]) {
          let g = !1;
          if (
            (m &&
              (this.getMatrixAt(_, Ca),
              this.getBoundingSphereAt(_, Dl).applyMatrix4(Ca),
              (g = !o_.intersectsSphere(Dl))),
            !g)
          ) {
            const x = p[_];
            (u[v] = x.start * a), (d[v] = x.count), v++;
          }
        }
    (this._multiDrawCount = v), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, n, r, i, o, s) {
    this.onBeforeRender(e, null, i, o, s);
  }
}
class fi extends qr {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const mv = new ee(),
  gv = new ee(),
  QT = new wt(),
  Dd = new Oc(),
  Rg = new Pr(),
  a_ = new ee(),
  eR = new ee();
class nl extends Qt {
  constructor(e = new Ut(), n = new fi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [0];
      for (let i = 1, o = n.count; i < o; i++)
        mv.fromBufferAttribute(n, i - 1),
          gv.fromBufferAttribute(n, i),
          (r[i] = r[i - 1]),
          (r[i] += mv.distanceTo(gv));
      e.setAttribute("lineDistance", new dt(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Line.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Rg.copy(r.boundingSphere),
      Rg.applyMatrix4(i),
      (Rg.radius += o),
      e.ray.intersectsSphere(Rg) === !1)
    )
      return;
    QT.copy(i).invert(), Dd.copy(e.ray).applyMatrix4(QT);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = r.index,
      p = r.attributes.position;
    if (u !== null) {
      const m = Math.max(0, s.start),
        v = Math.min(u.count, s.start + s.count);
      for (let _ = m, y = v - 1; _ < y; _ += c) {
        const g = u.getX(_),
          x = u.getX(_ + 1),
          S = Pg(this, e, Dd, l, g, x);
        S && n.push(S);
      }
      if (this.isLineLoop) {
        const _ = u.getX(v - 1),
          y = u.getX(m),
          g = Pg(this, e, Dd, l, _, y);
        g && n.push(g);
      }
    } else {
      const m = Math.max(0, s.start),
        v = Math.min(p.count, s.start + s.count);
      for (let _ = m, y = v - 1; _ < y; _ += c) {
        const g = Pg(this, e, Dd, l, _, _ + 1);
        g && n.push(g);
      }
      if (this.isLineLoop) {
        const _ = Pg(this, e, Dd, l, v - 1, m);
        _ && n.push(_);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
}
function Pg(t, e, n, r, i, o) {
  const s = t.geometry.attributes.position;
  if (
    (mv.fromBufferAttribute(s, i),
    gv.fromBufferAttribute(s, o),
    n.distanceSqToSegment(mv, gv, a_, eR) > r)
  )
    return;
  a_.applyMatrix4(t.matrixWorld);
  const l = e.ray.origin.distanceTo(a_);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: eR.clone().applyMatrix4(t.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: t,
    };
}
const tR = new ee(),
  nR = new ee();
class xs extends nl {
  constructor(e, n) {
    super(e, n), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position,
        r = [];
      for (let i = 0, o = n.count; i < o; i += 2)
        tR.fromBufferAttribute(n, i),
          nR.fromBufferAttribute(n, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + tR.distanceTo(nR));
      e.setAttribute("lineDistance", new dt(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class UN extends nl {
  constructor(e, n) {
    super(e, n), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class gE extends qr {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const rR = new wt(),
  NA = new Oc(),
  Ig = new Pr(),
  Lg = new ee();
class kN extends Qt {
  constructor(e = new Ut(), n = new gE()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, n) {
    const r = this.geometry,
      i = this.matrixWorld,
      o = e.params.Points.threshold,
      s = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Ig.copy(r.boundingSphere),
      Ig.applyMatrix4(i),
      (Ig.radius += o),
      e.ray.intersectsSphere(Ig) === !1)
    )
      return;
    rR.copy(i).invert(), NA.copy(e.ray).applyMatrix4(rR);
    const a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = r.index,
      d = r.attributes.position;
    if (c !== null) {
      const p = Math.max(0, s.start),
        m = Math.min(c.count, s.start + s.count);
      for (let v = p, _ = m; v < _; v++) {
        const y = c.getX(v);
        Lg.fromBufferAttribute(d, y), iR(Lg, y, l, i, e, n, this);
      }
    } else {
      const p = Math.max(0, s.start),
        m = Math.min(d.count, s.start + s.count);
      for (let v = p, _ = m; v < _; v++)
        Lg.fromBufferAttribute(d, v), iR(Lg, v, l, i, e, n, this);
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      r = Object.keys(n);
    if (r.length > 0) {
      const i = n[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let o = 0, s = i.length; o < s; o++) {
          const a = i[o].name || String(o);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = o);
        }
      }
    }
  }
}
function iR(t, e, n, r, i, o, s) {
  const a = NA.distanceSqToPoint(t);
  if (a < n) {
    const l = new ee();
    NA.closestPointToPoint(t, l), l.applyMatrix4(r);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    o.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: s,
    });
  }
}
class _W extends lr {
  constructor(e, n, r, i, o, s, a, l, c) {
    super(e, n, r, i, o, s, a, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = s !== void 0 ? s : kn),
      (this.magFilter = o !== void 0 ? o : kn),
      (this.generateMipmaps = !1);
    const u = this;
    function d() {
      (u.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class SW extends lr {
  constructor(e, n) {
    super({ width: e, height: n }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = xr),
      (this.minFilter = xr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class dy extends lr {
  constructor(e, n, r, i, o, s, a, l, c, u, d, p) {
    super(null, s, a, l, c, u, i, o, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: n, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class AW extends dy {
  constructor(e, n, r, i, o, s) {
    super(e, n, r, o, s),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = vo);
  }
}
class bW extends dy {
  constructor(e, n, r) {
    super(void 0, e[0].width, e[0].height, n, r, Qs),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class wW extends lr {
  constructor(e, n, r, i, o, s, a, l, c) {
    super(e, n, r, i, o, s, a, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Xo {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, n);
  }
  getPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return n;
  }
  getSpacedPoints(e = 5) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPointAt(r / e));
    return n;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let r,
      i = this.getPoint(0),
      o = 0;
    n.push(0);
    for (let s = 1; s <= e; s++)
      (r = this.getPoint(s / e)), (o += r.distanceTo(i)), n.push(o), (i = r);
    return (this.cacheArcLengths = n), n;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, n) {
    const r = this.getLengths();
    let i = 0;
    const o = r.length;
    let s;
    n ? (s = n) : (s = e * r[o - 1]);
    let a = 0,
      l = o - 1,
      c;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (c = r[i] - s), c < 0)) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === s)) return i / (o - 1);
    const u = r[i],
      p = r[i + 1] - u,
      m = (s - u) / p;
    return (i + m) / (o - 1);
  }
  getTangent(e, n) {
    let i = e - 1e-4,
      o = e + 1e-4;
    i < 0 && (i = 0), o > 1 && (o = 1);
    const s = this.getPoint(i),
      a = this.getPoint(o),
      l = n || (s.isVector2 ? new ke() : new ee());
    return l.copy(a).sub(s).normalize(), l;
  }
  getTangentAt(e, n) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, n);
  }
  computeFrenetFrames(e, n) {
    const r = new ee(),
      i = [],
      o = [],
      s = [],
      a = new ee(),
      l = new wt();
    for (let m = 0; m <= e; m++) {
      const v = m / e;
      i[m] = this.getTangentAt(v, new ee());
    }
    (o[0] = new ee()), (s[0] = new ee());
    let c = Number.MAX_VALUE;
    const u = Math.abs(i[0].x),
      d = Math.abs(i[0].y),
      p = Math.abs(i[0].z);
    u <= c && ((c = u), r.set(1, 0, 0)),
      d <= c && ((c = d), r.set(0, 1, 0)),
      p <= c && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      o[0].crossVectors(i[0], a),
      s[0].crossVectors(i[0], o[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((o[m] = o[m - 1].clone()),
        (s[m] = s[m - 1].clone()),
        a.crossVectors(i[m - 1], i[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const v = Math.acos(Un(i[m - 1].dot(i[m]), -1, 1));
        o[m].applyMatrix4(l.makeRotationAxis(a, v));
      }
      s[m].crossVectors(i[m], o[m]);
    }
    if (n === !0) {
      let m = Math.acos(Un(o[0].dot(o[e]), -1, 1));
      (m /= e), i[0].dot(a.crossVectors(o[0], o[e])) > 0 && (m = -m);
      for (let v = 1; v <= e; v++)
        o[v].applyMatrix4(l.makeRotationAxis(i[v], m * v)),
          s[v].crossVectors(i[v], o[v]);
    }
    return { tangents: i, normals: o, binormals: s };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class hy extends Xo {
  constructor(
    e = 0,
    n = 0,
    r = 1,
    i = 1,
    o = 0,
    s = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = n),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = o),
      (this.aEndAngle = s),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, n = new ke()) {
    const r = n,
      i = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const s = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += i;
    for (; o > i; ) o -= i;
    o < Number.EPSILON && (s ? (o = 0) : (o = i)),
      this.aClockwise === !0 && !s && (o === i ? (o = -i) : (o = o - i));
    const a = this.aStartAngle + e * o;
    let l = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = c - this.aY;
      (l = p * u - m * d + this.aX), (c = p * d + m * u + this.aY);
    }
    return r.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class zN extends hy {
  constructor(e, n, r, i, o, s) {
    super(e, n, r, r, i, o, s),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function vE() {
  let t = 0,
    e = 0,
    n = 0,
    r = 0;
  function i(o, s, a, l) {
    (t = o),
      (e = a),
      (n = -3 * o + 3 * s - 2 * a - l),
      (r = 2 * o - 2 * s + a + l);
  }
  return {
    initCatmullRom: function (o, s, a, l, c) {
      i(s, a, c * (a - o), c * (l - s));
    },
    initNonuniformCatmullRom: function (o, s, a, l, c, u, d) {
      let p = (s - o) / c - (a - o) / (c + u) + (a - s) / u,
        m = (a - s) / u - (l - s) / (u + d) + (l - a) / d;
      (p *= u), (m *= u), i(s, a, p, m);
    },
    calc: function (o) {
      const s = o * o,
        a = s * o;
      return t + e * o + n * s + r * a;
    },
  };
}
const Og = new ee(),
  l_ = new vE(),
  c_ = new vE(),
  u_ = new vE();
class BN extends Xo {
  constructor(e = [], n = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = n),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, n = new ee()) {
    const r = n,
      i = this.points,
      o = i.length,
      s = (o - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(s),
      l = s - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / o) + 1) * o)
      : l === 0 && a === o - 1 && ((a = o - 2), (l = 1));
    let c, u;
    this.closed || a > 0
      ? (c = i[(a - 1) % o])
      : (Og.subVectors(i[0], i[1]).add(i[0]), (c = Og));
    const d = i[a % o],
      p = i[(a + 1) % o];
    if (
      (this.closed || a + 2 < o
        ? (u = i[(a + 2) % o])
        : (Og.subVectors(i[o - 1], i[o - 2]).add(i[o - 1]), (u = Og)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(c.distanceToSquared(d), m),
        _ = Math.pow(d.distanceToSquared(p), m),
        y = Math.pow(p.distanceToSquared(u), m);
      _ < 1e-4 && (_ = 1),
        v < 1e-4 && (v = _),
        y < 1e-4 && (y = _),
        l_.initNonuniformCatmullRom(c.x, d.x, p.x, u.x, v, _, y),
        c_.initNonuniformCatmullRom(c.y, d.y, p.y, u.y, v, _, y),
        u_.initNonuniformCatmullRom(c.z, d.z, p.z, u.z, v, _, y);
    } else
      this.curveType === "catmullrom" &&
        (l_.initCatmullRom(c.x, d.x, p.x, u.x, this.tension),
        c_.initCatmullRom(c.y, d.y, p.y, u.y, this.tension),
        u_.initCatmullRom(c.z, d.z, p.z, u.z, this.tension));
    return r.set(l_.calc(l), c_.calc(l), u_.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new ee().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function oR(t, e, n, r, i) {
  const o = (r - e) * 0.5,
    s = (i - n) * 0.5,
    a = t * t,
    l = t * a;
  return (
    (2 * n - 2 * r + o + s) * l + (-3 * n + 3 * r - 2 * o - s) * a + o * t + n
  );
}
function EW(t, e) {
  const n = 1 - t;
  return n * n * e;
}
function MW(t, e) {
  return 2 * (1 - t) * t * e;
}
function CW(t, e) {
  return t * t * e;
}
function hh(t, e, n, r) {
  return EW(t, e) + MW(t, n) + CW(t, r);
}
function TW(t, e) {
  const n = 1 - t;
  return n * n * n * e;
}
function RW(t, e) {
  const n = 1 - t;
  return 3 * n * n * t * e;
}
function PW(t, e) {
  return 3 * (1 - t) * t * t * e;
}
function IW(t, e) {
  return t * t * t * e;
}
function ph(t, e, n, r, i) {
  return TW(t, e) + RW(t, n) + PW(t, r) + IW(t, i);
}
class yE extends Xo {
  constructor(e = new ke(), n = new ke(), r = new ke(), i = new ke()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new ke()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      a = this.v3;
    return r.set(ph(e, i.x, o.x, s.x, a.x), ph(e, i.y, o.y, s.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class HN extends Xo {
  constructor(e = new ee(), n = new ee(), r = new ee(), i = new ee()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, n = new ee()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      s = this.v2,
      a = this.v3;
    return (
      r.set(
        ph(e, i.x, o.x, s.x, a.x),
        ph(e, i.y, o.y, s.y, a.y),
        ph(e, i.z, o.z, s.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class xE extends Xo {
  constructor(e = new ke(), n = new ke()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new ke()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new ke()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class VN extends Xo {
  constructor(e = new ee(), n = new ee()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(e, n = new ee()) {
    const r = n;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new ee()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class _E extends Xo {
  constructor(e = new ke(), n = new ke(), r = new ke()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new ke()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return r.set(hh(e, i.x, o.x, s.x), hh(e, i.y, o.y, s.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class SE extends Xo {
  constructor(e = new ee(), n = new ee(), r = new ee()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = n),
      (this.v2 = r);
  }
  getPoint(e, n = new ee()) {
    const r = n,
      i = this.v0,
      o = this.v1,
      s = this.v2;
    return (
      r.set(hh(e, i.x, o.x, s.x), hh(e, i.y, o.y, s.y), hh(e, i.z, o.z, s.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class AE extends Xo {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, n = new ke()) {
    const r = n,
      i = this.points,
      o = (i.length - 1) * e,
      s = Math.floor(o),
      a = o - s,
      l = i[s === 0 ? s : s - 1],
      c = i[s],
      u = i[s > i.length - 2 ? i.length - 1 : s + 1],
      d = i[s > i.length - 3 ? i.length - 1 : s + 2];
    return r.set(oR(a, l.x, c.x, u.x, d.x), oR(a, l.y, c.y, u.y, d.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, r = this.points.length; n < r; n++) {
      const i = this.points[n];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let n = 0, r = e.points.length; n < r; n++) {
      const i = e.points[n];
      this.points.push(new ke().fromArray(i));
    }
    return this;
  }
}
var vv = Object.freeze({
  __proto__: null,
  ArcCurve: zN,
  CatmullRomCurve3: BN,
  CubicBezierCurve: yE,
  CubicBezierCurve3: HN,
  EllipseCurve: hy,
  LineCurve: xE,
  LineCurve3: VN,
  QuadraticBezierCurve: _E,
  QuadraticBezierCurve3: SE,
  SplineCurve: AE,
});
class GN extends Xo {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new vv[r](n, e));
    }
    return this;
  }
  getPoint(e, n) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let o = 0;
    for (; o < i.length; ) {
      if (i[o] >= r) {
        const s = i[o] - r,
          a = this.curves[o],
          l = a.getLength(),
          c = l === 0 ? 0 : 1 - s / l;
        return a.getPointAt(c, n);
      }
      o++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (n += this.curves[r].getLength()), e.push(n);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let r = 0; r <= e; r++) n.push(this.getPoint(r / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let r;
    for (let i = 0, o = this.curves; i < o.length; i++) {
      const s = o[i],
        a = s.isEllipseCurve
          ? e * 2
          : s.isLineCurve || s.isLineCurve3
          ? 1
          : s.isSplineCurve
          ? e * s.points.length
          : e,
        l = s.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        (r && r.equals(u)) || (n.push(u), (r = u));
      }
    }
    return (
      this.autoClose &&
        n.length > 1 &&
        !n[n.length - 1].equals(n[0]) &&
        n.push(n[0]),
      n
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let n = 0, r = this.curves.length; n < r; n++) {
      const i = this.curves[n];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let n = 0, r = e.curves.length; n < r; n++) {
      const i = e.curves[n];
      this.curves.push(new vv[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Jh extends GN {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new ke()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, r = e.length; n < r; n++) this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const r = new xE(this.currentPoint.clone(), new ke(e, n));
    return this.curves.push(r), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    const o = new _E(this.currentPoint.clone(), new ke(e, n), new ke(r, i));
    return this.curves.push(o), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, n, r, i, o, s) {
    const a = new yE(
      this.currentPoint.clone(),
      new ke(e, n),
      new ke(r, i),
      new ke(o, s)
    );
    return this.curves.push(a), this.currentPoint.set(o, s), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e),
      r = new AE(n);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, r, i, o, s) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, n + l, r, i, o, s), this;
  }
  absarc(e, n, r, i, o, s) {
    return this.absellipse(e, n, r, r, i, o, s), this;
  }
  ellipse(e, n, r, i, o, s, a, l) {
    const c = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absellipse(e + c, n + u, r, i, o, s, a, l), this;
  }
  absellipse(e, n, r, i, o, s, a, l) {
    const c = new hy(e, n, r, i, o, s, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Dp extends Ut {
  constructor(
    e = [new ke(0, -0.5), new ke(0.5, 0), new ke(0, 0.5)],
    n = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: n, phiStart: r, phiLength: i }),
      (n = Math.floor(n)),
      (i = Un(i, 0, Math.PI * 2));
    const o = [],
      s = [],
      a = [],
      l = [],
      c = [],
      u = 1 / n,
      d = new ee(),
      p = new ke(),
      m = new ee(),
      v = new ee(),
      _ = new ee();
    let y = 0,
      g = 0;
    for (let x = 0; x <= e.length - 1; x++)
      switch (x) {
        case 0:
          (y = e[x + 1].x - e[x].x),
            (g = e[x + 1].y - e[x].y),
            (m.x = g * 1),
            (m.y = -y),
            (m.z = g * 0),
            _.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          (y = e[x + 1].x - e[x].x),
            (g = e[x + 1].y - e[x].y),
            (m.x = g * 1),
            (m.y = -y),
            (m.z = g * 0),
            v.copy(m),
            (m.x += _.x),
            (m.y += _.y),
            (m.z += _.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            _.copy(v);
      }
    for (let x = 0; x <= n; x++) {
      const S = r + x * u * i,
        b = Math.sin(S),
        C = Math.cos(S);
      for (let M = 0; M <= e.length - 1; M++) {
        (d.x = e[M].x * b),
          (d.y = e[M].y),
          (d.z = e[M].x * C),
          s.push(d.x, d.y, d.z),
          (p.x = x / n),
          (p.y = M / (e.length - 1)),
          a.push(p.x, p.y);
        const T = l[3 * M + 0] * b,
          P = l[3 * M + 1],
          R = l[3 * M + 0] * C;
        c.push(T, P, R);
      }
    }
    for (let x = 0; x < n; x++)
      for (let S = 0; S < e.length - 1; S++) {
        const b = S + x * e.length,
          C = b,
          M = b + e.length,
          T = b + e.length + 1,
          P = b + 1;
        o.push(C, M, P), o.push(T, P, M);
      }
    this.setIndex(o),
      this.setAttribute("position", new dt(s, 3)),
      this.setAttribute("uv", new dt(a, 2)),
      this.setAttribute("normal", new dt(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Dp(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class py extends Dp {
  constructor(e = 1, n = 1, r = 4, i = 8) {
    const o = new Jh();
    o.absarc(0, -n / 2, e, Math.PI * 1.5, 0),
      o.absarc(0, n / 2, e, 0, Math.PI * 0.5),
      super(o.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: n,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new py(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class my extends Ut {
  constructor(e = 1, n = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: n,
        thetaStart: r,
        thetaLength: i,
      }),
      (n = Math.max(3, n));
    const o = [],
      s = [],
      a = [],
      l = [],
      c = new ee(),
      u = new ke();
    s.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= n; d++, p += 3) {
      const m = r + (d / n) * i;
      (c.x = e * Math.cos(m)),
        (c.y = e * Math.sin(m)),
        s.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (u.x = (s[p] / e + 1) / 2),
        (u.y = (s[p + 1] / e + 1) / 2),
        l.push(u.x, u.y);
    }
    for (let d = 1; d <= n; d++) o.push(d, d + 1, 0);
    this.setIndex(o),
      this.setAttribute("position", new dt(s, 3)),
      this.setAttribute("normal", new dt(a, 3)),
      this.setAttribute("uv", new dt(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new my(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Uf extends Ut {
  constructor(
    e = 1,
    n = 1,
    r = 1,
    i = 32,
    o = 1,
    s = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: n,
        height: r,
        radialSegments: i,
        heightSegments: o,
        openEnded: s,
        thetaStart: a,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (o = Math.floor(o));
    const u = [],
      d = [],
      p = [],
      m = [];
    let v = 0;
    const _ = [],
      y = r / 2;
    let g = 0;
    x(),
      s === !1 && (e > 0 && S(!0), n > 0 && S(!1)),
      this.setIndex(u),
      this.setAttribute("position", new dt(d, 3)),
      this.setAttribute("normal", new dt(p, 3)),
      this.setAttribute("uv", new dt(m, 2));
    function x() {
      const b = new ee(),
        C = new ee();
      let M = 0;
      const T = (n - e) / r;
      for (let P = 0; P <= o; P++) {
        const R = [],
          E = P / o,
          O = E * (n - e) + e;
        for (let D = 0; D <= i; D++) {
          const N = D / i,
            z = N * l + a,
            V = Math.sin(z),
            G = Math.cos(z);
          (C.x = O * V),
            (C.y = -E * r + y),
            (C.z = O * G),
            d.push(C.x, C.y, C.z),
            b.set(V, T, G).normalize(),
            p.push(b.x, b.y, b.z),
            m.push(N, 1 - E),
            R.push(v++);
        }
        _.push(R);
      }
      for (let P = 0; P < i; P++)
        for (let R = 0; R < o; R++) {
          const E = _[R][P],
            O = _[R + 1][P],
            D = _[R + 1][P + 1],
            N = _[R][P + 1];
          u.push(E, O, N), u.push(O, D, N), (M += 6);
        }
      c.addGroup(g, M, 0), (g += M);
    }
    function S(b) {
      const C = v,
        M = new ke(),
        T = new ee();
      let P = 0;
      const R = b === !0 ? e : n,
        E = b === !0 ? 1 : -1;
      for (let D = 1; D <= i; D++)
        d.push(0, y * E, 0), p.push(0, E, 0), m.push(0.5, 0.5), v++;
      const O = v;
      for (let D = 0; D <= i; D++) {
        const z = (D / i) * l + a,
          V = Math.cos(z),
          G = Math.sin(z);
        (T.x = R * G),
          (T.y = y * E),
          (T.z = R * V),
          d.push(T.x, T.y, T.z),
          p.push(0, E, 0),
          (M.x = V * 0.5 + 0.5),
          (M.y = G * 0.5 * E + 0.5),
          m.push(M.x, M.y),
          v++;
      }
      for (let D = 0; D < i; D++) {
        const N = C + D,
          z = O + D;
        b === !0 ? u.push(z, z + 1, N) : u.push(z + 1, z, N), (P += 3);
      }
      c.addGroup(g, P, b === !0 ? 1 : 2), (g += P);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Uf(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class gy extends Uf {
  constructor(e = 1, n = 1, r = 32, i = 1, o = !1, s = 0, a = Math.PI * 2) {
    super(0, e, n, r, i, o, s, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: n,
        radialSegments: r,
        heightSegments: i,
        openEnded: o,
        thetaStart: s,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new gy(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ll extends Ut {
  constructor(e = [], n = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: n, radius: r, detail: i });
    const o = [],
      s = [];
    a(i),
      c(r),
      u(),
      this.setAttribute("position", new dt(o, 3)),
      this.setAttribute("normal", new dt(o.slice(), 3)),
      this.setAttribute("uv", new dt(s, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(x) {
      const S = new ee(),
        b = new ee(),
        C = new ee();
      for (let M = 0; M < n.length; M += 3)
        m(n[M + 0], S), m(n[M + 1], b), m(n[M + 2], C), l(S, b, C, x);
    }
    function l(x, S, b, C) {
      const M = C + 1,
        T = [];
      for (let P = 0; P <= M; P++) {
        T[P] = [];
        const R = x.clone().lerp(b, P / M),
          E = S.clone().lerp(b, P / M),
          O = M - P;
        for (let D = 0; D <= O; D++)
          D === 0 && P === M
            ? (T[P][D] = R)
            : (T[P][D] = R.clone().lerp(E, D / O));
      }
      for (let P = 0; P < M; P++)
        for (let R = 0; R < 2 * (M - P) - 1; R++) {
          const E = Math.floor(R / 2);
          R % 2 === 0
            ? (p(T[P][E + 1]), p(T[P + 1][E]), p(T[P][E]))
            : (p(T[P][E + 1]), p(T[P + 1][E + 1]), p(T[P + 1][E]));
        }
    }
    function c(x) {
      const S = new ee();
      for (let b = 0; b < o.length; b += 3)
        (S.x = o[b + 0]),
          (S.y = o[b + 1]),
          (S.z = o[b + 2]),
          S.normalize().multiplyScalar(x),
          (o[b + 0] = S.x),
          (o[b + 1] = S.y),
          (o[b + 2] = S.z);
    }
    function u() {
      const x = new ee();
      for (let S = 0; S < o.length; S += 3) {
        (x.x = o[S + 0]), (x.y = o[S + 1]), (x.z = o[S + 2]);
        const b = y(x) / 2 / Math.PI + 0.5,
          C = g(x) / Math.PI + 0.5;
        s.push(b, 1 - C);
      }
      v(), d();
    }
    function d() {
      for (let x = 0; x < s.length; x += 6) {
        const S = s[x + 0],
          b = s[x + 2],
          C = s[x + 4],
          M = Math.max(S, b, C),
          T = Math.min(S, b, C);
        M > 0.9 &&
          T < 0.1 &&
          (S < 0.2 && (s[x + 0] += 1),
          b < 0.2 && (s[x + 2] += 1),
          C < 0.2 && (s[x + 4] += 1));
      }
    }
    function p(x) {
      o.push(x.x, x.y, x.z);
    }
    function m(x, S) {
      const b = x * 3;
      (S.x = e[b + 0]), (S.y = e[b + 1]), (S.z = e[b + 2]);
    }
    function v() {
      const x = new ee(),
        S = new ee(),
        b = new ee(),
        C = new ee(),
        M = new ke(),
        T = new ke(),
        P = new ke();
      for (let R = 0, E = 0; R < o.length; R += 9, E += 6) {
        x.set(o[R + 0], o[R + 1], o[R + 2]),
          S.set(o[R + 3], o[R + 4], o[R + 5]),
          b.set(o[R + 6], o[R + 7], o[R + 8]),
          M.set(s[E + 0], s[E + 1]),
          T.set(s[E + 2], s[E + 3]),
          P.set(s[E + 4], s[E + 5]),
          C.copy(x).add(S).add(b).divideScalar(3);
        const O = y(C);
        _(M, E + 0, x, O), _(T, E + 2, S, O), _(P, E + 4, b, O);
      }
    }
    function _(x, S, b, C) {
      C < 0 && x.x === 1 && (s[S] = x.x - 1),
        b.x === 0 && b.z === 0 && (s[S] = C / 2 / Math.PI + 0.5);
    }
    function y(x) {
      return Math.atan2(x.z, -x.x);
    }
    function g(x) {
      return Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ll(e.vertices, e.indices, e.radius, e.details);
  }
}
class vy extends ll {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      o = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      s = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(o, s, e, n),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new vy(e.radius, e.detail);
  }
}
const Ng = new ee(),
  Dg = new ee(),
  f_ = new ee(),
  Fg = new Gi();
class WN extends Ut {
  constructor(e = null, n = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: n }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        o = Math.cos(dc * n),
        s = e.getIndex(),
        a = e.getAttribute("position"),
        l = s ? s.count : a.count,
        c = [0, 0, 0],
        u = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let v = 0; v < l; v += 3) {
        s
          ? ((c[0] = s.getX(v)), (c[1] = s.getX(v + 1)), (c[2] = s.getX(v + 2)))
          : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
        const { a: _, b: y, c: g } = Fg;
        if (
          (_.fromBufferAttribute(a, c[0]),
          y.fromBufferAttribute(a, c[1]),
          g.fromBufferAttribute(a, c[2]),
          Fg.getNormal(f_),
          (d[0] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(
            _.z * i
          )}`),
          (d[1] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(
            y.z * i
          )}`),
          (d[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(
            g.z * i
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let x = 0; x < 3; x++) {
            const S = (x + 1) % 3,
              b = d[x],
              C = d[S],
              M = Fg[u[x]],
              T = Fg[u[S]],
              P = `${b}_${C}`,
              R = `${C}_${b}`;
            R in p && p[R]
              ? (f_.dot(p[R].normal) <= o &&
                  (m.push(M.x, M.y, M.z), m.push(T.x, T.y, T.z)),
                (p[R] = null))
              : P in p ||
                (p[P] = { index0: c[x], index1: c[S], normal: f_.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: _, index1: y } = p[v];
          Ng.fromBufferAttribute(a, _),
            Dg.fromBufferAttribute(a, y),
            m.push(Ng.x, Ng.y, Ng.z),
            m.push(Dg.x, Dg.y, Dg.z);
        }
      this.setAttribute("position", new dt(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class pc extends Jh {
  constructor(e) {
    super(e), (this.uuid = Xi()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const n = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      n[r] = this.holes[r].getPoints(e);
    return n;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let n = 0, r = this.holes.length; n < r; n++) {
      const i = this.holes[n];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let n = 0, r = e.holes.length; n < r; n++) {
      const i = e.holes[n];
      this.holes.push(new Jh().fromJSON(i));
    }
    return this;
  }
}
const LW = {
  triangulate: function (t, e, n = 2) {
    const r = e && e.length,
      i = r ? e[0] * n : t.length;
    let o = jN(t, 0, i, n, !0);
    const s = [];
    if (!o || o.next === o.prev) return s;
    let a, l, c, u, d, p, m;
    if ((r && (o = UW(t, e, o, n)), t.length > 80 * n)) {
      (a = c = t[0]), (l = u = t[1]);
      for (let v = n; v < i; v += n)
        (d = t[v]),
          (p = t[v + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > c && (c = d),
          p > u && (u = p);
      (m = Math.max(c - a, u - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return Qh(o, s, n, a, l, m, 0), s;
  },
};
function jN(t, e, n, r, i) {
  let o, s;
  if (i === YW(t, e, n, r) > 0)
    for (o = e; o < n; o += r) s = sR(o, t[o], t[o + 1], s);
  else for (o = n - r; o >= e; o -= r) s = sR(o, t[o], t[o + 1], s);
  return s && yy(s, s.next) && (tp(s), (s = s.next)), s;
}
function Cc(t, e) {
  if (!t) return t;
  e || (e = t);
  let n = t,
    r;
  do
    if (
      ((r = !1), !n.steiner && (yy(n, n.next) || Mn(n.prev, n, n.next) === 0))
    ) {
      if ((tp(n), (n = e = n.prev), n === n.next)) break;
      r = !0;
    } else n = n.next;
  while (r || n !== e);
  return e;
}
function Qh(t, e, n, r, i, o, s) {
  if (!t) return;
  !s && o && VW(t, r, i, o);
  let a = t,
    l,
    c;
  for (; t.prev !== t.next; ) {
    if (((l = t.prev), (c = t.next), o ? NW(t, r, i, o) : OW(t))) {
      e.push((l.i / n) | 0),
        e.push((t.i / n) | 0),
        e.push((c.i / n) | 0),
        tp(t),
        (t = c.next),
        (a = c.next);
      continue;
    }
    if (((t = c), t === a)) {
      s
        ? s === 1
          ? ((t = DW(Cc(t), e, n)), Qh(t, e, n, r, i, o, 2))
          : s === 2 && FW(t, e, n, r, i, o)
        : Qh(Cc(t), e, n, r, i, o, 1);
      break;
    }
  }
}
function OW(t) {
  const e = t.prev,
    n = t,
    r = t.next;
  if (Mn(e, n, r) >= 0) return !1;
  const i = e.x,
    o = n.x,
    s = r.x,
    a = e.y,
    l = n.y,
    c = r.y,
    u = i < o ? (i < s ? i : s) : o < s ? o : s,
    d = a < l ? (a < c ? a : c) : l < c ? l : c,
    p = i > o ? (i > s ? i : s) : o > s ? o : s,
    m = a > l ? (a > c ? a : c) : l > c ? l : c;
  let v = r.next;
  for (; v !== e; ) {
    if (
      v.x >= u &&
      v.x <= p &&
      v.y >= d &&
      v.y <= m &&
      Ku(i, a, o, l, s, c, v.x, v.y) &&
      Mn(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function NW(t, e, n, r) {
  const i = t.prev,
    o = t,
    s = t.next;
  if (Mn(i, o, s) >= 0) return !1;
  const a = i.x,
    l = o.x,
    c = s.x,
    u = i.y,
    d = o.y,
    p = s.y,
    m = a < l ? (a < c ? a : c) : l < c ? l : c,
    v = u < d ? (u < p ? u : p) : d < p ? d : p,
    _ = a > l ? (a > c ? a : c) : l > c ? l : c,
    y = u > d ? (u > p ? u : p) : d > p ? d : p,
    g = DA(m, v, e, n, r),
    x = DA(_, y, e, n, r);
  let S = t.prevZ,
    b = t.nextZ;
  for (; S && S.z >= g && b && b.z <= x; ) {
    if (
      (S.x >= m &&
        S.x <= _ &&
        S.y >= v &&
        S.y <= y &&
        S !== i &&
        S !== s &&
        Ku(a, u, l, d, c, p, S.x, S.y) &&
        Mn(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      b.x >= m &&
        b.x <= _ &&
        b.y >= v &&
        b.y <= y &&
        b !== i &&
        b !== s &&
        Ku(a, u, l, d, c, p, b.x, b.y) &&
        Mn(b.prev, b, b.next) >= 0)
    )
      return !1;
    b = b.nextZ;
  }
  for (; S && S.z >= g; ) {
    if (
      S.x >= m &&
      S.x <= _ &&
      S.y >= v &&
      S.y <= y &&
      S !== i &&
      S !== s &&
      Ku(a, u, l, d, c, p, S.x, S.y) &&
      Mn(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; b && b.z <= x; ) {
    if (
      b.x >= m &&
      b.x <= _ &&
      b.y >= v &&
      b.y <= y &&
      b !== i &&
      b !== s &&
      Ku(a, u, l, d, c, p, b.x, b.y) &&
      Mn(b.prev, b, b.next) >= 0
    )
      return !1;
    b = b.nextZ;
  }
  return !0;
}
function DW(t, e, n) {
  let r = t;
  do {
    const i = r.prev,
      o = r.next.next;
    !yy(i, o) &&
      $N(i, r, r.next, o) &&
      ep(i, o) &&
      ep(o, i) &&
      (e.push((i.i / n) | 0),
      e.push((r.i / n) | 0),
      e.push((o.i / n) | 0),
      tp(r),
      tp(r.next),
      (r = t = o)),
      (r = r.next);
  } while (r !== t);
  return Cc(r);
}
function FW(t, e, n, r, i, o) {
  let s = t;
  do {
    let a = s.next.next;
    for (; a !== s.prev; ) {
      if (s.i !== a.i && jW(s, a)) {
        let l = XN(s, a);
        (s = Cc(s, s.next)),
          (l = Cc(l, l.next)),
          Qh(s, e, n, r, i, o, 0),
          Qh(l, e, n, r, i, o, 0);
        return;
      }
      a = a.next;
    }
    s = s.next;
  } while (s !== t);
}
function UW(t, e, n, r) {
  const i = [];
  let o, s, a, l, c;
  for (o = 0, s = e.length; o < s; o++)
    (a = e[o] * r),
      (l = o < s - 1 ? e[o + 1] * r : t.length),
      (c = jN(t, a, l, r, !1)),
      c === c.next && (c.steiner = !0),
      i.push(WW(c));
  for (i.sort(kW), o = 0; o < i.length; o++) n = zW(i[o], n);
  return n;
}
function kW(t, e) {
  return t.x - e.x;
}
function zW(t, e) {
  const n = BW(t, e);
  if (!n) return e;
  const r = XN(n, t);
  return Cc(r, r.next), Cc(n, n.next);
}
function BW(t, e) {
  let n = e,
    r = -1 / 0,
    i;
  const o = t.x,
    s = t.y;
  do {
    if (s <= n.y && s >= n.next.y && n.next.y !== n.y) {
      const p = n.x + ((s - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
      if (
        p <= o &&
        p > r &&
        ((r = p), (i = n.x < n.next.x ? n : n.next), p === o)
      )
        return i;
    }
    n = n.next;
  } while (n !== e);
  if (!i) return null;
  const a = i,
    l = i.x,
    c = i.y;
  let u = 1 / 0,
    d;
  n = i;
  do
    o >= n.x &&
      n.x >= l &&
      o !== n.x &&
      Ku(s < c ? o : r, s, l, c, s < c ? r : o, s, n.x, n.y) &&
      ((d = Math.abs(s - n.y) / (o - n.x)),
      ep(n, t) &&
        (d < u || (d === u && (n.x > i.x || (n.x === i.x && HW(i, n))))) &&
        ((i = n), (u = d))),
      (n = n.next);
  while (n !== a);
  return i;
}
function HW(t, e) {
  return Mn(t.prev, t, e.prev) < 0 && Mn(e.next, t, t.next) < 0;
}
function VW(t, e, n, r) {
  let i = t;
  do
    i.z === 0 && (i.z = DA(i.x, i.y, e, n, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== t);
  (i.prevZ.nextZ = null), (i.prevZ = null), GW(i);
}
function GW(t) {
  let e,
    n,
    r,
    i,
    o,
    s,
    a,
    l,
    c = 1;
  do {
    for (n = t, t = null, o = null, s = 0; n; ) {
      for (s++, r = n, a = 0, e = 0; e < c && (a++, (r = r.nextZ), !!r); e++);
      for (l = c; a > 0 || (l > 0 && r); )
        a !== 0 && (l === 0 || !r || n.z <= r.z)
          ? ((i = n), (n = n.nextZ), a--)
          : ((i = r), (r = r.nextZ), l--),
          o ? (o.nextZ = i) : (t = i),
          (i.prevZ = o),
          (o = i);
      n = r;
    }
    (o.nextZ = null), (c *= 2);
  } while (s > 1);
  return t;
}
function DA(t, e, n, r, i) {
  return (
    (t = ((t - n) * i) | 0),
    (e = ((e - r) * i) | 0),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    t | (e << 1)
  );
}
function WW(t) {
  let e = t,
    n = t;
  do (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
  while (e !== t);
  return n;
}
function Ku(t, e, n, r, i, o, s, a) {
  return (
    (i - s) * (e - a) >= (t - s) * (o - a) &&
    (t - s) * (r - a) >= (n - s) * (e - a) &&
    (n - s) * (o - a) >= (i - s) * (r - a)
  );
}
function jW(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !$W(t, e) &&
    ((ep(t, e) &&
      ep(e, t) &&
      XW(t, e) &&
      (Mn(t.prev, t, e.prev) || Mn(t, e.prev, e))) ||
      (yy(t, e) && Mn(t.prev, t, t.next) > 0 && Mn(e.prev, e, e.next) > 0))
  );
}
function Mn(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function yy(t, e) {
  return t.x === e.x && t.y === e.y;
}
function $N(t, e, n, r) {
  const i = kg(Mn(t, e, n)),
    o = kg(Mn(t, e, r)),
    s = kg(Mn(n, r, t)),
    a = kg(Mn(n, r, e));
  return !!(
    (i !== o && s !== a) ||
    (i === 0 && Ug(t, n, e)) ||
    (o === 0 && Ug(t, r, e)) ||
    (s === 0 && Ug(n, t, r)) ||
    (a === 0 && Ug(n, e, r))
  );
}
function Ug(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  );
}
function kg(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function $W(t, e) {
  let n = t;
  do {
    if (
      n.i !== t.i &&
      n.next.i !== t.i &&
      n.i !== e.i &&
      n.next.i !== e.i &&
      $N(n, n.next, t, e)
    )
      return !0;
    n = n.next;
  } while (n !== t);
  return !1;
}
function ep(t, e) {
  return Mn(t.prev, t, t.next) < 0
    ? Mn(t, e, t.next) >= 0 && Mn(t, t.prev, e) >= 0
    : Mn(t, e, t.prev) < 0 || Mn(t, t.next, e) < 0;
}
function XW(t, e) {
  let n = t,
    r = !1;
  const i = (t.x + e.x) / 2,
    o = (t.y + e.y) / 2;
  do
    n.y > o != n.next.y > o &&
      n.next.y !== n.y &&
      i < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
      (r = !r),
      (n = n.next);
  while (n !== t);
  return r;
}
function XN(t, e) {
  const n = new FA(t.i, t.x, t.y),
    r = new FA(e.i, e.x, e.y),
    i = t.next,
    o = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = i),
    (i.prev = n),
    (r.next = n),
    (n.prev = r),
    (o.next = r),
    (r.prev = o),
    r
  );
}
function sR(t, e, n, r) {
  const i = new FA(t, e, n);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function tp(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function FA(t, e, n) {
  (this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function YW(t, e, n, r) {
  let i = 0;
  for (let o = e, s = n - r; o < n; o += r)
    (i += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
  return i;
}
class ms {
  static area(e) {
    const n = e.length;
    let r = 0;
    for (let i = n - 1, o = 0; o < n; i = o++)
      r += e[i].x * e[o].y - e[o].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return ms.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const r = [],
      i = [],
      o = [];
    aR(e), lR(r, e);
    let s = e.length;
    n.forEach(aR);
    for (let l = 0; l < n.length; l++)
      i.push(s), (s += n[l].length), lR(r, n[l]);
    const a = LW.triangulate(r, i);
    for (let l = 0; l < a.length; l += 3) o.push(a.slice(l, l + 3));
    return o;
  }
}
function aR(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function lR(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}
class xy extends Ut {
  constructor(
    e = new pc([
      new ke(0.5, 0.5),
      new ke(-0.5, 0.5),
      new ke(-0.5, -0.5),
      new ke(0.5, -0.5),
    ]),
    n = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: n }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      s(c);
    }
    this.setAttribute("position", new dt(i, 3)),
      this.setAttribute("uv", new dt(o, 2)),
      this.computeVertexNormals();
    function s(a) {
      const l = [],
        c = n.curveSegments !== void 0 ? n.curveSegments : 12,
        u = n.steps !== void 0 ? n.steps : 1,
        d = n.depth !== void 0 ? n.depth : 1;
      let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0,
        m = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2,
        v = n.bevelSize !== void 0 ? n.bevelSize : m - 0.1,
        _ = n.bevelOffset !== void 0 ? n.bevelOffset : 0,
        y = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const g = n.extrudePath,
        x = n.UVGenerator !== void 0 ? n.UVGenerator : qW;
      let S,
        b = !1,
        C,
        M,
        T,
        P;
      g &&
        ((S = g.getSpacedPoints(u)),
        (b = !0),
        (p = !1),
        (C = g.computeFrenetFrames(u, !1)),
        (M = new ee()),
        (T = new ee()),
        (P = new ee())),
        p || ((y = 0), (m = 0), (v = 0), (_ = 0));
      const R = a.extractPoints(c);
      let E = R.shape;
      const O = R.holes;
      if (!ms.isClockWise(E)) {
        E = E.reverse();
        for (let ie = 0, pe = O.length; ie < pe; ie++) {
          const de = O[ie];
          ms.isClockWise(de) && (O[ie] = de.reverse());
        }
      }
      const N = ms.triangulateShape(E, O),
        z = E;
      for (let ie = 0, pe = O.length; ie < pe; ie++) {
        const de = O[ie];
        E = E.concat(de);
      }
      function V(ie, pe, de) {
        return (
          pe || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          ie.clone().addScaledVector(pe, de)
        );
      }
      const G = E.length,
        Y = N.length;
      function U(ie, pe, de) {
        let Ee, he, Ce;
        const _e = ie.x - pe.x,
          $ = ie.y - pe.y,
          k = de.x - ie.x,
          J = de.y - ie.y,
          fe = _e * _e + $ * $,
          le = _e * J - $ * k;
        if (Math.abs(le) > Number.EPSILON) {
          const ce = Math.sqrt(fe),
            we = Math.sqrt(k * k + J * J),
            Be = pe.x - $ / ce,
            Me = pe.y + _e / ce,
            Ge = de.x - J / we,
            Le = de.y + k / we,
            je = ((Ge - Be) * J - (Le - Me) * k) / (_e * J - $ * k);
          (Ee = Be + _e * je - ie.x), (he = Me + $ * je - ie.y);
          const Je = Ee * Ee + he * he;
          if (Je <= 2) return new ke(Ee, he);
          Ce = Math.sqrt(Je / 2);
        } else {
          let ce = !1;
          _e > Number.EPSILON
            ? k > Number.EPSILON && (ce = !0)
            : _e < -Number.EPSILON
            ? k < -Number.EPSILON && (ce = !0)
            : Math.sign($) === Math.sign(J) && (ce = !0),
            ce
              ? ((Ee = -$), (he = _e), (Ce = Math.sqrt(fe)))
              : ((Ee = _e), (he = $), (Ce = Math.sqrt(fe / 2)));
        }
        return new ke(Ee / Ce, he / Ce);
      }
      const j = [];
      for (
        let ie = 0, pe = z.length, de = pe - 1, Ee = ie + 1;
        ie < pe;
        ie++, de++, Ee++
      )
        de === pe && (de = 0),
          Ee === pe && (Ee = 0),
          (j[ie] = U(z[ie], z[de], z[Ee]));
      const W = [];
      let B,
        q = j.concat();
      for (let ie = 0, pe = O.length; ie < pe; ie++) {
        const de = O[ie];
        B = [];
        for (
          let Ee = 0, he = de.length, Ce = he - 1, _e = Ee + 1;
          Ee < he;
          Ee++, Ce++, _e++
        )
          Ce === he && (Ce = 0),
            _e === he && (_e = 0),
            (B[Ee] = U(de[Ee], de[Ce], de[_e]));
        W.push(B), (q = q.concat(B));
      }
      for (let ie = 0; ie < y; ie++) {
        const pe = ie / y,
          de = m * Math.cos((pe * Math.PI) / 2),
          Ee = v * Math.sin((pe * Math.PI) / 2) + _;
        for (let he = 0, Ce = z.length; he < Ce; he++) {
          const _e = V(z[he], j[he], Ee);
          oe(_e.x, _e.y, -de);
        }
        for (let he = 0, Ce = O.length; he < Ce; he++) {
          const _e = O[he];
          B = W[he];
          for (let $ = 0, k = _e.length; $ < k; $++) {
            const J = V(_e[$], B[$], Ee);
            oe(J.x, J.y, -de);
          }
        }
      }
      const Z = v + _;
      for (let ie = 0; ie < G; ie++) {
        const pe = p ? V(E[ie], q[ie], Z) : E[ie];
        b
          ? (T.copy(C.normals[0]).multiplyScalar(pe.x),
            M.copy(C.binormals[0]).multiplyScalar(pe.y),
            P.copy(S[0]).add(T).add(M),
            oe(P.x, P.y, P.z))
          : oe(pe.x, pe.y, 0);
      }
      for (let ie = 1; ie <= u; ie++)
        for (let pe = 0; pe < G; pe++) {
          const de = p ? V(E[pe], q[pe], Z) : E[pe];
          b
            ? (T.copy(C.normals[ie]).multiplyScalar(de.x),
              M.copy(C.binormals[ie]).multiplyScalar(de.y),
              P.copy(S[ie]).add(T).add(M),
              oe(P.x, P.y, P.z))
            : oe(de.x, de.y, (d / u) * ie);
        }
      for (let ie = y - 1; ie >= 0; ie--) {
        const pe = ie / y,
          de = m * Math.cos((pe * Math.PI) / 2),
          Ee = v * Math.sin((pe * Math.PI) / 2) + _;
        for (let he = 0, Ce = z.length; he < Ce; he++) {
          const _e = V(z[he], j[he], Ee);
          oe(_e.x, _e.y, d + de);
        }
        for (let he = 0, Ce = O.length; he < Ce; he++) {
          const _e = O[he];
          B = W[he];
          for (let $ = 0, k = _e.length; $ < k; $++) {
            const J = V(_e[$], B[$], Ee);
            b
              ? oe(J.x, J.y + S[u - 1].y, S[u - 1].x + de)
              : oe(J.x, J.y, d + de);
          }
        }
      }
      H(), X();
      function H() {
        const ie = i.length / 3;
        if (p) {
          let pe = 0,
            de = G * pe;
          for (let Ee = 0; Ee < Y; Ee++) {
            const he = N[Ee];
            ue(he[2] + de, he[1] + de, he[0] + de);
          }
          (pe = u + y * 2), (de = G * pe);
          for (let Ee = 0; Ee < Y; Ee++) {
            const he = N[Ee];
            ue(he[0] + de, he[1] + de, he[2] + de);
          }
        } else {
          for (let pe = 0; pe < Y; pe++) {
            const de = N[pe];
            ue(de[2], de[1], de[0]);
          }
          for (let pe = 0; pe < Y; pe++) {
            const de = N[pe];
            ue(de[0] + G * u, de[1] + G * u, de[2] + G * u);
          }
        }
        r.addGroup(ie, i.length / 3 - ie, 0);
      }
      function X() {
        const ie = i.length / 3;
        let pe = 0;
        ne(z, pe), (pe += z.length);
        for (let de = 0, Ee = O.length; de < Ee; de++) {
          const he = O[de];
          ne(he, pe), (pe += he.length);
        }
        r.addGroup(ie, i.length / 3 - ie, 1);
      }
      function ne(ie, pe) {
        let de = ie.length;
        for (; --de >= 0; ) {
          const Ee = de;
          let he = de - 1;
          he < 0 && (he = ie.length - 1);
          for (let Ce = 0, _e = u + y * 2; Ce < _e; Ce++) {
            const $ = G * Ce,
              k = G * (Ce + 1),
              J = pe + Ee + $,
              fe = pe + he + $,
              le = pe + he + k,
              ce = pe + Ee + k;
            Ie(J, fe, le, ce);
          }
        }
      }
      function oe(ie, pe, de) {
        l.push(ie), l.push(pe), l.push(de);
      }
      function ue(ie, pe, de) {
        te(ie), te(pe), te(de);
        const Ee = i.length / 3,
          he = x.generateTopUV(r, i, Ee - 3, Ee - 2, Ee - 1);
        ge(he[0]), ge(he[1]), ge(he[2]);
      }
      function Ie(ie, pe, de, Ee) {
        te(ie), te(pe), te(Ee), te(pe), te(de), te(Ee);
        const he = i.length / 3,
          Ce = x.generateSideWallUV(r, i, he - 6, he - 3, he - 2, he - 1);
        ge(Ce[0]), ge(Ce[1]), ge(Ce[3]), ge(Ce[1]), ge(Ce[2]), ge(Ce[3]);
      }
      function te(ie) {
        i.push(l[ie * 3 + 0]), i.push(l[ie * 3 + 1]), i.push(l[ie * 3 + 2]);
      }
      function ge(ie) {
        o.push(ie.x), o.push(ie.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes,
      r = this.parameters.options;
    return KW(n, r, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let o = 0, s = e.shapes.length; o < s; o++) {
      const a = n[e.shapes[o]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new vv[i.type]().fromJSON(i)),
      new xy(r, e.options)
    );
  }
}
const qW = {
  generateTopUV: function (t, e, n, r, i) {
    const o = e[n * 3],
      s = e[n * 3 + 1],
      a = e[r * 3],
      l = e[r * 3 + 1],
      c = e[i * 3],
      u = e[i * 3 + 1];
    return [new ke(o, s), new ke(a, l), new ke(c, u)];
  },
  generateSideWallUV: function (t, e, n, r, i, o) {
    const s = e[n * 3],
      a = e[n * 3 + 1],
      l = e[n * 3 + 2],
      c = e[r * 3],
      u = e[r * 3 + 1],
      d = e[r * 3 + 2],
      p = e[i * 3],
      m = e[i * 3 + 1],
      v = e[i * 3 + 2],
      _ = e[o * 3],
      y = e[o * 3 + 1],
      g = e[o * 3 + 2];
    return Math.abs(a - u) < Math.abs(s - c)
      ? [new ke(s, 1 - l), new ke(c, 1 - d), new ke(p, 1 - v), new ke(_, 1 - g)]
      : [
          new ke(a, 1 - l),
          new ke(u, 1 - d),
          new ke(m, 1 - v),
          new ke(y, 1 - g),
        ];
  },
};
function KW(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let r = 0, i = t.length; r < i; r++) {
      const o = t[r];
      n.shapes.push(o.uuid);
    }
  else n.shapes.push(t.uuid);
  return (
    (n.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  );
}
class _y extends ll {
  constructor(e = 1, n = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      o = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, o, e, n),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new _y(e.radius, e.detail);
  }
}
class Fp extends ll {
  constructor(e = 1, n = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, n),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new Fp(e.radius, e.detail);
  }
}
class Sy extends Ut {
  constructor(e = 0.5, n = 1, r = 32, i = 1, o = 0, s = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: n,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: o,
        thetaLength: s,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      l = [],
      c = [],
      u = [];
    let d = e;
    const p = (n - e) / i,
      m = new ee(),
      v = new ke();
    for (let _ = 0; _ <= i; _++) {
      for (let y = 0; y <= r; y++) {
        const g = o + (y / r) * s;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          c.push(0, 0, 1),
          (v.x = (m.x / n + 1) / 2),
          (v.y = (m.y / n + 1) / 2),
          u.push(v.x, v.y);
      }
      d += p;
    }
    for (let _ = 0; _ < i; _++) {
      const y = _ * (r + 1);
      for (let g = 0; g < r; g++) {
        const x = g + y,
          S = x,
          b = x + r + 1,
          C = x + r + 2,
          M = x + 1;
        a.push(S, b, M), a.push(b, C, M);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new dt(l, 3)),
      this.setAttribute("normal", new dt(c, 3)),
      this.setAttribute("uv", new dt(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Sy(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Ay extends Ut {
  constructor(
    e = new pc([new ke(0, 0.5), new ke(-0.5, -0.5), new ke(0.5, -0.5)]),
    n = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: n });
    const r = [],
      i = [],
      o = [],
      s = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(a, l, u), (a += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new dt(i, 3)),
      this.setAttribute("normal", new dt(o, 3)),
      this.setAttribute("uv", new dt(s, 2));
    function c(u) {
      const d = i.length / 3,
        p = u.extractPoints(n);
      let m = p.shape;
      const v = p.holes;
      ms.isClockWise(m) === !1 && (m = m.reverse());
      for (let y = 0, g = v.length; y < g; y++) {
        const x = v[y];
        ms.isClockWise(x) === !0 && (v[y] = x.reverse());
      }
      const _ = ms.triangulateShape(m, v);
      for (let y = 0, g = v.length; y < g; y++) {
        const x = v[y];
        m = m.concat(x);
      }
      for (let y = 0, g = m.length; y < g; y++) {
        const x = m[y];
        i.push(x.x, x.y, 0), o.push(0, 0, 1), s.push(x.x, x.y);
      }
      for (let y = 0, g = _.length; y < g; y++) {
        const x = _[y],
          S = x[0] + d,
          b = x[1] + d,
          C = x[2] + d;
        r.push(S, b, C), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      n = this.parameters.shapes;
    return ZW(n, e);
  }
  static fromJSON(e, n) {
    const r = [];
    for (let i = 0, o = e.shapes.length; i < o; i++) {
      const s = n[e.shapes[i]];
      r.push(s);
    }
    return new Ay(r, e.curveSegments);
  }
}
function ZW(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, r = t.length; n < r; n++) {
      const i = t[n];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(t.uuid);
  return e;
}
class Up extends Ut {
  constructor(
    e = 1,
    n = 32,
    r = 16,
    i = 0,
    o = Math.PI * 2,
    s = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: n,
        heightSegments: r,
        phiStart: i,
        phiLength: o,
        thetaStart: s,
        thetaLength: a,
      }),
      (n = Math.max(3, Math.floor(n))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(s + a, Math.PI);
    let c = 0;
    const u = [],
      d = new ee(),
      p = new ee(),
      m = [],
      v = [],
      _ = [],
      y = [];
    for (let g = 0; g <= r; g++) {
      const x = [],
        S = g / r;
      let b = 0;
      g === 0 && s === 0
        ? (b = 0.5 / n)
        : g === r && l === Math.PI && (b = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const M = C / n;
        (d.x = -e * Math.cos(i + M * o) * Math.sin(s + S * a)),
          (d.y = e * Math.cos(s + S * a)),
          (d.z = e * Math.sin(i + M * o) * Math.sin(s + S * a)),
          v.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          _.push(p.x, p.y, p.z),
          y.push(M + b, 1 - S),
          x.push(c++);
      }
      u.push(x);
    }
    for (let g = 0; g < r; g++)
      for (let x = 0; x < n; x++) {
        const S = u[g][x + 1],
          b = u[g][x],
          C = u[g + 1][x],
          M = u[g + 1][x + 1];
        (g !== 0 || s > 0) && m.push(S, b, M),
          (g !== r - 1 || l < Math.PI) && m.push(b, C, M);
      }
    this.setIndex(m),
      this.setAttribute("position", new dt(v, 3)),
      this.setAttribute("normal", new dt(_, 3)),
      this.setAttribute("uv", new dt(y, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Up(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class by extends ll {
  constructor(e = 1, n = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, n),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: n });
  }
  static fromJSON(e) {
    return new by(e.radius, e.detail);
  }
}
class wy extends Ut {
  constructor(e = 1, n = 0.4, r = 12, i = 48, o = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        radialSegments: r,
        tubularSegments: i,
        arc: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const s = [],
      a = [],
      l = [],
      c = [],
      u = new ee(),
      d = new ee(),
      p = new ee();
    for (let m = 0; m <= r; m++)
      for (let v = 0; v <= i; v++) {
        const _ = (v / i) * o,
          y = (m / r) * Math.PI * 2;
        (d.x = (e + n * Math.cos(y)) * Math.cos(_)),
          (d.y = (e + n * Math.cos(y)) * Math.sin(_)),
          (d.z = n * Math.sin(y)),
          a.push(d.x, d.y, d.z),
          (u.x = e * Math.cos(_)),
          (u.y = e * Math.sin(_)),
          p.subVectors(d, u).normalize(),
          l.push(p.x, p.y, p.z),
          c.push(v / i),
          c.push(m / r);
      }
    for (let m = 1; m <= r; m++)
      for (let v = 1; v <= i; v++) {
        const _ = (i + 1) * m + v - 1,
          y = (i + 1) * (m - 1) + v - 1,
          g = (i + 1) * (m - 1) + v,
          x = (i + 1) * m + v;
        s.push(_, y, x), s.push(y, g, x);
      }
    this.setIndex(s),
      this.setAttribute("position", new dt(a, 3)),
      this.setAttribute("normal", new dt(l, 3)),
      this.setAttribute("uv", new dt(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new wy(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Ey extends Ut {
  constructor(e = 1, n = 0.4, r = 64, i = 8, o = 2, s = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: n,
        tubularSegments: r,
        radialSegments: i,
        p: o,
        q: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      c = [],
      u = [],
      d = new ee(),
      p = new ee(),
      m = new ee(),
      v = new ee(),
      _ = new ee(),
      y = new ee(),
      g = new ee();
    for (let S = 0; S <= r; ++S) {
      const b = (S / r) * o * Math.PI * 2;
      x(b, o, s, e, m),
        x(b + 0.01, o, s, e, v),
        y.subVectors(v, m),
        g.addVectors(v, m),
        _.crossVectors(y, g),
        g.crossVectors(_, y),
        _.normalize(),
        g.normalize();
      for (let C = 0; C <= i; ++C) {
        const M = (C / i) * Math.PI * 2,
          T = -n * Math.cos(M),
          P = n * Math.sin(M);
        (d.x = m.x + (T * g.x + P * _.x)),
          (d.y = m.y + (T * g.y + P * _.y)),
          (d.z = m.z + (T * g.z + P * _.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          c.push(p.x, p.y, p.z),
          u.push(S / r),
          u.push(C / i);
      }
    }
    for (let S = 1; S <= r; S++)
      for (let b = 1; b <= i; b++) {
        const C = (i + 1) * (S - 1) + (b - 1),
          M = (i + 1) * S + (b - 1),
          T = (i + 1) * S + b,
          P = (i + 1) * (S - 1) + b;
        a.push(C, M, P), a.push(M, T, P);
      }
    this.setIndex(a),
      this.setAttribute("position", new dt(l, 3)),
      this.setAttribute("normal", new dt(c, 3)),
      this.setAttribute("uv", new dt(u, 2));
    function x(S, b, C, M, T) {
      const P = Math.cos(S),
        R = Math.sin(S),
        E = (C / b) * S,
        O = Math.cos(E);
      (T.x = M * (2 + O) * 0.5 * P),
        (T.y = M * (2 + O) * R * 0.5),
        (T.z = M * Math.sin(E) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ey(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class My extends Ut {
  constructor(
    e = new SE(new ee(-1, -1, 0), new ee(-1, 1, 0), new ee(1, 1, 0)),
    n = 64,
    r = 1,
    i = 8,
    o = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: n,
        radius: r,
        radialSegments: i,
        closed: o,
      });
    const s = e.computeFrenetFrames(n, o);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals);
    const a = new ee(),
      l = new ee(),
      c = new ke();
    let u = new ee();
    const d = [],
      p = [],
      m = [],
      v = [];
    _(),
      this.setIndex(v),
      this.setAttribute("position", new dt(d, 3)),
      this.setAttribute("normal", new dt(p, 3)),
      this.setAttribute("uv", new dt(m, 2));
    function _() {
      for (let S = 0; S < n; S++) y(S);
      y(o === !1 ? n : 0), x(), g();
    }
    function y(S) {
      u = e.getPointAt(S / n, u);
      const b = s.normals[S],
        C = s.binormals[S];
      for (let M = 0; M <= i; M++) {
        const T = (M / i) * Math.PI * 2,
          P = Math.sin(T),
          R = -Math.cos(T);
        (l.x = R * b.x + P * C.x),
          (l.y = R * b.y + P * C.y),
          (l.z = R * b.z + P * C.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = u.x + r * l.x),
          (a.y = u.y + r * l.y),
          (a.z = u.z + r * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let S = 1; S <= n; S++)
        for (let b = 1; b <= i; b++) {
          const C = (i + 1) * (S - 1) + (b - 1),
            M = (i + 1) * S + (b - 1),
            T = (i + 1) * S + b,
            P = (i + 1) * (S - 1) + b;
          v.push(C, M, P), v.push(M, T, P);
        }
    }
    function x() {
      for (let S = 0; S <= n; S++)
        for (let b = 0; b <= i; b++)
          (c.x = S / n), (c.y = b / i), m.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new My(
      new vv[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class YN extends Ut {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const n = [],
        r = new Set(),
        i = new ee(),
        o = new ee();
      if (e.index !== null) {
        const s = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const d = l[c],
            p = d.start,
            m = d.count;
          for (let v = p, _ = p + m; v < _; v += 3)
            for (let y = 0; y < 3; y++) {
              const g = a.getX(v + y),
                x = a.getX(v + ((y + 1) % 3));
              i.fromBufferAttribute(s, g),
                o.fromBufferAttribute(s, x),
                cR(i, o, r) === !0 &&
                  (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z));
            }
        }
      } else {
        const s = e.attributes.position;
        for (let a = 0, l = s.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * a + c,
              d = 3 * a + ((c + 1) % 3);
            i.fromBufferAttribute(s, u),
              o.fromBufferAttribute(s, d),
              cR(i, o, r) === !0 &&
                (n.push(i.x, i.y, i.z), n.push(o.x, o.y, o.z));
          }
      }
      this.setAttribute("position", new dt(n, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function cR(t, e, n) {
  const r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;
  return n.has(r) === !0 || n.has(i) === !0 ? !1 : (n.add(r), n.add(i), !0);
}
var uR = Object.freeze({
  __proto__: null,
  BoxGeometry: Nc,
  CapsuleGeometry: py,
  CircleGeometry: my,
  ConeGeometry: gy,
  CylinderGeometry: Uf,
  DodecahedronGeometry: vy,
  EdgesGeometry: WN,
  ExtrudeGeometry: xy,
  IcosahedronGeometry: _y,
  LatheGeometry: Dp,
  OctahedronGeometry: Fp,
  PlaneGeometry: aa,
  PolyhedronGeometry: ll,
  RingGeometry: Sy,
  ShapeGeometry: Ay,
  SphereGeometry: Up,
  TetrahedronGeometry: by,
  TorusGeometry: wy,
  TorusKnotGeometry: Ey,
  TubeGeometry: My,
  WireframeGeometry: YN,
});
class qN extends qr {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new it(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class KN extends jo {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class bE extends qr {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new it(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new it(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new qi()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class ZN extends bE {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ke(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Un((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (n) {
          this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new it(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new it(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new it(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class JN extends qr {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new it(16777215)),
      (this.specular = new it(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new it(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new qi()),
      (this.combine = Rp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class QN extends qr {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new it(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class eD extends qr {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class tD extends qr {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new it(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new it(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new qi()),
      (this.combine = Rp),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class nD extends qr {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new it(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = al),
      (this.normalScale = new ke(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class rD extends fi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function rc(t, e, n) {
  return !t || (!n && t.constructor === e)
    ? t
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(t)
    : Array.prototype.slice.call(t);
}
function iD(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function oD(t) {
  function e(i, o) {
    return t[i] - t[o];
  }
  const n = t.length,
    r = new Array(n);
  for (let i = 0; i !== n; ++i) r[i] = i;
  return r.sort(e), r;
}
function UA(t, e, n) {
  const r = t.length,
    i = new t.constructor(r);
  for (let o = 0, s = 0; s !== r; ++o) {
    const a = n[o] * e;
    for (let l = 0; l !== e; ++l) i[s++] = t[a + l];
  }
  return i;
}
function wE(t, e, n, r) {
  let i = 1,
    o = t[0];
  for (; o !== void 0 && o[r] === void 0; ) o = t[i++];
  if (o === void 0) return;
  let s = o[r];
  if (s !== void 0)
    if (Array.isArray(s))
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), n.push.apply(n, s)),
          (o = t[i++]);
      while (o !== void 0);
    else if (s.toArray !== void 0)
      do
        (s = o[r]),
          s !== void 0 && (e.push(o.time), s.toArray(n, n.length)),
          (o = t[i++]);
      while (o !== void 0);
    else
      do (s = o[r]), s !== void 0 && (e.push(o.time), n.push(s)), (o = t[i++]);
      while (o !== void 0);
}
function JW(t, e, n, r, i = 30) {
  const o = t.clone();
  o.name = e;
  const s = [];
  for (let l = 0; l < o.tracks.length; ++l) {
    const c = o.tracks[l],
      u = c.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < c.times.length; ++m) {
      const v = c.times[m] * i;
      if (!(v < n || v >= r)) {
        d.push(c.times[m]);
        for (let _ = 0; _ < u; ++_) p.push(c.values[m * u + _]);
      }
    }
    d.length !== 0 &&
      ((c.times = rc(d, c.times.constructor)),
      (c.values = rc(p, c.values.constructor)),
      s.push(c));
  }
  o.tracks = s;
  let a = 1 / 0;
  for (let l = 0; l < o.tracks.length; ++l)
    a > o.tracks[l].times[0] && (a = o.tracks[l].times[0]);
  for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * a);
  return o.resetDuration(), o;
}
function QW(t, e = 0, n = t, r = 30) {
  r <= 0 && (r = 30);
  const i = n.tracks.length,
    o = e / r;
  for (let s = 0; s < i; ++s) {
    const a = n.tracks[s],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = t.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (u = d / 3);
    let p = 0;
    const m = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const v = a.times.length - 1;
    let _;
    if (o <= a.times[0]) {
      const g = u,
        x = d - u;
      _ = a.values.slice(g, x);
    } else if (o >= a.times[v]) {
      const g = v * d + u,
        x = g + d - u;
      _ = a.values.slice(g, x);
    } else {
      const g = a.createInterpolant(),
        x = u,
        S = d - u;
      g.evaluate(o), (_ = g.resultBuffer.slice(x, S));
    }
    l === "quaternion" &&
      new $r().fromArray(_).normalize().conjugate().toArray(_);
    const y = c.times.length;
    for (let g = 0; g < y; ++g) {
      const x = g * m + p;
      if (l === "quaternion")
        $r.multiplyQuaternionsFlat(c.values, x, _, 0, c.values, x);
      else {
        const S = m - p * 2;
        for (let b = 0; b < S; ++b) c.values[x + b] -= _[b];
      }
    }
  }
  return (t.blendMode = rE), t;
}
const ej = {
  convertArray: rc,
  isTypedArray: iD,
  getKeyframeOrder: oD,
  sortedArray: UA,
  flattenJSON: wE,
  subclip: JW,
  makeClipAdditive: QW,
};
class kp {
  constructor(e, n, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new n.constructor(r)),
      (this.sampleValues = n),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const n = this.parameterPositions;
    let r = this._cachedIndex,
      i = n[r],
      o = n[r - 1];
    e: {
      t: {
        let s;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < o) break r;
                return (
                  (r = n.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((o = i), (i = n[++r]), e < i)) break t;
            }
            s = n.length;
            break n;
          }
          if (!(e >= o)) {
            const a = n[1];
            e < a && ((r = 2), (o = a));
            for (let l = r - 2; ; ) {
              if (o === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = o), (o = n[--r - 1]), e >= o)) break t;
            }
            (s = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < s; ) {
          const a = (r + s) >>> 1;
          e < n[a] ? (s = a) : (r = a + 1);
        }
        if (((i = n[r]), (o = n[r - 1]), o === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = n.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, o, i);
    }
    return this.interpolate_(r, o, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const n = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      o = e * i;
    for (let s = 0; s !== i; ++s) n[s] = r[o + s];
    return n;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class sD extends kp {
  constructor(e, n, r, i) {
    super(e, n, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: ec, endingEnd: ec });
  }
  intervalChanged_(e, n, r) {
    const i = this.parameterPositions;
    let o = e - 2,
      s = e + 1,
      a = i[o],
      l = i[s];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case tc:
          (o = e), (a = 2 * n - r);
          break;
        case jh:
          (o = i.length - 2), (a = n + i[o] - i[o + 1]);
          break;
        default:
          (o = e), (a = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case tc:
          (s = e), (l = 2 * r - n);
          break;
        case jh:
          (s = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (s = e - 1), (l = n);
      }
    const c = (r - n) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (n - a)),
      (this._weightNext = c / (l - r)),
      (this._offsetPrev = o * u),
      (this._offsetNext = s * u);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      v = (r - n) / (i - n),
      _ = v * v,
      y = _ * v,
      g = -p * y + 2 * p * _ - p * v,
      x = (1 + p) * y + (-1.5 - 2 * p) * _ + (-0.5 + p) * v + 1,
      S = (-1 - m) * y + (1.5 + m) * _ + 0.5 * v,
      b = m * y - m * _;
    for (let C = 0; C !== a; ++C)
      o[C] = g * s[u + C] + x * s[c + C] + S * s[l + C] + b * s[d + C];
    return o;
  }
}
class EE extends kp {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (r - n) / (i - n),
      d = 1 - u;
    for (let p = 0; p !== a; ++p) o[p] = s[c + p] * d + s[l + p] * u;
    return o;
  }
}
class aD extends kp {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Yo {
  constructor(e, n, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (n === void 0 || n.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = rc(n, this.TimeBufferType)),
      (this.values = rc(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const n = e.constructor;
    let r;
    if (n.toJSON !== this.toJSON) r = n.toJSON(e);
    else {
      r = {
        name: e.name,
        times: rc(e.times, Array),
        values: rc(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new aD(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new EE(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new sD(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let n;
    switch (e) {
      case Gh:
        n = this.InterpolantFactoryMethodDiscrete;
        break;
      case Wh:
        n = this.InterpolantFactoryMethodLinear;
        break;
      case T0:
        n = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (n === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = n), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Gh;
      case this.InterpolantFactoryMethodLinear:
        return Wh;
      case this.InterpolantFactoryMethodSmooth:
        return T0;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const n = this.times;
      for (let r = 0, i = n.length; r !== i; ++r) n[r] *= e;
    }
    return this;
  }
  trim(e, n) {
    const r = this.times,
      i = r.length;
    let o = 0,
      s = i - 1;
    for (; o !== i && r[o] < e; ) ++o;
    for (; s !== -1 && r[s] > n; ) --s;
    if ((++s, o !== 0 || s !== i)) {
      o >= s && ((s = Math.max(s, 1)), (o = s - 1));
      const a = this.getValueSize();
      (this.times = r.slice(o, s)),
        (this.values = this.values.slice(o * a, s * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const n = this.getValueSize();
    n - Math.floor(n) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      o = r.length;
    o === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let s = null;
    for (let a = 0; a !== o; a++) {
      const l = r[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (s !== null && s > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, s),
          (e = !1);
        break;
      }
      s = l;
    }
    if (i !== void 0 && iD(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === T0,
      o = e.length - 1;
    let s = 1;
    for (let a = 1; a < o; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const d = a * r,
            p = d - r,
            m = d + r;
          for (let v = 0; v !== r; ++v) {
            const _ = n[d + v];
            if (_ !== n[p + v] || _ !== n[m + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== s) {
          e[s] = e[a];
          const d = a * r,
            p = s * r;
          for (let m = 0; m !== r; ++m) n[p + m] = n[d + m];
        }
        ++s;
      }
    }
    if (o > 0) {
      e[s] = e[o];
      for (let a = o * r, l = s * r, c = 0; c !== r; ++c) n[l + c] = n[a + c];
      ++s;
    }
    return (
      s !== e.length
        ? ((this.times = e.slice(0, s)), (this.values = n.slice(0, s * r)))
        : ((this.times = e), (this.values = n)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      n = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, n);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
Yo.prototype.TimeBufferType = Float32Array;
Yo.prototype.ValueBufferType = Float32Array;
Yo.prototype.DefaultInterpolation = Wh;
class Dc extends Yo {}
Dc.prototype.ValueTypeName = "bool";
Dc.prototype.ValueBufferType = Array;
Dc.prototype.DefaultInterpolation = Gh;
Dc.prototype.InterpolantFactoryMethodLinear = void 0;
Dc.prototype.InterpolantFactoryMethodSmooth = void 0;
class ME extends Yo {}
ME.prototype.ValueTypeName = "color";
class np extends Yo {}
np.prototype.ValueTypeName = "number";
class lD extends kp {
  constructor(e, n, r, i) {
    super(e, n, r, i);
  }
  interpolate_(e, n, r, i) {
    const o = this.resultBuffer,
      s = this.sampleValues,
      a = this.valueSize,
      l = (r - n) / (i - n);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) $r.slerpFlat(o, 0, s, c - a, s, c, l);
    return o;
  }
}
class kf extends Yo {
  InterpolantFactoryMethodLinear(e) {
    return new lD(this.times, this.values, this.getValueSize(), e);
  }
}
kf.prototype.ValueTypeName = "quaternion";
kf.prototype.DefaultInterpolation = Wh;
kf.prototype.InterpolantFactoryMethodSmooth = void 0;
class Fc extends Yo {}
Fc.prototype.ValueTypeName = "string";
Fc.prototype.ValueBufferType = Array;
Fc.prototype.DefaultInterpolation = Gh;
Fc.prototype.InterpolantFactoryMethodLinear = void 0;
Fc.prototype.InterpolantFactoryMethodSmooth = void 0;
class rp extends Yo {}
rp.prototype.ValueTypeName = "vector";
class ip {
  constructor(e = "", n = -1, r = [], i = ny) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = n),
      (this.blendMode = i),
      (this.uuid = Xi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const n = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let s = 0, a = r.length; s !== a; ++s) n.push(nj(r[s]).scale(i));
    const o = new this(e.name, e.duration, n, e.blendMode);
    return (o.uuid = e.uuid), o;
  }
  static toJSON(e) {
    const n = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: n,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let o = 0, s = r.length; o !== s; ++o) n.push(Yo.toJSON(r[o]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, n, r, i) {
    const o = n.length,
      s = [];
    for (let a = 0; a < o; a++) {
      let l = [],
        c = [];
      l.push((a + o - 1) % o, a, (a + 1) % o), c.push(0, 1, 0);
      const u = oD(l);
      (l = UA(l, 1, u)),
        (c = UA(c, 1, u)),
        !i && l[0] === 0 && (l.push(o), c.push(c[0])),
        s.push(
          new np(".morphTargetInfluences[" + n[a].name + "]", l, c).scale(1 / r)
        );
    }
    return new this(e, -1, s);
  }
  static findByName(e, n) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === n) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, n, r) {
    const i = {},
      o = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(o);
      if (u && u.length > 1) {
        const d = u[1];
        let p = i[d];
        p || (i[d] = p = []), p.push(c);
      }
    }
    const s = [];
    for (const a in i)
      s.push(this.CreateFromMorphTargetSequence(a, i[a], n, r));
    return s;
  }
  static parseAnimation(e, n) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (d, p, m, v, _) {
        if (m.length !== 0) {
          const y = [],
            g = [];
          wE(m, y, g, v), y.length !== 0 && _.push(new d(p, y, g));
        }
      },
      i = [],
      o = e.name || "default",
      s = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const p = c[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let _ = 0; _ < p[v].morphTargets.length; _++)
                m[p[v].morphTargets[_]] = -1;
          for (const _ in m) {
            const y = [],
              g = [];
            for (let x = 0; x !== p[v].morphTargets.length; ++x) {
              const S = p[v];
              y.push(S.time), g.push(S.morphTarget === _ ? 1 : 0);
            }
            i.push(new np(".morphTargetInfluence[" + _ + "]", y, g));
          }
          l = m.length * s;
        } else {
          const m = ".bones[" + n[d].name + "]";
          r(rp, m + ".position", p, "pos", i),
            r(kf, m + ".quaternion", p, "rot", i),
            r(rp, m + ".scale", p, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(o, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let n = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const o = this.tracks[r];
      n = Math.max(n, o.times[o.times.length - 1]);
    }
    return (this.duration = n), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let n = 0; n < this.tracks.length; n++)
      e = e && this.tracks[n].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++) e.push(this.tracks[n].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function tj(t) {
  switch (t.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return np;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return rp;
    case "color":
      return ME;
    case "quaternion":
      return kf;
    case "bool":
    case "boolean":
      return Dc;
    case "string":
      return Fc;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
}
function nj(t) {
  if (t.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = tj(t.type);
  if (t.times === void 0) {
    const n = [],
      r = [];
    wE(t.keys, n, r, "value"), (t.times = n), (t.values = r);
  }
  return e.parse !== void 0
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
const Gs = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    this.enabled !== !1 && (this.files[t] = e);
  },
  get: function (t) {
    if (this.enabled !== !1) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
let CE = class {
  constructor(e, n, r) {
    const i = this;
    let o = !1,
      s = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = n),
      (this.onError = r),
      (this.itemStart = function (u) {
        a++, o === !1 && i.onStart !== void 0 && i.onStart(u, s, a), (o = !0);
      }),
      (this.itemEnd = function (u) {
        s++,
          i.onProgress !== void 0 && i.onProgress(u, s, a),
          s === a && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, p = c.length; d < p; d += 2) {
          const m = c[d],
            v = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return v;
        }
        return null;
      });
  }
};
const cD = new CE();
let Ci = class {
  constructor(e) {
    (this.manager = e !== void 0 ? e : cD),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, n) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, n, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
};
Ci.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Ds = {};
class rj extends Error {
  constructor(e, n) {
    super(e), (this.response = n);
  }
}
class ea extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = Gs.get(e);
    if (o !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          n && n(o), this.manager.itemEnd(e);
        }, 0),
        o
      );
    if (Ds[e] !== void 0) {
      Ds[e].push({ onLoad: n, onProgress: r, onError: i });
      return;
    }
    (Ds[e] = []), Ds[e].push({ onLoad: n, onProgress: r, onError: i });
    const s = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(s)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = Ds[e],
            d = c.body.getReader(),
            p = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            m = p ? parseInt(p) : 0,
            v = m !== 0;
          let _ = 0;
          const y = new ReadableStream({
            start(g) {
              x();
              function x() {
                d.read().then(({ done: S, value: b }) => {
                  if (S) g.close();
                  else {
                    _ += b.byteLength;
                    const C = new ProgressEvent("progress", {
                      lengthComputable: v,
                      loaded: _,
                      total: m,
                    });
                    for (let M = 0, T = u.length; M < T; M++) {
                      const P = u[M];
                      P.onProgress && P.onProgress(C);
                    }
                    g.enqueue(b), x();
                  }
                });
              }
            },
          });
          return new Response(y);
        } else
          throw new rj(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return c.arrayBuffer().then((v) => m.decode(v));
            }
        }
      })
      .then((c) => {
        Gs.add(e, c);
        const u = Ds[e];
        delete Ds[e];
        for (let d = 0, p = u.length; d < p; d++) {
          const m = u[d];
          m.onLoad && m.onLoad(c);
        }
      })
      .catch((c) => {
        const u = Ds[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete Ds[e];
        for (let d = 0, p = u.length; d < p; d++) {
          const m = u[d];
          m.onError && m.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class ij extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = new ea(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            n(o.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const i = ip.parse(e[r]);
      n.push(i);
    }
    return n;
  }
}
class oj extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = [],
      a = new dy(),
      l = new ea(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(o.withCredentials);
    let c = 0;
    function u(d) {
      l.load(
        e[d],
        function (p) {
          const m = o.parse(p, !0);
          (s[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = kn),
              (a.image = s),
              (a.format = m.format),
              (a.needsUpdate = !0),
              n && n(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) u(d);
    else
      l.load(
        e,
        function (d) {
          const p = o.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < m; v++) {
              s[v] = { mipmaps: [] };
              for (let _ = 0; _ < p.mipmapCount; _++)
                s[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + _]),
                  (s[v].format = p.format),
                  (s[v].width = p.width),
                  (s[v].height = p.height);
            }
            a.image = s;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = kn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            n && n(a);
        },
        r,
        i
      );
    return a;
  }
}
let op = class extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Gs.get(e);
    if (s !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          n && n(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    const a = Zh("img");
    function l() {
      u(), Gs.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
};
class sj extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = new Op();
    o.colorSpace = fo;
    const s = new op(this.manager);
    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
    let a = 0;
    function l(c) {
      s.load(
        e[c],
        function (u) {
          (o.images[c] = u), a++, a === 6 && ((o.needsUpdate = !0), n && n(o));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return o;
  }
}
class aj extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = new Ka(),
      a = new ea(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(o.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = o.parse(l);
          } catch (u) {
            if (i !== void 0) i(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (s.image = c.image)
            : c.data !== void 0 &&
              ((s.image.width = c.width),
              (s.image.height = c.height),
              (s.image.data = c.data)),
            (s.wrapS = c.wrapS !== void 0 ? c.wrapS : vo),
            (s.wrapT = c.wrapT !== void 0 ? c.wrapT : vo),
            (s.magFilter = c.magFilter !== void 0 ? c.magFilter : kn),
            (s.minFilter = c.minFilter !== void 0 ? c.minFilter : kn),
            (s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (s.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (s.flipY = c.flipY),
            c.format !== void 0 && (s.format = c.format),
            c.type !== void 0 && (s.type = c.type),
            c.mipmaps !== void 0 &&
              ((s.mipmaps = c.mipmaps), (s.minFilter = ls)),
            c.mipmapCount === 1 && (s.minFilter = kn),
            c.generateMipmaps !== void 0 &&
              (s.generateMipmaps = c.generateMipmaps),
            (s.needsUpdate = !0),
            n && n(s, c);
        },
        r,
        i
      ),
      s
    );
  }
}
let lj = class extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = new lr(),
      s = new op(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (a) {
          (o.image = a), (o.needsUpdate = !0), n !== void 0 && n(o);
        },
        r,
        i
      ),
      o
    );
  }
};
class cl extends Qt {
  constructor(e, n = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new it(e)),
      (this.intensity = n);
  }
  dispose() {}
  copy(e, n) {
    return (
      super.copy(e, n),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.color = this.color.getHex()),
      (n.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (n.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (n.object.distance = this.distance),
      this.angle !== void 0 && (n.object.angle = this.angle),
      this.decay !== void 0 && (n.object.decay = this.decay),
      this.penumbra !== void 0 && (n.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()),
      n
    );
  }
}
class uD extends cl {
  constructor(e, n, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new it(n));
  }
  copy(e, n) {
    return super.copy(e, n), this.groundColor.copy(e.groundColor), this;
  }
}
const d_ = new wt(),
  fR = new ee(),
  dR = new ee();
class TE {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ke(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new wt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Np()),
      (this._frameExtents = new ke(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new tn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera,
      r = this.matrix;
    fR.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(fR),
      dR.setFromMatrixPosition(e.target.matrixWorld),
      n.lookAt(dR),
      n.updateMatrixWorld(),
      d_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(d_),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(d_);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class cj extends TE {
  constructor() {
    super(new En(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const n = this.camera,
      r = xf * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      o = e.distance || n.far;
    (r !== n.fov || i !== n.aspect || o !== n.far) &&
      ((n.fov = r), (n.aspect = i), (n.far = o), n.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class fD extends cl {
  constructor(e, n, r = 0, i = Math.PI / 3, o = 0, s = 2) {
    super(e, n),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Qt()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = o),
      (this.decay = s),
      (this.map = null),
      (this.shadow = new cj());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const hR = new wt(),
  Fd = new ee(),
  h_ = new ee();
class uj extends TE {
  constructor() {
    super(new En(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ke(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new tn(2, 1, 1, 1),
        new tn(0, 1, 1, 1),
        new tn(3, 1, 1, 1),
        new tn(1, 1, 1, 1),
        new tn(3, 0, 1, 1),
        new tn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new ee(1, 0, 0),
        new ee(-1, 0, 0),
        new ee(0, 0, 1),
        new ee(0, 0, -1),
        new ee(0, 1, 0),
        new ee(0, -1, 0),
      ]),
      (this._cubeUps = [
        new ee(0, 1, 0),
        new ee(0, 1, 0),
        new ee(0, 1, 0),
        new ee(0, 1, 0),
        new ee(0, 0, 1),
        new ee(0, 0, -1),
      ]);
  }
  updateMatrices(e, n = 0) {
    const r = this.camera,
      i = this.matrix,
      o = e.distance || r.far;
    o !== r.far && ((r.far = o), r.updateProjectionMatrix()),
      Fd.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Fd),
      h_.copy(r.position),
      h_.add(this._cubeDirections[n]),
      r.up.copy(this._cubeUps[n]),
      r.lookAt(h_),
      r.updateMatrixWorld(),
      i.makeTranslation(-Fd.x, -Fd.y, -Fd.z),
      hR.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(hR);
  }
}
class dD extends cl {
  constructor(e, n, r = 0, i = 2) {
    super(e, n),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new uj());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class fj extends TE {
  constructor() {
    super(new ps(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class hD extends cl {
  constructor(e, n) {
    super(e, n),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Qt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Qt()),
      (this.shadow = new fj());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class pD extends cl {
  constructor(e, n) {
    super(e, n), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class mD extends cl {
  constructor(e, n, r = 10, i = 10) {
    super(e, n),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.width = this.width), (n.object.height = this.height), n;
  }
}
class gD {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new ee());
  }
  set(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].copy(e[n]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      n.copy(s[0]).multiplyScalar(0.282095),
      n.addScaledVector(s[1], 0.488603 * i),
      n.addScaledVector(s[2], 0.488603 * o),
      n.addScaledVector(s[3], 0.488603 * r),
      n.addScaledVector(s[4], 1.092548 * (r * i)),
      n.addScaledVector(s[5], 1.092548 * (i * o)),
      n.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)),
      n.addScaledVector(s[7], 1.092548 * (r * o)),
      n.addScaledVector(s[8], 0.546274 * (r * r - i * i)),
      n
    );
  }
  getIrradianceAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z,
      s = this.coefficients;
    return (
      n.copy(s[0]).multiplyScalar(0.886227),
      n.addScaledVector(s[1], 2 * 0.511664 * i),
      n.addScaledVector(s[2], 2 * 0.511664 * o),
      n.addScaledVector(s[3], 2 * 0.511664 * r),
      n.addScaledVector(s[4], 2 * 0.429043 * r * i),
      n.addScaledVector(s[5], 2 * 0.429043 * i * o),
      n.addScaledVector(s[6], 0.743125 * o * o - 0.247708),
      n.addScaledVector(s[7], 2 * 0.429043 * r * o),
      n.addScaledVector(s[8], 0.429043 * (r * r - i * i)),
      n
    );
  }
  add(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].add(e.coefficients[n]);
    return this;
  }
  addScaledSH(e, n) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], n);
    return this;
  }
  scale(e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].multiplyScalar(e);
    return this;
  }
  lerp(e, n) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], n);
    return this;
  }
  equals(e) {
    for (let n = 0; n < 9; n++)
      if (!this.coefficients[n].equals(e.coefficients[n])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, n + i * 3);
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, n + i * 3);
    return e;
  }
  static getBasisAt(e, n) {
    const r = e.x,
      i = e.y,
      o = e.z;
    (n[0] = 0.282095),
      (n[1] = 0.488603 * i),
      (n[2] = 0.488603 * o),
      (n[3] = 0.488603 * r),
      (n[4] = 1.092548 * r * i),
      (n[5] = 1.092548 * i * o),
      (n[6] = 0.315392 * (3 * o * o - 1)),
      (n[7] = 1.092548 * r * o),
      (n[8] = 0.546274 * (r * r - i * i));
  }
}
class vD extends cl {
  constructor(e = new gD(), n = 1) {
    super(void 0, n), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (n.object.sh = this.sh.toArray()), n;
  }
}
class Cy extends Ci {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, n, r, i) {
    const o = this,
      s = new ea(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            n(o.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = this.textures;
    function r(o) {
      return (
        n[o] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", o),
        n[o]
      );
    }
    const i = Cy.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new it().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const o in e.uniforms) {
        const s = e.uniforms[o];
        switch (((i.uniforms[o] = {}), s.type)) {
          case "t":
            i.uniforms[o].value = r(s.value);
            break;
          case "c":
            i.uniforms[o].value = new it().setHex(s.value);
            break;
          case "v2":
            i.uniforms[o].value = new ke().fromArray(s.value);
            break;
          case "v3":
            i.uniforms[o].value = new ee().fromArray(s.value);
            break;
          case "v4":
            i.uniforms[o].value = new tn().fromArray(s.value);
            break;
          case "m3":
            i.uniforms[o].value = new Dt().fromArray(s.value);
            break;
          case "m4":
            i.uniforms[o].value = new wt().fromArray(s.value);
            break;
          default:
            i.uniforms[o].value = s.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const o in e.extensions) i.extensions[o] = e.extensions[o];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let o = e.normalScale;
      Array.isArray(o) === !1 && (o = [o, o]),
        (i.normalScale = new ke().fromArray(o));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new ke().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const n = {
      ShadowMaterial: qN,
      SpriteMaterial: pE,
      RawShaderMaterial: KN,
      ShaderMaterial: jo,
      PointsMaterial: gE,
      MeshPhysicalMaterial: ZN,
      MeshStandardMaterial: bE,
      MeshPhongMaterial: JN,
      MeshToonMaterial: QN,
      MeshNormalMaterial: eD,
      MeshLambertMaterial: tD,
      MeshDepthMaterial: sy,
      MeshDistanceMaterial: ay,
      MeshBasicMaterial: sa,
      MeshMatcapMaterial: nD,
      LineDashedMaterial: rD,
      LineBasicMaterial: fi,
      Material: qr,
    };
    return new n[e]();
  }
}
class kA {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let n = "";
    for (let r = 0, i = e.length; r < i; r++) n += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(n));
    } catch {
      return n;
    }
  }
  static extractUrlBase(e) {
    const n = e.lastIndexOf("/");
    return n === -1 ? "./" : e.slice(0, n + 1);
  }
  static resolveURL(e, n) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(n) &&
          /^\//.test(e) &&
          (n = n.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : n + e);
  }
}
class RE extends Ut {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class yD extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = new ea(o.manager);
    s.setPath(o.path),
      s.setRequestHeader(o.requestHeader),
      s.setWithCredentials(o.withCredentials),
      s.load(
        e,
        function (a) {
          try {
            n(o.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), o.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const n = {},
      r = {};
    function i(m, v) {
      if (n[v] !== void 0) return n[v];
      const y = m.interleavedBuffers[v],
        g = o(m, y.buffer),
        x = Xu(y.type, g),
        S = new uy(x, y.stride);
      return (S.uuid = y.uuid), (n[v] = S), S;
    }
    function o(m, v) {
      if (r[v] !== void 0) return r[v];
      const y = m.arrayBuffers[v],
        g = new Uint32Array(y).buffer;
      return (r[v] = g), g;
    }
    const s = e.isInstancedBufferGeometry ? new RE() : new Ut(),
      a = e.data.index;
    if (a !== void 0) {
      const m = Xu(a.type, a.array);
      s.setIndex(new sn(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const v = l[m];
      let _;
      if (v.isInterleavedBufferAttribute) {
        const y = i(e.data, v.data);
        _ = new Ec(y, v.itemSize, v.offset, v.normalized);
      } else {
        const y = Xu(v.type, v.array),
          g = v.isInstancedBufferAttribute ? Mc : sn;
        _ = new g(y, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (_.name = v.name),
        v.usage !== void 0 && _.setUsage(v.usage),
        s.setAttribute(m, _);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const m in c) {
        const v = c[m],
          _ = [];
        for (let y = 0, g = v.length; y < g; y++) {
          const x = v[y];
          let S;
          if (x.isInterleavedBufferAttribute) {
            const b = i(e.data, x.data);
            S = new Ec(b, x.itemSize, x.offset, x.normalized);
          } else {
            const b = Xu(x.type, x.array);
            S = new sn(b, x.itemSize, x.normalized);
          }
          x.name !== void 0 && (S.name = x.name), _.push(S);
        }
        s.morphAttributes[m] = _;
      }
    e.data.morphTargetsRelative && (s.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, v = d.length; m !== v; ++m) {
        const _ = d[m];
        s.addGroup(_.start, _.count, _.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new ee();
      p.center !== void 0 && m.fromArray(p.center),
        (s.boundingSphere = new Pr(m, p.radius));
    }
    return (
      e.name && (s.name = e.name), e.userData && (s.userData = e.userData), s
    );
  }
}
class dj extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = this.path === "" ? kA.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || s;
    const a = new ea(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (d) {
            i !== void 0 && i(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const u = c.metadata;
          if (
            u === void 0 ||
            u.type === void 0 ||
            u.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          o.parse(c, n);
        },
        r,
        i
      );
  }
  async loadAsync(e, n) {
    const r = this,
      i = this.path === "" ? kA.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const o = new ea(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials);
    const s = await o.loadAsync(e, n),
      a = JSON.parse(s),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, n) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      o = this.parseGeometries(e.geometries, i),
      s = this.parseImages(e.images, function () {
        n !== void 0 && n(c);
      }),
      a = this.parseTextures(e.textures, s),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, o, l, a, r),
      u = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, u), n !== void 0)) {
      let d = !1;
      for (const p in s)
        if (s[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && n(c);
    }
    return c;
  }
  async parseAsync(e) {
    const n = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      o = await this.parseImagesAsync(e.images),
      s = this.parseTextures(e.textures, o),
      a = this.parseMaterials(e.materials, s),
      l = this.parseObject(e.object, i, a, s, n),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const o = new pc().fromJSON(e[r]);
        n[o.uuid] = o;
      }
    return n;
  }
  parseSkeletons(e, n) {
    const r = {},
      i = {};
    if (
      (n.traverse(function (o) {
        o.isBone && (i[o.uuid] = o);
      }),
      e !== void 0)
    )
      for (let o = 0, s = e.length; o < s; o++) {
        const a = new fy().fromJSON(e[o], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, n) {
    const r = {};
    if (e !== void 0) {
      const i = new yD();
      for (let o = 0, s = e.length; o < s; o++) {
        let a;
        const l = e[o];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in uR
              ? (a = uR[l.type].fromJSON(l, n))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (r[l.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, n) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const o = new Cy();
      o.setTextures(n);
      for (let s = 0, a = e.length; s < a; s++) {
        const l = e[s];
        r[l.uuid] === void 0 && (r[l.uuid] = o.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const n = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          o = ip.parse(i);
        n[o.uuid] = o;
      }
    return n;
  }
  parseImages(e, n) {
    const r = this,
      i = {};
    let o;
    function s(l) {
      return (
        r.manager.itemStart(l),
        o.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c;
        return s(u);
      } else
        return l.data
          ? { data: Xu(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new CE(n);
      (o = new op(l)), o.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const d = e[c],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const y = p[v],
              g = a(y);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new Ka(g.data, g.width, g.height)));
          }
          i[d.uuid] = new nc(m);
        } else {
          const m = a(d.url);
          i[d.uuid] = new nc(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const n = this,
      r = {};
    let i;
    async function o(s) {
      if (typeof s == "string") {
        const a = s,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : n.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return s.data
          ? { data: Xu(s.type, s.data), width: s.width, height: s.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new op(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let s = 0, a = e.length; s < a; s++) {
        const l = e[s],
          c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const m = c[d],
              v = await o(m);
            v !== null &&
              (v instanceof HTMLImageElement
                ? u.push(v)
                : u.push(new Ka(v.data, v.width, v.height)));
          }
          r[l.uuid] = new nc(u);
        } else {
          const u = await o(l.url);
          r[l.uuid] = new nc(u);
        }
      }
    }
    return r;
  }
  parseTextures(e, n) {
    function r(o, s) {
      return typeof o == "number"
        ? o
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            o
          ),
          s[o]);
    }
    const i = {};
    if (e !== void 0)
      for (let o = 0, s = e.length; o < s; o++) {
        const a = e[o];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          n[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = n[a.image],
          c = l.data;
        let u;
        Array.isArray(c)
          ? ((u = new Op()), c.length === 6 && (u.needsUpdate = !0))
          : (c && c.data ? (u = new Ka()) : (u = new lr()),
            c && (u.needsUpdate = !0)),
          (u.source = l),
          (u.uuid = a.uuid),
          a.name !== void 0 && (u.name = a.name),
          a.mapping !== void 0 && (u.mapping = r(a.mapping, hj)),
          a.channel !== void 0 && (u.channel = a.channel),
          a.offset !== void 0 && u.offset.fromArray(a.offset),
          a.repeat !== void 0 && u.repeat.fromArray(a.repeat),
          a.center !== void 0 && u.center.fromArray(a.center),
          a.rotation !== void 0 && (u.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((u.wrapS = r(a.wrap[0], pR)), (u.wrapT = r(a.wrap[1], pR))),
          a.format !== void 0 && (u.format = a.format),
          a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat),
          a.type !== void 0 && (u.type = a.type),
          a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (u.minFilter = r(a.minFilter, mR)),
          a.magFilter !== void 0 && (u.magFilter = r(a.magFilter, mR)),
          a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (u.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (u.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (u.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (u.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (u.compareFunction = a.compareFunction),
          a.userData !== void 0 && (u.userData = a.userData),
          (i[a.uuid] = u);
      }
    return i;
  }
  parseObject(e, n, r, i, o) {
    let s;
    function a(p) {
      return (
        n[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        n[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, _ = p.length; v < _; v++) {
            const y = p[v];
            r[y] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", y),
              m.push(r[y]);
          }
          return m;
        }
        return (
          r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          r[p]
        );
      }
    }
    function c(p) {
      return (
        i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        i[p]
      );
    }
    let u, d;
    switch (e.type) {
      case "Scene":
        (s = new hE()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (s.background = new it(e.background))
              : (s.background = c(e.background))),
          e.environment !== void 0 && (s.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (s.fog = new cy(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (s.fog = new ly(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (s.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (s.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (s.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            s.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (s.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            s.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (s = new En(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (s.focus = e.focus),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.filmGauge !== void 0 && (s.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (s.filmOffset = e.filmOffset),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (s = new ps(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (s.zoom = e.zoom),
          e.view !== void 0 && (s.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        s = new pD(e.color, e.intensity);
        break;
      case "DirectionalLight":
        s = new hD(e.color, e.intensity);
        break;
      case "PointLight":
        s = new dD(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        s = new mD(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        s = new fD(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        s = new uD(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        s = new vD().fromJSON(e);
        break;
      case "SkinnedMesh":
        (u = a(e.geometry)),
          (d = l(e.material)),
          (s = new NN(u, d)),
          e.bindMode !== void 0 && (s.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && s.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (s.skeleton = e.skeleton);
        break;
      case "Mesh":
        (u = a(e.geometry)), (d = l(e.material)), (s = new Cn(u, d));
        break;
      case "InstancedMesh":
        (u = a(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          v = e.instanceColor;
        (s = new DN(u, d, p)),
          (s.instanceMatrix = new Mc(new Float32Array(m.array), 16)),
          v !== void 0 &&
            (s.instanceColor = new Mc(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        (u = a(e.geometry)),
          (d = l(e.material)),
          (s = new FN(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            d
          )),
          (s.geometry = u),
          (s.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (s.sortObjects = e.sortObjects),
          (s._drawRanges = e.drawRanges),
          (s._reservedRanges = e.reservedRanges),
          (s._visibility = e.visibility),
          (s._active = e.active),
          (s._bounds = e.bounds.map((_) => {
            const y = new Rr();
            y.min.fromArray(_.boxMin), y.max.fromArray(_.boxMax);
            const g = new Pr();
            return (
              (g.radius = _.sphereRadius),
              g.center.fromArray(_.sphereCenter),
              {
                boxInitialized: _.boxInitialized,
                box: y,
                sphereInitialized: _.sphereInitialized,
                sphere: g,
              }
            );
          })),
          (s._maxGeometryCount = e.maxGeometryCount),
          (s._maxVertexCount = e.maxVertexCount),
          (s._maxIndexCount = e.maxIndexCount),
          (s._geometryInitialized = e.geometryInitialized),
          (s._geometryCount = e.geometryCount),
          (s._matricesTexture = c(e.matricesTexture.uuid));
        break;
      case "LOD":
        s = new ON();
        break;
      case "Line":
        s = new nl(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        s = new UN(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        s = new xs(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        s = new kN(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        s = new LN(l(e.material));
        break;
      case "Group":
        s = new qu();
        break;
      case "Bone":
        s = new mE();
        break;
      default:
        s = new Qt();
    }
    if (
      ((s.uuid = e.uuid),
      e.name !== void 0 && (s.name = e.name),
      e.matrix !== void 0
        ? (s.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (s.matrixAutoUpdate = e.matrixAutoUpdate),
          s.matrixAutoUpdate &&
            s.matrix.decompose(s.position, s.quaternion, s.scale))
        : (e.position !== void 0 && s.position.fromArray(e.position),
          e.rotation !== void 0 && s.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && s.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && s.scale.fromArray(e.scale)),
      e.up !== void 0 && s.up.fromArray(e.up),
      e.castShadow !== void 0 && (s.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (s.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (s.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (s.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (s.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          s.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (s.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (s.visible = e.visible),
      e.frustumCulled !== void 0 && (s.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (s.renderOrder = e.renderOrder),
      e.userData !== void 0 && (s.userData = e.userData),
      e.layers !== void 0 && (s.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        s.add(this.parseObject(p[m], n, r, i, o));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        s.animations.push(o[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (s.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const v = p[m],
          _ = s.getObjectByProperty("uuid", v.object);
        _ !== void 0 && s.addLevel(_, v.distance, v.hysteresis);
      }
    }
    return s;
  }
  bindSkeletons(e, n) {
    Object.keys(n).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = n[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
}
const hj = {
    UVMapping: ty,
    CubeReflectionMapping: Qs,
    CubeRefractionMapping: tl,
    EquirectangularReflectionMapping: zh,
    EquirectangularRefractionMapping: Bh,
    CubeUVReflectionMapping: Nf,
  },
  pR = {
    RepeatWrapping: Hh,
    ClampToEdgeWrapping: vo,
    MirroredRepeatWrapping: Vh,
  },
  mR = {
    NearestFilter: xr,
    NearestMipmapNearestFilter: Yw,
    NearestMipmapLinearFilter: $u,
    LinearFilter: kn,
    LinearMipmapNearestFilter: fh,
    LinearMipmapLinearFilter: ls,
  };
class pj extends Ci {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, n, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = Gs.get(e);
    if (s !== void 0) {
      if ((o.manager.itemStart(e), s.then)) {
        s.then((c) => {
          n && n(c), o.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          n && n(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(o.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Gs.add(e, c), n && n(c), o.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        i && i(c), Gs.remove(e), o.manager.itemError(e), o.manager.itemEnd(e);
      });
    Gs.add(e, l), o.manager.itemStart(e);
  }
}
let zg;
class PE {
  static getContext() {
    return (
      zg === void 0 &&
        (zg = new (window.AudioContext || window.webkitAudioContext)()),
      zg
    );
  }
  static setContext(e) {
    zg = e;
  }
}
class mj extends Ci {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = this,
      s = new ea(this.manager);
    s.setResponseType("arraybuffer"),
      s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            PE.getContext()
              .decodeAudioData(c, function (d) {
                n(d);
              })
              .catch(a);
          } catch (c) {
            a(c);
          }
        },
        r,
        i
      );
    function a(l) {
      i ? i(l) : console.error(l), o.manager.itemError(e);
    }
  }
}
const gR = new wt(),
  vR = new wt(),
  Fl = new wt();
class gj {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new En()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new En()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const n = this._cache;
    if (
      n.focus !== e.focus ||
      n.fov !== e.fov ||
      n.aspect !== e.aspect * this.aspect ||
      n.near !== e.near ||
      n.far !== e.far ||
      n.zoom !== e.zoom ||
      n.eyeSep !== this.eyeSep
    ) {
      (n.focus = e.focus),
        (n.fov = e.fov),
        (n.aspect = e.aspect * this.aspect),
        (n.near = e.near),
        (n.far = e.far),
        (n.zoom = e.zoom),
        (n.eyeSep = this.eyeSep),
        Fl.copy(e.projectionMatrix);
      const i = n.eyeSep / 2,
        o = (i * n.near) / n.focus,
        s = (n.near * Math.tan(dc * n.fov * 0.5)) / n.zoom;
      let a, l;
      (vR.elements[12] = -i),
        (gR.elements[12] = i),
        (a = -s * n.aspect + o),
        (l = s * n.aspect + o),
        (Fl.elements[0] = (2 * n.near) / (l - a)),
        (Fl.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(Fl),
        (a = -s * n.aspect - o),
        (l = s * n.aspect - o),
        (Fl.elements[0] = (2 * n.near) / (l - a)),
        (Fl.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(Fl);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(vR),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(gR);
  }
}
class IE {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = yR()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const n = yR();
      (e = (n - this.oldTime) / 1e3),
        (this.oldTime = n),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function yR() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Ul = new ee(),
  xR = new $r(),
  vj = new ee(),
  kl = new ee();
class yj extends Qt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = PE.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new IE());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const n = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Ul, xR, vj),
      kl.set(0, 0, -1).applyQuaternion(xR),
      n.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      n.positionX.linearRampToValueAtTime(Ul.x, i),
        n.positionY.linearRampToValueAtTime(Ul.y, i),
        n.positionZ.linearRampToValueAtTime(Ul.z, i),
        n.forwardX.linearRampToValueAtTime(kl.x, i),
        n.forwardY.linearRampToValueAtTime(kl.y, i),
        n.forwardZ.linearRampToValueAtTime(kl.z, i),
        n.upX.linearRampToValueAtTime(r.x, i),
        n.upY.linearRampToValueAtTime(r.y, i),
        n.upZ.linearRampToValueAtTime(r.z, i);
    } else
      n.setPosition(Ul.x, Ul.y, Ul.z),
        n.setOrientation(kl.x, kl.y, kl.z, r.x, r.y, r.z);
  }
}
class xD extends Qt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const n = this.context.createBufferSource();
    return (
      (n.buffer = this.buffer),
      (n.loop = this.loop),
      (n.loopStart = this.loopStart),
      (n.loopEnd = this.loopEnd),
      (n.onended = this.onEnded.bind(this)),
      n.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = n),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, n = this.filters.length; e < n; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, n = this.filters.length; e < n; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const zl = new ee(),
  _R = new $r(),
  xj = new ee(),
  Bl = new ee();
class _j extends xD {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, n, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = n),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(zl, _R, xj), Bl.set(0, 0, 1).applyQuaternion(_R);
    const n = this.panner;
    if (n.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      n.positionX.linearRampToValueAtTime(zl.x, r),
        n.positionY.linearRampToValueAtTime(zl.y, r),
        n.positionZ.linearRampToValueAtTime(zl.z, r),
        n.orientationX.linearRampToValueAtTime(Bl.x, r),
        n.orientationY.linearRampToValueAtTime(Bl.y, r),
        n.orientationZ.linearRampToValueAtTime(Bl.z, r);
    } else n.setPosition(zl.x, zl.y, zl.z), n.setOrientation(Bl.x, Bl.y, Bl.z);
  }
}
class Sj {
  constructor(e, n = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = n),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const n = this.getFrequencyData();
    for (let r = 0; r < n.length; r++) e += n[r];
    return e / n.length;
  }
}
class _D {
  constructor(e, n, r) {
    (this.binding = e), (this.valueSize = r);
    let i, o, s;
    switch (n) {
      case "quaternion":
        (i = this._slerp),
          (o = this._slerpAdditive),
          (s = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (o = this._select),
          (s = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (o = this._lerpAdditive),
          (s = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = o),
      (this._setIdentity = s),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, n) {
    const r = this.buffer,
      i = this.valueSize,
      o = e * i + i;
    let s = this.cumulativeWeight;
    if (s === 0) {
      for (let a = 0; a !== i; ++a) r[o + a] = r[a];
      s = n;
    } else {
      s += n;
      const a = n / s;
      this._mixBufferRegion(r, o, 0, a, i);
    }
    this.cumulativeWeight = s;
  }
  accumulateAdditive(e) {
    const n = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(n, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const n = this.valueSize,
      r = this.buffer,
      i = e * n + n,
      o = this.cumulativeWeight,
      s = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), o < 1)
    ) {
      const l = n * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - o, n);
    }
    s > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * n, 1, n);
    for (let l = n, c = n + n; l !== c; ++l)
      if (r[l] !== r[l + n]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      n = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(n, i);
    for (let o = r, s = i; o !== s; ++o) n[o] = n[i + (o % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      n = e + this.valueSize;
    for (let r = e; r < n; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      n = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[n + r] = this.buffer[e + r];
  }
  _select(e, n, r, i, o) {
    if (i >= 0.5) for (let s = 0; s !== o; ++s) e[n + s] = e[r + s];
  }
  _slerp(e, n, r, i) {
    $r.slerpFlat(e, n, e, n, e, r, i);
  }
  _slerpAdditive(e, n, r, i, o) {
    const s = this._workIndex * o;
    $r.multiplyQuaternionsFlat(e, s, e, n, e, r),
      $r.slerpFlat(e, n, e, n, e, s, i);
  }
  _lerp(e, n, r, i, o) {
    const s = 1 - i;
    for (let a = 0; a !== o; ++a) {
      const l = n + a;
      e[l] = e[l] * s + e[r + a] * i;
    }
  }
  _lerpAdditive(e, n, r, i, o) {
    for (let s = 0; s !== o; ++s) {
      const a = n + s;
      e[a] = e[a] + e[r + s] * i;
    }
  }
}
const LE = "\\[\\]\\.:\\/",
  Aj = new RegExp("[" + LE + "]", "g"),
  OE = "[^" + LE + "]",
  bj = "[^" + LE.replace("\\.", "") + "]",
  wj = /((?:WC+[\/:])*)/.source.replace("WC", OE),
  Ej = /(WCOD+)?/.source.replace("WCOD", bj),
  Mj = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", OE),
  Cj = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", OE),
  Tj = new RegExp("^" + wj + Ej + Mj + Cj + "$"),
  Rj = ["material", "materials", "bones", "map"];
class Pj {
  constructor(e, n, r) {
    const i = r || qt.parseTrackName(n);
    (this._targetGroup = e), (this._bindings = e.subscribe_(n, i));
  }
  getValue(e, n) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, n);
  }
  setValue(e, n) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, o = r.length; i !== o; ++i)
      r[i].setValue(e, n);
  }
  bind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, r = e.length; n !== r; ++n)
      e[n].unbind();
  }
}
class qt {
  constructor(e, n, r) {
    (this.path = n),
      (this.parsedPath = r || qt.parseTrackName(n)),
      (this.node = qt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, n, r) {
    return e && e.isAnimationObjectGroup
      ? new qt.Composite(e, n, r)
      : new qt(e, n, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Aj, "");
  }
  static parseTrackName(e) {
    const n = Tj.exec(e);
    if (n === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: n[2],
        objectName: n[3],
        objectIndex: n[4],
        propertyName: n[5],
        propertyIndex: n[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const o = r.nodeName.substring(i + 1);
      Rj.indexOf(o) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = o));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, n) {
    if (
      n === void 0 ||
      n === "" ||
      n === "." ||
      n === -1 ||
      n === e.name ||
      n === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(n);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (o) {
          for (let s = 0; s < o.length; s++) {
            const a = o[s];
            if (a.name === n || a.uuid === n) return a;
            const l = r(a.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, n) {
    e[n] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) e[n++] = r[i];
  }
  _getValue_arrayElement(e, n) {
    e[n] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, n) {
    this.resolvedProperty.toArray(e, n);
  }
  _setValue_direct(e, n) {
    this.targetObject[this.propertyName] = e[n];
  }
  _setValue_direct_setNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
    (this.targetObject[this.propertyName] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
  }
  _setValue_array_setNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
    const r = this.resolvedProperty;
    for (let i = 0, o = r.length; i !== o; ++i) r[i] = e[n++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, n) {
    this.resolvedProperty[this.propertyIndex] = e[n];
  }
  _setValue_arrayElement_setNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
    (this.resolvedProperty[this.propertyIndex] = e[n]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, n) {
    this.resolvedProperty.fromArray(e, n);
  }
  _setValue_fromArray_setNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
    this.resolvedProperty.fromArray(e, n),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, n) {
    this.bind(), this.getValue(e, n);
  }
  _setValue_unbound(e, n) {
    this.bind(), this.setValue(e, n);
  }
  bind() {
    let e = this.node;
    const n = this.parsedPath,
      r = n.objectName,
      i = n.propertyName;
    let o = n.propertyIndex;
    if (
      (e || ((e = qt.findNode(this.rootNode, n.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let c = n.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const s = e[i];
    if (s === void 0) {
      const c = n.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (o !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[o] !== void 0 &&
          (o = e.morphTargetDictionary[o]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = s),
        (this.propertyIndex = o);
    } else
      s.fromArray !== void 0 && s.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
        : Array.isArray(s)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = s))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
qt.Composite = Pj;
qt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
qt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
qt.prototype.GetterByBindingType = [
  qt.prototype._getValue_direct,
  qt.prototype._getValue_array,
  qt.prototype._getValue_arrayElement,
  qt.prototype._getValue_toArray,
];
qt.prototype.SetterByBindingTypeAndVersioning = [
  [
    qt.prototype._setValue_direct,
    qt.prototype._setValue_direct_setNeedsUpdate,
    qt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    qt.prototype._setValue_array,
    qt.prototype._setValue_array_setNeedsUpdate,
    qt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    qt.prototype._setValue_arrayElement,
    qt.prototype._setValue_arrayElement_setNeedsUpdate,
    qt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    qt.prototype._setValue_fromArray,
    qt.prototype._setValue_fromArray_setNeedsUpdate,
    qt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class Ij {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = Xi()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return n._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      o = this._bindings,
      s = o.length;
    let a,
      l = e.length,
      c = this.nCachedObjects_;
    for (let u = 0, d = arguments.length; u !== d; ++u) {
      const p = arguments[u],
        m = p.uuid;
      let v = n[m];
      if (v === void 0) {
        (v = l++), (n[m] = v), e.push(p);
        for (let _ = 0, y = s; _ !== y; ++_) o[_].push(new qt(p, r[_], i[_]));
      } else if (v < c) {
        a = e[v];
        const _ = --c,
          y = e[_];
        (n[y.uuid] = v), (e[v] = y), (n[m] = _), (e[_] = p);
        for (let g = 0, x = s; g !== x; ++g) {
          const S = o[g],
            b = S[_];
          let C = S[v];
          (S[v] = b), C === void 0 && (C = new qt(p, r[g], i[g])), (S[_] = C);
        }
      } else
        e[v] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_;
    for (let s = 0, a = arguments.length; s !== a; ++s) {
      const l = arguments[s],
        c = l.uuid,
        u = n[c];
      if (u !== void 0 && u >= o) {
        const d = o++,
          p = e[d];
        (n[p.uuid] = u), (e[u] = p), (n[c] = d), (e[d] = l);
        for (let m = 0, v = i; m !== v; ++m) {
          const _ = r[m],
            y = _[d],
            g = _[u];
          (_[u] = y), (_[d] = g);
        }
      }
    }
    this.nCachedObjects_ = o;
  }
  uncache() {
    const e = this._objects,
      n = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let o = this.nCachedObjects_,
      s = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        u = c.uuid,
        d = n[u];
      if (d !== void 0)
        if ((delete n[u], d < o)) {
          const p = --o,
            m = e[p],
            v = --s,
            _ = e[v];
          (n[m.uuid] = d), (e[d] = m), (n[_.uuid] = p), (e[p] = _), e.pop();
          for (let y = 0, g = i; y !== g; ++y) {
            const x = r[y],
              S = x[p],
              b = x[v];
            (x[d] = S), (x[p] = b), x.pop();
          }
        } else {
          const p = --s,
            m = e[p];
          p > 0 && (n[m.uuid] = d), (e[d] = m), e.pop();
          for (let v = 0, _ = i; v !== _; ++v) {
            const y = r[v];
            (y[d] = y[p]), y.pop();
          }
        }
    }
    this.nCachedObjects_ = o;
  }
  subscribe_(e, n) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const o = this._bindings;
    if (i !== void 0) return o[i];
    const s = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      c = l.length,
      u = this.nCachedObjects_,
      d = new Array(c);
    (i = o.length), (r[e] = i), s.push(e), a.push(n), o.push(d);
    for (let p = u, m = l.length; p !== m; ++p) {
      const v = l[p];
      d[p] = new qt(v, e, n);
    }
    return d;
  }
  unsubscribe_(e) {
    const n = this._bindingsIndicesByPath,
      r = n[e];
    if (r !== void 0) {
      const i = this._paths,
        o = this._parsedPaths,
        s = this._bindings,
        a = s.length - 1,
        l = s[a],
        c = e[a];
      (n[c] = r),
        (s[r] = l),
        s.pop(),
        (o[r] = o[a]),
        o.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class SD {
  constructor(e, n, r = null, i = n.blendMode) {
    (this._mixer = e),
      (this._clip = n),
      (this._localRoot = r),
      (this.blendMode = i);
    const o = n.tracks,
      s = o.length,
      a = new Array(s),
      l = { endingStart: ec, endingEnd: ec };
    for (let c = 0; c !== s; ++c) {
      const u = o[c].createInterpolant(null);
      (a[c] = u), (u.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(s)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = eN),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, n) {
    return (this.loop = e), (this.repetitions = n), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, n, r) {
    if ((e.fadeOut(n), this.fadeIn(n), r)) {
      const i = this._clip.duration,
        o = e._clip.duration,
        s = o / i,
        a = i / o;
      e.warp(1, s, n), this.warp(a, 1, n);
    }
    return this;
  }
  crossFadeTo(e, n, r) {
    return e.crossFadeFrom(this, n, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, n, r) {
    const i = this._mixer,
      o = i.time,
      s = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = o), (l[1] = o + r), (c[0] = e / s), (c[1] = n / s), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, n, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const o = this._startTime;
    if (o !== null) {
      const l = (e - o) * r;
      l < 0 || r === 0 ? (n = 0) : ((this._startTime = null), (n = r * l));
    }
    n *= this._updateTimeScale(e);
    const s = this._updateTime(n),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case rE:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(s), c[u].accumulateAdditive(a);
          break;
        case ny:
        default:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(s), c[u].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let n = 0;
    if (this.enabled) {
      n = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = n), n;
  }
  _updateTimeScale(e) {
    let n = 0;
    if (!this.paused) {
      n = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (n *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            n === 0 ? (this.paused = !0) : (this.timeScale = n));
      }
    }
    return (this._effectiveTimeScale = n), n;
  }
  _updateTime(e) {
    const n = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      o = this._loopCount;
    const s = r === tN;
    if (e === 0) return o === -1 ? i : s && (o & 1) === 1 ? n - i : i;
    if (r === QO) {
      o === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= n) i = n;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (o === -1 &&
          (e >= 0
            ? ((o = 0), this._setEndings(!0, this.repetitions === 0, s))
            : this._setEndings(this.repetitions === 0, !0, s)),
        i >= n || i < 0)
      ) {
        const a = Math.floor(i / n);
        (i -= n * a), (o += Math.abs(a));
        const l = this.repetitions - o;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? n : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, s);
          } else this._setEndings(!1, !1, s);
          (this._loopCount = o),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (s && (o & 1) === 1) return n - i;
    }
    return i;
  }
  _setEndings(e, n, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = tc), (i.endingEnd = tc))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? tc : ec)
          : (i.endingStart = jh),
        n ? (i.endingEnd = this.zeroSlopeAtEnd ? tc : ec) : (i.endingEnd = jh));
  }
  _scheduleFading(e, n, r) {
    const i = this._mixer,
      o = i.time;
    let s = this._weightInterpolant;
    s === null &&
      ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
    const a = s.parameterPositions,
      l = s.sampleValues;
    return (a[0] = o), (l[0] = n), (a[1] = o + e), (l[1] = r), this;
  }
}
const Lj = new Float32Array(1);
class Oj extends oa {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, n) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      o = i.length,
      s = e._propertyBindings,
      a = e._interpolants,
      l = r.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let d = 0; d !== o; ++d) {
      const p = i[d],
        m = p.name;
      let v = u[m];
      if (v !== void 0) ++v.referenceCount, (s[d] = v);
      else {
        if (((v = s[d]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, m));
          continue;
        }
        const _ = n && n._propertyBindings[d].binding.parsedPath;
        (v = new _D(qt.create(r, m, _), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, m),
          (s[d] = v);
      }
      a[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          o = this._actionsByClip[i];
        this._bindAction(e, o && o.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const o = n[r];
        o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const n = e._propertyBindings;
      for (let r = 0, i = n.length; r !== i; ++r) {
        const o = n[r];
        --o.useCount === 0 &&
          (o.restoreOriginalState(), this._takeBackBinding(o));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const n = e._cacheIndex;
    return n !== null && n < this._nActiveActions;
  }
  _addInactiveAction(e, n, r) {
    const i = this._actions,
      o = this._actionsByClip;
    let s = o[n];
    if (s === void 0)
      (s = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (o[n] = s);
    else {
      const a = s.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const n = this._actions,
      r = n[n.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (n[i] = r), n.pop(), (e._cacheIndex = null);
    const o = e._clip.uuid,
      s = this._actionsByClip,
      a = s[o],
      l = a.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    (c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete s[o],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const n = e._propertyBindings;
    for (let r = 0, i = n.length; r !== i; ++r) {
      const o = n[r];
      --o.referenceCount === 0 && this._removeInactiveBinding(o);
    }
  }
  _lendAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _takeBackAction(e) {
    const n = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _addInactiveBinding(e, n, r) {
    const i = this._bindingsByRootAndName,
      o = this._bindings;
    let s = i[n];
    s === void 0 && ((s = {}), (i[n] = s)),
      (s[r] = e),
      (e._cacheIndex = o.length),
      o.push(e);
  }
  _removeInactiveBinding(e) {
    const n = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      o = r.path,
      s = this._bindingsByRootAndName,
      a = s[i],
      l = n[n.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (n[c] = l),
      n.pop(),
      delete a[o],
      Object.keys(a).length === 0 && delete s[i];
  }
  _lendBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _takeBackBinding(e) {
    const n = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      o = n[i];
    (e._cacheIndex = i), (n[i] = e), (o._cacheIndex = r), (n[r] = o);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      n = this._nActiveControlInterpolants++;
    let r = e[n];
    return (
      r === void 0 &&
        ((r = new EE(new Float32Array(2), new Float32Array(2), 1, Lj)),
        (r.__cacheIndex = n),
        (e[n] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const n = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      o = n[i];
    (e.__cacheIndex = i), (n[i] = e), (o.__cacheIndex = r), (n[r] = o);
  }
  clipAction(e, n, r) {
    const i = n || this._root,
      o = i.uuid;
    let s = typeof e == "string" ? ip.findByName(i, e) : e;
    const a = s !== null ? s.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (r === void 0 && (s !== null ? (r = s.blendMode) : (r = ny)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[o];
      if (d !== void 0 && d.blendMode === r) return d;
      (c = l.knownActions[0]), s === null && (s = c._clip);
    }
    if (s === null) return null;
    const u = new SD(this, s, n, r);
    return this._bindAction(u, c), this._addInactiveAction(u, a, o), u;
  }
  existingAction(e, n) {
    const r = n || this._root,
      i = r.uuid,
      o = typeof e == "string" ? ip.findByName(r, e) : e,
      s = o ? o.uuid : e,
      a = this._actionsByClip[s];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      n = this._nActiveActions;
    for (let r = n - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const n = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      o = Math.sign(e),
      s = (this._accuIndex ^= 1);
    for (let c = 0; c !== r; ++c) n[c]._update(i, e, o, s);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(s);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let n = 0; n < this._actions.length; n++) this._actions[n].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const n = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      o = i[r];
    if (o !== void 0) {
      const s = o.knownActions;
      for (let a = 0, l = s.length; a !== l; ++a) {
        const c = s[a];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          d = n[n.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (d._cacheIndex = u),
          (n[u] = d),
          n.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const n = e.uuid,
      r = this._actionsByClip;
    for (const s in r) {
      const a = r[s].actionByRoot,
        l = a[n];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      o = i[n];
    if (o !== void 0)
      for (const s in o) {
        const a = o[s];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, n) {
    const r = this.existingAction(e, n);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class NE {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new NE(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let Nj = 0;
class Dj extends oa {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: Nj++ }),
      (this.name = ""),
      (this.usage = qh),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const n = this.uniforms.indexOf(e);
    return n !== -1 && this.uniforms.splice(n, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const n = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = n.length; r < i; r++) {
      const o = Array.isArray(n[r]) ? n[r] : [n[r]];
      for (let s = 0; s < o.length; s++) this.uniforms.push(o[s].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Fj extends uy {
  constructor(e, n, r = 1) {
    super(e, n),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const n = super.clone(e);
    return (n.meshPerAttribute = this.meshPerAttribute), n;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.isInstancedInterleavedBuffer = !0),
      (n.meshPerAttribute = this.meshPerAttribute),
      n
    );
  }
}
class Uj {
  constructor(e, n, r, i, o) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = n),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, n) {
    return (this.type = e), (this.elementSize = n), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const SR = new wt();
class AD {
  constructor(e, n, r = 0, i = 1 / 0) {
    (this.ray = new Oc(e, n)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new hc()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(n)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = n))
      : n.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (n.near + n.far) / (n.near - n.far))
          .unproject(n),
        this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld),
        (this.camera = n))
      : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return (
      SR.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(SR),
      this
    );
  }
  intersectObject(e, n = !0, r = []) {
    return zA(e, this, r, n), r.sort(AR), r;
  }
  intersectObjects(e, n = !0, r = []) {
    for (let i = 0, o = e.length; i < o; i++) zA(e[i], this, r, n);
    return r.sort(AR), r;
  }
}
function AR(t, e) {
  return t.distance - e.distance;
}
function zA(t, e, n, r) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), r === !0)) {
    const i = t.children;
    for (let o = 0, s = i.length; o < s; o++) zA(i[o], e, n, !0);
  }
}
class BA {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.phi = n), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + n * n + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(Un(n / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class kj {
  constructor(e = 1, n = 0, r = 0) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  set(e, n, r) {
    return (this.radius = e), (this.theta = n), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bR = new ke();
class zj {
  constructor(e = new ke(1 / 0, 1 / 0), n = new ke(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, r = e.length; n < r; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const r = bR.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, bR).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const wR = new ee(),
  Bg = new ee();
class Bj {
  constructor(e = new ee(), n = new ee()) {
    (this.start = e), (this.end = n);
  }
  set(e, n) {
    return this.start.copy(e), this.end.copy(n), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, n) {
    return this.delta(n).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, n) {
    wR.subVectors(e, this.start), Bg.subVectors(this.end, this.start);
    const r = Bg.dot(Bg);
    let o = Bg.dot(wR) / r;
    return n && (o = Un(o, 0, 1)), o;
  }
  closestPointToPoint(e, n, r) {
    const i = this.closestPointToPointParameter(e, n);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ER = new ee();
class Hj extends Qt {
  constructor(e, n) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "SpotLightHelper");
    const r = new Ut(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let s = 0, a = 1, l = 32; s < l; s++, a++) {
      const c = (s / l) * Math.PI * 2,
        u = (a / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
    }
    r.setAttribute("position", new dt(i, 3));
    const o = new fi({ fog: !1, toneMapped: !1 });
    (this.cone = new xs(r, o)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e),
      ER.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(ER),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Ta = new ee(),
  Hg = new wt(),
  p_ = new wt();
class Vj extends xs {
  constructor(e) {
    const n = bD(e),
      r = new Ut(),
      i = [],
      o = [],
      s = new it(0, 0, 1),
      a = new it(0, 1, 0);
    for (let c = 0; c < n.length; c++) {
      const u = n[c];
      u.parent &&
        u.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        o.push(s.r, s.g, s.b),
        o.push(a.r, a.g, a.b));
    }
    r.setAttribute("position", new dt(i, 3)),
      r.setAttribute("color", new dt(o, 3));
    const l = new fi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = n),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const n = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    p_.copy(this.root.matrixWorld).invert();
    for (let o = 0, s = 0; o < n.length; o++) {
      const a = n[o];
      a.parent &&
        a.parent.isBone &&
        (Hg.multiplyMatrices(p_, a.matrixWorld),
        Ta.setFromMatrixPosition(Hg),
        i.setXYZ(s, Ta.x, Ta.y, Ta.z),
        Hg.multiplyMatrices(p_, a.parent.matrixWorld),
        Ta.setFromMatrixPosition(Hg),
        i.setXYZ(s + 1, Ta.x, Ta.y, Ta.z),
        (s += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function bD(t) {
  const e = [];
  t.isBone === !0 && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, bD(t.children[n]));
  return e;
}
class Gj extends Cn {
  constructor(e, n, r) {
    const i = new Up(n, 4, 2),
      o = new sa({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, o),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const Wj = new ee(),
  MR = new it(),
  CR = new it();
class jj extends Qt {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new Fp(n);
    i.rotateY(Math.PI * 0.5),
      (this.material = new sa({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const o = i.getAttribute("position"),
      s = new Float32Array(o.count * 3);
    i.setAttribute("color", new sn(s, 3)),
      this.add(new Cn(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const n = e.geometry.getAttribute("color");
      MR.copy(this.light.color), CR.copy(this.light.groundColor);
      for (let r = 0, i = n.count; r < i; r++) {
        const o = r < i / 2 ? MR : CR;
        n.setXYZ(r, o.r, o.g, o.b);
      }
      n.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(Wj.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class $j extends xs {
  constructor(e = 10, n = 10, r = 4473924, i = 8947848) {
    (r = new it(r)), (i = new it(i));
    const o = n / 2,
      s = e / n,
      a = e / 2,
      l = [],
      c = [];
    for (let p = 0, m = 0, v = -a; p <= n; p++, v += s) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const _ = p === o ? r : i;
      _.toArray(c, m),
        (m += 3),
        _.toArray(c, m),
        (m += 3),
        _.toArray(c, m),
        (m += 3),
        _.toArray(c, m),
        (m += 3);
    }
    const u = new Ut();
    u.setAttribute("position", new dt(l, 3)),
      u.setAttribute("color", new dt(c, 3));
    const d = new fi({ vertexColors: !0, toneMapped: !1 });
    super(u, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Xj extends xs {
  constructor(e = 10, n = 16, r = 8, i = 64, o = 4473924, s = 8947848) {
    (o = new it(o)), (s = new it(s));
    const a = [],
      l = [];
    if (n > 1)
      for (let d = 0; d < n; d++) {
        const p = (d / n) * (Math.PI * 2),
          m = Math.sin(p) * e,
          v = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, v);
        const _ = d & 1 ? o : s;
        l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b);
      }
    for (let d = 0; d < r; d++) {
      const p = d & 1 ? o : s,
        m = e - (e / r) * d;
      for (let v = 0; v < i; v++) {
        let _ = (v / i) * (Math.PI * 2),
          y = Math.sin(_) * m,
          g = Math.cos(_) * m;
        a.push(y, 0, g),
          l.push(p.r, p.g, p.b),
          (_ = ((v + 1) / i) * (Math.PI * 2)),
          (y = Math.sin(_) * m),
          (g = Math.cos(_) * m),
          a.push(y, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const c = new Ut();
    c.setAttribute("position", new dt(a, 3)),
      c.setAttribute("color", new dt(l, 3));
    const u = new fi({ vertexColors: !0, toneMapped: !1 });
    super(c, u), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const TR = new ee(),
  Vg = new ee(),
  RR = new ee();
class Yj extends Qt {
  constructor(e, n, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      n === void 0 && (n = 1);
    let i = new Ut();
    i.setAttribute(
      "position",
      new dt([-n, n, 0, n, n, 0, n, -n, 0, -n, -n, 0, -n, n, 0], 3)
    );
    const o = new fi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new nl(i, o)),
      this.add(this.lightPlane),
      (i = new Ut()),
      i.setAttribute("position", new dt([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new nl(i, o)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      TR.setFromMatrixPosition(this.light.matrixWorld),
      Vg.setFromMatrixPosition(this.light.target.matrixWorld),
      RR.subVectors(Vg, TR),
      this.lightPlane.lookAt(Vg),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Vg),
      (this.targetLine.scale.z = RR.length());
  }
}
const Gg = new ee(),
  Nn = new Lp();
class qj extends xs {
  constructor(e) {
    const n = new Ut(),
      r = new fi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      o = [],
      s = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(v, _) {
      l(v), l(_);
    }
    function l(v) {
      i.push(0, 0, 0),
        o.push(0, 0, 0),
        s[v] === void 0 && (s[v] = []),
        s[v].push(i.length / 3 - 1);
    }
    n.setAttribute("position", new dt(i, 3)),
      n.setAttribute("color", new dt(o, 3)),
      super(n, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = s),
      this.update();
    const c = new it(16755200),
      u = new it(16711680),
      d = new it(43775),
      p = new it(16777215),
      m = new it(3355443);
    this.setColors(c, u, d, p, m);
  }
  setColors(e, n, r, i, o) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, n.r, n.g, n.b),
      a.setXYZ(25, n.r, n.g, n.b),
      a.setXYZ(26, n.r, n.g, n.b),
      a.setXYZ(27, n.r, n.g, n.b),
      a.setXYZ(28, n.r, n.g, n.b),
      a.setXYZ(29, n.r, n.g, n.b),
      a.setXYZ(30, n.r, n.g, n.b),
      a.setXYZ(31, n.r, n.g, n.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, o.r, o.g, o.b),
      a.setXYZ(41, o.r, o.g, o.b),
      a.setXYZ(42, o.r, o.g, o.b),
      a.setXYZ(43, o.r, o.g, o.b),
      a.setXYZ(44, o.r, o.g, o.b),
      a.setXYZ(45, o.r, o.g, o.b),
      a.setXYZ(46, o.r, o.g, o.b),
      a.setXYZ(47, o.r, o.g, o.b),
      a.setXYZ(48, o.r, o.g, o.b),
      a.setXYZ(49, o.r, o.g, o.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      n = this.pointMap,
      r = 1,
      i = 1;
    Nn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Gn("c", n, e, Nn, 0, 0, -1),
      Gn("t", n, e, Nn, 0, 0, 1),
      Gn("n1", n, e, Nn, -r, -i, -1),
      Gn("n2", n, e, Nn, r, -i, -1),
      Gn("n3", n, e, Nn, -r, i, -1),
      Gn("n4", n, e, Nn, r, i, -1),
      Gn("f1", n, e, Nn, -r, -i, 1),
      Gn("f2", n, e, Nn, r, -i, 1),
      Gn("f3", n, e, Nn, -r, i, 1),
      Gn("f4", n, e, Nn, r, i, 1),
      Gn("u1", n, e, Nn, r * 0.7, i * 1.1, -1),
      Gn("u2", n, e, Nn, -r * 0.7, i * 1.1, -1),
      Gn("u3", n, e, Nn, 0, i * 2, -1),
      Gn("cf1", n, e, Nn, -r, 0, 1),
      Gn("cf2", n, e, Nn, r, 0, 1),
      Gn("cf3", n, e, Nn, 0, -i, 1),
      Gn("cf4", n, e, Nn, 0, i, 1),
      Gn("cn1", n, e, Nn, -r, 0, -1),
      Gn("cn2", n, e, Nn, r, 0, -1),
      Gn("cn3", n, e, Nn, 0, -i, -1),
      Gn("cn4", n, e, Nn, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Gn(t, e, n, r, i, o, s) {
  Gg.set(i, o, s).unproject(r);
  const a = e[t];
  if (a !== void 0) {
    const l = n.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++) l.setXYZ(a[c], Gg.x, Gg.y, Gg.z);
  }
}
const Wg = new Rr();
class Kj extends xs {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      o = new Ut();
    o.setIndex(new sn(r, 1)),
      o.setAttribute("position", new sn(i, 3)),
      super(o, new fi({ color: n, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Wg.setFromObject(this.object),
      Wg.isEmpty())
    )
      return;
    const n = Wg.min,
      r = Wg.max,
      i = this.geometry.attributes.position,
      o = i.array;
    (o[0] = r.x),
      (o[1] = r.y),
      (o[2] = r.z),
      (o[3] = n.x),
      (o[4] = r.y),
      (o[5] = r.z),
      (o[6] = n.x),
      (o[7] = n.y),
      (o[8] = r.z),
      (o[9] = r.x),
      (o[10] = n.y),
      (o[11] = r.z),
      (o[12] = r.x),
      (o[13] = r.y),
      (o[14] = n.z),
      (o[15] = n.x),
      (o[16] = r.y),
      (o[17] = n.z),
      (o[18] = n.x),
      (o[19] = n.y),
      (o[20] = n.z),
      (o[21] = r.x),
      (o[22] = n.y),
      (o[23] = n.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, n) {
    return super.copy(e, n), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Zj extends xs {
  constructor(e, n = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      o = new Ut();
    o.setIndex(new sn(r, 1)),
      o.setAttribute("position", new dt(i, 3)),
      super(o, new fi({ color: n, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const n = this.box;
    n.isEmpty() ||
      (n.getCenter(this.position),
      n.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Jj extends nl {
  constructor(e, n = 1, r = 16776960) {
    const i = r,
      o = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      s = new Ut();
    s.setAttribute("position", new dt(o, 3)),
      s.computeBoundingSphere(),
      super(s, new fi({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = n);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new Ut();
    l.setAttribute("position", new dt(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new Cn(
          l,
          new sa({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const PR = new ee();
let jg, m_;
class Qj extends Qt {
  constructor(
    e = new ee(0, 0, 1),
    n = new ee(0, 0, 0),
    r = 1,
    i = 16776960,
    o = r * 0.2,
    s = o * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      jg === void 0 &&
        ((jg = new Ut()),
        jg.setAttribute("position", new dt([0, 0, 0, 0, 1, 0], 3)),
        (m_ = new Uf(0, 0.5, 1, 5, 1)),
        m_.translate(0, -0.5, 0)),
      this.position.copy(n),
      (this.line = new nl(jg, new fi({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Cn(m_, new sa({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, o, s);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      PR.set(e.z, 0, -e.x).normalize();
      const n = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(PR, n);
    }
  }
  setLength(e, n = e * 0.2, r = n * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - n), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, n, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class e9 extends xs {
  constructor(e = 1) {
    const n = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new Ut();
    i.setAttribute("position", new dt(n, 3)),
      i.setAttribute("color", new dt(r, 3));
    const o = new fi({ vertexColors: !0, toneMapped: !1 });
    super(i, o), (this.type = "AxesHelper");
  }
  setColors(e, n, r) {
    const i = new it(),
      o = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(o, 0),
      i.toArray(o, 3),
      i.set(n),
      i.toArray(o, 6),
      i.toArray(o, 9),
      i.set(r),
      i.toArray(o, 12),
      i.toArray(o, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class t9 {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new it()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, n) {
    return (
      (this.currentPath = new Jh()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, n),
      this
    );
  }
  lineTo(e, n) {
    return this.currentPath.lineTo(e, n), this;
  }
  quadraticCurveTo(e, n, r, i) {
    return this.currentPath.quadraticCurveTo(e, n, r, i), this;
  }
  bezierCurveTo(e, n, r, i, o, s) {
    return this.currentPath.bezierCurveTo(e, n, r, i, o, s), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function n(g) {
      const x = [];
      for (let S = 0, b = g.length; S < b; S++) {
        const C = g[S],
          M = new pc();
        (M.curves = C.curves), x.push(M);
      }
      return x;
    }
    function r(g, x) {
      const S = x.length;
      let b = !1;
      for (let C = S - 1, M = 0; M < S; C = M++) {
        let T = x[C],
          P = x[M],
          R = P.x - T.x,
          E = P.y - T.y;
        if (Math.abs(E) > Number.EPSILON) {
          if (
            (E < 0 && ((T = x[M]), (R = -R), (P = x[C]), (E = -E)),
            g.y < T.y || g.y > P.y)
          )
            continue;
          if (g.y === T.y) {
            if (g.x === T.x) return !0;
          } else {
            const O = E * (g.x - T.x) - R * (g.y - T.y);
            if (O === 0) return !0;
            if (O < 0) continue;
            b = !b;
          }
        } else {
          if (g.y !== T.y) continue;
          if ((P.x <= g.x && g.x <= T.x) || (T.x <= g.x && g.x <= P.x))
            return !0;
        }
      }
      return b;
    }
    const i = ms.isClockWise,
      o = this.subPaths;
    if (o.length === 0) return [];
    let s, a, l;
    const c = [];
    if (o.length === 1)
      return (a = o[0]), (l = new pc()), (l.curves = a.curves), c.push(l), c;
    let u = !i(o[0].getPoints());
    u = e ? !u : u;
    const d = [],
      p = [];
    let m = [],
      v = 0,
      _;
    (p[v] = void 0), (m[v] = []);
    for (let g = 0, x = o.length; g < x; g++)
      (a = o[g]),
        (_ = a.getPoints()),
        (s = i(_)),
        (s = e ? !s : s),
        s
          ? (!u && p[v] && v++,
            (p[v] = { s: new pc(), p: _ }),
            (p[v].s.curves = a.curves),
            u && v++,
            (m[v] = []))
          : m[v].push({ h: a, p: _[0] });
    if (!p[0]) return n(o);
    if (p.length > 1) {
      let g = !1,
        x = 0;
      for (let S = 0, b = p.length; S < b; S++) d[S] = [];
      for (let S = 0, b = p.length; S < b; S++) {
        const C = m[S];
        for (let M = 0; M < C.length; M++) {
          const T = C[M];
          let P = !0;
          for (let R = 0; R < p.length; R++)
            r(T.p, p[R].p) &&
              (S !== R && x++, P ? ((P = !1), d[R].push(T)) : (g = !0));
          P && d[S].push(T);
        }
      }
      x > 0 && g === !1 && (m = d);
    }
    let y;
    for (let g = 0, x = p.length; g < x; g++) {
      (l = p[g].s), c.push(l), (y = m[g]);
      for (let S = 0, b = y.length; S < b; S++) l.holes.push(y[S].h);
    }
    return c;
  }
}
class n9 extends Wo {
  constructor(e = 1, n = 1, r = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, n, { ...i, count: r }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Qv } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Qv));
const r9 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: Xw,
      AddEquation: Fa,
      AddOperation: FO,
      AdditiveAnimationBlendMode: rE,
      AdditiveBlending: eA,
      AgXToneMapping: HO,
      AlphaFormat: XO,
      AlwaysCompare: uN,
      AlwaysDepth: RO,
      AlwaysStencilFunc: PA,
      AmbientLight: pD,
      AnimationAction: SD,
      AnimationClip: ip,
      AnimationLoader: ij,
      AnimationMixer: Oj,
      AnimationObjectGroup: Ij,
      AnimationUtils: ej,
      ArcCurve: zN,
      ArrayCamera: RN,
      ArrowHelper: Qj,
      AttachedBindMode: rA,
      Audio: xD,
      AudioAnalyser: Sj,
      AudioContext: PE,
      AudioListener: yj,
      AudioLoader: mj,
      AxesHelper: e9,
      BackSide: li,
      BasicDepthPacking: nN,
      BasicShadowMap: cO,
      BatchedMesh: FN,
      Bone: mE,
      BooleanKeyframeTrack: Dc,
      Box2: zj,
      Box3: Rr,
      Box3Helper: Zj,
      BoxGeometry: Nc,
      BoxHelper: Kj,
      BufferAttribute: sn,
      BufferGeometry: Ut,
      BufferGeometryLoader: yD,
      ByteType: WO,
      Cache: Gs,
      Camera: Lp,
      CameraHelper: qj,
      CanvasTexture: wW,
      CapsuleGeometry: py,
      CatmullRomCurve3: BN,
      CineonToneMapping: zO,
      CircleGeometry: my,
      ClampToEdgeWrapping: vo,
      Clock: IE,
      Color: it,
      ColorKeyframeTrack: ME,
      ColorManagement: rn,
      CompressedArrayTexture: AW,
      CompressedCubeTexture: bW,
      CompressedTexture: dy,
      CompressedTextureLoader: oj,
      ConeGeometry: gy,
      ConstantAlphaFactor: MO,
      ConstantColorFactor: wO,
      CubeCamera: _N,
      CubeReflectionMapping: Qs,
      CubeRefractionMapping: tl,
      CubeTexture: Op,
      CubeTextureLoader: sj,
      CubeUVReflectionMapping: Nf,
      CubicBezierCurve: yE,
      CubicBezierCurve3: HN,
      CubicInterpolant: sD,
      CullFaceBack: QS,
      CullFaceFront: lO,
      CullFaceFrontBack: f5,
      CullFaceNone: aO,
      Curve: Xo,
      CurvePath: GN,
      CustomBlending: uO,
      CustomToneMapping: BO,
      CylinderGeometry: Uf,
      Cylindrical: kj,
      Data3DTexture: aE,
      DataArrayTexture: iy,
      DataTexture: Ka,
      DataTextureLoader: aj,
      DataUtils: _6,
      DecrementStencilOp: A5,
      DecrementWrapStencilOp: w5,
      DefaultLoadingManager: cD,
      DepthFormat: fc,
      DepthStencilFormat: yf,
      DepthTexture: dE,
      DetachedBindMode: GO,
      DirectionalLight: hD,
      DirectionalLightHelper: Yj,
      DiscreteInterpolant: aD,
      DisplayP3ColorSpace: ry,
      DodecahedronGeometry: vy,
      DoubleSide: mo,
      DstAlphaFactor: xO,
      DstColorFactor: SO,
      DynamicCopyUsage: z5,
      DynamicDrawUsage: O5,
      DynamicReadUsage: F5,
      EdgesGeometry: WN,
      EllipseCurve: hy,
      EqualCompare: sN,
      EqualDepth: IO,
      EqualStencilFunc: T5,
      EquirectangularReflectionMapping: zh,
      EquirectangularRefractionMapping: Bh,
      Euler: qi,
      EventDispatcher: oa,
      ExtrudeGeometry: xy,
      FileLoader: ea,
      Float16BufferAttribute: M6,
      Float32BufferAttribute: dt,
      FloatType: yo,
      Fog: cy,
      FogExp2: ly,
      FramebufferTexture: SW,
      FrontSide: Js,
      Frustum: Np,
      GLBufferAttribute: Uj,
      GLSL1: H5,
      GLSL3: IA,
      GreaterCompare: aN,
      GreaterDepth: OO,
      GreaterEqualCompare: cN,
      GreaterEqualDepth: LO,
      GreaterEqualStencilFunc: L5,
      GreaterStencilFunc: P5,
      GridHelper: $j,
      Group: qu,
      HalfFloatType: Pp,
      HemisphereLight: uD,
      HemisphereLightHelper: jj,
      IcosahedronGeometry: _y,
      ImageBitmapLoader: pj,
      ImageLoader: op,
      ImageUtils: gN,
      IncrementStencilOp: S5,
      IncrementWrapStencilOp: b5,
      InstancedBufferAttribute: Mc,
      InstancedBufferGeometry: RE,
      InstancedInterleavedBuffer: Fj,
      InstancedMesh: DN,
      Int16BufferAttribute: w6,
      Int32BufferAttribute: E6,
      Int8BufferAttribute: S6,
      IntType: Kw,
      InterleavedBuffer: uy,
      InterleavedBufferAttribute: Ec,
      Interpolant: kp,
      InterpolateDiscrete: Gh,
      InterpolateLinear: Wh,
      InterpolateSmooth: T0,
      InvertStencilOp: E5,
      KeepStencilOp: $l,
      KeyframeTrack: Yo,
      LOD: ON,
      LatheGeometry: Dp,
      Layers: hc,
      LessCompare: oN,
      LessDepth: PO,
      LessEqualCompare: oE,
      LessEqualDepth: kh,
      LessEqualStencilFunc: R5,
      LessStencilFunc: C5,
      Light: cl,
      LightProbe: vD,
      Line: nl,
      Line3: Bj,
      LineBasicMaterial: fi,
      LineCurve: xE,
      LineCurve3: VN,
      LineDashedMaterial: rD,
      LineLoop: UN,
      LineSegments: xs,
      LinearDisplayP3ColorSpace: Ip,
      LinearFilter: kn,
      LinearInterpolant: EE,
      LinearMipMapLinearFilter: m5,
      LinearMipMapNearestFilter: p5,
      LinearMipmapLinearFilter: ls,
      LinearMipmapNearestFilter: fh,
      LinearSRGBColorSpace: ia,
      LinearToneMapping: UO,
      LinearTransfer: $h,
      Loader: Ci,
      LoaderUtils: kA,
      LoadingManager: CE,
      LoopOnce: QO,
      LoopPingPong: tN,
      LoopRepeat: eN,
      LuminanceAlphaFormat: KO,
      LuminanceFormat: qO,
      MOUSE: Wl,
      Material: qr,
      MaterialLoader: Cy,
      MathUtils: i6,
      Matrix3: Dt,
      Matrix4: wt,
      MaxEquation: pO,
      Mesh: Cn,
      MeshBasicMaterial: sa,
      MeshDepthMaterial: sy,
      MeshDistanceMaterial: ay,
      MeshLambertMaterial: tD,
      MeshMatcapMaterial: nD,
      MeshNormalMaterial: eD,
      MeshPhongMaterial: JN,
      MeshPhysicalMaterial: ZN,
      MeshStandardMaterial: bE,
      MeshToonMaterial: QN,
      MinEquation: hO,
      MirroredRepeatWrapping: Vh,
      MixOperation: DO,
      MultiplyBlending: nA,
      MultiplyOperation: Rp,
      NearestFilter: xr,
      NearestMipMapLinearFilter: h5,
      NearestMipMapNearestFilter: d5,
      NearestMipmapLinearFilter: $u,
      NearestMipmapNearestFilter: Yw,
      NeutralToneMapping: VO,
      NeverCompare: iN,
      NeverDepth: TO,
      NeverStencilFunc: M5,
      NoBlending: js,
      NoColorSpace: zs,
      NoToneMapping: hs,
      NormalAnimationBlendMode: ny,
      NormalBlending: uc,
      NotEqualCompare: lN,
      NotEqualDepth: NO,
      NotEqualStencilFunc: I5,
      NumberKeyframeTrack: np,
      Object3D: Qt,
      ObjectLoader: dj,
      ObjectSpaceNormalMap: rN,
      OctahedronGeometry: Fp,
      OneFactor: gO,
      OneMinusConstantAlphaFactor: CO,
      OneMinusConstantColorFactor: EO,
      OneMinusDstAlphaFactor: _O,
      OneMinusDstColorFactor: AO,
      OneMinusSrcAlphaFactor: pv,
      OneMinusSrcColorFactor: yO,
      OrthographicCamera: ps,
      P3Primaries: Yh,
      PCFShadowMap: ey,
      PCFSoftShadowMap: uh,
      PMREMGenerator: LA,
      Path: Jh,
      PerspectiveCamera: En,
      Plane: ks,
      PlaneGeometry: aa,
      PlaneHelper: Jj,
      PointLight: dD,
      PointLightHelper: Gj,
      Points: kN,
      PointsMaterial: gE,
      PolarGridHelper: Xj,
      PolyhedronGeometry: ll,
      PositionalAudio: _j,
      PropertyBinding: qt,
      PropertyMixer: _D,
      QuadraticBezierCurve: _E,
      QuadraticBezierCurve3: SE,
      Quaternion: $r,
      QuaternionKeyframeTrack: kf,
      QuaternionLinearInterpolant: lD,
      RED_GREEN_RGTC2_Format: TA,
      RED_RGTC1_Format: JO,
      REVISION: Qv,
      RGBADepthPacking: iE,
      RGBAFormat: Si,
      RGBAIntegerFormat: nE,
      RGBA_ASTC_10x10_Format: AA,
      RGBA_ASTC_10x5_Format: xA,
      RGBA_ASTC_10x6_Format: _A,
      RGBA_ASTC_10x8_Format: SA,
      RGBA_ASTC_12x10_Format: bA,
      RGBA_ASTC_12x12_Format: wA,
      RGBA_ASTC_4x4_Format: fA,
      RGBA_ASTC_5x4_Format: dA,
      RGBA_ASTC_5x5_Format: hA,
      RGBA_ASTC_6x5_Format: pA,
      RGBA_ASTC_6x6_Format: mA,
      RGBA_ASTC_8x5_Format: gA,
      RGBA_ASTC_8x6_Format: vA,
      RGBA_ASTC_8x8_Format: yA,
      RGBA_BPTC_Format: C0,
      RGBA_ETC2_EAC_Format: uA,
      RGBA_PVRTC_2BPPV1_Format: aA,
      RGBA_PVRTC_4BPPV1_Format: sA,
      RGBA_S3TC_DXT1_Format: w0,
      RGBA_S3TC_DXT3_Format: E0,
      RGBA_S3TC_DXT5_Format: M0,
      RGBFormat: YO,
      RGB_BPTC_SIGNED_Format: EA,
      RGB_BPTC_UNSIGNED_Format: MA,
      RGB_ETC1_Format: lA,
      RGB_ETC2_Format: cA,
      RGB_PVRTC_2BPPV1_Format: oA,
      RGB_PVRTC_4BPPV1_Format: iA,
      RGB_S3TC_DXT1_Format: b0,
      RGFormat: ZO,
      RGIntegerFormat: tE,
      RawShaderMaterial: KN,
      Ray: Oc,
      Raycaster: AD,
      Rec709Primaries: Xh,
      RectAreaLight: mD,
      RedFormat: Qw,
      RedIntegerFormat: eE,
      ReinhardToneMapping: kO,
      RenderTarget: vN,
      RepeatWrapping: Hh,
      ReplaceStencilOp: _5,
      ReverseSubtractEquation: dO,
      RingGeometry: Sy,
      SIGNED_RED_GREEN_RGTC2_Format: RA,
      SIGNED_RED_RGTC1_Format: CA,
      SRGBColorSpace: fo,
      SRGBTransfer: hn,
      Scene: hE,
      ShaderChunk: Lt,
      ShaderLib: Uo,
      ShaderMaterial: jo,
      ShadowMaterial: qN,
      Shape: pc,
      ShapeGeometry: Ay,
      ShapePath: t9,
      ShapeUtils: ms,
      ShortType: jO,
      Skeleton: fy,
      SkeletonHelper: Vj,
      SkinnedMesh: NN,
      Source: nc,
      Sphere: Pr,
      SphereGeometry: Up,
      Spherical: BA,
      SphericalHarmonics3: gD,
      SplineCurve: AE,
      SpotLight: fD,
      SpotLightHelper: Hj,
      Sprite: LN,
      SpriteMaterial: pE,
      SrcAlphaFactor: hv,
      SrcAlphaSaturateFactor: bO,
      SrcColorFactor: vO,
      StaticCopyUsage: k5,
      StaticDrawUsage: qh,
      StaticReadUsage: D5,
      StereoCamera: gj,
      StreamCopyUsage: B5,
      StreamDrawUsage: N5,
      StreamReadUsage: U5,
      StringKeyframeTrack: Fc,
      SubtractEquation: fO,
      SubtractiveBlending: tA,
      TOUCH: jl,
      TangentSpaceNormalMap: al,
      TetrahedronGeometry: by,
      Texture: lr,
      TextureLoader: lj,
      TorusGeometry: wy,
      TorusKnotGeometry: Ey,
      Triangle: Gi,
      TriangleFanDrawMode: y5,
      TriangleStripDrawMode: v5,
      TrianglesDrawMode: g5,
      TubeGeometry: My,
      UVMapping: ty,
      Uint16BufferAttribute: lE,
      Uint32BufferAttribute: cE,
      Uint8BufferAttribute: A6,
      Uint8ClampedBufferAttribute: b6,
      Uniform: NE,
      UniformsGroup: Dj,
      UniformsLib: et,
      UniformsUtils: uE,
      UnsignedByteType: gs,
      UnsignedInt248Type: Df,
      UnsignedInt5999Type: $O,
      UnsignedIntType: wc,
      UnsignedShort4444Type: Zw,
      UnsignedShort5551Type: Jw,
      UnsignedShortType: qw,
      VSMShadowMap: Lo,
      Vector2: ke,
      Vector3: ee,
      Vector4: tn,
      VectorKeyframeTrack: rp,
      VideoTexture: _W,
      WebGL3DRenderTarget: u6,
      WebGLArrayRenderTarget: c6,
      WebGLCoordinateSystem: cs,
      WebGLCubeRenderTarget: SN,
      WebGLMultipleRenderTargets: n9,
      WebGLRenderTarget: Wo,
      WebGLRenderer: PN,
      WebGLUtils: TN,
      WebGPUCoordinateSystem: Kh,
      WireframeGeometry: YN,
      WrapAroundEnding: jh,
      ZeroCurvatureEnding: ec,
      ZeroFactor: mO,
      ZeroSlopeEnding: tc,
      ZeroStencilOp: x5,
      createCanvasElement: pN,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var wD = { exports: {} },
  Uc = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Uc.ConcurrentRoot = 1;
Uc.ContinuousEventPriority = 4;
Uc.DefaultEventPriority = 16;
Uc.DiscreteEventPriority = 1;
Uc.IdleEventPriority = 536870912;
Uc.LegacyRoot = 0;
wD.exports = Uc;
var Zu = wD.exports;
function i9(t) {
  let e;
  const n = new Set(),
    r = (c, u) => {
      const d = typeof c == "function" ? c(e) : c;
      if (d !== e) {
        const p = e;
        (e = u ? d : Object.assign({}, e, d)), n.forEach((m) => m(e, p));
      }
    },
    i = () => e,
    o = (c, u = i, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = u(e);
      function m() {
        const v = u(e);
        if (!d(p, v)) {
          const _ = p;
          c((p = v), _);
        }
      }
      return n.add(m), () => n.delete(m);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (c, u, d) =>
        u || d ? o(c, u, d) : (n.add(c), () => n.delete(c)),
      destroy: () => n.clear(),
    };
  return (e = t(r, i, l)), l;
}
const o9 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  IR = o9 ? L.useEffect : L.useLayoutEffect;
function s9(t) {
  const e = typeof t == "function" ? i9(t) : t,
    n = (r = e.getState, i = Object.is) => {
      const [, o] = L.useReducer((y) => y + 1, 0),
        s = e.getState(),
        a = L.useRef(s),
        l = L.useRef(r),
        c = L.useRef(i),
        u = L.useRef(!1),
        d = L.useRef();
      d.current === void 0 && (d.current = r(s));
      let p,
        m = !1;
      (a.current !== s || l.current !== r || c.current !== i || u.current) &&
        ((p = r(s)), (m = !i(d.current, p))),
        IR(() => {
          m && (d.current = p),
            (a.current = s),
            (l.current = r),
            (c.current = i),
            (u.current = !1);
        });
      const v = L.useRef(s);
      IR(() => {
        const y = () => {
            try {
              const x = e.getState(),
                S = l.current(x);
              c.current(d.current, S) ||
                ((a.current = x), (d.current = S), o());
            } catch {
              (u.current = !0), o();
            }
          },
          g = e.subscribe(y);
        return e.getState() !== v.current && y(), g;
      }, []);
      const _ = m ? p : d.current;
      return L.useDebugValue(_), _;
    };
  return (
    Object.assign(n, e),
    (n[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [n, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    n
  );
}
const a9 = (t) => typeof t == "object" && typeof t.then == "function",
  ic = [];
function ED(t, e, n = (r, i) => r === i) {
  if (t === e) return !0;
  if (!t || !e) return !1;
  const r = t.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!n(t[i], e[i])) return !1;
  return !0;
}
function MD(t, e = null, n = !1, r = {}) {
  e === null && (e = [t]);
  for (const o of ic)
    if (ED(e, o.keys, o.equal)) {
      if (n) return;
      if (Object.prototype.hasOwnProperty.call(o, "error")) throw o.error;
      if (Object.prototype.hasOwnProperty.call(o, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (o.timeout && clearTimeout(o.timeout),
            (o.timeout = setTimeout(o.remove, r.lifespan))),
          o.response
        );
      if (!n) throw o.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const o = ic.indexOf(i);
      o !== -1 && ic.splice(o, 1);
    },
    promise: (a9(t) ? t : t(...e))
      .then((o) => {
        (i.response = o),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((o) => (i.error = o)),
  };
  if ((ic.push(i), !n)) throw i.promise;
}
const CD = (t, e, n) => MD(t, e, !1, n),
  l9 = (t, e, n) => void MD(t, e, !0, n),
  c9 = (t) => {
    if (t === void 0 || t.length === 0) ic.splice(0, ic.length);
    else {
      const e = ic.find((n) => ED(t, n.keys, n.equal));
      e && e.remove();
    }
  };
var TD = { exports: {} },
  RD = { exports: {} },
  PD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (t) {
  function e(U, j) {
    var W = U.length;
    U.push(j);
    e: for (; 0 < W; ) {
      var B = (W - 1) >>> 1,
        q = U[B];
      if (0 < i(q, j)) (U[B] = j), (U[W] = q), (W = B);
      else break e;
    }
  }
  function n(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var j = U[0],
      W = U.pop();
    if (W !== j) {
      U[0] = W;
      e: for (var B = 0, q = U.length, Z = q >>> 1; B < Z; ) {
        var H = 2 * (B + 1) - 1,
          X = U[H],
          ne = H + 1,
          oe = U[ne];
        if (0 > i(X, W))
          ne < q && 0 > i(oe, X)
            ? ((U[B] = oe), (U[ne] = W), (B = ne))
            : ((U[B] = X), (U[H] = W), (B = H));
        else if (ne < q && 0 > i(oe, W)) (U[B] = oe), (U[ne] = W), (B = ne);
        else break e;
      }
    }
    return j;
  }
  function i(U, j) {
    var W = U.sortIndex - j.sortIndex;
    return W !== 0 ? W : U.id - j.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance;
    t.unstable_now = function () {
      return o.now();
    };
  } else {
    var s = Date,
      a = s.now();
    t.unstable_now = function () {
      return s.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    _ = !1,
    y = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    x = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var j = n(c); j !== null; ) {
      if (j.callback === null) r(c);
      else if (j.startTime <= U)
        r(c), (j.sortIndex = j.expirationTime), e(l, j);
      else break;
      j = n(c);
    }
  }
  function b(U) {
    if (((_ = !1), S(U), !v))
      if (n(l) !== null) (v = !0), G(C);
      else {
        var j = n(c);
        j !== null && Y(b, j.startTime - U);
      }
  }
  function C(U, j) {
    (v = !1), _ && ((_ = !1), g(P), (P = -1)), (m = !0);
    var W = p;
    try {
      for (
        S(j), d = n(l);
        d !== null && (!(d.expirationTime > j) || (U && !O()));

      ) {
        var B = d.callback;
        if (typeof B == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var q = B(d.expirationTime <= j);
          (j = t.unstable_now()),
            typeof q == "function" ? (d.callback = q) : d === n(l) && r(l),
            S(j);
        } else r(l);
        d = n(l);
      }
      if (d !== null) var Z = !0;
      else {
        var H = n(c);
        H !== null && Y(b, H.startTime - j), (Z = !1);
      }
      return Z;
    } finally {
      (d = null), (p = W), (m = !1);
    }
  }
  var M = !1,
    T = null,
    P = -1,
    R = 5,
    E = -1;
  function O() {
    return !(t.unstable_now() - E < R);
  }
  function D() {
    if (T !== null) {
      var U = t.unstable_now();
      E = U;
      var j = !0;
      try {
        j = T(!0, U);
      } finally {
        j ? N() : ((M = !1), (T = null));
      }
    } else M = !1;
  }
  var N;
  if (typeof x == "function")
    N = function () {
      x(D);
    };
  else if (typeof MessageChannel < "u") {
    var z = new MessageChannel(),
      V = z.port2;
    (z.port1.onmessage = D),
      (N = function () {
        V.postMessage(null);
      });
  } else
    N = function () {
      y(D, 0);
    };
  function G(U) {
    (T = U), M || ((M = !0), N());
  }
  function Y(U, j) {
    P = y(function () {
      U(t.unstable_now());
    }, j);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || m || ((v = !0), G(C));
    }),
    (t.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (U) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var j = 3;
          break;
        default:
          j = p;
      }
      var W = p;
      p = j;
      try {
        return U();
      } finally {
        p = W;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (U, j) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var W = p;
      p = U;
      try {
        return j();
      } finally {
        p = W;
      }
    }),
    (t.unstable_scheduleCallback = function (U, j, W) {
      var B = t.unstable_now();
      switch (
        (typeof W == "object" && W !== null
          ? ((W = W.delay), (W = typeof W == "number" && 0 < W ? B + W : B))
          : (W = B),
        U)
      ) {
        case 1:
          var q = -1;
          break;
        case 2:
          q = 250;
          break;
        case 5:
          q = 1073741823;
          break;
        case 4:
          q = 1e4;
          break;
        default:
          q = 5e3;
      }
      return (
        (q = W + q),
        (U = {
          id: u++,
          callback: j,
          priorityLevel: U,
          startTime: W,
          expirationTime: q,
          sortIndex: -1,
        }),
        W > B
          ? ((U.sortIndex = W),
            e(c, U),
            n(l) === null &&
              U === n(c) &&
              (_ ? (g(P), (P = -1)) : (_ = !0), Y(b, W - B)))
          : ((U.sortIndex = q), e(l, U), v || m || ((v = !0), G(C))),
        U
      );
    }),
    (t.unstable_shouldYield = O),
    (t.unstable_wrapCallback = function (U) {
      var j = p;
      return function () {
        var W = p;
        p = j;
        try {
          return U.apply(this, arguments);
        } finally {
          p = W;
        }
      };
    });
})(PD);
RD.exports = PD;
var HA = RD.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var u9 = function (e) {
  var n = {},
    r = L,
    i = HA,
    o = Object.assign;
  function s(f) {
    for (
      var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + f,
        A = 1;
      A < arguments.length;
      A++
    )
      h += "&args[]=" + encodeURIComponent(arguments[A]);
    return (
      "Minified React error #" +
      f +
      "; visit " +
      h +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    u = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    _ = Symbol.for("react.forward_ref"),
    y = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    x = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    b = Symbol.for("react.offscreen"),
    C = Symbol.iterator;
  function M(f) {
    return f === null || typeof f != "object"
      ? null
      : ((f = (C && f[C]) || f["@@iterator"]),
        typeof f == "function" ? f : null);
  }
  function T(f) {
    if (f == null) return null;
    if (typeof f == "function") return f.displayName || f.name || null;
    if (typeof f == "string") return f;
    switch (f) {
      case u:
        return "Fragment";
      case c:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case y:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof f == "object")
      switch (f.$$typeof) {
        case v:
          return (f.displayName || "Context") + ".Consumer";
        case m:
          return (f._context.displayName || "Context") + ".Provider";
        case _:
          var h = f.render;
          return (
            (f = f.displayName),
            f ||
              ((f = h.displayName || h.name || ""),
              (f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")),
            f
          );
        case x:
          return (
            (h = f.displayName || null), h !== null ? h : T(f.type) || "Memo"
          );
        case S:
          (h = f._payload), (f = f._init);
          try {
            return T(f(h));
          } catch {}
      }
    return null;
  }
  function P(f) {
    var h = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (f = h.render),
          (f = f.displayName || f.name || ""),
          h.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return T(h);
      case 8:
        return h === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function R(f) {
    var h = f,
      A = f;
    if (f.alternate) for (; h.return; ) h = h.return;
    else {
      f = h;
      do (h = f), h.flags & 4098 && (A = h.return), (f = h.return);
      while (f);
    }
    return h.tag === 3 ? A : null;
  }
  function E(f) {
    if (R(f) !== f) throw Error(s(188));
  }
  function O(f) {
    var h = f.alternate;
    if (!h) {
      if (((h = R(f)), h === null)) throw Error(s(188));
      return h !== f ? null : f;
    }
    for (var A = f, w = h; ; ) {
      var I = A.return;
      if (I === null) break;
      var F = I.alternate;
      if (F === null) {
        if (((w = I.return), w !== null)) {
          A = w;
          continue;
        }
        break;
      }
      if (I.child === F.child) {
        for (F = I.child; F; ) {
          if (F === A) return E(I), f;
          if (F === w) return E(I), h;
          F = F.sibling;
        }
        throw Error(s(188));
      }
      if (A.return !== w.return) (A = I), (w = F);
      else {
        for (var re = !1, me = I.child; me; ) {
          if (me === A) {
            (re = !0), (A = I), (w = F);
            break;
          }
          if (me === w) {
            (re = !0), (w = I), (A = F);
            break;
          }
          me = me.sibling;
        }
        if (!re) {
          for (me = F.child; me; ) {
            if (me === A) {
              (re = !0), (A = F), (w = I);
              break;
            }
            if (me === w) {
              (re = !0), (w = F), (A = I);
              break;
            }
            me = me.sibling;
          }
          if (!re) throw Error(s(189));
        }
      }
      if (A.alternate !== w) throw Error(s(190));
    }
    if (A.tag !== 3) throw Error(s(188));
    return A.stateNode.current === A ? f : h;
  }
  function D(f) {
    return (f = O(f)), f !== null ? N(f) : null;
  }
  function N(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      var h = N(f);
      if (h !== null) return h;
      f = f.sibling;
    }
    return null;
  }
  function z(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      if (f.tag !== 4) {
        var h = z(f);
        if (h !== null) return h;
      }
      f = f.sibling;
    }
    return null;
  }
  var V = Array.isArray,
    G = e.getPublicInstance,
    Y = e.getRootHostContext,
    U = e.getChildHostContext,
    j = e.prepareForCommit,
    W = e.resetAfterCommit,
    B = e.createInstance,
    q = e.appendInitialChild,
    Z = e.finalizeInitialChildren,
    H = e.prepareUpdate,
    X = e.shouldSetTextContent,
    ne = e.createTextInstance,
    oe = e.scheduleTimeout,
    ue = e.cancelTimeout,
    Ie = e.noTimeout,
    te = e.isPrimaryRenderer,
    ge = e.supportsMutation,
    ie = e.supportsPersistence,
    pe = e.supportsHydration,
    de = e.getInstanceFromNode,
    Ee = e.preparePortalMount,
    he = e.getCurrentEventPriority,
    Ce = e.detachDeletedInstance,
    _e = e.supportsMicrotasks,
    $ = e.scheduleMicrotask,
    k = e.supportsTestSelectors,
    J = e.findFiberRoot,
    fe = e.getBoundingRect,
    le = e.getTextContent,
    ce = e.isHiddenSubtree,
    we = e.matchAccessibilityRole,
    Be = e.setFocusIfFocusable,
    Me = e.setupIntersectionObserver,
    Ge = e.appendChild,
    Le = e.appendChildToContainer,
    je = e.commitTextUpdate,
    Je = e.commitMount,
    Ye = e.commitUpdate,
    De = e.insertBefore,
    ze = e.insertInContainerBefore,
    Ve = e.removeChild,
    ae = e.removeChildFromContainer,
    be = e.resetTextContent,
    se = e.hideInstance,
    Ae = e.hideTextInstance,
    ye = e.unhideInstance,
    He = e.unhideTextInstance,
    qe = e.clearContainer,
    at = e.cloneInstance,
    st = e.createContainerChildSet,
    ht = e.appendChildToContainerChildSet,
    pt = e.finalizeContainerChildren,
    Ze = e.replaceContainerChildren,
    Mt = e.cloneHiddenInstance,
    Rt = e.cloneHiddenTextInstance,
    Yt = e.canHydrateInstance,
    en = e.canHydrateTextInstance,
    Qn = e.canHydrateSuspenseInstance,
    cr = e.isSuspenseInstancePending,
    $t = e.isSuspenseInstanceFallback,
    ur = e.registerSuspenseInstanceRetry,
    fr = e.getNextHydratableSibling,
    Xt = e.getFirstHydratableChild,
    Vt = e.getFirstHydratableChildWithinContainer,
    In = e.getFirstHydratableChildWithinSuspenseInstance,
    br = e.hydrateInstance,
    K = e.hydrateTextInstance,
    Se = e.hydrateSuspenseInstance,
    Oe = e.getNextHydratableInstanceAfterSuspenseInstance,
    Te = e.commitHydratedContainer,
    Re = e.commitHydratedSuspenseInstance,
    Qe = e.clearSuspenseBoundary,
    ct = e.clearSuspenseBoundaryFromContainer,
    nt = e.shouldDeleteUnhydratedTailInstances,
    xt = e.didNotMatchHydratedContainerTextInstance,
    Ct = e.didNotMatchHydratedTextInstance,
    $e;
  function Et(f) {
    if ($e === void 0)
      try {
        throw Error();
      } catch (A) {
        var h = A.stack.trim().match(/\n( *(at )?)/);
        $e = (h && h[1]) || "";
      }
    return (
      `
` +
      $e +
      f
    );
  }
  var dn = !1;
  function cn(f, h) {
    if (!f || dn) return "";
    dn = !0;
    var A = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h)
        if (
          ((h = function () {
            throw Error();
          }),
          Object.defineProperty(h.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(h, []);
          } catch (Ke) {
            var w = Ke;
          }
          Reflect.construct(f, [], h);
        } else {
          try {
            h.call();
          } catch (Ke) {
            w = Ke;
          }
          f.call(h.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Ke) {
          w = Ke;
        }
        f();
      }
    } catch (Ke) {
      if (Ke && w && typeof Ke.stack == "string") {
        for (
          var I = Ke.stack.split(`
`),
            F = w.stack.split(`
`),
            re = I.length - 1,
            me = F.length - 1;
          1 <= re && 0 <= me && I[re] !== F[me];

        )
          me--;
        for (; 1 <= re && 0 <= me; re--, me--)
          if (I[re] !== F[me]) {
            if (re !== 1 || me !== 1)
              do
                if ((re--, me--, 0 > me || I[re] !== F[me])) {
                  var Ue =
                    `
` + I[re].replace(" at new ", " at ");
                  return (
                    f.displayName &&
                      Ue.includes("<anonymous>") &&
                      (Ue = Ue.replace("<anonymous>", f.displayName)),
                    Ue
                  );
                }
              while (1 <= re && 0 <= me);
            break;
          }
      }
    } finally {
      (dn = !1), (Error.prepareStackTrace = A);
    }
    return (f = f ? f.displayName || f.name : "") ? Et(f) : "";
  }
  var Xn = Object.prototype.hasOwnProperty,
    Lr = [],
    Nt = -1;
  function vt(f) {
    return { current: f };
  }
  function Wt(f) {
    0 > Nt || ((f.current = Lr[Nt]), (Lr[Nt] = null), Nt--);
  }
  function _t(f, h) {
    Nt++, (Lr[Nt] = f.current), (f.current = h);
  }
  var zn = {},
    Ln = vt(zn),
    yn = vt(!1),
    hi = zn;
  function nn(f, h) {
    var A = f.type.contextTypes;
    if (!A) return zn;
    var w = f.stateNode;
    if (w && w.__reactInternalMemoizedUnmaskedChildContext === h)
      return w.__reactInternalMemoizedMaskedChildContext;
    var I = {},
      F;
    for (F in A) I[F] = h[F];
    return (
      w &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = h),
        (f.__reactInternalMemoizedMaskedChildContext = I)),
      I
    );
  }
  function un(f) {
    return (f = f.childContextTypes), f != null;
  }
  function Kr() {
    Wt(yn), Wt(Ln);
  }
  function er(f, h, A) {
    if (Ln.current !== zn) throw Error(s(168));
    _t(Ln, h), _t(yn, A);
  }
  function qo(f, h, A) {
    var w = f.stateNode;
    if (((h = h.childContextTypes), typeof w.getChildContext != "function"))
      return A;
    w = w.getChildContext();
    for (var I in w) if (!(I in h)) throw Error(s(108, P(f) || "Unknown", I));
    return o({}, A, w);
  }
  function Ko(f) {
    return (
      (f =
        ((f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext) ||
        zn),
      (hi = Ln.current),
      _t(Ln, f),
      _t(yn, yn.current),
      !0
    );
  }
  function Or(f, h, A) {
    var w = f.stateNode;
    if (!w) throw Error(s(169));
    A
      ? ((f = qo(f, h, hi)),
        (w.__reactInternalMemoizedMergedChildContext = f),
        Wt(yn),
        Wt(Ln),
        _t(Ln, f))
      : Wt(yn),
      _t(yn, A);
  }
  var Ri = Math.clz32 ? Math.clz32 : Xp,
    Hc = Math.log,
    hl = Math.LN2;
  function Xp(f) {
    return (f >>>= 0), f === 0 ? 32 : (31 - ((Hc(f) / hl) | 0)) | 0;
  }
  var _s = 64,
    Ss = 4194304;
  function As(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function pl(f, h) {
    var A = f.pendingLanes;
    if (A === 0) return 0;
    var w = 0,
      I = f.suspendedLanes,
      F = f.pingedLanes,
      re = A & 268435455;
    if (re !== 0) {
      var me = re & ~I;
      me !== 0 ? (w = As(me)) : ((F &= re), F !== 0 && (w = As(F)));
    } else (re = A & ~I), re !== 0 ? (w = As(re)) : F !== 0 && (w = As(F));
    if (w === 0) return 0;
    if (
      h !== 0 &&
      h !== w &&
      !(h & I) &&
      ((I = w & -w), (F = h & -h), I >= F || (I === 16 && (F & 4194240) !== 0))
    )
      return h;
    if ((w & 4 && (w |= A & 16), (h = f.entangledLanes), h !== 0))
      for (f = f.entanglements, h &= w; 0 < h; )
        (A = 31 - Ri(h)), (I = 1 << A), (w |= f[A]), (h &= ~I);
    return w;
  }
  function Yp(f, h) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Xf(f, h) {
    for (
      var A = f.suspendedLanes,
        w = f.pingedLanes,
        I = f.expirationTimes,
        F = f.pendingLanes;
      0 < F;

    ) {
      var re = 31 - Ri(F),
        me = 1 << re,
        Ue = I[re];
      Ue === -1
        ? (!(me & A) || me & w) && (I[re] = Yp(me, h))
        : Ue <= h && (f.expiredLanes |= me),
        (F &= ~me);
    }
  }
  function bs(f) {
    return (
      (f = f.pendingLanes & -1073741825),
      f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
    );
  }
  function Vc(f) {
    for (var h = [], A = 0; 31 > A; A++) h.push(f);
    return h;
  }
  function Zo(f, h, A) {
    (f.pendingLanes |= h),
      h !== 536870912 && ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
      (f = f.eventTimes),
      (h = 31 - Ri(h)),
      (f[h] = A);
  }
  function ua(f, h) {
    var A = f.pendingLanes & ~h;
    (f.pendingLanes = h),
      (f.suspendedLanes = 0),
      (f.pingedLanes = 0),
      (f.expiredLanes &= h),
      (f.mutableReadLanes &= h),
      (f.entangledLanes &= h),
      (h = f.entanglements);
    var w = f.eventTimes;
    for (f = f.expirationTimes; 0 < A; ) {
      var I = 31 - Ri(A),
        F = 1 << I;
      (h[I] = 0), (w[I] = -1), (f[I] = -1), (A &= ~F);
    }
  }
  function Jo(f, h) {
    var A = (f.entangledLanes |= h);
    for (f = f.entanglements; A; ) {
      var w = 31 - Ri(A),
        I = 1 << w;
      (I & h) | (f[w] & h) && (f[w] |= h), (A &= ~I);
    }
  }
  var Ht = 0;
  function Yf(f) {
    return (
      (f &= -f), 1 < f ? (4 < f ? (f & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var ws = i.unstable_scheduleCallback,
    Gc = i.unstable_cancelCallback,
    qf = i.unstable_shouldYield,
    qp = i.unstable_requestPaint,
    An = i.unstable_now,
    ml = i.unstable_ImmediatePriority,
    Kp = i.unstable_UserBlockingPriority,
    Zr = i.unstable_NormalPriority,
    Kf = i.unstable_IdlePriority,
    gl = null,
    Pi = null;
  function Zf(f) {
    if (Pi && typeof Pi.onCommitFiberRoot == "function")
      try {
        Pi.onCommitFiberRoot(gl, f, void 0, (f.current.flags & 128) === 128);
      } catch {}
  }
  function Zp(f, h) {
    return (f === h && (f !== 0 || 1 / f === 1 / h)) || (f !== f && h !== h);
  }
  var Ii = typeof Object.is == "function" ? Object.is : Zp,
    Jr = null,
    Qo = !1,
    Qi = !1;
  function Jf(f) {
    Jr === null ? (Jr = [f]) : Jr.push(f);
  }
  function Qf(f) {
    (Qo = !0), Jf(f);
  }
  function pi() {
    if (!Qi && Jr !== null) {
      Qi = !0;
      var f = 0,
        h = Ht;
      try {
        var A = Jr;
        for (Ht = 1; f < A.length; f++) {
          var w = A[f];
          do w = w(!0);
          while (w !== null);
        }
        (Jr = null), (Qo = !1);
      } catch (I) {
        throw (Jr !== null && (Jr = Jr.slice(f + 1)), ws(ml, pi), I);
      } finally {
        (Ht = h), (Qi = !1);
      }
    }
    return null;
  }
  var vl = a.ReactCurrentBatchConfig;
  function yl(f, h) {
    if (Ii(f, h)) return !0;
    if (
      typeof f != "object" ||
      f === null ||
      typeof h != "object" ||
      h === null
    )
      return !1;
    var A = Object.keys(f),
      w = Object.keys(h);
    if (A.length !== w.length) return !1;
    for (w = 0; w < A.length; w++) {
      var I = A[w];
      if (!Xn.call(h, I) || !Ii(f[I], h[I])) return !1;
    }
    return !0;
  }
  function xl(f) {
    switch (f.tag) {
      case 5:
        return Et(f.type);
      case 16:
        return Et("Lazy");
      case 13:
        return Et("Suspense");
      case 19:
        return Et("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (f = cn(f.type, !1)), f;
      case 11:
        return (f = cn(f.type.render, !1)), f;
      case 1:
        return (f = cn(f.type, !0)), f;
      default:
        return "";
    }
  }
  function Qr(f, h) {
    if (f && f.defaultProps) {
      (h = o({}, h)), (f = f.defaultProps);
      for (var A in f) h[A] === void 0 && (h[A] = f[A]);
      return h;
    }
    return h;
  }
  var dr = vt(null),
    Wc = null,
    Eo = null,
    fa = null;
  function jc() {
    fa = Eo = Wc = null;
  }
  function Jp(f, h, A) {
    te
      ? (_t(dr, h._currentValue), (h._currentValue = A))
      : (_t(dr, h._currentValue2), (h._currentValue2 = A));
  }
  function hr(f) {
    var h = dr.current;
    Wt(dr), te ? (f._currentValue = h) : (f._currentValue2 = h);
  }
  function ei(f, h, A) {
    for (; f !== null; ) {
      var w = f.alternate;
      if (
        ((f.childLanes & h) !== h
          ? ((f.childLanes |= h), w !== null && (w.childLanes |= h))
          : w !== null && (w.childLanes & h) !== h && (w.childLanes |= h),
        f === A)
      )
        break;
      f = f.return;
    }
  }
  function Bn(f, h) {
    (Wc = f),
      (fa = Eo = null),
      (f = f.dependencies),
      f !== null &&
        f.firstContext !== null &&
        (f.lanes & h && (Di = !0), (f.firstContext = null));
  }
  function Hn(f) {
    var h = te ? f._currentValue : f._currentValue2;
    if (fa !== f)
      if (((f = { context: f, memoizedValue: h, next: null }), Eo === null)) {
        if (Wc === null) throw Error(s(308));
        (Eo = f), (Wc.dependencies = { lanes: 0, firstContext: f });
      } else Eo = Eo.next = f;
    return h;
  }
  var Li = null,
    da = !1;
  function ux(f) {
    f.updateQueue = {
      baseState: f.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function gM(f, h) {
    (f = f.updateQueue),
      h.updateQueue === f &&
        (h.updateQueue = {
          baseState: f.baseState,
          firstBaseUpdate: f.firstBaseUpdate,
          lastBaseUpdate: f.lastBaseUpdate,
          shared: f.shared,
          effects: f.effects,
        });
  }
  function Es(f, h) {
    return {
      eventTime: f,
      lane: h,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function ha(f, h) {
    var A = f.updateQueue;
    A !== null &&
      ((A = A.shared),
      Yn !== null && f.mode & 1 && !(kt & 2)
        ? ((f = A.interleaved),
          f === null
            ? ((h.next = h), Li === null ? (Li = [A]) : Li.push(A))
            : ((h.next = f.next), (f.next = h)),
          (A.interleaved = h))
        : ((f = A.pending),
          f === null ? (h.next = h) : ((h.next = f.next), (f.next = h)),
          (A.pending = h)));
  }
  function Qp(f, h, A) {
    if (
      ((h = h.updateQueue), h !== null && ((h = h.shared), (A & 4194240) !== 0))
    ) {
      var w = h.lanes;
      (w &= f.pendingLanes), (A |= w), (h.lanes = A), Jo(f, A);
    }
  }
  function vM(f, h) {
    var A = f.updateQueue,
      w = f.alternate;
    if (w !== null && ((w = w.updateQueue), A === w)) {
      var I = null,
        F = null;
      if (((A = A.firstBaseUpdate), A !== null)) {
        do {
          var re = {
            eventTime: A.eventTime,
            lane: A.lane,
            tag: A.tag,
            payload: A.payload,
            callback: A.callback,
            next: null,
          };
          F === null ? (I = F = re) : (F = F.next = re), (A = A.next);
        } while (A !== null);
        F === null ? (I = F = h) : (F = F.next = h);
      } else I = F = h;
      (A = {
        baseState: w.baseState,
        firstBaseUpdate: I,
        lastBaseUpdate: F,
        shared: w.shared,
        effects: w.effects,
      }),
        (f.updateQueue = A);
      return;
    }
    (f = A.lastBaseUpdate),
      f === null ? (A.firstBaseUpdate = h) : (f.next = h),
      (A.lastBaseUpdate = h);
  }
  function em(f, h, A, w) {
    var I = f.updateQueue;
    da = !1;
    var F = I.firstBaseUpdate,
      re = I.lastBaseUpdate,
      me = I.shared.pending;
    if (me !== null) {
      I.shared.pending = null;
      var Ue = me,
        Ke = Ue.next;
      (Ue.next = null), re === null ? (F = Ke) : (re.next = Ke), (re = Ue);
      var ut = f.alternate;
      ut !== null &&
        ((ut = ut.updateQueue),
        (me = ut.lastBaseUpdate),
        me !== re &&
          (me === null ? (ut.firstBaseUpdate = Ke) : (me.next = Ke),
          (ut.lastBaseUpdate = Ue)));
    }
    if (F !== null) {
      var Pt = I.baseState;
      (re = 0), (ut = Ke = Ue = null), (me = F);
      do {
        var St = me.lane,
          fn = me.eventTime;
        if ((w & St) === St) {
          ut !== null &&
            (ut = ut.next =
              {
                eventTime: fn,
                lane: 0,
                tag: me.tag,
                payload: me.payload,
                callback: me.callback,
                next: null,
              });
          e: {
            var gt = f,
              Ur = me;
            switch (((St = h), (fn = A), Ur.tag)) {
              case 1:
                if (((gt = Ur.payload), typeof gt == "function")) {
                  Pt = gt.call(fn, Pt, St);
                  break e;
                }
                Pt = gt;
                break e;
              case 3:
                gt.flags = (gt.flags & -65537) | 128;
              case 0:
                if (
                  ((gt = Ur.payload),
                  (St = typeof gt == "function" ? gt.call(fn, Pt, St) : gt),
                  St == null)
                )
                  break e;
                Pt = o({}, Pt, St);
                break e;
              case 2:
                da = !0;
            }
          }
          me.callback !== null &&
            me.lane !== 0 &&
            ((f.flags |= 64),
            (St = I.effects),
            St === null ? (I.effects = [me]) : St.push(me));
        } else
          (fn = {
            eventTime: fn,
            lane: St,
            tag: me.tag,
            payload: me.payload,
            callback: me.callback,
            next: null,
          }),
            ut === null ? ((Ke = ut = fn), (Ue = Pt)) : (ut = ut.next = fn),
            (re |= St);
        if (((me = me.next), me === null)) {
          if (((me = I.shared.pending), me === null)) break;
          (St = me),
            (me = St.next),
            (St.next = null),
            (I.lastBaseUpdate = St),
            (I.shared.pending = null);
        }
      } while (!0);
      if (
        (ut === null && (Ue = Pt),
        (I.baseState = Ue),
        (I.firstBaseUpdate = Ke),
        (I.lastBaseUpdate = ut),
        (h = I.shared.interleaved),
        h !== null)
      ) {
        I = h;
        do (re |= I.lane), (I = I.next);
        while (I !== h);
      } else F === null && (I.shared.lanes = 0);
      (eu |= re), (f.lanes = re), (f.memoizedState = Pt);
    }
  }
  function yM(f, h, A) {
    if (((f = h.effects), (h.effects = null), f !== null))
      for (h = 0; h < f.length; h++) {
        var w = f[h],
          I = w.callback;
        if (I !== null) {
          if (((w.callback = null), (w = A), typeof I != "function"))
            throw Error(s(191, I));
          I.call(w);
        }
      }
  }
  var xM = new r.Component().refs;
  function fx(f, h, A, w) {
    (h = f.memoizedState),
      (A = A(w, h)),
      (A = A == null ? h : o({}, h, A)),
      (f.memoizedState = A),
      f.lanes === 0 && (f.updateQueue.baseState = A);
  }
  var tm = {
    isMounted: function (f) {
      return (f = f._reactInternals) ? R(f) === f : !1;
    },
    enqueueSetState: function (f, h, A) {
      f = f._reactInternals;
      var w = ni(),
        I = ga(f),
        F = Es(w, I);
      (F.payload = h),
        A != null && (F.callback = A),
        ha(f, F),
        (h = io(f, I, w)),
        h !== null && Qp(h, f, I);
    },
    enqueueReplaceState: function (f, h, A) {
      f = f._reactInternals;
      var w = ni(),
        I = ga(f),
        F = Es(w, I);
      (F.tag = 1),
        (F.payload = h),
        A != null && (F.callback = A),
        ha(f, F),
        (h = io(f, I, w)),
        h !== null && Qp(h, f, I);
    },
    enqueueForceUpdate: function (f, h) {
      f = f._reactInternals;
      var A = ni(),
        w = ga(f),
        I = Es(A, w);
      (I.tag = 2),
        h != null && (I.callback = h),
        ha(f, I),
        (h = io(f, w, A)),
        h !== null && Qp(h, f, w);
    },
  };
  function _M(f, h, A, w, I, F, re) {
    return (
      (f = f.stateNode),
      typeof f.shouldComponentUpdate == "function"
        ? f.shouldComponentUpdate(w, F, re)
        : h.prototype && h.prototype.isPureReactComponent
        ? !yl(A, w) || !yl(I, F)
        : !0
    );
  }
  function SM(f, h, A) {
    var w = !1,
      I = zn,
      F = h.contextType;
    return (
      typeof F == "object" && F !== null
        ? (F = Hn(F))
        : ((I = un(h) ? hi : Ln.current),
          (w = h.contextTypes),
          (F = (w = w != null) ? nn(f, I) : zn)),
      (h = new h(A, F)),
      (f.memoizedState =
        h.state !== null && h.state !== void 0 ? h.state : null),
      (h.updater = tm),
      (f.stateNode = h),
      (h._reactInternals = f),
      w &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = I),
        (f.__reactInternalMemoizedMaskedChildContext = F)),
      h
    );
  }
  function AM(f, h, A, w) {
    (f = h.state),
      typeof h.componentWillReceiveProps == "function" &&
        h.componentWillReceiveProps(A, w),
      typeof h.UNSAFE_componentWillReceiveProps == "function" &&
        h.UNSAFE_componentWillReceiveProps(A, w),
      h.state !== f && tm.enqueueReplaceState(h, h.state, null);
  }
  function dx(f, h, A, w) {
    var I = f.stateNode;
    (I.props = A), (I.state = f.memoizedState), (I.refs = xM), ux(f);
    var F = h.contextType;
    typeof F == "object" && F !== null
      ? (I.context = Hn(F))
      : ((F = un(h) ? hi : Ln.current), (I.context = nn(f, F))),
      (I.state = f.memoizedState),
      (F = h.getDerivedStateFromProps),
      typeof F == "function" && (fx(f, h, F, A), (I.state = f.memoizedState)),
      typeof h.getDerivedStateFromProps == "function" ||
        typeof I.getSnapshotBeforeUpdate == "function" ||
        (typeof I.UNSAFE_componentWillMount != "function" &&
          typeof I.componentWillMount != "function") ||
        ((h = I.state),
        typeof I.componentWillMount == "function" && I.componentWillMount(),
        typeof I.UNSAFE_componentWillMount == "function" &&
          I.UNSAFE_componentWillMount(),
        h !== I.state && tm.enqueueReplaceState(I, I.state, null),
        em(f, A, I, w),
        (I.state = f.memoizedState)),
      typeof I.componentDidMount == "function" && (f.flags |= 4194308);
  }
  var $c = [],
    Xc = 0,
    nm = null,
    rm = 0,
    eo = [],
    to = 0,
    _l = null,
    Ms = 1,
    Cs = "";
  function Sl(f, h) {
    ($c[Xc++] = rm), ($c[Xc++] = nm), (nm = f), (rm = h);
  }
  function bM(f, h, A) {
    (eo[to++] = Ms), (eo[to++] = Cs), (eo[to++] = _l), (_l = f);
    var w = Ms;
    f = Cs;
    var I = 32 - Ri(w) - 1;
    (w &= ~(1 << I)), (A += 1);
    var F = 32 - Ri(h) + I;
    if (30 < F) {
      var re = I - (I % 5);
      (F = (w & ((1 << re) - 1)).toString(32)),
        (w >>= re),
        (I -= re),
        (Ms = (1 << (32 - Ri(h) + I)) | (A << I) | w),
        (Cs = F + f);
    } else (Ms = (1 << F) | (A << I) | w), (Cs = f);
  }
  function hx(f) {
    f.return !== null && (Sl(f, 1), bM(f, 1, 0));
  }
  function px(f) {
    for (; f === nm; )
      (nm = $c[--Xc]), ($c[Xc] = null), (rm = $c[--Xc]), ($c[Xc] = null);
    for (; f === _l; )
      (_l = eo[--to]),
        (eo[to] = null),
        (Cs = eo[--to]),
        (eo[to] = null),
        (Ms = eo[--to]),
        (eo[to] = null);
  }
  var Oi = null,
    Ni = null,
    xn = !1,
    ed = !1,
    Mo = null;
  function wM(f, h) {
    var A = oo(5, null, null, 0);
    (A.elementType = "DELETED"),
      (A.stateNode = h),
      (A.return = f),
      (h = f.deletions),
      h === null ? ((f.deletions = [A]), (f.flags |= 16)) : h.push(A);
  }
  function EM(f, h) {
    switch (f.tag) {
      case 5:
        return (
          (h = Yt(h, f.type, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (Oi = f), (Ni = Xt(h)), !0) : !1
        );
      case 6:
        return (
          (h = en(h, f.pendingProps)),
          h !== null ? ((f.stateNode = h), (Oi = f), (Ni = null), !0) : !1
        );
      case 13:
        if (((h = Qn(h)), h !== null)) {
          var A = _l !== null ? { id: Ms, overflow: Cs } : null;
          return (
            (f.memoizedState = {
              dehydrated: h,
              treeContext: A,
              retryLane: 1073741824,
            }),
            (A = oo(18, null, null, 0)),
            (A.stateNode = h),
            (A.return = f),
            (f.child = A),
            (Oi = f),
            (Ni = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function mx(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function gx(f) {
    if (xn) {
      var h = Ni;
      if (h) {
        var A = h;
        if (!EM(f, h)) {
          if (mx(f)) throw Error(s(418));
          h = fr(A);
          var w = Oi;
          h && EM(f, h)
            ? wM(w, A)
            : ((f.flags = (f.flags & -4097) | 2), (xn = !1), (Oi = f));
        }
      } else {
        if (mx(f)) throw Error(s(418));
        (f.flags = (f.flags & -4097) | 2), (xn = !1), (Oi = f);
      }
    }
  }
  function MM(f) {
    for (
      f = f.return;
      f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;

    )
      f = f.return;
    Oi = f;
  }
  function td(f) {
    if (!pe || f !== Oi) return !1;
    if (!xn) return MM(f), (xn = !0), !1;
    if (
      f.tag !== 3 &&
      (f.tag !== 5 || (nt(f.type) && !X(f.type, f.memoizedProps)))
    ) {
      var h = Ni;
      if (h) {
        if (mx(f)) {
          for (f = Ni; f; ) f = fr(f);
          throw Error(s(418));
        }
        for (; h; ) wM(f, h), (h = fr(h));
      }
    }
    if ((MM(f), f.tag === 13)) {
      if (!pe) throw Error(s(316));
      if (((f = f.memoizedState), (f = f !== null ? f.dehydrated : null), !f))
        throw Error(s(317));
      Ni = Oe(f);
    } else Ni = Oi ? fr(f.stateNode) : null;
    return !0;
  }
  function Yc() {
    pe && ((Ni = Oi = null), (ed = xn = !1));
  }
  function vx(f) {
    Mo === null ? (Mo = [f]) : Mo.push(f);
  }
  function nd(f, h, A) {
    if (
      ((f = A.ref),
      f !== null && typeof f != "function" && typeof f != "object")
    ) {
      if (A._owner) {
        if (((A = A._owner), A)) {
          if (A.tag !== 1) throw Error(s(309));
          var w = A.stateNode;
        }
        if (!w) throw Error(s(147, f));
        var I = w,
          F = "" + f;
        return h !== null &&
          h.ref !== null &&
          typeof h.ref == "function" &&
          h.ref._stringRef === F
          ? h.ref
          : ((h = function (re) {
              var me = I.refs;
              me === xM && (me = I.refs = {}),
                re === null ? delete me[F] : (me[F] = re);
            }),
            (h._stringRef = F),
            h);
      }
      if (typeof f != "string") throw Error(s(284));
      if (!A._owner) throw Error(s(290, f));
    }
    return f;
  }
  function im(f, h) {
    throw (
      ((f = Object.prototype.toString.call(h)),
      Error(
        s(
          31,
          f === "[object Object]"
            ? "object with keys {" + Object.keys(h).join(", ") + "}"
            : f
        )
      ))
    );
  }
  function CM(f) {
    var h = f._init;
    return h(f._payload);
  }
  function TM(f) {
    function h(Pe, xe) {
      if (f) {
        var Ne = Pe.deletions;
        Ne === null ? ((Pe.deletions = [xe]), (Pe.flags |= 16)) : Ne.push(xe);
      }
    }
    function A(Pe, xe) {
      if (!f) return null;
      for (; xe !== null; ) h(Pe, xe), (xe = xe.sibling);
      return null;
    }
    function w(Pe, xe) {
      for (Pe = new Map(); xe !== null; )
        xe.key !== null ? Pe.set(xe.key, xe) : Pe.set(xe.index, xe),
          (xe = xe.sibling);
      return Pe;
    }
    function I(Pe, xe) {
      return (Pe = ya(Pe, xe)), (Pe.index = 0), (Pe.sibling = null), Pe;
    }
    function F(Pe, xe, Ne) {
      return (
        (Pe.index = Ne),
        f
          ? ((Ne = Pe.alternate),
            Ne !== null
              ? ((Ne = Ne.index), Ne < xe ? ((Pe.flags |= 2), xe) : Ne)
              : ((Pe.flags |= 2), xe))
          : ((Pe.flags |= 1048576), xe)
      );
    }
    function re(Pe) {
      return f && Pe.alternate === null && (Pe.flags |= 2), Pe;
    }
    function me(Pe, xe, Ne, rt) {
      return xe === null || xe.tag !== 6
        ? ((xe = e1(Ne, Pe.mode, rt)), (xe.return = Pe), xe)
        : ((xe = I(xe, Ne)), (xe.return = Pe), xe);
    }
    function Ue(Pe, xe, Ne, rt) {
      var mt = Ne.type;
      return mt === u
        ? ut(Pe, xe, Ne.props.children, rt, Ne.key)
        : xe !== null &&
          (xe.elementType === mt ||
            (typeof mt == "object" &&
              mt !== null &&
              mt.$$typeof === S &&
              CM(mt) === xe.type))
        ? ((rt = I(xe, Ne.props)),
          (rt.ref = nd(Pe, xe, Ne)),
          (rt.return = Pe),
          rt)
        : ((rt = Dm(Ne.type, Ne.key, Ne.props, null, Pe.mode, rt)),
          (rt.ref = nd(Pe, xe, Ne)),
          (rt.return = Pe),
          rt);
    }
    function Ke(Pe, xe, Ne, rt) {
      return xe === null ||
        xe.tag !== 4 ||
        xe.stateNode.containerInfo !== Ne.containerInfo ||
        xe.stateNode.implementation !== Ne.implementation
        ? ((xe = t1(Ne, Pe.mode, rt)), (xe.return = Pe), xe)
        : ((xe = I(xe, Ne.children || [])), (xe.return = Pe), xe);
    }
    function ut(Pe, xe, Ne, rt, mt) {
      return xe === null || xe.tag !== 7
        ? ((xe = Tl(Ne, Pe.mode, rt, mt)), (xe.return = Pe), xe)
        : ((xe = I(xe, Ne)), (xe.return = Pe), xe);
    }
    function Pt(Pe, xe, Ne) {
      if ((typeof xe == "string" && xe !== "") || typeof xe == "number")
        return (xe = e1("" + xe, Pe.mode, Ne)), (xe.return = Pe), xe;
      if (typeof xe == "object" && xe !== null) {
        switch (xe.$$typeof) {
          case l:
            return (
              (Ne = Dm(xe.type, xe.key, xe.props, null, Pe.mode, Ne)),
              (Ne.ref = nd(Pe, null, xe)),
              (Ne.return = Pe),
              Ne
            );
          case c:
            return (xe = t1(xe, Pe.mode, Ne)), (xe.return = Pe), xe;
          case S:
            var rt = xe._init;
            return Pt(Pe, rt(xe._payload), Ne);
        }
        if (V(xe) || M(xe))
          return (xe = Tl(xe, Pe.mode, Ne, null)), (xe.return = Pe), xe;
        im(Pe, xe);
      }
      return null;
    }
    function St(Pe, xe, Ne, rt) {
      var mt = xe !== null ? xe.key : null;
      if ((typeof Ne == "string" && Ne !== "") || typeof Ne == "number")
        return mt !== null ? null : me(Pe, xe, "" + Ne, rt);
      if (typeof Ne == "object" && Ne !== null) {
        switch (Ne.$$typeof) {
          case l:
            return Ne.key === mt ? Ue(Pe, xe, Ne, rt) : null;
          case c:
            return Ne.key === mt ? Ke(Pe, xe, Ne, rt) : null;
          case S:
            return (mt = Ne._init), St(Pe, xe, mt(Ne._payload), rt);
        }
        if (V(Ne) || M(Ne))
          return mt !== null ? null : ut(Pe, xe, Ne, rt, null);
        im(Pe, Ne);
      }
      return null;
    }
    function fn(Pe, xe, Ne, rt, mt) {
      if ((typeof rt == "string" && rt !== "") || typeof rt == "number")
        return (Pe = Pe.get(Ne) || null), me(xe, Pe, "" + rt, mt);
      if (typeof rt == "object" && rt !== null) {
        switch (rt.$$typeof) {
          case l:
            return (
              (Pe = Pe.get(rt.key === null ? Ne : rt.key) || null),
              Ue(xe, Pe, rt, mt)
            );
          case c:
            return (
              (Pe = Pe.get(rt.key === null ? Ne : rt.key) || null),
              Ke(xe, Pe, rt, mt)
            );
          case S:
            var Ft = rt._init;
            return fn(Pe, xe, Ne, Ft(rt._payload), mt);
        }
        if (V(rt) || M(rt))
          return (Pe = Pe.get(Ne) || null), ut(xe, Pe, rt, mt, null);
        im(xe, rt);
      }
      return null;
    }
    function gt(Pe, xe, Ne, rt) {
      for (
        var mt = null, Ft = null, It = xe, Zt = (xe = 0), mr = null;
        It !== null && Zt < Ne.length;
        Zt++
      ) {
        It.index > Zt ? ((mr = It), (It = null)) : (mr = It.sibling);
        var Jt = St(Pe, It, Ne[Zt], rt);
        if (Jt === null) {
          It === null && (It = mr);
          break;
        }
        f && It && Jt.alternate === null && h(Pe, It),
          (xe = F(Jt, xe, Zt)),
          Ft === null ? (mt = Jt) : (Ft.sibling = Jt),
          (Ft = Jt),
          (It = mr);
      }
      if (Zt === Ne.length) return A(Pe, It), xn && Sl(Pe, Zt), mt;
      if (It === null) {
        for (; Zt < Ne.length; Zt++)
          (It = Pt(Pe, Ne[Zt], rt)),
            It !== null &&
              ((xe = F(It, xe, Zt)),
              Ft === null ? (mt = It) : (Ft.sibling = It),
              (Ft = It));
        return xn && Sl(Pe, Zt), mt;
      }
      for (It = w(Pe, It); Zt < Ne.length; Zt++)
        (mr = fn(It, Pe, Zt, Ne[Zt], rt)),
          mr !== null &&
            (f &&
              mr.alternate !== null &&
              It.delete(mr.key === null ? Zt : mr.key),
            (xe = F(mr, xe, Zt)),
            Ft === null ? (mt = mr) : (Ft.sibling = mr),
            (Ft = mr));
      return (
        f &&
          It.forEach(function (xa) {
            return h(Pe, xa);
          }),
        xn && Sl(Pe, Zt),
        mt
      );
    }
    function Ur(Pe, xe, Ne, rt) {
      var mt = M(Ne);
      if (typeof mt != "function") throw Error(s(150));
      if (((Ne = mt.call(Ne)), Ne == null)) throw Error(s(151));
      for (
        var Ft = (mt = null), It = xe, Zt = (xe = 0), mr = null, Jt = Ne.next();
        It !== null && !Jt.done;
        Zt++, Jt = Ne.next()
      ) {
        It.index > Zt ? ((mr = It), (It = null)) : (mr = It.sibling);
        var xa = St(Pe, It, Jt.value, rt);
        if (xa === null) {
          It === null && (It = mr);
          break;
        }
        f && It && xa.alternate === null && h(Pe, It),
          (xe = F(xa, xe, Zt)),
          Ft === null ? (mt = xa) : (Ft.sibling = xa),
          (Ft = xa),
          (It = mr);
      }
      if (Jt.done) return A(Pe, It), xn && Sl(Pe, Zt), mt;
      if (It === null) {
        for (; !Jt.done; Zt++, Jt = Ne.next())
          (Jt = Pt(Pe, Jt.value, rt)),
            Jt !== null &&
              ((xe = F(Jt, xe, Zt)),
              Ft === null ? (mt = Jt) : (Ft.sibling = Jt),
              (Ft = Jt));
        return xn && Sl(Pe, Zt), mt;
      }
      for (It = w(Pe, It); !Jt.done; Zt++, Jt = Ne.next())
        (Jt = fn(It, Pe, Zt, Jt.value, rt)),
          Jt !== null &&
            (f &&
              Jt.alternate !== null &&
              It.delete(Jt.key === null ? Zt : Jt.key),
            (xe = F(Jt, xe, Zt)),
            Ft === null ? (mt = Jt) : (Ft.sibling = Jt),
            (Ft = Jt));
      return (
        f &&
          It.forEach(function (pk) {
            return h(Pe, pk);
          }),
        xn && Sl(Pe, Zt),
        mt
      );
    }
    function so(Pe, xe, Ne, rt) {
      if (
        (typeof Ne == "object" &&
          Ne !== null &&
          Ne.type === u &&
          Ne.key === null &&
          (Ne = Ne.props.children),
        typeof Ne == "object" && Ne !== null)
      ) {
        switch (Ne.$$typeof) {
          case l:
            e: {
              for (var mt = Ne.key, Ft = xe; Ft !== null; ) {
                if (Ft.key === mt) {
                  if (((mt = Ne.type), mt === u)) {
                    if (Ft.tag === 7) {
                      A(Pe, Ft.sibling),
                        (xe = I(Ft, Ne.props.children)),
                        (xe.return = Pe),
                        (Pe = xe);
                      break e;
                    }
                  } else if (
                    Ft.elementType === mt ||
                    (typeof mt == "object" &&
                      mt !== null &&
                      mt.$$typeof === S &&
                      CM(mt) === Ft.type)
                  ) {
                    A(Pe, Ft.sibling),
                      (xe = I(Ft, Ne.props)),
                      (xe.ref = nd(Pe, Ft, Ne)),
                      (xe.return = Pe),
                      (Pe = xe);
                    break e;
                  }
                  A(Pe, Ft);
                  break;
                } else h(Pe, Ft);
                Ft = Ft.sibling;
              }
              Ne.type === u
                ? ((xe = Tl(Ne.props.children, Pe.mode, rt, Ne.key)),
                  (xe.return = Pe),
                  (Pe = xe))
                : ((rt = Dm(Ne.type, Ne.key, Ne.props, null, Pe.mode, rt)),
                  (rt.ref = nd(Pe, xe, Ne)),
                  (rt.return = Pe),
                  (Pe = rt));
            }
            return re(Pe);
          case c:
            e: {
              for (Ft = Ne.key; xe !== null; ) {
                if (xe.key === Ft)
                  if (
                    xe.tag === 4 &&
                    xe.stateNode.containerInfo === Ne.containerInfo &&
                    xe.stateNode.implementation === Ne.implementation
                  ) {
                    A(Pe, xe.sibling),
                      (xe = I(xe, Ne.children || [])),
                      (xe.return = Pe),
                      (Pe = xe);
                    break e;
                  } else {
                    A(Pe, xe);
                    break;
                  }
                else h(Pe, xe);
                xe = xe.sibling;
              }
              (xe = t1(Ne, Pe.mode, rt)), (xe.return = Pe), (Pe = xe);
            }
            return re(Pe);
          case S:
            return (Ft = Ne._init), so(Pe, xe, Ft(Ne._payload), rt);
        }
        if (V(Ne)) return gt(Pe, xe, Ne, rt);
        if (M(Ne)) return Ur(Pe, xe, Ne, rt);
        im(Pe, Ne);
      }
      return (typeof Ne == "string" && Ne !== "") || typeof Ne == "number"
        ? ((Ne = "" + Ne),
          xe !== null && xe.tag === 6
            ? (A(Pe, xe.sibling), (xe = I(xe, Ne)), (xe.return = Pe), (Pe = xe))
            : (A(Pe, xe),
              (xe = e1(Ne, Pe.mode, rt)),
              (xe.return = Pe),
              (Pe = xe)),
          re(Pe))
        : A(Pe, xe);
    }
    return so;
  }
  var qc = TM(!0),
    RM = TM(!1),
    rd = {},
    no = vt(rd),
    id = vt(rd),
    Kc = vt(rd);
  function es(f) {
    if (f === rd) throw Error(s(174));
    return f;
  }
  function yx(f, h) {
    _t(Kc, h), _t(id, f), _t(no, rd), (f = Y(h)), Wt(no), _t(no, f);
  }
  function Zc() {
    Wt(no), Wt(id), Wt(Kc);
  }
  function PM(f) {
    var h = es(Kc.current),
      A = es(no.current);
    (h = U(A, f.type, h)), A !== h && (_t(id, f), _t(no, h));
  }
  function xx(f) {
    id.current === f && (Wt(no), Wt(id));
  }
  var bn = vt(0);
  function om(f) {
    for (var h = f; h !== null; ) {
      if (h.tag === 13) {
        var A = h.memoizedState;
        if (A !== null && ((A = A.dehydrated), A === null || cr(A) || $t(A)))
          return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if (h.flags & 128) return h;
      } else if (h.child !== null) {
        (h.child.return = h), (h = h.child);
        continue;
      }
      if (h === f) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === f) return null;
        h = h.return;
      }
      (h.sibling.return = h.return), (h = h.sibling);
    }
    return null;
  }
  var _x = [];
  function Sx() {
    for (var f = 0; f < _x.length; f++) {
      var h = _x[f];
      te
        ? (h._workInProgressVersionPrimary = null)
        : (h._workInProgressVersionSecondary = null);
    }
    _x.length = 0;
  }
  var sm = a.ReactCurrentDispatcher,
    ro = a.ReactCurrentBatchConfig,
    Jc = 0,
    On = null,
    Nr = null,
    pr = null,
    am = !1,
    od = !1,
    sd = 0,
    z4 = 0;
  function Dr() {
    throw Error(s(321));
  }
  function Ax(f, h) {
    if (h === null) return !1;
    for (var A = 0; A < h.length && A < f.length; A++)
      if (!Ii(f[A], h[A])) return !1;
    return !0;
  }
  function bx(f, h, A, w, I, F) {
    if (
      ((Jc = F),
      (On = h),
      (h.memoizedState = null),
      (h.updateQueue = null),
      (h.lanes = 0),
      (sm.current = f === null || f.memoizedState === null ? G4 : W4),
      (f = A(w, I)),
      od)
    ) {
      F = 0;
      do {
        if (((od = !1), (sd = 0), 25 <= F)) throw Error(s(301));
        (F += 1),
          (pr = Nr = null),
          (h.updateQueue = null),
          (sm.current = j4),
          (f = A(w, I));
      } while (od);
    }
    if (
      ((sm.current = dm),
      (h = Nr !== null && Nr.next !== null),
      (Jc = 0),
      (pr = Nr = On = null),
      (am = !1),
      h)
    )
      throw Error(s(300));
    return f;
  }
  function wx() {
    var f = sd !== 0;
    return (sd = 0), f;
  }
  function Ts() {
    var f = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return pr === null ? (On.memoizedState = pr = f) : (pr = pr.next = f), pr;
  }
  function ts() {
    if (Nr === null) {
      var f = On.alternate;
      f = f !== null ? f.memoizedState : null;
    } else f = Nr.next;
    var h = pr === null ? On.memoizedState : pr.next;
    if (h !== null) (pr = h), (Nr = f);
    else {
      if (f === null) throw Error(s(310));
      (Nr = f),
        (f = {
          memoizedState: Nr.memoizedState,
          baseState: Nr.baseState,
          baseQueue: Nr.baseQueue,
          queue: Nr.queue,
          next: null,
        }),
        pr === null ? (On.memoizedState = pr = f) : (pr = pr.next = f);
    }
    return pr;
  }
  function Al(f, h) {
    return typeof h == "function" ? h(f) : h;
  }
  function lm(f) {
    var h = ts(),
      A = h.queue;
    if (A === null) throw Error(s(311));
    A.lastRenderedReducer = f;
    var w = Nr,
      I = w.baseQueue,
      F = A.pending;
    if (F !== null) {
      if (I !== null) {
        var re = I.next;
        (I.next = F.next), (F.next = re);
      }
      (w.baseQueue = I = F), (A.pending = null);
    }
    if (I !== null) {
      (F = I.next), (w = w.baseState);
      var me = (re = null),
        Ue = null,
        Ke = F;
      do {
        var ut = Ke.lane;
        if ((Jc & ut) === ut)
          Ue !== null &&
            (Ue = Ue.next =
              {
                lane: 0,
                action: Ke.action,
                hasEagerState: Ke.hasEagerState,
                eagerState: Ke.eagerState,
                next: null,
              }),
            (w = Ke.hasEagerState ? Ke.eagerState : f(w, Ke.action));
        else {
          var Pt = {
            lane: ut,
            action: Ke.action,
            hasEagerState: Ke.hasEagerState,
            eagerState: Ke.eagerState,
            next: null,
          };
          Ue === null ? ((me = Ue = Pt), (re = w)) : (Ue = Ue.next = Pt),
            (On.lanes |= ut),
            (eu |= ut);
        }
        Ke = Ke.next;
      } while (Ke !== null && Ke !== F);
      Ue === null ? (re = w) : (Ue.next = me),
        Ii(w, h.memoizedState) || (Di = !0),
        (h.memoizedState = w),
        (h.baseState = re),
        (h.baseQueue = Ue),
        (A.lastRenderedState = w);
    }
    if (((f = A.interleaved), f !== null)) {
      I = f;
      do (F = I.lane), (On.lanes |= F), (eu |= F), (I = I.next);
      while (I !== f);
    } else I === null && (A.lanes = 0);
    return [h.memoizedState, A.dispatch];
  }
  function cm(f) {
    var h = ts(),
      A = h.queue;
    if (A === null) throw Error(s(311));
    A.lastRenderedReducer = f;
    var w = A.dispatch,
      I = A.pending,
      F = h.memoizedState;
    if (I !== null) {
      A.pending = null;
      var re = (I = I.next);
      do (F = f(F, re.action)), (re = re.next);
      while (re !== I);
      Ii(F, h.memoizedState) || (Di = !0),
        (h.memoizedState = F),
        h.baseQueue === null && (h.baseState = F),
        (A.lastRenderedState = F);
    }
    return [F, w];
  }
  function IM() {}
  function LM(f, h) {
    var A = On,
      w = ts(),
      I = h(),
      F = !Ii(w.memoizedState, I);
    if (
      (F && ((w.memoizedState = I), (Di = !0)),
      (w = w.queue),
      ld(DM.bind(null, A, w, f), [f]),
      w.getSnapshot !== h || F || (pr !== null && pr.memoizedState.tag & 1))
    ) {
      if (
        ((A.flags |= 2048),
        ad(9, NM.bind(null, A, w, I, h), void 0, null),
        Yn === null)
      )
        throw Error(s(349));
      Jc & 30 || OM(A, h, I);
    }
    return I;
  }
  function OM(f, h, A) {
    (f.flags |= 16384),
      (f = { getSnapshot: h, value: A }),
      (h = On.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (On.updateQueue = h),
          (h.stores = [f]))
        : ((A = h.stores), A === null ? (h.stores = [f]) : A.push(f));
  }
  function NM(f, h, A, w) {
    (h.value = A), (h.getSnapshot = w), FM(h) && io(f, 1, -1);
  }
  function DM(f, h, A) {
    return A(function () {
      FM(h) && io(f, 1, -1);
    });
  }
  function FM(f) {
    var h = f.getSnapshot;
    f = f.value;
    try {
      var A = h();
      return !Ii(f, A);
    } catch {
      return !0;
    }
  }
  function Ex(f) {
    var h = Ts();
    return (
      typeof f == "function" && (f = f()),
      (h.memoizedState = h.baseState = f),
      (f = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Al,
        lastRenderedState: f,
      }),
      (h.queue = f),
      (f = f.dispatch = V4.bind(null, On, f)),
      [h.memoizedState, f]
    );
  }
  function ad(f, h, A, w) {
    return (
      (f = { tag: f, create: h, destroy: A, deps: w, next: null }),
      (h = On.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (On.updateQueue = h),
          (h.lastEffect = f.next = f))
        : ((A = h.lastEffect),
          A === null
            ? (h.lastEffect = f.next = f)
            : ((w = A.next), (A.next = f), (f.next = w), (h.lastEffect = f))),
      f
    );
  }
  function UM() {
    return ts().memoizedState;
  }
  function um(f, h, A, w) {
    var I = Ts();
    (On.flags |= f),
      (I.memoizedState = ad(1 | h, A, void 0, w === void 0 ? null : w));
  }
  function fm(f, h, A, w) {
    var I = ts();
    w = w === void 0 ? null : w;
    var F = void 0;
    if (Nr !== null) {
      var re = Nr.memoizedState;
      if (((F = re.destroy), w !== null && Ax(w, re.deps))) {
        I.memoizedState = ad(h, A, F, w);
        return;
      }
    }
    (On.flags |= f), (I.memoizedState = ad(1 | h, A, F, w));
  }
  function Mx(f, h) {
    return um(8390656, 8, f, h);
  }
  function ld(f, h) {
    return fm(2048, 8, f, h);
  }
  function kM(f, h) {
    return fm(4, 2, f, h);
  }
  function zM(f, h) {
    return fm(4, 4, f, h);
  }
  function BM(f, h) {
    if (typeof h == "function")
      return (
        (f = f()),
        h(f),
        function () {
          h(null);
        }
      );
    if (h != null)
      return (
        (f = f()),
        (h.current = f),
        function () {
          h.current = null;
        }
      );
  }
  function HM(f, h, A) {
    return (
      (A = A != null ? A.concat([f]) : null), fm(4, 4, BM.bind(null, h, f), A)
    );
  }
  function Cx() {}
  function VM(f, h) {
    var A = ts();
    h = h === void 0 ? null : h;
    var w = A.memoizedState;
    return w !== null && h !== null && Ax(h, w[1])
      ? w[0]
      : ((A.memoizedState = [f, h]), f);
  }
  function GM(f, h) {
    var A = ts();
    h = h === void 0 ? null : h;
    var w = A.memoizedState;
    return w !== null && h !== null && Ax(h, w[1])
      ? w[0]
      : ((f = f()), (A.memoizedState = [f, h]), f);
  }
  function B4(f, h) {
    var A = Ht;
    (Ht = A !== 0 && 4 > A ? A : 4), f(!0);
    var w = ro.transition;
    ro.transition = {};
    try {
      f(!1), h();
    } finally {
      (Ht = A), (ro.transition = w);
    }
  }
  function WM() {
    return ts().memoizedState;
  }
  function H4(f, h, A) {
    var w = ga(f);
    (A = {
      lane: w,
      action: A,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      jM(f)
        ? $M(h, A)
        : (XM(f, h, A),
          (A = ni()),
          (f = io(f, w, A)),
          f !== null && YM(f, h, w));
  }
  function V4(f, h, A) {
    var w = ga(f),
      I = {
        lane: w,
        action: A,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (jM(f)) $M(h, I);
    else {
      XM(f, h, I);
      var F = f.alternate;
      if (
        f.lanes === 0 &&
        (F === null || F.lanes === 0) &&
        ((F = h.lastRenderedReducer), F !== null)
      )
        try {
          var re = h.lastRenderedState,
            me = F(re, A);
          if (((I.hasEagerState = !0), (I.eagerState = me), Ii(me, re))) return;
        } catch {
        } finally {
        }
      (A = ni()), (f = io(f, w, A)), f !== null && YM(f, h, w);
    }
  }
  function jM(f) {
    var h = f.alternate;
    return f === On || (h !== null && h === On);
  }
  function $M(f, h) {
    od = am = !0;
    var A = f.pending;
    A === null ? (h.next = h) : ((h.next = A.next), (A.next = h)),
      (f.pending = h);
  }
  function XM(f, h, A) {
    Yn !== null && f.mode & 1 && !(kt & 2)
      ? ((f = h.interleaved),
        f === null
          ? ((A.next = A), Li === null ? (Li = [h]) : Li.push(h))
          : ((A.next = f.next), (f.next = A)),
        (h.interleaved = A))
      : ((f = h.pending),
        f === null ? (A.next = A) : ((A.next = f.next), (f.next = A)),
        (h.pending = A));
  }
  function YM(f, h, A) {
    if (A & 4194240) {
      var w = h.lanes;
      (w &= f.pendingLanes), (A |= w), (h.lanes = A), Jo(f, A);
    }
  }
  var dm = {
      readContext: Hn,
      useCallback: Dr,
      useContext: Dr,
      useEffect: Dr,
      useImperativeHandle: Dr,
      useInsertionEffect: Dr,
      useLayoutEffect: Dr,
      useMemo: Dr,
      useReducer: Dr,
      useRef: Dr,
      useState: Dr,
      useDebugValue: Dr,
      useDeferredValue: Dr,
      useTransition: Dr,
      useMutableSource: Dr,
      useSyncExternalStore: Dr,
      useId: Dr,
      unstable_isNewReconciler: !1,
    },
    G4 = {
      readContext: Hn,
      useCallback: function (f, h) {
        return (Ts().memoizedState = [f, h === void 0 ? null : h]), f;
      },
      useContext: Hn,
      useEffect: Mx,
      useImperativeHandle: function (f, h, A) {
        return (
          (A = A != null ? A.concat([f]) : null),
          um(4194308, 4, BM.bind(null, h, f), A)
        );
      },
      useLayoutEffect: function (f, h) {
        return um(4194308, 4, f, h);
      },
      useInsertionEffect: function (f, h) {
        return um(4, 2, f, h);
      },
      useMemo: function (f, h) {
        var A = Ts();
        return (
          (h = h === void 0 ? null : h),
          (f = f()),
          (A.memoizedState = [f, h]),
          f
        );
      },
      useReducer: function (f, h, A) {
        var w = Ts();
        return (
          (h = A !== void 0 ? A(h) : h),
          (w.memoizedState = w.baseState = h),
          (f = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: f,
            lastRenderedState: h,
          }),
          (w.queue = f),
          (f = f.dispatch = H4.bind(null, On, f)),
          [w.memoizedState, f]
        );
      },
      useRef: function (f) {
        var h = Ts();
        return (f = { current: f }), (h.memoizedState = f);
      },
      useState: Ex,
      useDebugValue: Cx,
      useDeferredValue: function (f) {
        var h = Ex(f),
          A = h[0],
          w = h[1];
        return (
          Mx(
            function () {
              var I = ro.transition;
              ro.transition = {};
              try {
                w(f);
              } finally {
                ro.transition = I;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = Ex(!1),
          h = f[0];
        return (f = B4.bind(null, f[1])), (Ts().memoizedState = f), [h, f];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (f, h, A) {
        var w = On,
          I = Ts();
        if (xn) {
          if (A === void 0) throw Error(s(407));
          A = A();
        } else {
          if (((A = h()), Yn === null)) throw Error(s(349));
          Jc & 30 || OM(w, h, A);
        }
        I.memoizedState = A;
        var F = { value: A, getSnapshot: h };
        return (
          (I.queue = F),
          Mx(DM.bind(null, w, F, f), [f]),
          (w.flags |= 2048),
          ad(9, NM.bind(null, w, F, A, h), void 0, null),
          A
        );
      },
      useId: function () {
        var f = Ts(),
          h = Yn.identifierPrefix;
        if (xn) {
          var A = Cs,
            w = Ms;
          (A = (w & ~(1 << (32 - Ri(w) - 1))).toString(32) + A),
            (h = ":" + h + "R" + A),
            (A = sd++),
            0 < A && (h += "H" + A.toString(32)),
            (h += ":");
        } else (A = z4++), (h = ":" + h + "r" + A.toString(32) + ":");
        return (f.memoizedState = h);
      },
      unstable_isNewReconciler: !1,
    },
    W4 = {
      readContext: Hn,
      useCallback: VM,
      useContext: Hn,
      useEffect: ld,
      useImperativeHandle: HM,
      useInsertionEffect: kM,
      useLayoutEffect: zM,
      useMemo: GM,
      useReducer: lm,
      useRef: UM,
      useState: function () {
        return lm(Al);
      },
      useDebugValue: Cx,
      useDeferredValue: function (f) {
        var h = lm(Al),
          A = h[0],
          w = h[1];
        return (
          ld(
            function () {
              var I = ro.transition;
              ro.transition = {};
              try {
                w(f);
              } finally {
                ro.transition = I;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = lm(Al)[0],
          h = ts().memoizedState;
        return [f, h];
      },
      useMutableSource: IM,
      useSyncExternalStore: LM,
      useId: WM,
      unstable_isNewReconciler: !1,
    },
    j4 = {
      readContext: Hn,
      useCallback: VM,
      useContext: Hn,
      useEffect: ld,
      useImperativeHandle: HM,
      useInsertionEffect: kM,
      useLayoutEffect: zM,
      useMemo: GM,
      useReducer: cm,
      useRef: UM,
      useState: function () {
        return cm(Al);
      },
      useDebugValue: Cx,
      useDeferredValue: function (f) {
        var h = cm(Al),
          A = h[0],
          w = h[1];
        return (
          ld(
            function () {
              var I = ro.transition;
              ro.transition = {};
              try {
                w(f);
              } finally {
                ro.transition = I;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = cm(Al)[0],
          h = ts().memoizedState;
        return [f, h];
      },
      useMutableSource: IM,
      useSyncExternalStore: LM,
      useId: WM,
      unstable_isNewReconciler: !1,
    };
  function Tx(f, h) {
    try {
      var A = "",
        w = h;
      do (A += xl(w)), (w = w.return);
      while (w);
      var I = A;
    } catch (F) {
      I =
        `
Error generating stack: ` +
        F.message +
        `
` +
        F.stack;
    }
    return { value: f, source: h, stack: I };
  }
  function Rx(f, h) {
    try {
      console.error(h.value);
    } catch (A) {
      setTimeout(function () {
        throw A;
      });
    }
  }
  var $4 = typeof WeakMap == "function" ? WeakMap : Map;
  function qM(f, h, A) {
    (A = Es(-1, A)), (A.tag = 3), (A.payload = { element: null });
    var w = h.value;
    return (
      (A.callback = function () {
        Tm || ((Tm = !0), (Xx = w)), Rx(f, h);
      }),
      A
    );
  }
  function KM(f, h, A) {
    (A = Es(-1, A)), (A.tag = 3);
    var w = f.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var I = h.value;
      (A.payload = function () {
        return w(I);
      }),
        (A.callback = function () {
          Rx(f, h);
        });
    }
    var F = f.stateNode;
    return (
      F !== null &&
        typeof F.componentDidCatch == "function" &&
        (A.callback = function () {
          Rx(f, h),
            typeof w != "function" &&
              (pa === null ? (pa = new Set([this])) : pa.add(this));
          var re = h.stack;
          this.componentDidCatch(h.value, {
            componentStack: re !== null ? re : "",
          });
        }),
      A
    );
  }
  function ZM(f, h, A) {
    var w = f.pingCache;
    if (w === null) {
      w = f.pingCache = new $4();
      var I = new Set();
      w.set(h, I);
    } else (I = w.get(h)), I === void 0 && ((I = new Set()), w.set(h, I));
    I.has(A) || (I.add(A), (f = sk.bind(null, f, h, A)), h.then(f, f));
  }
  function JM(f) {
    do {
      var h;
      if (
        ((h = f.tag === 13) &&
          ((h = f.memoizedState),
          (h = h !== null ? h.dehydrated !== null : !0)),
        h)
      )
        return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function QM(f, h, A, w, I) {
    return f.mode & 1
      ? ((f.flags |= 65536), (f.lanes = I), f)
      : (f === h
          ? (f.flags |= 65536)
          : ((f.flags |= 128),
            (A.flags |= 131072),
            (A.flags &= -52805),
            A.tag === 1 &&
              (A.alternate === null
                ? (A.tag = 17)
                : ((h = Es(-1, 1)), (h.tag = 2), ha(A, h))),
            (A.lanes |= 1)),
        f);
  }
  function ns(f) {
    f.flags |= 4;
  }
  function eC(f, h) {
    if (f !== null && f.child === h.child) return !0;
    if (h.flags & 16) return !1;
    for (f = h.child; f !== null; ) {
      if (f.flags & 12854 || f.subtreeFlags & 12854) return !1;
      f = f.sibling;
    }
    return !0;
  }
  var cd, ud, hm, pm;
  if (ge)
    (cd = function (f, h) {
      for (var A = h.child; A !== null; ) {
        if (A.tag === 5 || A.tag === 6) q(f, A.stateNode);
        else if (A.tag !== 4 && A.child !== null) {
          (A.child.return = A), (A = A.child);
          continue;
        }
        if (A === h) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === h) return;
          A = A.return;
        }
        (A.sibling.return = A.return), (A = A.sibling);
      }
    }),
      (ud = function () {}),
      (hm = function (f, h, A, w, I) {
        if (((f = f.memoizedProps), f !== w)) {
          var F = h.stateNode,
            re = es(no.current);
          (A = H(F, A, f, w, I, re)), (h.updateQueue = A) && ns(h);
        }
      }),
      (pm = function (f, h, A, w) {
        A !== w && ns(h);
      });
  else if (ie) {
    cd = function (f, h, A, w) {
      for (var I = h.child; I !== null; ) {
        if (I.tag === 5) {
          var F = I.stateNode;
          A && w && (F = Mt(F, I.type, I.memoizedProps, I)), q(f, F);
        } else if (I.tag === 6)
          (F = I.stateNode), A && w && (F = Rt(F, I.memoizedProps, I)), q(f, F);
        else if (I.tag !== 4) {
          if (I.tag === 22 && I.memoizedState !== null)
            (F = I.child), F !== null && (F.return = I), cd(f, I, !0, !0);
          else if (I.child !== null) {
            (I.child.return = I), (I = I.child);
            continue;
          }
        }
        if (I === h) break;
        for (; I.sibling === null; ) {
          if (I.return === null || I.return === h) return;
          I = I.return;
        }
        (I.sibling.return = I.return), (I = I.sibling);
      }
    };
    var tC = function (f, h, A, w) {
      for (var I = h.child; I !== null; ) {
        if (I.tag === 5) {
          var F = I.stateNode;
          A && w && (F = Mt(F, I.type, I.memoizedProps, I)), ht(f, F);
        } else if (I.tag === 6)
          (F = I.stateNode),
            A && w && (F = Rt(F, I.memoizedProps, I)),
            ht(f, F);
        else if (I.tag !== 4) {
          if (I.tag === 22 && I.memoizedState !== null)
            (F = I.child), F !== null && (F.return = I), tC(f, I, !0, !0);
          else if (I.child !== null) {
            (I.child.return = I), (I = I.child);
            continue;
          }
        }
        if (I === h) break;
        for (; I.sibling === null; ) {
          if (I.return === null || I.return === h) return;
          I = I.return;
        }
        (I.sibling.return = I.return), (I = I.sibling);
      }
    };
    (ud = function (f, h) {
      var A = h.stateNode;
      if (!eC(f, h)) {
        f = A.containerInfo;
        var w = st(f);
        tC(w, h, !1, !1), (A.pendingChildren = w), ns(h), pt(f, w);
      }
    }),
      (hm = function (f, h, A, w, I) {
        var F = f.stateNode,
          re = f.memoizedProps;
        if ((f = eC(f, h)) && re === w) h.stateNode = F;
        else {
          var me = h.stateNode,
            Ue = es(no.current),
            Ke = null;
          re !== w && (Ke = H(me, A, re, w, I, Ue)),
            f && Ke === null
              ? (h.stateNode = F)
              : ((F = at(F, Ke, A, re, w, h, f, me)),
                Z(F, A, w, I, Ue) && ns(h),
                (h.stateNode = F),
                f ? ns(h) : cd(F, h, !1, !1));
        }
      }),
      (pm = function (f, h, A, w) {
        A !== w
          ? ((f = es(Kc.current)),
            (A = es(no.current)),
            (h.stateNode = ne(w, f, A, h)),
            ns(h))
          : (h.stateNode = f.stateNode);
      });
  } else (ud = function () {}), (hm = function () {}), (pm = function () {});
  function fd(f, h) {
    if (!xn)
      switch (f.tailMode) {
        case "hidden":
          h = f.tail;
          for (var A = null; h !== null; )
            h.alternate !== null && (A = h), (h = h.sibling);
          A === null ? (f.tail = null) : (A.sibling = null);
          break;
        case "collapsed":
          A = f.tail;
          for (var w = null; A !== null; )
            A.alternate !== null && (w = A), (A = A.sibling);
          w === null
            ? h || f.tail === null
              ? (f.tail = null)
              : (f.tail.sibling = null)
            : (w.sibling = null);
      }
  }
  function Fr(f) {
    var h = f.alternate !== null && f.alternate.child === f.child,
      A = 0,
      w = 0;
    if (h)
      for (var I = f.child; I !== null; )
        (A |= I.lanes | I.childLanes),
          (w |= I.subtreeFlags & 14680064),
          (w |= I.flags & 14680064),
          (I.return = f),
          (I = I.sibling);
    else
      for (I = f.child; I !== null; )
        (A |= I.lanes | I.childLanes),
          (w |= I.subtreeFlags),
          (w |= I.flags),
          (I.return = f),
          (I = I.sibling);
    return (f.subtreeFlags |= w), (f.childLanes = A), h;
  }
  function X4(f, h, A) {
    var w = h.pendingProps;
    switch ((px(h), h.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Fr(h), null;
      case 1:
        return un(h.type) && Kr(), Fr(h), null;
      case 3:
        return (
          (w = h.stateNode),
          Zc(),
          Wt(yn),
          Wt(Ln),
          Sx(),
          w.pendingContext &&
            ((w.context = w.pendingContext), (w.pendingContext = null)),
          (f === null || f.child === null) &&
            (td(h)
              ? ns(h)
              : f === null ||
                (f.memoizedState.isDehydrated && !(h.flags & 256)) ||
                ((h.flags |= 1024), Mo !== null && (Kx(Mo), (Mo = null)))),
          ud(f, h),
          Fr(h),
          null
        );
      case 5:
        xx(h), (A = es(Kc.current));
        var I = h.type;
        if (f !== null && h.stateNode != null)
          hm(f, h, I, w, A),
            f.ref !== h.ref && ((h.flags |= 512), (h.flags |= 2097152));
        else {
          if (!w) {
            if (h.stateNode === null) throw Error(s(166));
            return Fr(h), null;
          }
          if (((f = es(no.current)), td(h))) {
            if (!pe) throw Error(s(175));
            (f = br(h.stateNode, h.type, h.memoizedProps, A, f, h, !ed)),
              (h.updateQueue = f),
              f !== null && ns(h);
          } else {
            var F = B(I, w, A, f, h);
            cd(F, h, !1, !1), (h.stateNode = F), Z(F, I, w, A, f) && ns(h);
          }
          h.ref !== null && ((h.flags |= 512), (h.flags |= 2097152));
        }
        return Fr(h), null;
      case 6:
        if (f && h.stateNode != null) pm(f, h, f.memoizedProps, w);
        else {
          if (typeof w != "string" && h.stateNode === null) throw Error(s(166));
          if (((f = es(Kc.current)), (A = es(no.current)), td(h))) {
            if (!pe) throw Error(s(176));
            if (
              ((f = h.stateNode),
              (w = h.memoizedProps),
              (A = K(f, w, h, !ed)) && ((I = Oi), I !== null))
            )
              switch (((F = (I.mode & 1) !== 0), I.tag)) {
                case 3:
                  xt(I.stateNode.containerInfo, f, w, F);
                  break;
                case 5:
                  Ct(I.type, I.memoizedProps, I.stateNode, f, w, F);
              }
            A && ns(h);
          } else h.stateNode = ne(w, f, A, h);
        }
        return Fr(h), null;
      case 13:
        if (
          (Wt(bn),
          (w = h.memoizedState),
          xn && Ni !== null && h.mode & 1 && !(h.flags & 128))
        ) {
          for (f = Ni; f; ) f = fr(f);
          return Yc(), (h.flags |= 98560), h;
        }
        if (w !== null && w.dehydrated !== null) {
          if (((w = td(h)), f === null)) {
            if (!w) throw Error(s(318));
            if (!pe) throw Error(s(344));
            if (
              ((f = h.memoizedState),
              (f = f !== null ? f.dehydrated : null),
              !f)
            )
              throw Error(s(317));
            Se(f, h);
          } else
            Yc(), !(h.flags & 128) && (h.memoizedState = null), (h.flags |= 4);
          return Fr(h), null;
        }
        return (
          Mo !== null && (Kx(Mo), (Mo = null)),
          h.flags & 128
            ? ((h.lanes = A), h)
            : ((w = w !== null),
              (A = !1),
              f === null ? td(h) : (A = f.memoizedState !== null),
              w &&
                !A &&
                ((h.child.flags |= 8192),
                h.mode & 1 &&
                  (f === null || bn.current & 1 ? tr === 0 && (tr = 3) : Jx())),
              h.updateQueue !== null && (h.flags |= 4),
              Fr(h),
              null)
        );
      case 4:
        return (
          Zc(),
          ud(f, h),
          f === null && Ee(h.stateNode.containerInfo),
          Fr(h),
          null
        );
      case 10:
        return hr(h.type._context), Fr(h), null;
      case 17:
        return un(h.type) && Kr(), Fr(h), null;
      case 19:
        if ((Wt(bn), (I = h.memoizedState), I === null)) return Fr(h), null;
        if (((w = (h.flags & 128) !== 0), (F = I.rendering), F === null))
          if (w) fd(I, !1);
          else {
            if (tr !== 0 || (f !== null && f.flags & 128))
              for (f = h.child; f !== null; ) {
                if (((F = om(f)), F !== null)) {
                  for (
                    h.flags |= 128,
                      fd(I, !1),
                      f = F.updateQueue,
                      f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                      h.subtreeFlags = 0,
                      f = A,
                      w = h.child;
                    w !== null;

                  )
                    (A = w),
                      (I = f),
                      (A.flags &= 14680066),
                      (F = A.alternate),
                      F === null
                        ? ((A.childLanes = 0),
                          (A.lanes = I),
                          (A.child = null),
                          (A.subtreeFlags = 0),
                          (A.memoizedProps = null),
                          (A.memoizedState = null),
                          (A.updateQueue = null),
                          (A.dependencies = null),
                          (A.stateNode = null))
                        : ((A.childLanes = F.childLanes),
                          (A.lanes = F.lanes),
                          (A.child = F.child),
                          (A.subtreeFlags = 0),
                          (A.deletions = null),
                          (A.memoizedProps = F.memoizedProps),
                          (A.memoizedState = F.memoizedState),
                          (A.updateQueue = F.updateQueue),
                          (A.type = F.type),
                          (I = F.dependencies),
                          (A.dependencies =
                            I === null
                              ? null
                              : {
                                  lanes: I.lanes,
                                  firstContext: I.firstContext,
                                })),
                      (w = w.sibling);
                  return _t(bn, (bn.current & 1) | 2), h.child;
                }
                f = f.sibling;
              }
            I.tail !== null &&
              An() > $x &&
              ((h.flags |= 128), (w = !0), fd(I, !1), (h.lanes = 4194304));
          }
        else {
          if (!w)
            if (((f = om(F)), f !== null)) {
              if (
                ((h.flags |= 128),
                (w = !0),
                (f = f.updateQueue),
                f !== null && ((h.updateQueue = f), (h.flags |= 4)),
                fd(I, !0),
                I.tail === null &&
                  I.tailMode === "hidden" &&
                  !F.alternate &&
                  !xn)
              )
                return Fr(h), null;
            } else
              2 * An() - I.renderingStartTime > $x &&
                A !== 1073741824 &&
                ((h.flags |= 128), (w = !0), fd(I, !1), (h.lanes = 4194304));
          I.isBackwards
            ? ((F.sibling = h.child), (h.child = F))
            : ((f = I.last),
              f !== null ? (f.sibling = F) : (h.child = F),
              (I.last = F));
        }
        return I.tail !== null
          ? ((h = I.tail),
            (I.rendering = h),
            (I.tail = h.sibling),
            (I.renderingStartTime = An()),
            (h.sibling = null),
            (f = bn.current),
            _t(bn, w ? (f & 1) | 2 : f & 1),
            h)
          : (Fr(h), null);
      case 22:
      case 23:
        return (
          Zx(),
          (w = h.memoizedState !== null),
          f !== null && (f.memoizedState !== null) !== w && (h.flags |= 8192),
          w && h.mode & 1
            ? Fi & 1073741824 &&
              (Fr(h), ge && h.subtreeFlags & 6 && (h.flags |= 8192))
            : Fr(h),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(s(156, h.tag));
  }
  var Y4 = a.ReactCurrentOwner,
    Di = !1;
  function ti(f, h, A, w) {
    h.child = f === null ? RM(h, null, A, w) : qc(h, f.child, A, w);
  }
  function nC(f, h, A, w, I) {
    A = A.render;
    var F = h.ref;
    return (
      Bn(h, I),
      (w = bx(f, h, A, w, F, I)),
      (A = wx()),
      f !== null && !Di
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~I),
          Rs(f, h, I))
        : (xn && A && hx(h), (h.flags |= 1), ti(f, h, w, I), h.child)
    );
  }
  function rC(f, h, A, w, I) {
    if (f === null) {
      var F = A.type;
      return typeof F == "function" &&
        !Qx(F) &&
        F.defaultProps === void 0 &&
        A.compare === null &&
        A.defaultProps === void 0
        ? ((h.tag = 15), (h.type = F), iC(f, h, F, w, I))
        : ((f = Dm(A.type, null, w, h, h.mode, I)),
          (f.ref = h.ref),
          (f.return = h),
          (h.child = f));
    }
    if (((F = f.child), !(f.lanes & I))) {
      var re = F.memoizedProps;
      if (
        ((A = A.compare),
        (A = A !== null ? A : yl),
        A(re, w) && f.ref === h.ref)
      )
        return Rs(f, h, I);
    }
    return (
      (h.flags |= 1),
      (f = ya(F, w)),
      (f.ref = h.ref),
      (f.return = h),
      (h.child = f)
    );
  }
  function iC(f, h, A, w, I) {
    if (f !== null && yl(f.memoizedProps, w) && f.ref === h.ref)
      if (((Di = !1), (f.lanes & I) !== 0)) f.flags & 131072 && (Di = !0);
      else return (h.lanes = f.lanes), Rs(f, h, I);
    return Px(f, h, A, w, I);
  }
  function oC(f, h, A) {
    var w = h.pendingProps,
      I = w.children,
      F = f !== null ? f.memoizedState : null;
    if (w.mode === "hidden")
      if (!(h.mode & 1))
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          _t(Qc, Fi),
          (Fi |= A);
      else if (A & 1073741824)
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          (w = F !== null ? F.baseLanes : A),
          _t(Qc, Fi),
          (Fi |= w);
      else
        return (
          (f = F !== null ? F.baseLanes | A : A),
          (h.lanes = h.childLanes = 1073741824),
          (h.memoizedState = { baseLanes: f, cachePool: null }),
          (h.updateQueue = null),
          _t(Qc, Fi),
          (Fi |= f),
          null
        );
    else
      F !== null ? ((w = F.baseLanes | A), (h.memoizedState = null)) : (w = A),
        _t(Qc, Fi),
        (Fi |= w);
    return ti(f, h, I, A), h.child;
  }
  function sC(f, h) {
    var A = h.ref;
    ((f === null && A !== null) || (f !== null && f.ref !== A)) &&
      ((h.flags |= 512), (h.flags |= 2097152));
  }
  function Px(f, h, A, w, I) {
    var F = un(A) ? hi : Ln.current;
    return (
      (F = nn(h, F)),
      Bn(h, I),
      (A = bx(f, h, A, w, F, I)),
      (w = wx()),
      f !== null && !Di
        ? ((h.updateQueue = f.updateQueue),
          (h.flags &= -2053),
          (f.lanes &= ~I),
          Rs(f, h, I))
        : (xn && w && hx(h), (h.flags |= 1), ti(f, h, A, I), h.child)
    );
  }
  function aC(f, h, A, w, I) {
    if (un(A)) {
      var F = !0;
      Ko(h);
    } else F = !1;
    if ((Bn(h, I), h.stateNode === null))
      f !== null &&
        ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
        SM(h, A, w),
        dx(h, A, w, I),
        (w = !0);
    else if (f === null) {
      var re = h.stateNode,
        me = h.memoizedProps;
      re.props = me;
      var Ue = re.context,
        Ke = A.contextType;
      typeof Ke == "object" && Ke !== null
        ? (Ke = Hn(Ke))
        : ((Ke = un(A) ? hi : Ln.current), (Ke = nn(h, Ke)));
      var ut = A.getDerivedStateFromProps,
        Pt =
          typeof ut == "function" ||
          typeof re.getSnapshotBeforeUpdate == "function";
      Pt ||
        (typeof re.UNSAFE_componentWillReceiveProps != "function" &&
          typeof re.componentWillReceiveProps != "function") ||
        ((me !== w || Ue !== Ke) && AM(h, re, w, Ke)),
        (da = !1);
      var St = h.memoizedState;
      (re.state = St),
        em(h, w, re, I),
        (Ue = h.memoizedState),
        me !== w || St !== Ue || yn.current || da
          ? (typeof ut == "function" &&
              (fx(h, A, ut, w), (Ue = h.memoizedState)),
            (me = da || _M(h, A, me, w, St, Ue, Ke))
              ? (Pt ||
                  (typeof re.UNSAFE_componentWillMount != "function" &&
                    typeof re.componentWillMount != "function") ||
                  (typeof re.componentWillMount == "function" &&
                    re.componentWillMount(),
                  typeof re.UNSAFE_componentWillMount == "function" &&
                    re.UNSAFE_componentWillMount()),
                typeof re.componentDidMount == "function" &&
                  (h.flags |= 4194308))
              : (typeof re.componentDidMount == "function" &&
                  (h.flags |= 4194308),
                (h.memoizedProps = w),
                (h.memoizedState = Ue)),
            (re.props = w),
            (re.state = Ue),
            (re.context = Ke),
            (w = me))
          : (typeof re.componentDidMount == "function" && (h.flags |= 4194308),
            (w = !1));
    } else {
      (re = h.stateNode),
        gM(f, h),
        (me = h.memoizedProps),
        (Ke = h.type === h.elementType ? me : Qr(h.type, me)),
        (re.props = Ke),
        (Pt = h.pendingProps),
        (St = re.context),
        (Ue = A.contextType),
        typeof Ue == "object" && Ue !== null
          ? (Ue = Hn(Ue))
          : ((Ue = un(A) ? hi : Ln.current), (Ue = nn(h, Ue)));
      var fn = A.getDerivedStateFromProps;
      (ut =
        typeof fn == "function" ||
        typeof re.getSnapshotBeforeUpdate == "function") ||
        (typeof re.UNSAFE_componentWillReceiveProps != "function" &&
          typeof re.componentWillReceiveProps != "function") ||
        ((me !== Pt || St !== Ue) && AM(h, re, w, Ue)),
        (da = !1),
        (St = h.memoizedState),
        (re.state = St),
        em(h, w, re, I);
      var gt = h.memoizedState;
      me !== Pt || St !== gt || yn.current || da
        ? (typeof fn == "function" && (fx(h, A, fn, w), (gt = h.memoizedState)),
          (Ke = da || _M(h, A, Ke, w, St, gt, Ue) || !1)
            ? (ut ||
                (typeof re.UNSAFE_componentWillUpdate != "function" &&
                  typeof re.componentWillUpdate != "function") ||
                (typeof re.componentWillUpdate == "function" &&
                  re.componentWillUpdate(w, gt, Ue),
                typeof re.UNSAFE_componentWillUpdate == "function" &&
                  re.UNSAFE_componentWillUpdate(w, gt, Ue)),
              typeof re.componentDidUpdate == "function" && (h.flags |= 4),
              typeof re.getSnapshotBeforeUpdate == "function" &&
                (h.flags |= 1024))
            : (typeof re.componentDidUpdate != "function" ||
                (me === f.memoizedProps && St === f.memoizedState) ||
                (h.flags |= 4),
              typeof re.getSnapshotBeforeUpdate != "function" ||
                (me === f.memoizedProps && St === f.memoizedState) ||
                (h.flags |= 1024),
              (h.memoizedProps = w),
              (h.memoizedState = gt)),
          (re.props = w),
          (re.state = gt),
          (re.context = Ue),
          (w = Ke))
        : (typeof re.componentDidUpdate != "function" ||
            (me === f.memoizedProps && St === f.memoizedState) ||
            (h.flags |= 4),
          typeof re.getSnapshotBeforeUpdate != "function" ||
            (me === f.memoizedProps && St === f.memoizedState) ||
            (h.flags |= 1024),
          (w = !1));
    }
    return Ix(f, h, A, w, F, I);
  }
  function Ix(f, h, A, w, I, F) {
    sC(f, h);
    var re = (h.flags & 128) !== 0;
    if (!w && !re) return I && Or(h, A, !1), Rs(f, h, F);
    (w = h.stateNode), (Y4.current = h);
    var me =
      re && typeof A.getDerivedStateFromError != "function" ? null : w.render();
    return (
      (h.flags |= 1),
      f !== null && re
        ? ((h.child = qc(h, f.child, null, F)), (h.child = qc(h, null, me, F)))
        : ti(f, h, me, F),
      (h.memoizedState = w.state),
      I && Or(h, A, !0),
      h.child
    );
  }
  function lC(f) {
    var h = f.stateNode;
    h.pendingContext
      ? er(f, h.pendingContext, h.pendingContext !== h.context)
      : h.context && er(f, h.context, !1),
      yx(f, h.containerInfo);
  }
  function cC(f, h, A, w, I) {
    return Yc(), vx(I), (h.flags |= 256), ti(f, h, A, w), h.child;
  }
  var mm = { dehydrated: null, treeContext: null, retryLane: 0 };
  function gm(f) {
    return { baseLanes: f, cachePool: null };
  }
  function uC(f, h, A) {
    var w = h.pendingProps,
      I = bn.current,
      F = !1,
      re = (h.flags & 128) !== 0,
      me;
    if (
      ((me = re) ||
        (me = f !== null && f.memoizedState === null ? !1 : (I & 2) !== 0),
      me
        ? ((F = !0), (h.flags &= -129))
        : (f === null || f.memoizedState !== null) && (I |= 1),
      _t(bn, I & 1),
      f === null)
    )
      return (
        gx(h),
        (f = h.memoizedState),
        f !== null && ((f = f.dehydrated), f !== null)
          ? (h.mode & 1
              ? $t(f)
                ? (h.lanes = 8)
                : (h.lanes = 1073741824)
              : (h.lanes = 1),
            null)
          : ((I = w.children),
            (f = w.fallback),
            F
              ? ((w = h.mode),
                (F = h.child),
                (I = { mode: "hidden", children: I }),
                !(w & 1) && F !== null
                  ? ((F.childLanes = 0), (F.pendingProps = I))
                  : (F = Fm(I, w, 0, null)),
                (f = Tl(f, w, A, null)),
                (F.return = h),
                (f.return = h),
                (F.sibling = f),
                (h.child = F),
                (h.child.memoizedState = gm(A)),
                (h.memoizedState = mm),
                f)
              : Lx(h, I))
      );
    if (((I = f.memoizedState), I !== null)) {
      if (((me = I.dehydrated), me !== null)) {
        if (re)
          return h.flags & 256
            ? ((h.flags &= -257), vm(f, h, A, Error(s(422))))
            : h.memoizedState !== null
            ? ((h.child = f.child), (h.flags |= 128), null)
            : ((F = w.fallback),
              (I = h.mode),
              (w = Fm({ mode: "visible", children: w.children }, I, 0, null)),
              (F = Tl(F, I, A, null)),
              (F.flags |= 2),
              (w.return = h),
              (F.return = h),
              (w.sibling = F),
              (h.child = w),
              h.mode & 1 && qc(h, f.child, null, A),
              (h.child.memoizedState = gm(A)),
              (h.memoizedState = mm),
              F);
        if (!(h.mode & 1)) h = vm(f, h, A, null);
        else if ($t(me)) h = vm(f, h, A, Error(s(419)));
        else if (((w = (A & f.childLanes) !== 0), Di || w)) {
          if (((w = Yn), w !== null)) {
            switch (A & -A) {
              case 4:
                F = 2;
                break;
              case 16:
                F = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                F = 32;
                break;
              case 536870912:
                F = 268435456;
                break;
              default:
                F = 0;
            }
            (w = F & (w.suspendedLanes | A) ? 0 : F),
              w !== 0 && w !== I.retryLane && ((I.retryLane = w), io(f, w, -1));
          }
          Jx(), (h = vm(f, h, A, Error(s(421))));
        } else
          cr(me)
            ? ((h.flags |= 128),
              (h.child = f.child),
              (h = ak.bind(null, f)),
              ur(me, h),
              (h = null))
            : ((A = I.treeContext),
              pe &&
                ((Ni = In(me)),
                (Oi = h),
                (xn = !0),
                (Mo = null),
                (ed = !1),
                A !== null &&
                  ((eo[to++] = Ms),
                  (eo[to++] = Cs),
                  (eo[to++] = _l),
                  (Ms = A.id),
                  (Cs = A.overflow),
                  (_l = h))),
              (h = Lx(h, h.pendingProps.children)),
              (h.flags |= 4096));
        return h;
      }
      return F
        ? ((w = dC(f, h, w.children, w.fallback, A)),
          (F = h.child),
          (I = f.child.memoizedState),
          (F.memoizedState =
            I === null
              ? gm(A)
              : { baseLanes: I.baseLanes | A, cachePool: null }),
          (F.childLanes = f.childLanes & ~A),
          (h.memoizedState = mm),
          w)
        : ((A = fC(f, h, w.children, A)), (h.memoizedState = null), A);
    }
    return F
      ? ((w = dC(f, h, w.children, w.fallback, A)),
        (F = h.child),
        (I = f.child.memoizedState),
        (F.memoizedState =
          I === null ? gm(A) : { baseLanes: I.baseLanes | A, cachePool: null }),
        (F.childLanes = f.childLanes & ~A),
        (h.memoizedState = mm),
        w)
      : ((A = fC(f, h, w.children, A)), (h.memoizedState = null), A);
  }
  function Lx(f, h) {
    return (
      (h = Fm({ mode: "visible", children: h }, f.mode, 0, null)),
      (h.return = f),
      (f.child = h)
    );
  }
  function fC(f, h, A, w) {
    var I = f.child;
    return (
      (f = I.sibling),
      (A = ya(I, { mode: "visible", children: A })),
      !(h.mode & 1) && (A.lanes = w),
      (A.return = h),
      (A.sibling = null),
      f !== null &&
        ((w = h.deletions),
        w === null ? ((h.deletions = [f]), (h.flags |= 16)) : w.push(f)),
      (h.child = A)
    );
  }
  function dC(f, h, A, w, I) {
    var F = h.mode;
    f = f.child;
    var re = f.sibling,
      me = { mode: "hidden", children: A };
    return (
      !(F & 1) && h.child !== f
        ? ((A = h.child),
          (A.childLanes = 0),
          (A.pendingProps = me),
          (h.deletions = null))
        : ((A = ya(f, me)), (A.subtreeFlags = f.subtreeFlags & 14680064)),
      re !== null ? (w = ya(re, w)) : ((w = Tl(w, F, I, null)), (w.flags |= 2)),
      (w.return = h),
      (A.return = h),
      (A.sibling = w),
      (h.child = A),
      w
    );
  }
  function vm(f, h, A, w) {
    return (
      w !== null && vx(w),
      qc(h, f.child, null, A),
      (f = Lx(h, h.pendingProps.children)),
      (f.flags |= 2),
      (h.memoizedState = null),
      f
    );
  }
  function hC(f, h, A) {
    f.lanes |= h;
    var w = f.alternate;
    w !== null && (w.lanes |= h), ei(f.return, h, A);
  }
  function Ox(f, h, A, w, I) {
    var F = f.memoizedState;
    F === null
      ? (f.memoizedState = {
          isBackwards: h,
          rendering: null,
          renderingStartTime: 0,
          last: w,
          tail: A,
          tailMode: I,
        })
      : ((F.isBackwards = h),
        (F.rendering = null),
        (F.renderingStartTime = 0),
        (F.last = w),
        (F.tail = A),
        (F.tailMode = I));
  }
  function pC(f, h, A) {
    var w = h.pendingProps,
      I = w.revealOrder,
      F = w.tail;
    if ((ti(f, h, w.children, A), (w = bn.current), w & 2))
      (w = (w & 1) | 2), (h.flags |= 128);
    else {
      if (f !== null && f.flags & 128)
        e: for (f = h.child; f !== null; ) {
          if (f.tag === 13) f.memoizedState !== null && hC(f, A, h);
          else if (f.tag === 19) hC(f, A, h);
          else if (f.child !== null) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === h) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === h) break e;
            f = f.return;
          }
          (f.sibling.return = f.return), (f = f.sibling);
        }
      w &= 1;
    }
    if ((_t(bn, w), !(h.mode & 1))) h.memoizedState = null;
    else
      switch (I) {
        case "forwards":
          for (A = h.child, I = null; A !== null; )
            (f = A.alternate),
              f !== null && om(f) === null && (I = A),
              (A = A.sibling);
          (A = I),
            A === null
              ? ((I = h.child), (h.child = null))
              : ((I = A.sibling), (A.sibling = null)),
            Ox(h, !1, I, A, F);
          break;
        case "backwards":
          for (A = null, I = h.child, h.child = null; I !== null; ) {
            if (((f = I.alternate), f !== null && om(f) === null)) {
              h.child = I;
              break;
            }
            (f = I.sibling), (I.sibling = A), (A = I), (I = f);
          }
          Ox(h, !0, A, null, F);
          break;
        case "together":
          Ox(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
    return h.child;
  }
  function Rs(f, h, A) {
    if (
      (f !== null && (h.dependencies = f.dependencies),
      (eu |= h.lanes),
      !(A & h.childLanes))
    )
      return null;
    if (f !== null && h.child !== f.child) throw Error(s(153));
    if (h.child !== null) {
      for (
        f = h.child, A = ya(f, f.pendingProps), h.child = A, A.return = h;
        f.sibling !== null;

      )
        (f = f.sibling),
          (A = A.sibling = ya(f, f.pendingProps)),
          (A.return = h);
      A.sibling = null;
    }
    return h.child;
  }
  function q4(f, h, A) {
    switch (h.tag) {
      case 3:
        lC(h), Yc();
        break;
      case 5:
        PM(h);
        break;
      case 1:
        un(h.type) && Ko(h);
        break;
      case 4:
        yx(h, h.stateNode.containerInfo);
        break;
      case 10:
        Jp(h, h.type._context, h.memoizedProps.value);
        break;
      case 13:
        var w = h.memoizedState;
        if (w !== null)
          return w.dehydrated !== null
            ? (_t(bn, bn.current & 1), (h.flags |= 128), null)
            : A & h.child.childLanes
            ? uC(f, h, A)
            : (_t(bn, bn.current & 1),
              (f = Rs(f, h, A)),
              f !== null ? f.sibling : null);
        _t(bn, bn.current & 1);
        break;
      case 19:
        if (((w = (A & h.childLanes) !== 0), f.flags & 128)) {
          if (w) return pC(f, h, A);
          h.flags |= 128;
        }
        var I = h.memoizedState;
        if (
          (I !== null &&
            ((I.rendering = null), (I.tail = null), (I.lastEffect = null)),
          _t(bn, bn.current),
          w)
        )
          break;
        return null;
      case 22:
      case 23:
        return (h.lanes = 0), oC(f, h, A);
    }
    return Rs(f, h, A);
  }
  function K4(f, h) {
    switch ((px(h), h.tag)) {
      case 1:
        return (
          un(h.type) && Kr(),
          (f = h.flags),
          f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 3:
        return (
          Zc(),
          Wt(yn),
          Wt(Ln),
          Sx(),
          (f = h.flags),
          f & 65536 && !(f & 128) ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 5:
        return xx(h), null;
      case 13:
        if (
          (Wt(bn), (f = h.memoizedState), f !== null && f.dehydrated !== null)
        ) {
          if (h.alternate === null) throw Error(s(340));
          Yc();
        }
        return (
          (f = h.flags), f & 65536 ? ((h.flags = (f & -65537) | 128), h) : null
        );
      case 19:
        return Wt(bn), null;
      case 4:
        return Zc(), null;
      case 10:
        return hr(h.type._context), null;
      case 22:
      case 23:
        return Zx(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var ym = !1,
    bl = !1,
    Z4 = typeof WeakSet == "function" ? WeakSet : Set,
    tt = null;
  function xm(f, h) {
    var A = f.ref;
    if (A !== null)
      if (typeof A == "function")
        try {
          A(null);
        } catch (w) {
          vi(f, h, w);
        }
      else A.current = null;
  }
  function Nx(f, h, A) {
    try {
      A();
    } catch (w) {
      vi(f, h, w);
    }
  }
  var mC = !1;
  function J4(f, h) {
    for (j(f.containerInfo), tt = h; tt !== null; )
      if (
        ((f = tt), (h = f.child), (f.subtreeFlags & 1028) !== 0 && h !== null)
      )
        (h.return = f), (tt = h);
      else
        for (; tt !== null; ) {
          f = tt;
          try {
            var A = f.alternate;
            if (f.flags & 1024)
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (A !== null) {
                    var w = A.memoizedProps,
                      I = A.memoizedState,
                      F = f.stateNode,
                      re = F.getSnapshotBeforeUpdate(
                        f.elementType === f.type ? w : Qr(f.type, w),
                        I
                      );
                    F.__reactInternalSnapshotBeforeUpdate = re;
                  }
                  break;
                case 3:
                  ge && qe(f.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(s(163));
              }
          } catch (me) {
            vi(f, f.return, me);
          }
          if (((h = f.sibling), h !== null)) {
            (h.return = f.return), (tt = h);
            break;
          }
          tt = f.return;
        }
    return (A = mC), (mC = !1), A;
  }
  function wl(f, h, A) {
    var w = h.updateQueue;
    if (((w = w !== null ? w.lastEffect : null), w !== null)) {
      var I = (w = w.next);
      do {
        if ((I.tag & f) === f) {
          var F = I.destroy;
          (I.destroy = void 0), F !== void 0 && Nx(h, A, F);
        }
        I = I.next;
      } while (I !== w);
    }
  }
  function dd(f, h) {
    if (
      ((h = h.updateQueue), (h = h !== null ? h.lastEffect : null), h !== null)
    ) {
      var A = (h = h.next);
      do {
        if ((A.tag & f) === f) {
          var w = A.create;
          A.destroy = w();
        }
        A = A.next;
      } while (A !== h);
    }
  }
  function Dx(f) {
    var h = f.ref;
    if (h !== null) {
      var A = f.stateNode;
      switch (f.tag) {
        case 5:
          f = G(A);
          break;
        default:
          f = A;
      }
      typeof h == "function" ? h(f) : (h.current = f);
    }
  }
  function gC(f, h, A) {
    if (Pi && typeof Pi.onCommitFiberUnmount == "function")
      try {
        Pi.onCommitFiberUnmount(gl, h);
      } catch {}
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((f = h.updateQueue), f !== null && ((f = f.lastEffect), f !== null))
        ) {
          var w = (f = f.next);
          do {
            var I = w,
              F = I.destroy;
            (I = I.tag),
              F !== void 0 && (I & 2 || I & 4) && Nx(h, A, F),
              (w = w.next);
          } while (w !== f);
        }
        break;
      case 1:
        if (
          (xm(h, A),
          (f = h.stateNode),
          typeof f.componentWillUnmount == "function")
        )
          try {
            (f.props = h.memoizedProps),
              (f.state = h.memoizedState),
              f.componentWillUnmount();
          } catch (re) {
            vi(h, A, re);
          }
        break;
      case 5:
        xm(h, A);
        break;
      case 4:
        ge
          ? AC(f, h, A)
          : ie &&
            ie &&
            ((h = h.stateNode.containerInfo), (A = st(h)), Ze(h, A));
    }
  }
  function vC(f, h, A) {
    for (var w = h; ; )
      if ((gC(f, w, A), w.child === null || (ge && w.tag === 4))) {
        if (w === h) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === h) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      } else (w.child.return = w), (w = w.child);
  }
  function yC(f) {
    var h = f.alternate;
    h !== null && ((f.alternate = null), yC(h)),
      (f.child = null),
      (f.deletions = null),
      (f.sibling = null),
      f.tag === 5 && ((h = f.stateNode), h !== null && Ce(h)),
      (f.stateNode = null),
      (f.return = null),
      (f.dependencies = null),
      (f.memoizedProps = null),
      (f.memoizedState = null),
      (f.pendingProps = null),
      (f.stateNode = null),
      (f.updateQueue = null);
  }
  function xC(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function _C(f) {
    e: for (;;) {
      for (; f.sibling === null; ) {
        if (f.return === null || xC(f.return)) return null;
        f = f.return;
      }
      for (
        f.sibling.return = f.return, f = f.sibling;
        f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

      ) {
        if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
        (f.child.return = f), (f = f.child);
      }
      if (!(f.flags & 2)) return f.stateNode;
    }
  }
  function SC(f) {
    if (ge) {
      e: {
        for (var h = f.return; h !== null; ) {
          if (xC(h)) break e;
          h = h.return;
        }
        throw Error(s(160));
      }
      var A = h;
      switch (A.tag) {
        case 5:
          (h = A.stateNode),
            A.flags & 32 && (be(h), (A.flags &= -33)),
            (A = _C(f)),
            Ux(f, A, h);
          break;
        case 3:
        case 4:
          (h = A.stateNode.containerInfo), (A = _C(f)), Fx(f, A, h);
          break;
        default:
          throw Error(s(161));
      }
    }
  }
  function Fx(f, h, A) {
    var w = f.tag;
    if (w === 5 || w === 6) (f = f.stateNode), h ? ze(A, f, h) : Le(A, f);
    else if (w !== 4 && ((f = f.child), f !== null))
      for (Fx(f, h, A), f = f.sibling; f !== null; )
        Fx(f, h, A), (f = f.sibling);
  }
  function Ux(f, h, A) {
    var w = f.tag;
    if (w === 5 || w === 6) (f = f.stateNode), h ? De(A, f, h) : Ge(A, f);
    else if (w !== 4 && ((f = f.child), f !== null))
      for (Ux(f, h, A), f = f.sibling; f !== null; )
        Ux(f, h, A), (f = f.sibling);
  }
  function AC(f, h, A) {
    for (var w = h, I = !1, F, re; ; ) {
      if (!I) {
        I = w.return;
        e: for (;;) {
          if (I === null) throw Error(s(160));
          switch (((F = I.stateNode), I.tag)) {
            case 5:
              re = !1;
              break e;
            case 3:
              (F = F.containerInfo), (re = !0);
              break e;
            case 4:
              (F = F.containerInfo), (re = !0);
              break e;
          }
          I = I.return;
        }
        I = !0;
      }
      if (w.tag === 5 || w.tag === 6)
        vC(f, w, A), re ? ae(F, w.stateNode) : Ve(F, w.stateNode);
      else if (w.tag === 18) re ? ct(F, w.stateNode) : Qe(F, w.stateNode);
      else if (w.tag === 4) {
        if (w.child !== null) {
          (F = w.stateNode.containerInfo),
            (re = !0),
            (w.child.return = w),
            (w = w.child);
          continue;
        }
      } else if ((gC(f, w, A), w.child !== null)) {
        (w.child.return = w), (w = w.child);
        continue;
      }
      if (w === h) break;
      for (; w.sibling === null; ) {
        if (w.return === null || w.return === h) return;
        (w = w.return), w.tag === 4 && (I = !1);
      }
      (w.sibling.return = w.return), (w = w.sibling);
    }
  }
  function kx(f, h) {
    if (ge) {
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          wl(3, h, h.return), dd(3, h), wl(5, h, h.return);
          return;
        case 1:
          return;
        case 5:
          var A = h.stateNode;
          if (A != null) {
            var w = h.memoizedProps;
            f = f !== null ? f.memoizedProps : w;
            var I = h.type,
              F = h.updateQueue;
            (h.updateQueue = null), F !== null && Ye(A, F, I, f, w, h);
          }
          return;
        case 6:
          if (h.stateNode === null) throw Error(s(162));
          (A = h.memoizedProps),
            je(h.stateNode, f !== null ? f.memoizedProps : A, A);
          return;
        case 3:
          pe &&
            f !== null &&
            f.memoizedState.isDehydrated &&
            Te(h.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          _m(h);
          return;
        case 19:
          _m(h);
          return;
        case 17:
          return;
      }
      throw Error(s(163));
    }
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        wl(3, h, h.return), dd(3, h), wl(5, h, h.return);
        return;
      case 12:
        return;
      case 13:
        _m(h);
        return;
      case 19:
        _m(h);
        return;
      case 3:
        pe &&
          f !== null &&
          f.memoizedState.isDehydrated &&
          Te(h.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (ie) {
      switch (h.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (h = h.stateNode), Ze(h.containerInfo, h.pendingChildren);
          break e;
      }
      throw Error(s(163));
    }
  }
  function _m(f) {
    var h = f.updateQueue;
    if (h !== null) {
      f.updateQueue = null;
      var A = f.stateNode;
      A === null && (A = f.stateNode = new Z4()),
        h.forEach(function (w) {
          var I = lk.bind(null, f, w);
          A.has(w) || (A.add(w), w.then(I, I));
        });
    }
  }
  function Q4(f, h) {
    for (tt = h; tt !== null; ) {
      h = tt;
      var A = h.deletions;
      if (A !== null)
        for (var w = 0; w < A.length; w++) {
          var I = A[w];
          try {
            var F = f;
            ge ? AC(F, I, h) : vC(F, I, h);
            var re = I.alternate;
            re !== null && (re.return = null), (I.return = null);
          } catch (mt) {
            vi(I, h, mt);
          }
        }
      if (((A = h.child), h.subtreeFlags & 12854 && A !== null))
        (A.return = h), (tt = A);
      else
        for (; tt !== null; ) {
          h = tt;
          try {
            var me = h.flags;
            if ((me & 32 && ge && be(h.stateNode), me & 512)) {
              var Ue = h.alternate;
              if (Ue !== null) {
                var Ke = Ue.ref;
                Ke !== null &&
                  (typeof Ke == "function" ? Ke(null) : (Ke.current = null));
              }
            }
            if (me & 8192)
              switch (h.tag) {
                case 13:
                  if (h.memoizedState !== null) {
                    var ut = h.alternate;
                    (ut === null || ut.memoizedState === null) && (jx = An());
                  }
                  break;
                case 22:
                  var Pt = h.memoizedState !== null,
                    St = h.alternate,
                    fn = St !== null && St.memoizedState !== null;
                  if (((A = h), ge)) {
                    e: if (((w = A), (I = Pt), (F = null), ge))
                      for (var gt = w; ; ) {
                        if (gt.tag === 5) {
                          if (F === null) {
                            F = gt;
                            var Ur = gt.stateNode;
                            I ? se(Ur) : ye(gt.stateNode, gt.memoizedProps);
                          }
                        } else if (gt.tag === 6) {
                          if (F === null) {
                            var so = gt.stateNode;
                            I ? Ae(so) : He(so, gt.memoizedProps);
                          }
                        } else if (
                          ((gt.tag !== 22 && gt.tag !== 23) ||
                            gt.memoizedState === null ||
                            gt === w) &&
                          gt.child !== null
                        ) {
                          (gt.child.return = gt), (gt = gt.child);
                          continue;
                        }
                        if (gt === w) break;
                        for (; gt.sibling === null; ) {
                          if (gt.return === null || gt.return === w) break e;
                          F === gt && (F = null), (gt = gt.return);
                        }
                        F === gt && (F = null),
                          (gt.sibling.return = gt.return),
                          (gt = gt.sibling);
                      }
                  }
                  if (Pt && !fn && A.mode & 1) {
                    tt = A;
                    for (var Pe = A.child; Pe !== null; ) {
                      for (A = tt = Pe; tt !== null; ) {
                        w = tt;
                        var xe = w.child;
                        switch (w.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            wl(4, w, w.return);
                            break;
                          case 1:
                            xm(w, w.return);
                            var Ne = w.stateNode;
                            if (typeof Ne.componentWillUnmount == "function") {
                              var rt = w.return;
                              try {
                                (Ne.props = w.memoizedProps),
                                  (Ne.state = w.memoizedState),
                                  Ne.componentWillUnmount();
                              } catch (mt) {
                                vi(w, rt, mt);
                              }
                            }
                            break;
                          case 5:
                            xm(w, w.return);
                            break;
                          case 22:
                            if (w.memoizedState !== null) {
                              EC(A);
                              continue;
                            }
                        }
                        xe !== null ? ((xe.return = w), (tt = xe)) : EC(A);
                      }
                      Pe = Pe.sibling;
                    }
                  }
              }
            switch (me & 4102) {
              case 2:
                SC(h), (h.flags &= -3);
                break;
              case 6:
                SC(h), (h.flags &= -3), kx(h.alternate, h);
                break;
              case 4096:
                h.flags &= -4097;
                break;
              case 4100:
                (h.flags &= -4097), kx(h.alternate, h);
                break;
              case 4:
                kx(h.alternate, h);
            }
          } catch (mt) {
            vi(h, h.return, mt);
          }
          if (((A = h.sibling), A !== null)) {
            (A.return = h.return), (tt = A);
            break;
          }
          tt = h.return;
        }
    }
  }
  function ek(f, h, A) {
    (tt = f), bC(f);
  }
  function bC(f, h, A) {
    for (var w = (f.mode & 1) !== 0; tt !== null; ) {
      var I = tt,
        F = I.child;
      if (I.tag === 22 && w) {
        var re = I.memoizedState !== null || ym;
        if (!re) {
          var me = I.alternate,
            Ue = (me !== null && me.memoizedState !== null) || bl;
          me = ym;
          var Ke = bl;
          if (((ym = re), (bl = Ue) && !Ke))
            for (tt = I; tt !== null; )
              (re = tt),
                (Ue = re.child),
                re.tag === 22 && re.memoizedState !== null
                  ? MC(I)
                  : Ue !== null
                  ? ((Ue.return = re), (tt = Ue))
                  : MC(I);
          for (; F !== null; ) (tt = F), bC(F), (F = F.sibling);
          (tt = I), (ym = me), (bl = Ke);
        }
        wC(f);
      } else
        I.subtreeFlags & 8772 && F !== null
          ? ((F.return = I), (tt = F))
          : wC(f);
    }
  }
  function wC(f) {
    for (; tt !== null; ) {
      var h = tt;
      if (h.flags & 8772) {
        var A = h.alternate;
        try {
          if (h.flags & 8772)
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                bl || dd(5, h);
                break;
              case 1:
                var w = h.stateNode;
                if (h.flags & 4 && !bl)
                  if (A === null) w.componentDidMount();
                  else {
                    var I =
                      h.elementType === h.type
                        ? A.memoizedProps
                        : Qr(h.type, A.memoizedProps);
                    w.componentDidUpdate(
                      I,
                      A.memoizedState,
                      w.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var F = h.updateQueue;
                F !== null && yM(h, F, w);
                break;
              case 3:
                var re = h.updateQueue;
                if (re !== null) {
                  if (((A = null), h.child !== null))
                    switch (h.child.tag) {
                      case 5:
                        A = G(h.child.stateNode);
                        break;
                      case 1:
                        A = h.child.stateNode;
                    }
                  yM(h, re, A);
                }
                break;
              case 5:
                var me = h.stateNode;
                A === null && h.flags & 4 && Je(me, h.type, h.memoizedProps, h);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (pe && h.memoizedState === null) {
                  var Ue = h.alternate;
                  if (Ue !== null) {
                    var Ke = Ue.memoizedState;
                    if (Ke !== null) {
                      var ut = Ke.dehydrated;
                      ut !== null && Re(ut);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(s(163));
            }
          bl || (h.flags & 512 && Dx(h));
        } catch (Pt) {
          vi(h, h.return, Pt);
        }
      }
      if (h === f) {
        tt = null;
        break;
      }
      if (((A = h.sibling), A !== null)) {
        (A.return = h.return), (tt = A);
        break;
      }
      tt = h.return;
    }
  }
  function EC(f) {
    for (; tt !== null; ) {
      var h = tt;
      if (h === f) {
        tt = null;
        break;
      }
      var A = h.sibling;
      if (A !== null) {
        (A.return = h.return), (tt = A);
        break;
      }
      tt = h.return;
    }
  }
  function MC(f) {
    for (; tt !== null; ) {
      var h = tt;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var A = h.return;
            try {
              dd(4, h);
            } catch (Ue) {
              vi(h, A, Ue);
            }
            break;
          case 1:
            var w = h.stateNode;
            if (typeof w.componentDidMount == "function") {
              var I = h.return;
              try {
                w.componentDidMount();
              } catch (Ue) {
                vi(h, I, Ue);
              }
            }
            var F = h.return;
            try {
              Dx(h);
            } catch (Ue) {
              vi(h, F, Ue);
            }
            break;
          case 5:
            var re = h.return;
            try {
              Dx(h);
            } catch (Ue) {
              vi(h, re, Ue);
            }
        }
      } catch (Ue) {
        vi(h, h.return, Ue);
      }
      if (h === f) {
        tt = null;
        break;
      }
      var me = h.sibling;
      if (me !== null) {
        (me.return = h.return), (tt = me);
        break;
      }
      tt = h.return;
    }
  }
  var Sm = 0,
    Am = 1,
    bm = 2,
    wm = 3,
    Em = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var hd = Symbol.for;
    (Sm = hd("selector.component")),
      (Am = hd("selector.has_pseudo_class")),
      (bm = hd("selector.role")),
      (wm = hd("selector.test_id")),
      (Em = hd("selector.text"));
  }
  function zx(f) {
    var h = de(f);
    if (h != null) {
      if (typeof h.memoizedProps["data-testname"] != "string")
        throw Error(s(364));
      return h;
    }
    if (((f = J(f)), f === null)) throw Error(s(362));
    return f.stateNode.current;
  }
  function Bx(f, h) {
    switch (h.$$typeof) {
      case Sm:
        if (f.type === h.value) return !0;
        break;
      case Am:
        e: {
          (h = h.value), (f = [f, 0]);
          for (var A = 0; A < f.length; ) {
            var w = f[A++],
              I = f[A++],
              F = h[I];
            if (w.tag !== 5 || !ce(w)) {
              for (; F != null && Bx(w, F); ) I++, (F = h[I]);
              if (I === h.length) {
                h = !0;
                break e;
              } else
                for (w = w.child; w !== null; ) f.push(w, I), (w = w.sibling);
            }
          }
          h = !1;
        }
        return h;
      case bm:
        if (f.tag === 5 && we(f.stateNode, h.value)) return !0;
        break;
      case Em:
        if (
          (f.tag === 5 || f.tag === 6) &&
          ((f = le(f)), f !== null && 0 <= f.indexOf(h.value))
        )
          return !0;
        break;
      case wm:
        if (
          f.tag === 5 &&
          ((f = f.memoizedProps["data-testname"]),
          typeof f == "string" && f.toLowerCase() === h.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(s(365));
    }
    return !1;
  }
  function Hx(f) {
    switch (f.$$typeof) {
      case Sm:
        return "<" + (T(f.value) || "Unknown") + ">";
      case Am:
        return ":has(" + (Hx(f) || "") + ")";
      case bm:
        return '[role="' + f.value + '"]';
      case Em:
        return '"' + f.value + '"';
      case wm:
        return '[data-testname="' + f.value + '"]';
      default:
        throw Error(s(365));
    }
  }
  function CC(f, h) {
    var A = [];
    f = [f, 0];
    for (var w = 0; w < f.length; ) {
      var I = f[w++],
        F = f[w++],
        re = h[F];
      if (I.tag !== 5 || !ce(I)) {
        for (; re != null && Bx(I, re); ) F++, (re = h[F]);
        if (F === h.length) A.push(I);
        else for (I = I.child; I !== null; ) f.push(I, F), (I = I.sibling);
      }
    }
    return A;
  }
  function Vx(f, h) {
    if (!k) throw Error(s(363));
    (f = zx(f)), (f = CC(f, h)), (h = []), (f = Array.from(f));
    for (var A = 0; A < f.length; ) {
      var w = f[A++];
      if (w.tag === 5) ce(w) || h.push(w.stateNode);
      else for (w = w.child; w !== null; ) f.push(w), (w = w.sibling);
    }
    return h;
  }
  var tk = Math.ceil,
    Mm = a.ReactCurrentDispatcher,
    Gx = a.ReactCurrentOwner,
    Vn = a.ReactCurrentBatchConfig,
    kt = 0,
    Yn = null,
    qn = null,
    wr = 0,
    Fi = 0,
    Qc = vt(0),
    tr = 0,
    pd = null,
    eu = 0,
    Cm = 0,
    Wx = 0,
    md = null,
    mi = null,
    jx = 0,
    $x = 1 / 0;
  function tu() {
    $x = An() + 500;
  }
  var Tm = !1,
    Xx = null,
    pa = null,
    Rm = !1,
    ma = null,
    Pm = 0,
    gd = 0,
    Yx = null,
    Im = -1,
    Lm = 0;
  function ni() {
    return kt & 6 ? An() : Im !== -1 ? Im : (Im = An());
  }
  function ga(f) {
    return f.mode & 1
      ? kt & 2 && wr !== 0
        ? wr & -wr
        : vl.transition !== null
        ? (Lm === 0 &&
            ((f = _s), (_s <<= 1), !(_s & 4194240) && (_s = 64), (Lm = f)),
          Lm)
        : ((f = Ht), f !== 0 ? f : he())
      : 1;
  }
  function io(f, h, A) {
    if (50 < gd) throw ((gd = 0), (Yx = null), Error(s(185)));
    var w = Om(f, h);
    return w === null
      ? null
      : (Zo(w, h, A),
        (!(kt & 2) || w !== Yn) &&
          (w === Yn && (!(kt & 2) && (Cm |= h), tr === 4 && va(w, wr)),
          gi(w, A),
          h === 1 && kt === 0 && !(f.mode & 1) && (tu(), Qo && pi())),
        w);
  }
  function Om(f, h) {
    f.lanes |= h;
    var A = f.alternate;
    for (A !== null && (A.lanes |= h), A = f, f = f.return; f !== null; )
      (f.childLanes |= h),
        (A = f.alternate),
        A !== null && (A.childLanes |= h),
        (A = f),
        (f = f.return);
    return A.tag === 3 ? A.stateNode : null;
  }
  function gi(f, h) {
    var A = f.callbackNode;
    Xf(f, h);
    var w = pl(f, f === Yn ? wr : 0);
    if (w === 0)
      A !== null && Gc(A), (f.callbackNode = null), (f.callbackPriority = 0);
    else if (((h = w & -w), f.callbackPriority !== h)) {
      if ((A != null && Gc(A), h === 1))
        f.tag === 0 ? Qf(RC.bind(null, f)) : Jf(RC.bind(null, f)),
          _e
            ? $(function () {
                kt === 0 && pi();
              })
            : ws(ml, pi),
          (A = null);
      else {
        switch (Yf(w)) {
          case 1:
            A = ml;
            break;
          case 4:
            A = Kp;
            break;
          case 16:
            A = Zr;
            break;
          case 536870912:
            A = Kf;
            break;
          default:
            A = Zr;
        }
        A = kC(A, TC.bind(null, f));
      }
      (f.callbackPriority = h), (f.callbackNode = A);
    }
  }
  function TC(f, h) {
    if (((Im = -1), (Lm = 0), kt & 6)) throw Error(s(327));
    var A = f.callbackNode;
    if (Cl() && f.callbackNode !== A) return null;
    var w = pl(f, f === Yn ? wr : 0);
    if (w === 0) return null;
    if (w & 30 || w & f.expiredLanes || h) h = Nm(f, w);
    else {
      h = w;
      var I = kt;
      kt |= 2;
      var F = LC();
      (Yn !== f || wr !== h) && (tu(), El(f, h));
      do
        try {
          ik();
          break;
        } catch (me) {
          IC(f, me);
        }
      while (!0);
      jc(),
        (Mm.current = F),
        (kt = I),
        qn !== null ? (h = 0) : ((Yn = null), (wr = 0), (h = tr));
    }
    if (h !== 0) {
      if (
        (h === 2 && ((I = bs(f)), I !== 0 && ((w = I), (h = qx(f, I)))),
        h === 1)
      )
        throw ((A = pd), El(f, 0), va(f, w), gi(f, An()), A);
      if (h === 6) va(f, w);
      else {
        if (
          ((I = f.current.alternate),
          !(w & 30) &&
            !nk(I) &&
            ((h = Nm(f, w)),
            h === 2 && ((F = bs(f)), F !== 0 && ((w = F), (h = qx(f, F)))),
            h === 1))
        )
          throw ((A = pd), El(f, 0), va(f, w), gi(f, An()), A);
        switch (((f.finishedWork = I), (f.finishedLanes = w), h)) {
          case 0:
          case 1:
            throw Error(s(345));
          case 2:
            Ml(f, mi);
            break;
          case 3:
            if (
              (va(f, w),
              (w & 130023424) === w && ((h = jx + 500 - An()), 10 < h))
            ) {
              if (pl(f, 0) !== 0) break;
              if (((I = f.suspendedLanes), (I & w) !== w)) {
                ni(), (f.pingedLanes |= f.suspendedLanes & I);
                break;
              }
              f.timeoutHandle = oe(Ml.bind(null, f, mi), h);
              break;
            }
            Ml(f, mi);
            break;
          case 4:
            if ((va(f, w), (w & 4194240) === w)) break;
            for (h = f.eventTimes, I = -1; 0 < w; ) {
              var re = 31 - Ri(w);
              (F = 1 << re), (re = h[re]), re > I && (I = re), (w &= ~F);
            }
            if (
              ((w = I),
              (w = An() - w),
              (w =
                (120 > w
                  ? 120
                  : 480 > w
                  ? 480
                  : 1080 > w
                  ? 1080
                  : 1920 > w
                  ? 1920
                  : 3e3 > w
                  ? 3e3
                  : 4320 > w
                  ? 4320
                  : 1960 * tk(w / 1960)) - w),
              10 < w)
            ) {
              f.timeoutHandle = oe(Ml.bind(null, f, mi), w);
              break;
            }
            Ml(f, mi);
            break;
          case 5:
            Ml(f, mi);
            break;
          default:
            throw Error(s(329));
        }
      }
    }
    return gi(f, An()), f.callbackNode === A ? TC.bind(null, f) : null;
  }
  function qx(f, h) {
    var A = md;
    return (
      f.current.memoizedState.isDehydrated && (El(f, h).flags |= 256),
      (f = Nm(f, h)),
      f !== 2 && ((h = mi), (mi = A), h !== null && Kx(h)),
      f
    );
  }
  function Kx(f) {
    mi === null ? (mi = f) : mi.push.apply(mi, f);
  }
  function nk(f) {
    for (var h = f; ; ) {
      if (h.flags & 16384) {
        var A = h.updateQueue;
        if (A !== null && ((A = A.stores), A !== null))
          for (var w = 0; w < A.length; w++) {
            var I = A[w],
              F = I.getSnapshot;
            I = I.value;
            try {
              if (!Ii(F(), I)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((A = h.child), h.subtreeFlags & 16384 && A !== null))
        (A.return = h), (h = A);
      else {
        if (h === f) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === f) return !0;
          h = h.return;
        }
        (h.sibling.return = h.return), (h = h.sibling);
      }
    }
    return !0;
  }
  function va(f, h) {
    for (
      h &= ~Wx,
        h &= ~Cm,
        f.suspendedLanes |= h,
        f.pingedLanes &= ~h,
        f = f.expirationTimes;
      0 < h;

    ) {
      var A = 31 - Ri(h),
        w = 1 << A;
      (f[A] = -1), (h &= ~w);
    }
  }
  function RC(f) {
    if (kt & 6) throw Error(s(327));
    Cl();
    var h = pl(f, 0);
    if (!(h & 1)) return gi(f, An()), null;
    var A = Nm(f, h);
    if (f.tag !== 0 && A === 2) {
      var w = bs(f);
      w !== 0 && ((h = w), (A = qx(f, w)));
    }
    if (A === 1) throw ((A = pd), El(f, 0), va(f, h), gi(f, An()), A);
    if (A === 6) throw Error(s(345));
    return (
      (f.finishedWork = f.current.alternate),
      (f.finishedLanes = h),
      Ml(f, mi),
      gi(f, An()),
      null
    );
  }
  function PC(f) {
    ma !== null && ma.tag === 0 && !(kt & 6) && Cl();
    var h = kt;
    kt |= 1;
    var A = Vn.transition,
      w = Ht;
    try {
      if (((Vn.transition = null), (Ht = 1), f)) return f();
    } finally {
      (Ht = w), (Vn.transition = A), (kt = h), !(kt & 6) && pi();
    }
  }
  function Zx() {
    (Fi = Qc.current), Wt(Qc);
  }
  function El(f, h) {
    (f.finishedWork = null), (f.finishedLanes = 0);
    var A = f.timeoutHandle;
    if ((A !== Ie && ((f.timeoutHandle = Ie), ue(A)), qn !== null))
      for (A = qn.return; A !== null; ) {
        var w = A;
        switch ((px(w), w.tag)) {
          case 1:
            (w = w.type.childContextTypes), w != null && Kr();
            break;
          case 3:
            Zc(), Wt(yn), Wt(Ln), Sx();
            break;
          case 5:
            xx(w);
            break;
          case 4:
            Zc();
            break;
          case 13:
            Wt(bn);
            break;
          case 19:
            Wt(bn);
            break;
          case 10:
            hr(w.type._context);
            break;
          case 22:
          case 23:
            Zx();
        }
        A = A.return;
      }
    if (
      ((Yn = f),
      (qn = f = ya(f.current, null)),
      (wr = Fi = h),
      (tr = 0),
      (pd = null),
      (Wx = Cm = eu = 0),
      (mi = md = null),
      Li !== null)
    ) {
      for (h = 0; h < Li.length; h++)
        if (((A = Li[h]), (w = A.interleaved), w !== null)) {
          A.interleaved = null;
          var I = w.next,
            F = A.pending;
          if (F !== null) {
            var re = F.next;
            (F.next = I), (w.next = re);
          }
          A.pending = w;
        }
      Li = null;
    }
    return f;
  }
  function IC(f, h) {
    do {
      var A = qn;
      try {
        if ((jc(), (sm.current = dm), am)) {
          for (var w = On.memoizedState; w !== null; ) {
            var I = w.queue;
            I !== null && (I.pending = null), (w = w.next);
          }
          am = !1;
        }
        if (
          ((Jc = 0),
          (pr = Nr = On = null),
          (od = !1),
          (sd = 0),
          (Gx.current = null),
          A === null || A.return === null)
        ) {
          (tr = 1), (pd = h), (qn = null);
          break;
        }
        e: {
          var F = f,
            re = A.return,
            me = A,
            Ue = h;
          if (
            ((h = wr),
            (me.flags |= 32768),
            Ue !== null &&
              typeof Ue == "object" &&
              typeof Ue.then == "function")
          ) {
            var Ke = Ue,
              ut = me,
              Pt = ut.tag;
            if (!(ut.mode & 1) && (Pt === 0 || Pt === 11 || Pt === 15)) {
              var St = ut.alternate;
              St
                ? ((ut.updateQueue = St.updateQueue),
                  (ut.memoizedState = St.memoizedState),
                  (ut.lanes = St.lanes))
                : ((ut.updateQueue = null), (ut.memoizedState = null));
            }
            var fn = JM(re);
            if (fn !== null) {
              (fn.flags &= -257),
                QM(fn, re, me, F, h),
                fn.mode & 1 && ZM(F, Ke, h),
                (h = fn),
                (Ue = Ke);
              var gt = h.updateQueue;
              if (gt === null) {
                var Ur = new Set();
                Ur.add(Ue), (h.updateQueue = Ur);
              } else gt.add(Ue);
              break e;
            } else {
              if (!(h & 1)) {
                ZM(F, Ke, h), Jx();
                break e;
              }
              Ue = Error(s(426));
            }
          } else if (xn && me.mode & 1) {
            var so = JM(re);
            if (so !== null) {
              !(so.flags & 65536) && (so.flags |= 256),
                QM(so, re, me, F, h),
                vx(Ue);
              break e;
            }
          }
          (F = Ue),
            tr !== 4 && (tr = 2),
            md === null ? (md = [F]) : md.push(F),
            (Ue = Tx(Ue, me)),
            (me = re);
          do {
            switch (me.tag) {
              case 3:
                (me.flags |= 65536), (h &= -h), (me.lanes |= h);
                var Pe = qM(me, Ue, h);
                vM(me, Pe);
                break e;
              case 1:
                F = Ue;
                var xe = me.type,
                  Ne = me.stateNode;
                if (
                  !(me.flags & 128) &&
                  (typeof xe.getDerivedStateFromError == "function" ||
                    (Ne !== null &&
                      typeof Ne.componentDidCatch == "function" &&
                      (pa === null || !pa.has(Ne))))
                ) {
                  (me.flags |= 65536), (h &= -h), (me.lanes |= h);
                  var rt = KM(me, F, h);
                  vM(me, rt);
                  break e;
                }
            }
            me = me.return;
          } while (me !== null);
        }
        NC(A);
      } catch (mt) {
        (h = mt), qn === A && A !== null && (qn = A = A.return);
        continue;
      }
      break;
    } while (!0);
  }
  function LC() {
    var f = Mm.current;
    return (Mm.current = dm), f === null ? dm : f;
  }
  function Jx() {
    (tr === 0 || tr === 3 || tr === 2) && (tr = 4),
      Yn === null || (!(eu & 268435455) && !(Cm & 268435455)) || va(Yn, wr);
  }
  function Nm(f, h) {
    var A = kt;
    kt |= 2;
    var w = LC();
    (Yn === f && wr === h) || El(f, h);
    do
      try {
        rk();
        break;
      } catch (I) {
        IC(f, I);
      }
    while (!0);
    if ((jc(), (kt = A), (Mm.current = w), qn !== null)) throw Error(s(261));
    return (Yn = null), (wr = 0), tr;
  }
  function rk() {
    for (; qn !== null; ) OC(qn);
  }
  function ik() {
    for (; qn !== null && !qf(); ) OC(qn);
  }
  function OC(f) {
    var h = UC(f.alternate, f, Fi);
    (f.memoizedProps = f.pendingProps),
      h === null ? NC(f) : (qn = h),
      (Gx.current = null);
  }
  function NC(f) {
    var h = f;
    do {
      var A = h.alternate;
      if (((f = h.return), h.flags & 32768)) {
        if (((A = K4(A, h)), A !== null)) {
          (A.flags &= 32767), (qn = A);
          return;
        }
        if (f !== null)
          (f.flags |= 32768), (f.subtreeFlags = 0), (f.deletions = null);
        else {
          (tr = 6), (qn = null);
          return;
        }
      } else if (((A = X4(A, h, Fi)), A !== null)) {
        qn = A;
        return;
      }
      if (((h = h.sibling), h !== null)) {
        qn = h;
        return;
      }
      qn = h = f;
    } while (h !== null);
    tr === 0 && (tr = 5);
  }
  function Ml(f, h) {
    var A = Ht,
      w = Vn.transition;
    try {
      (Vn.transition = null), (Ht = 1), ok(f, h, A);
    } finally {
      (Vn.transition = w), (Ht = A);
    }
    return null;
  }
  function ok(f, h, A) {
    do Cl();
    while (ma !== null);
    if (kt & 6) throw Error(s(327));
    var w = f.finishedWork,
      I = f.finishedLanes;
    if (w === null) return null;
    if (((f.finishedWork = null), (f.finishedLanes = 0), w === f.current))
      throw Error(s(177));
    (f.callbackNode = null), (f.callbackPriority = 0);
    var F = w.lanes | w.childLanes;
    if (
      (ua(f, F),
      f === Yn && ((qn = Yn = null), (wr = 0)),
      (!(w.subtreeFlags & 2064) && !(w.flags & 2064)) ||
        Rm ||
        ((Rm = !0),
        kC(Zr, function () {
          return Cl(), null;
        })),
      (F = (w.flags & 15990) !== 0),
      w.subtreeFlags & 15990 || F)
    ) {
      (F = Vn.transition), (Vn.transition = null);
      var re = Ht;
      Ht = 1;
      var me = kt;
      (kt |= 4),
        (Gx.current = null),
        J4(f, w),
        Q4(f, w),
        W(f.containerInfo),
        (f.current = w),
        ek(w),
        qp(),
        (kt = me),
        (Ht = re),
        (Vn.transition = F);
    } else f.current = w;
    if (
      (Rm && ((Rm = !1), (ma = f), (Pm = I)),
      (F = f.pendingLanes),
      F === 0 && (pa = null),
      Zf(w.stateNode),
      gi(f, An()),
      h !== null)
    )
      for (A = f.onRecoverableError, w = 0; w < h.length; w++) A(h[w]);
    if (Tm) throw ((Tm = !1), (f = Xx), (Xx = null), f);
    return (
      Pm & 1 && f.tag !== 0 && Cl(),
      (F = f.pendingLanes),
      F & 1 ? (f === Yx ? gd++ : ((gd = 0), (Yx = f))) : (gd = 0),
      pi(),
      null
    );
  }
  function Cl() {
    if (ma !== null) {
      var f = Yf(Pm),
        h = Vn.transition,
        A = Ht;
      try {
        if (((Vn.transition = null), (Ht = 16 > f ? 16 : f), ma === null))
          var w = !1;
        else {
          if (((f = ma), (ma = null), (Pm = 0), kt & 6)) throw Error(s(331));
          var I = kt;
          for (kt |= 4, tt = f.current; tt !== null; ) {
            var F = tt,
              re = F.child;
            if (tt.flags & 16) {
              var me = F.deletions;
              if (me !== null) {
                for (var Ue = 0; Ue < me.length; Ue++) {
                  var Ke = me[Ue];
                  for (tt = Ke; tt !== null; ) {
                    var ut = tt;
                    switch (ut.tag) {
                      case 0:
                      case 11:
                      case 15:
                        wl(8, ut, F);
                    }
                    var Pt = ut.child;
                    if (Pt !== null) (Pt.return = ut), (tt = Pt);
                    else
                      for (; tt !== null; ) {
                        ut = tt;
                        var St = ut.sibling,
                          fn = ut.return;
                        if ((yC(ut), ut === Ke)) {
                          tt = null;
                          break;
                        }
                        if (St !== null) {
                          (St.return = fn), (tt = St);
                          break;
                        }
                        tt = fn;
                      }
                  }
                }
                var gt = F.alternate;
                if (gt !== null) {
                  var Ur = gt.child;
                  if (Ur !== null) {
                    gt.child = null;
                    do {
                      var so = Ur.sibling;
                      (Ur.sibling = null), (Ur = so);
                    } while (Ur !== null);
                  }
                }
                tt = F;
              }
            }
            if (F.subtreeFlags & 2064 && re !== null)
              (re.return = F), (tt = re);
            else
              e: for (; tt !== null; ) {
                if (((F = tt), F.flags & 2048))
                  switch (F.tag) {
                    case 0:
                    case 11:
                    case 15:
                      wl(9, F, F.return);
                  }
                var Pe = F.sibling;
                if (Pe !== null) {
                  (Pe.return = F.return), (tt = Pe);
                  break e;
                }
                tt = F.return;
              }
          }
          var xe = f.current;
          for (tt = xe; tt !== null; ) {
            re = tt;
            var Ne = re.child;
            if (re.subtreeFlags & 2064 && Ne !== null)
              (Ne.return = re), (tt = Ne);
            else
              e: for (re = xe; tt !== null; ) {
                if (((me = tt), me.flags & 2048))
                  try {
                    switch (me.tag) {
                      case 0:
                      case 11:
                      case 15:
                        dd(9, me);
                    }
                  } catch (mt) {
                    vi(me, me.return, mt);
                  }
                if (me === re) {
                  tt = null;
                  break e;
                }
                var rt = me.sibling;
                if (rt !== null) {
                  (rt.return = me.return), (tt = rt);
                  break e;
                }
                tt = me.return;
              }
          }
          if (
            ((kt = I),
            pi(),
            Pi && typeof Pi.onPostCommitFiberRoot == "function")
          )
            try {
              Pi.onPostCommitFiberRoot(gl, f);
            } catch {}
          w = !0;
        }
        return w;
      } finally {
        (Ht = A), (Vn.transition = h);
      }
    }
    return !1;
  }
  function DC(f, h, A) {
    (h = Tx(A, h)),
      (h = qM(f, h, 1)),
      ha(f, h),
      (h = ni()),
      (f = Om(f, 1)),
      f !== null && (Zo(f, 1, h), gi(f, h));
  }
  function vi(f, h, A) {
    if (f.tag === 3) DC(f, f, A);
    else
      for (; h !== null; ) {
        if (h.tag === 3) {
          DC(h, f, A);
          break;
        } else if (h.tag === 1) {
          var w = h.stateNode;
          if (
            typeof h.type.getDerivedStateFromError == "function" ||
            (typeof w.componentDidCatch == "function" &&
              (pa === null || !pa.has(w)))
          ) {
            (f = Tx(A, f)),
              (f = KM(h, f, 1)),
              ha(h, f),
              (f = ni()),
              (h = Om(h, 1)),
              h !== null && (Zo(h, 1, f), gi(h, f));
            break;
          }
        }
        h = h.return;
      }
  }
  function sk(f, h, A) {
    var w = f.pingCache;
    w !== null && w.delete(h),
      (h = ni()),
      (f.pingedLanes |= f.suspendedLanes & A),
      Yn === f &&
        (wr & A) === A &&
        (tr === 4 || (tr === 3 && (wr & 130023424) === wr && 500 > An() - jx)
          ? El(f, 0)
          : (Wx |= A)),
      gi(f, h);
  }
  function FC(f, h) {
    h === 0 &&
      (f.mode & 1
        ? ((h = Ss), (Ss <<= 1), !(Ss & 130023424) && (Ss = 4194304))
        : (h = 1));
    var A = ni();
    (f = Om(f, h)), f !== null && (Zo(f, h, A), gi(f, A));
  }
  function ak(f) {
    var h = f.memoizedState,
      A = 0;
    h !== null && (A = h.retryLane), FC(f, A);
  }
  function lk(f, h) {
    var A = 0;
    switch (f.tag) {
      case 13:
        var w = f.stateNode,
          I = f.memoizedState;
        I !== null && (A = I.retryLane);
        break;
      case 19:
        w = f.stateNode;
        break;
      default:
        throw Error(s(314));
    }
    w !== null && w.delete(h), FC(f, A);
  }
  var UC;
  UC = function (f, h, A) {
    if (f !== null)
      if (f.memoizedProps !== h.pendingProps || yn.current) Di = !0;
      else {
        if (!(f.lanes & A) && !(h.flags & 128)) return (Di = !1), q4(f, h, A);
        Di = !!(f.flags & 131072);
      }
    else (Di = !1), xn && h.flags & 1048576 && bM(h, rm, h.index);
    switch (((h.lanes = 0), h.tag)) {
      case 2:
        var w = h.type;
        f !== null &&
          ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (f = h.pendingProps);
        var I = nn(h, Ln.current);
        Bn(h, A), (I = bx(null, h, w, f, I, A));
        var F = wx();
        return (
          (h.flags |= 1),
          typeof I == "object" &&
          I !== null &&
          typeof I.render == "function" &&
          I.$$typeof === void 0
            ? ((h.tag = 1),
              (h.memoizedState = null),
              (h.updateQueue = null),
              un(w) ? ((F = !0), Ko(h)) : (F = !1),
              (h.memoizedState =
                I.state !== null && I.state !== void 0 ? I.state : null),
              ux(h),
              (I.updater = tm),
              (h.stateNode = I),
              (I._reactInternals = h),
              dx(h, w, f, A),
              (h = Ix(null, h, w, !0, F, A)))
            : ((h.tag = 0), xn && F && hx(h), ti(null, h, I, A), (h = h.child)),
          h
        );
      case 16:
        w = h.elementType;
        e: {
          switch (
            (f !== null &&
              ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
            (f = h.pendingProps),
            (I = w._init),
            (w = I(w._payload)),
            (h.type = w),
            (I = h.tag = uk(w)),
            (f = Qr(w, f)),
            I)
          ) {
            case 0:
              h = Px(null, h, w, f, A);
              break e;
            case 1:
              h = aC(null, h, w, f, A);
              break e;
            case 11:
              h = nC(null, h, w, f, A);
              break e;
            case 14:
              h = rC(null, h, w, Qr(w.type, f), A);
              break e;
          }
          throw Error(s(306, w, ""));
        }
        return h;
      case 0:
        return (
          (w = h.type),
          (I = h.pendingProps),
          (I = h.elementType === w ? I : Qr(w, I)),
          Px(f, h, w, I, A)
        );
      case 1:
        return (
          (w = h.type),
          (I = h.pendingProps),
          (I = h.elementType === w ? I : Qr(w, I)),
          aC(f, h, w, I, A)
        );
      case 3:
        e: {
          if ((lC(h), f === null)) throw Error(s(387));
          (w = h.pendingProps),
            (F = h.memoizedState),
            (I = F.element),
            gM(f, h),
            em(h, w, null, A);
          var re = h.memoizedState;
          if (((w = re.element), pe && F.isDehydrated))
            if (
              ((F = {
                element: w,
                isDehydrated: !1,
                cache: re.cache,
                transitions: re.transitions,
              }),
              (h.updateQueue.baseState = F),
              (h.memoizedState = F),
              h.flags & 256)
            ) {
              (I = Error(s(423))), (h = cC(f, h, w, A, I));
              break e;
            } else if (w !== I) {
              (I = Error(s(424))), (h = cC(f, h, w, A, I));
              break e;
            } else
              for (
                pe &&
                  ((Ni = Vt(h.stateNode.containerInfo)),
                  (Oi = h),
                  (xn = !0),
                  (Mo = null),
                  (ed = !1)),
                  A = RM(h, null, w, A),
                  h.child = A;
                A;

              )
                (A.flags = (A.flags & -3) | 4096), (A = A.sibling);
          else {
            if ((Yc(), w === I)) {
              h = Rs(f, h, A);
              break e;
            }
            ti(f, h, w, A);
          }
          h = h.child;
        }
        return h;
      case 5:
        return (
          PM(h),
          f === null && gx(h),
          (w = h.type),
          (I = h.pendingProps),
          (F = f !== null ? f.memoizedProps : null),
          (re = I.children),
          X(w, I) ? (re = null) : F !== null && X(w, F) && (h.flags |= 32),
          sC(f, h),
          ti(f, h, re, A),
          h.child
        );
      case 6:
        return f === null && gx(h), null;
      case 13:
        return uC(f, h, A);
      case 4:
        return (
          yx(h, h.stateNode.containerInfo),
          (w = h.pendingProps),
          f === null ? (h.child = qc(h, null, w, A)) : ti(f, h, w, A),
          h.child
        );
      case 11:
        return (
          (w = h.type),
          (I = h.pendingProps),
          (I = h.elementType === w ? I : Qr(w, I)),
          nC(f, h, w, I, A)
        );
      case 7:
        return ti(f, h, h.pendingProps, A), h.child;
      case 8:
        return ti(f, h, h.pendingProps.children, A), h.child;
      case 12:
        return ti(f, h, h.pendingProps.children, A), h.child;
      case 10:
        e: {
          if (
            ((w = h.type._context),
            (I = h.pendingProps),
            (F = h.memoizedProps),
            (re = I.value),
            Jp(h, w, re),
            F !== null)
          )
            if (Ii(F.value, re)) {
              if (F.children === I.children && !yn.current) {
                h = Rs(f, h, A);
                break e;
              }
            } else
              for (F = h.child, F !== null && (F.return = h); F !== null; ) {
                var me = F.dependencies;
                if (me !== null) {
                  re = F.child;
                  for (var Ue = me.firstContext; Ue !== null; ) {
                    if (Ue.context === w) {
                      if (F.tag === 1) {
                        (Ue = Es(-1, A & -A)), (Ue.tag = 2);
                        var Ke = F.updateQueue;
                        if (Ke !== null) {
                          Ke = Ke.shared;
                          var ut = Ke.pending;
                          ut === null
                            ? (Ue.next = Ue)
                            : ((Ue.next = ut.next), (ut.next = Ue)),
                            (Ke.pending = Ue);
                        }
                      }
                      (F.lanes |= A),
                        (Ue = F.alternate),
                        Ue !== null && (Ue.lanes |= A),
                        ei(F.return, A, h),
                        (me.lanes |= A);
                      break;
                    }
                    Ue = Ue.next;
                  }
                } else if (F.tag === 10)
                  re = F.type === h.type ? null : F.child;
                else if (F.tag === 18) {
                  if (((re = F.return), re === null)) throw Error(s(341));
                  (re.lanes |= A),
                    (me = re.alternate),
                    me !== null && (me.lanes |= A),
                    ei(re, A, h),
                    (re = F.sibling);
                } else re = F.child;
                if (re !== null) re.return = F;
                else
                  for (re = F; re !== null; ) {
                    if (re === h) {
                      re = null;
                      break;
                    }
                    if (((F = re.sibling), F !== null)) {
                      (F.return = re.return), (re = F);
                      break;
                    }
                    re = re.return;
                  }
                F = re;
              }
          ti(f, h, I.children, A), (h = h.child);
        }
        return h;
      case 9:
        return (
          (I = h.type),
          (w = h.pendingProps.children),
          Bn(h, A),
          (I = Hn(I)),
          (w = w(I)),
          (h.flags |= 1),
          ti(f, h, w, A),
          h.child
        );
      case 14:
        return (
          (w = h.type),
          (I = Qr(w, h.pendingProps)),
          (I = Qr(w.type, I)),
          rC(f, h, w, I, A)
        );
      case 15:
        return iC(f, h, h.type, h.pendingProps, A);
      case 17:
        return (
          (w = h.type),
          (I = h.pendingProps),
          (I = h.elementType === w ? I : Qr(w, I)),
          f !== null &&
            ((f.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (h.tag = 1),
          un(w) ? ((f = !0), Ko(h)) : (f = !1),
          Bn(h, A),
          SM(h, w, I),
          dx(h, w, I, A),
          Ix(null, h, w, !0, f, A)
        );
      case 19:
        return pC(f, h, A);
      case 22:
        return oC(f, h, A);
    }
    throw Error(s(156, h.tag));
  };
  function kC(f, h) {
    return ws(f, h);
  }
  function ck(f, h, A, w) {
    (this.tag = f),
      (this.key = A),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = h),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = w),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function oo(f, h, A, w) {
    return new ck(f, h, A, w);
  }
  function Qx(f) {
    return (f = f.prototype), !(!f || !f.isReactComponent);
  }
  function uk(f) {
    if (typeof f == "function") return Qx(f) ? 1 : 0;
    if (f != null) {
      if (((f = f.$$typeof), f === _)) return 11;
      if (f === x) return 14;
    }
    return 2;
  }
  function ya(f, h) {
    var A = f.alternate;
    return (
      A === null
        ? ((A = oo(f.tag, h, f.key, f.mode)),
          (A.elementType = f.elementType),
          (A.type = f.type),
          (A.stateNode = f.stateNode),
          (A.alternate = f),
          (f.alternate = A))
        : ((A.pendingProps = h),
          (A.type = f.type),
          (A.flags = 0),
          (A.subtreeFlags = 0),
          (A.deletions = null)),
      (A.flags = f.flags & 14680064),
      (A.childLanes = f.childLanes),
      (A.lanes = f.lanes),
      (A.child = f.child),
      (A.memoizedProps = f.memoizedProps),
      (A.memoizedState = f.memoizedState),
      (A.updateQueue = f.updateQueue),
      (h = f.dependencies),
      (A.dependencies =
        h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }),
      (A.sibling = f.sibling),
      (A.index = f.index),
      (A.ref = f.ref),
      A
    );
  }
  function Dm(f, h, A, w, I, F) {
    var re = 2;
    if (((w = f), typeof f == "function")) Qx(f) && (re = 1);
    else if (typeof f == "string") re = 5;
    else
      e: switch (f) {
        case u:
          return Tl(A.children, I, F, h);
        case d:
          (re = 8), (I |= 8);
          break;
        case p:
          return (
            (f = oo(12, A, h, I | 2)), (f.elementType = p), (f.lanes = F), f
          );
        case y:
          return (f = oo(13, A, h, I)), (f.elementType = y), (f.lanes = F), f;
        case g:
          return (f = oo(19, A, h, I)), (f.elementType = g), (f.lanes = F), f;
        case b:
          return Fm(A, I, F, h);
        default:
          if (typeof f == "object" && f !== null)
            switch (f.$$typeof) {
              case m:
                re = 10;
                break e;
              case v:
                re = 9;
                break e;
              case _:
                re = 11;
                break e;
              case x:
                re = 14;
                break e;
              case S:
                (re = 16), (w = null);
                break e;
            }
          throw Error(s(130, f == null ? f : typeof f, ""));
      }
    return (
      (h = oo(re, A, h, I)), (h.elementType = f), (h.type = w), (h.lanes = F), h
    );
  }
  function Tl(f, h, A, w) {
    return (f = oo(7, f, w, h)), (f.lanes = A), f;
  }
  function Fm(f, h, A, w) {
    return (
      (f = oo(22, f, w, h)),
      (f.elementType = b),
      (f.lanes = A),
      (f.stateNode = {}),
      f
    );
  }
  function e1(f, h, A) {
    return (f = oo(6, f, null, h)), (f.lanes = A), f;
  }
  function t1(f, h, A) {
    return (
      (h = oo(4, f.children !== null ? f.children : [], f.key, h)),
      (h.lanes = A),
      (h.stateNode = {
        containerInfo: f.containerInfo,
        pendingChildren: null,
        implementation: f.implementation,
      }),
      h
    );
  }
  function fk(f, h, A, w, I) {
    (this.tag = h),
      (this.containerInfo = f),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Ie),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Vc(0)),
      (this.expirationTimes = Vc(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Vc(0)),
      (this.identifierPrefix = w),
      (this.onRecoverableError = I),
      pe && (this.mutableSourceEagerHydrationData = null);
  }
  function zC(f, h, A, w, I, F, re, me, Ue) {
    return (
      (f = new fk(f, h, A, me, Ue)),
      h === 1 ? ((h = 1), F === !0 && (h |= 8)) : (h = 0),
      (F = oo(3, null, null, h)),
      (f.current = F),
      (F.stateNode = f),
      (F.memoizedState = {
        element: w,
        isDehydrated: A,
        cache: null,
        transitions: null,
      }),
      ux(F),
      f
    );
  }
  function BC(f) {
    if (!f) return zn;
    f = f._reactInternals;
    e: {
      if (R(f) !== f || f.tag !== 1) throw Error(s(170));
      var h = f;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (un(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(s(171));
    }
    if (f.tag === 1) {
      var A = f.type;
      if (un(A)) return qo(f, A, h);
    }
    return h;
  }
  function HC(f) {
    var h = f._reactInternals;
    if (h === void 0)
      throw typeof f.render == "function"
        ? Error(s(188))
        : ((f = Object.keys(f).join(",")), Error(s(268, f)));
    return (f = D(h)), f === null ? null : f.stateNode;
  }
  function VC(f, h) {
    if (((f = f.memoizedState), f !== null && f.dehydrated !== null)) {
      var A = f.retryLane;
      f.retryLane = A !== 0 && A < h ? A : h;
    }
  }
  function n1(f, h) {
    VC(f, h), (f = f.alternate) && VC(f, h);
  }
  function dk(f) {
    return (f = D(f)), f === null ? null : f.stateNode;
  }
  function hk() {
    return null;
  }
  return (
    (n.attemptContinuousHydration = function (f) {
      if (f.tag === 13) {
        var h = ni();
        io(f, 134217728, h), n1(f, 134217728);
      }
    }),
    (n.attemptHydrationAtCurrentPriority = function (f) {
      if (f.tag === 13) {
        var h = ni(),
          A = ga(f);
        io(f, A, h), n1(f, A);
      }
    }),
    (n.attemptSynchronousHydration = function (f) {
      switch (f.tag) {
        case 3:
          var h = f.stateNode;
          if (h.current.memoizedState.isDehydrated) {
            var A = As(h.pendingLanes);
            A !== 0 && (Jo(h, A | 1), gi(h, An()), !(kt & 6) && (tu(), pi()));
          }
          break;
        case 13:
          var w = ni();
          PC(function () {
            return io(f, 1, w);
          }),
            n1(f, 1);
      }
    }),
    (n.batchedUpdates = function (f, h) {
      var A = kt;
      kt |= 1;
      try {
        return f(h);
      } finally {
        (kt = A), kt === 0 && (tu(), Qo && pi());
      }
    }),
    (n.createComponentSelector = function (f) {
      return { $$typeof: Sm, value: f };
    }),
    (n.createContainer = function (f, h, A, w, I, F, re) {
      return zC(f, h, !1, null, A, w, I, F, re);
    }),
    (n.createHasPseudoClassSelector = function (f) {
      return { $$typeof: Am, value: f };
    }),
    (n.createHydrationContainer = function (f, h, A, w, I, F, re, me, Ue) {
      return (
        (f = zC(A, w, !0, f, I, F, re, me, Ue)),
        (f.context = BC(null)),
        (A = f.current),
        (w = ni()),
        (I = ga(A)),
        (F = Es(w, I)),
        (F.callback = h ?? null),
        ha(A, F),
        (f.current.lanes = I),
        Zo(f, I, w),
        gi(f, w),
        f
      );
    }),
    (n.createPortal = function (f, h, A) {
      var w =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: c,
        key: w == null ? null : "" + w,
        children: f,
        containerInfo: h,
        implementation: A,
      };
    }),
    (n.createRoleSelector = function (f) {
      return { $$typeof: bm, value: f };
    }),
    (n.createTestNameSelector = function (f) {
      return { $$typeof: wm, value: f };
    }),
    (n.createTextSelector = function (f) {
      return { $$typeof: Em, value: f };
    }),
    (n.deferredUpdates = function (f) {
      var h = Ht,
        A = Vn.transition;
      try {
        return (Vn.transition = null), (Ht = 16), f();
      } finally {
        (Ht = h), (Vn.transition = A);
      }
    }),
    (n.discreteUpdates = function (f, h, A, w, I) {
      var F = Ht,
        re = Vn.transition;
      try {
        return (Vn.transition = null), (Ht = 1), f(h, A, w, I);
      } finally {
        (Ht = F), (Vn.transition = re), kt === 0 && tu();
      }
    }),
    (n.findAllNodes = Vx),
    (n.findBoundingRects = function (f, h) {
      if (!k) throw Error(s(363));
      (h = Vx(f, h)), (f = []);
      for (var A = 0; A < h.length; A++) f.push(fe(h[A]));
      for (h = f.length - 1; 0 < h; h--) {
        A = f[h];
        for (
          var w = A.x, I = w + A.width, F = A.y, re = F + A.height, me = h - 1;
          0 <= me;
          me--
        )
          if (h !== me) {
            var Ue = f[me],
              Ke = Ue.x,
              ut = Ke + Ue.width,
              Pt = Ue.y,
              St = Pt + Ue.height;
            if (w >= Ke && F >= Pt && I <= ut && re <= St) {
              f.splice(h, 1);
              break;
            } else if (w !== Ke || A.width !== Ue.width || St < F || Pt > re) {
              if (!(F !== Pt || A.height !== Ue.height || ut < w || Ke > I)) {
                Ke > w && ((Ue.width += Ke - w), (Ue.x = w)),
                  ut < I && (Ue.width = I - Ke),
                  f.splice(h, 1);
                break;
              }
            } else {
              Pt > F && ((Ue.height += Pt - F), (Ue.y = F)),
                St < re && (Ue.height = re - Pt),
                f.splice(h, 1);
              break;
            }
          }
      }
      return f;
    }),
    (n.findHostInstance = HC),
    (n.findHostInstanceWithNoPortals = function (f) {
      return (
        (f = O(f)),
        (f = f !== null ? z(f) : null),
        f === null ? null : f.stateNode
      );
    }),
    (n.findHostInstanceWithWarning = function (f) {
      return HC(f);
    }),
    (n.flushControlled = function (f) {
      var h = kt;
      kt |= 1;
      var A = Vn.transition,
        w = Ht;
      try {
        (Vn.transition = null), (Ht = 1), f();
      } finally {
        (Ht = w), (Vn.transition = A), (kt = h), kt === 0 && (tu(), pi());
      }
    }),
    (n.flushPassiveEffects = Cl),
    (n.flushSync = PC),
    (n.focusWithin = function (f, h) {
      if (!k) throw Error(s(363));
      for (f = zx(f), h = CC(f, h), h = Array.from(h), f = 0; f < h.length; ) {
        var A = h[f++];
        if (!ce(A)) {
          if (A.tag === 5 && Be(A.stateNode)) return !0;
          for (A = A.child; A !== null; ) h.push(A), (A = A.sibling);
        }
      }
      return !1;
    }),
    (n.getCurrentUpdatePriority = function () {
      return Ht;
    }),
    (n.getFindAllNodesFailureDescription = function (f, h) {
      if (!k) throw Error(s(363));
      var A = 0,
        w = [];
      f = [zx(f), 0];
      for (var I = 0; I < f.length; ) {
        var F = f[I++],
          re = f[I++],
          me = h[re];
        if (
          (F.tag !== 5 || !ce(F)) &&
          (Bx(F, me) && (w.push(Hx(me)), re++, re > A && (A = re)),
          re < h.length)
        )
          for (F = F.child; F !== null; ) f.push(F, re), (F = F.sibling);
      }
      if (A < h.length) {
        for (f = []; A < h.length; A++) f.push(Hx(h[A]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (w.join(" > ") +
            `

No matching component was found for:
  `) +
          f.join(" > ")
        );
      }
      return null;
    }),
    (n.getPublicRootInstance = function (f) {
      if (((f = f.current), !f.child)) return null;
      switch (f.child.tag) {
        case 5:
          return G(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }),
    (n.injectIntoDevTools = function (f) {
      if (
        ((f = {
          bundleType: f.bundleType,
          version: f.version,
          rendererPackageName: f.rendererPackageName,
          rendererConfig: f.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: dk,
          findFiberByHostInstance: f.findFiberByHostInstance || hk,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        f = !1;
      else {
        var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (h.isDisabled || !h.supportsFiber) f = !0;
        else {
          try {
            (gl = h.inject(f)), (Pi = h);
          } catch {}
          f = !!h.checkDCE;
        }
      }
      return f;
    }),
    (n.isAlreadyRendering = function () {
      return !1;
    }),
    (n.observeVisibleRects = function (f, h, A, w) {
      if (!k) throw Error(s(363));
      f = Vx(f, h);
      var I = Me(f, A, w).disconnect;
      return {
        disconnect: function () {
          I();
        },
      };
    }),
    (n.registerMutableSourceForHydration = function (f, h) {
      var A = h._getVersion;
      (A = A(h._source)),
        f.mutableSourceEagerHydrationData == null
          ? (f.mutableSourceEagerHydrationData = [h, A])
          : f.mutableSourceEagerHydrationData.push(h, A);
    }),
    (n.runWithPriority = function (f, h) {
      var A = Ht;
      try {
        return (Ht = f), h();
      } finally {
        Ht = A;
      }
    }),
    (n.shouldError = function () {
      return null;
    }),
    (n.shouldSuspend = function () {
      return !1;
    }),
    (n.updateContainer = function (f, h, A, w) {
      var I = h.current,
        F = ni(),
        re = ga(I);
      return (
        (A = BC(A)),
        h.context === null ? (h.context = A) : (h.pendingContext = A),
        (h = Es(F, re)),
        (h.payload = { element: f }),
        (w = w === void 0 ? null : w),
        w !== null && (h.callback = w),
        ha(I, h),
        (f = io(I, re, F)),
        f !== null && Qp(f, I, re),
        re
      );
    }),
    n
  );
};
TD.exports = u9;
var f9 = TD.exports;
const d9 = Ap(f9),
  DE = {},
  h9 = (t) => void Object.assign(DE, t);
function p9(t, e) {
  function n(u, { args: d = [], attach: p, ...m }, v) {
    let _ = `${u[0].toUpperCase()}${u.slice(1)}`,
      y;
    if (u === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      y = Lu(g, { type: u, root: v, attach: p, primitive: !0 });
    } else {
      const g = DE[_];
      if (!g)
        throw new Error(
          `R3F: ${_} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      y = Lu(new g(...d), {
        type: u,
        root: v,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      y.__r3f.attach === void 0 &&
        (y.isBufferGeometry
          ? (y.__r3f.attach = "geometry")
          : y.isMaterial && (y.__r3f.attach = "material")),
      _ !== "inject" && y_(y, m),
      y
    );
  }
  function r(u, d) {
    let p = !1;
    if (d) {
      var m, v;
      (m = d.__r3f) != null && m.attach
        ? v_(u, d, d.__r3f.attach)
        : d.isObject3D && u.isObject3D && (u.add(d), (p = !0)),
        p || (v = u.__r3f) == null || v.objects.push(d),
        d.__r3f || Lu(d, {}),
        (d.__r3f.parent = u),
        GA(d),
        Ou(d);
    }
  }
  function i(u, d, p) {
    let m = !1;
    if (d) {
      var v, _;
      if ((v = d.__r3f) != null && v.attach) v_(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        (d.parent = u),
          d.dispatchEvent({ type: "added" }),
          u.dispatchEvent({ type: "childadded", child: d });
        const y = u.children.filter((x) => x !== d),
          g = y.indexOf(p);
        (u.children = [...y.slice(0, g), d, ...y.slice(g)]), (m = !0);
      }
      m || (_ = u.__r3f) == null || _.objects.push(d),
        d.__r3f || Lu(d, {}),
        (d.__r3f.parent = u),
        GA(d),
        Ou(d);
    }
  }
  function o(u, d, p = !1) {
    u && [...u].forEach((m) => s(d, m, p));
  }
  function s(u, d, p) {
    if (d) {
      var m, v, _;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = u.__r3f) != null &&
          m.objects &&
          (u.__r3f.objects = u.__r3f.objects.filter((b) => b !== d)),
        (v = d.__r3f) != null && v.attach)
      )
        FR(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        var y;
        u.remove(d), (y = d.__r3f) != null && y.root && A9(I0(d), d);
      }
      const x = (_ = d.__r3f) == null ? void 0 : _.primitive,
        S = !x && (p === void 0 ? d.dispose !== null : p);
      if (!x) {
        var g;
        o((g = d.__r3f) == null ? void 0 : g.objects, d, S),
          o(d.children, d, S);
      }
      if ((delete d.__r3f, S && d.dispose && d.type !== "Scene")) {
        const b = () => {
          try {
            d.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? HA.unstable_scheduleCallback(HA.unstable_IdlePriority, b)
          : b();
      }
      Ou(u);
    }
  }
  function a(u, d, p, m) {
    var v;
    const _ = (v = u.__r3f) == null ? void 0 : v.parent;
    if (!_) return;
    const y = n(d, p, u.__r3f.root);
    if (u.children) {
      for (const g of u.children) g.__r3f && r(y, g);
      u.children = u.children.filter((g) => !g.__r3f);
    }
    u.__r3f.objects.forEach((g) => r(y, g)),
      (u.__r3f.objects = []),
      u.__r3f.autoRemovedBeforeAppend || s(_, u),
      y.parent && (y.__r3f.autoRemovedBeforeAppend = !0),
      r(_, y),
      y.raycast &&
        y.__r3f.eventCount &&
        I0(y).getState().internal.interaction.push(y),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = y),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(y) : (g.ref.current = y)));
      });
  }
  const l = () => {};
  return {
    reconciler: d9({
      createInstance: n,
      removeChild: s,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (u, d) => {
        if (!d) return;
        const p = u.getState().scene;
        p.__r3f && ((p.__r3f.root = u), r(p, d));
      },
      removeChildFromContainer: (u, d) => {
        d && s(u.getState().scene, d);
      },
      insertInContainerBefore: (u, d, p) => {
        if (!d || !p) return;
        const m = u.getState().scene;
        m.__r3f && i(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (u) => u,
      finalizeInitialChildren(u) {
        var d;
        return !!((d = u == null ? void 0 : u.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(u, d, p, m) {
        var v;
        if (
          ((v = u == null ? void 0 : u.__r3f) != null ? v : {}).primitive &&
          m.object &&
          m.object !== u
        )
          return [!0];
        {
          const { args: y = [], children: g, ...x } = m,
            { args: S = [], children: b, ...C } = p;
          if (!Array.isArray(y))
            throw new Error("R3F: the args prop must be an array!");
          if (y.some((T, P) => T !== S[P])) return [!0];
          const M = UD(u, x, C, !0);
          return M.changes.length ? [!1, M] : null;
        }
      },
      commitUpdate(u, [d, p], m, v, _, y) {
        d ? a(u, m, _, y) : y_(u, p);
      },
      commitMount(u, d, p, m) {
        var v;
        const _ = (v = u.__r3f) != null ? v : {};
        u.raycast &&
          _.handlers &&
          _.eventCount &&
          I0(u).getState().internal.interaction.push(u);
      },
      getPublicInstance: (u) => u,
      prepareForCommit: () => null,
      preparePortalMount: (u) => Lu(u.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(u) {
        var d;
        const { attach: p, parent: m } = (d = u.__r3f) != null ? d : {};
        p && m && FR(m, u, p), u.isObject3D && (u.visible = !1), Ou(u);
      },
      unhideInstance(u, d) {
        var p;
        const { attach: m, parent: v } = (p = u.__r3f) != null ? p : {};
        m && v && v_(v, u, m),
          ((u.isObject3D && d.visible == null) || d.visible) &&
            (u.visible = !0),
          Ou(u);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Zu.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && pn.fun(performance.now)
          ? performance.now
          : pn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: pn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: pn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: y_,
  };
}
var LR, OR;
const g_ = (t) => "colorSpace" in t || "outputColorSpace" in t,
  ID = () => {
    var t;
    return (t = DE.ColorManagement) != null ? t : null;
  },
  LD = (t) => t && t.isOrthographicCamera,
  m9 = (t) => t && t.hasOwnProperty("current"),
  zp =
    typeof window < "u" &&
    (((LR = window.document) != null && LR.createElement) ||
      ((OR = window.navigator) == null ? void 0 : OR.product) === "ReactNative")
      ? L.useLayoutEffect
      : L.useEffect;
function OD(t) {
  const e = L.useRef(t);
  return zp(() => void (e.current = t), [t]), e;
}
function g9({ set: t }) {
  return zp(() => (t(new Promise(() => null)), () => t(!1)), [t]), null;
}
class ND extends L.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
ND.getDerivedStateFromError = () => ({ error: !0 });
const DD = "__default",
  NR = new Map(),
  v9 = (t) => t && !!t.memoized && !!t.changes;
function FD(t) {
  var e;
  const n =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(t) ? Math.min(Math.max(t[0], n), t[1]) : t;
}
const Ud = (t) => {
  var e;
  return (e = t.__r3f) == null ? void 0 : e.root.getState();
};
function I0(t) {
  let e = t.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const pn = {
  obj: (t) => t === Object(t) && !pn.arr(t) && typeof t != "function",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  boo: (t) => typeof t == "boolean",
  und: (t) => t === void 0,
  arr: (t) => Array.isArray(t),
  equ(
    t,
    e,
    { arrays: n = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof t != typeof e || !!t != !!e) return !1;
    if (pn.str(t) || pn.num(t) || pn.boo(t)) return t === e;
    const o = pn.obj(t);
    if (o && r === "reference") return t === e;
    const s = pn.arr(t);
    if (s && n === "reference") return t === e;
    if ((s || o) && t === e) return !0;
    let a;
    for (a in t) if (!(a in e)) return !1;
    if (o && n === "shallow" && r === "shallow") {
      for (a in i ? e : t)
        if (!pn.equ(t[a], e[a], { strict: i, objects: "reference" })) return !1;
    } else for (a in i ? e : t) if (t[a] !== e[a]) return !1;
    if (pn.und(a)) {
      if (
        (s && t.length === 0 && e.length === 0) ||
        (o && Object.keys(t).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (t !== e) return !1;
    }
    return !0;
  },
};
function y9(t) {
  const e = { nodes: {}, materials: {} };
  return (
    t &&
      t.traverse((n) => {
        n.name && (e.nodes[n.name] = n),
          n.material &&
            !e.materials[n.material.name] &&
            (e.materials[n.material.name] = n.material);
      }),
    e
  );
}
function x9(t) {
  t.dispose && t.type !== "Scene" && t.dispose();
  for (const e in t) e.dispose == null || e.dispose(), delete t[e];
}
function Lu(t, e) {
  const n = t;
  return (
    (n.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    t
  );
}
function VA(t, e) {
  let n = t;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (n = r.reduce((o, s) => o[s], t)), { target: n, key: i };
  } else return { target: n, key: e };
}
const DR = /-\d+$/;
function v_(t, e, n) {
  if (pn.str(n)) {
    if (DR.test(n)) {
      const o = n.replace(DR, ""),
        { target: s, key: a } = VA(t, o);
      Array.isArray(s[a]) || (s[a] = []);
    }
    const { target: r, key: i } = VA(t, n);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = n(t, e);
}
function FR(t, e, n) {
  var r, i;
  if (pn.str(n)) {
    const { target: o, key: s } = VA(t, n),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete o[s] : (o[s] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(t, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function UD(
  t,
  { children: e, key: n, ref: r, ...i },
  { children: o, key: s, ref: a, ...l } = {},
  c = !1
) {
  const u = t.__r3f,
    d = Object.entries(i),
    p = [];
  if (c) {
    const v = Object.keys(l);
    for (let _ = 0; _ < v.length; _++)
      i.hasOwnProperty(v[_]) || d.unshift([v[_], DD + "remove"]);
  }
  d.forEach(([v, _]) => {
    var y;
    if (
      ((y = t.__r3f) != null && y.primitive && v === "object") ||
      pn.equ(_, l[v])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
      return p.push([v, _, !0, []]);
    let g = [];
    v.includes("-") && (g = v.split("-")), p.push([v, _, !1, g]);
    for (const x in i) {
      const S = i[x];
      x.startsWith(`${v}-`) && p.push([x, S, !1, x.split("-")]);
    }
  });
  const m = { ...i };
  return (
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.args &&
      (m.args = u.memoizedProps.args),
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.attach &&
      (m.attach = u.memoizedProps.attach),
    { memoized: m, changes: p }
  );
}
function y_(t, e) {
  var n;
  const r = t.__r3f,
    i = r == null ? void 0 : r.root,
    o = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: s, changes: a } = v9(e) ? e : UD(t, e),
    l = r == null ? void 0 : r.eventCount;
  t.__r3f && (t.__r3f.memoizedProps = s);
  for (let p = 0; p < a.length; p++) {
    let [m, v, _, y] = a[p];
    if (g_(t)) {
      const b = "srgb",
        C = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (v = v === 3001 ? b : C))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (v = v === 3001 ? b : C));
    }
    let g = t,
      x = g[m];
    if (y.length && ((x = y.reduce((S, b) => S[b], t)), !(x && x.set))) {
      const [S, ...b] = y.reverse();
      (g = b.reverse().reduce((C, M) => C[M], t)), (m = S);
    }
    if (v === DD + "remove")
      if (g.constructor) {
        let S = NR.get(g.constructor);
        S || ((S = new g.constructor()), NR.set(g.constructor, S)), (v = S[m]);
      } else v = 0;
    if (_ && r)
      v ? (r.handlers[m] = v) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (x && x.set && (x.copy || x instanceof hc)) {
      if (Array.isArray(v)) x.fromArray ? x.fromArray(v) : x.set(...v);
      else if (x.copy && v && v.constructor && x.constructor === v.constructor)
        x.copy(v);
      else if (v !== void 0) {
        var c;
        const S = (c = x) == null ? void 0 : c.isColor;
        !S && x.setScalar
          ? x.setScalar(v)
          : x instanceof hc && v instanceof hc
          ? (x.mask = v.mask)
          : x.set(v),
          !ID() && o && !o.linear && S && x.convertSRGBToLinear();
      }
    } else {
      var u;
      if (
        ((g[m] = v),
        (u = g[m]) != null &&
          u.isTexture &&
          g[m].format === Si &&
          g[m].type === gs &&
          o)
      ) {
        const S = g[m];
        g_(S) && g_(o.gl)
          ? (S.colorSpace = o.gl.outputColorSpace)
          : (S.encoding = o.gl.outputEncoding);
      }
    }
    Ou(t);
  }
  if (r && r.parent && t.raycast && l !== r.eventCount) {
    const p = I0(t).getState().internal,
      m = p.interaction.indexOf(t);
    m > -1 && p.interaction.splice(m, 1), r.eventCount && p.interaction.push(t);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (n = t.__r3f) != null &&
      n.parent &&
      GA(t),
    t
  );
}
function Ou(t) {
  var e, n;
  const r =
    (e = t.__r3f) == null || (n = e.root) == null || n.getState == null
      ? void 0
      : n.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function GA(t) {
  t.onUpdate == null || t.onUpdate(t);
}
function _9(t, e) {
  t.manual ||
    (LD(t)
      ? ((t.left = e.width / -2),
        (t.right = e.width / 2),
        (t.top = e.height / 2),
        (t.bottom = e.height / -2))
      : (t.aspect = e.width / e.height),
    t.updateProjectionMatrix(),
    t.updateMatrixWorld());
}
function $g(t) {
  return (t.eventObject || t.object).uuid + "/" + t.index + t.instanceId;
}
function S9() {
  var t;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Zu.DefaultEventPriority;
  switch ((t = e.event) == null ? void 0 : t.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Zu.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Zu.ContinuousEventPriority;
    default:
      return Zu.DefaultEventPriority;
  }
}
function kD(t, e, n, r) {
  const i = n.get(e);
  i &&
    (n.delete(e),
    n.size === 0 && (t.delete(r), i.target.releasePointerCapture(r)));
}
function A9(t, e) {
  const { internal: n } = t.getState();
  (n.interaction = n.interaction.filter((r) => r !== e)),
    (n.initialHits = n.initialHits.filter((r) => r !== e)),
    n.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && n.hovered.delete(i);
    }),
    n.capturedMap.forEach((r, i) => {
      kD(n.capturedMap, e, r, i);
    });
}
function b9(t) {
  function e(l) {
    const { internal: c } = t.getState(),
      u = l.offsetX - c.initialClick[0],
      d = l.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(u * u + d * d));
  }
  function n(l) {
    return l.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((u) => {
        var d;
        return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + u];
      })
    );
  }
  function r(l, c) {
    const u = t.getState(),
      d = new Set(),
      p = [],
      m = c ? c(u.internal.interaction) : u.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const x = Ud(m[g]);
      x && (x.raycaster.camera = void 0);
    }
    u.previousRoot || u.events.compute == null || u.events.compute(l, u);
    function v(g) {
      const x = Ud(g);
      if (!x || !x.events.enabled || x.raycaster.camera === null) return [];
      if (x.raycaster.camera === void 0) {
        var S;
        x.events.compute == null ||
          x.events.compute(
            l,
            x,
            (S = x.previousRoot) == null ? void 0 : S.getState()
          ),
          x.raycaster.camera === void 0 && (x.raycaster.camera = null);
      }
      return x.raycaster.camera ? x.raycaster.intersectObject(g, !0) : [];
    }
    let _ = m
      .flatMap(v)
      .sort((g, x) => {
        const S = Ud(g.object),
          b = Ud(x.object);
        return !S || !b
          ? g.distance - x.distance
          : b.events.priority - S.events.priority || g.distance - x.distance;
      })
      .filter((g) => {
        const x = $g(g);
        return d.has(x) ? !1 : (d.add(x), !0);
      });
    u.events.filter && (_ = u.events.filter(_, u));
    for (const g of _) {
      let x = g.object;
      for (; x; ) {
        var y;
        (y = x.__r3f) != null &&
          y.eventCount &&
          p.push({ ...g, eventObject: x }),
          (x = x.parent);
      }
    }
    if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId))
      for (let g of u.internal.capturedMap.get(l.pointerId).values())
        d.has($g(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function i(l, c, u, d) {
    const p = t.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const v of l) {
        const _ = Ud(v.object) || p,
          { raycaster: y, pointer: g, camera: x, internal: S } = _,
          b = new ee(g.x, g.y, 0).unproject(x),
          C = (E) => {
            var O, D;
            return (O =
              (D = S.capturedMap.get(E)) == null
                ? void 0
                : D.has(v.eventObject)) != null
              ? O
              : !1;
          },
          M = (E) => {
            const O = { intersection: v, target: c.target };
            S.capturedMap.has(E)
              ? S.capturedMap.get(E).set(v.eventObject, O)
              : S.capturedMap.set(E, new Map([[v.eventObject, O]])),
              c.target.setPointerCapture(E);
          },
          T = (E) => {
            const O = S.capturedMap.get(E);
            O && kD(S.capturedMap, v.eventObject, O, E);
          };
        let P = {};
        for (let E in c) {
          let O = c[E];
          typeof O != "function" && (P[E] = O);
        }
        let R = {
          ...v,
          ...P,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: u,
          unprojectedPoint: b,
          ray: y.ray,
          camera: x,
          stopPropagation() {
            const E = "pointerId" in c && S.capturedMap.get(c.pointerId);
            if (
              (!E || E.has(v.eventObject)) &&
              ((R.stopped = m.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (O) => O.eventObject === v.eventObject
                ))
            ) {
              const O = l.slice(0, l.indexOf(v));
              o([...O, v]);
            }
          },
          target: {
            hasPointerCapture: C,
            setPointerCapture: M,
            releasePointerCapture: T,
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: M,
            releasePointerCapture: T,
          },
          nativeEvent: c,
        };
        if ((d(R), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function o(l) {
    const { internal: c } = t.getState();
    for (const u of c.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === u.object &&
            d.index === u.index &&
            d.instanceId === u.instanceId
        )
      ) {
        const p = u.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((c.hovered.delete($g(u)), p != null && p.eventCount)) {
          const v = { ...u, intersections: l };
          m.onPointerOut == null || m.onPointerOut(v),
            m.onPointerLeave == null || m.onPointerLeave(v);
        }
      }
  }
  function s(l, c) {
    for (let u = 0; u < c.length; u++) {
      const d = c[u].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => o([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: u } = t.getState();
          "pointerId" in c &&
            u.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              u.capturedMap.has(c.pointerId) &&
                (u.capturedMap.delete(c.pointerId), o([]));
            });
        };
    }
    return function (u) {
      const { onPointerMissed: d, internal: p } = t.getState();
      p.lastEvent.current = u;
      const m = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        y = r(u, m ? n : void 0),
        g = v ? e(u) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [u.offsetX, u.offsetY]),
        (p.initialHits = y.map((S) => S.eventObject))),
        v && !y.length && g <= 2 && (s(u, p.interaction), d && d(u)),
        m && o(y);
      function x(S) {
        const b = S.eventObject,
          C = b.__r3f,
          M = C == null ? void 0 : C.handlers;
        if (C != null && C.eventCount)
          if (m) {
            if (
              M.onPointerOver ||
              M.onPointerEnter ||
              M.onPointerOut ||
              M.onPointerLeave
            ) {
              const T = $g(S),
                P = p.hovered.get(T);
              P
                ? P.stopped && S.stopPropagation()
                : (p.hovered.set(T, S),
                  M.onPointerOver == null || M.onPointerOver(S),
                  M.onPointerEnter == null || M.onPointerEnter(S));
            }
            M.onPointerMove == null || M.onPointerMove(S);
          } else {
            const T = M[l];
            T
              ? (!v || p.initialHits.includes(b)) &&
                (s(
                  u,
                  p.interaction.filter((P) => !p.initialHits.includes(P))
                ),
                T(S))
              : v &&
                p.initialHits.includes(b) &&
                s(
                  u,
                  p.interaction.filter((P) => !p.initialHits.includes(P))
                );
          }
      }
      i(y, u, g, x);
    };
  }
  return { handlePointer: a };
}
const zD = (t) => !!(t != null && t.render),
  BD = L.createContext(null),
  w9 = (t, e) => {
    const n = s9((a, l) => {
        const c = new ee(),
          u = new ee(),
          d = new ee();
        function p(g = l().camera, x = u, S = l().size) {
          const { width: b, height: C, top: M, left: T } = S,
            P = b / C;
          x.isVector3 ? d.copy(x) : d.set(...x);
          const R = g.getWorldPosition(c).distanceTo(d);
          if (LD(g))
            return {
              width: b / g.zoom,
              height: C / g.zoom,
              top: M,
              left: T,
              factor: 1,
              distance: R,
              aspect: P,
            };
          {
            const E = (g.fov * Math.PI) / 180,
              O = 2 * Math.tan(E / 2) * R,
              D = O * (b / C);
            return {
              width: D,
              height: O,
              top: M,
              left: T,
              factor: b / D,
              distance: R,
              aspect: P,
            };
          }
        }
        let m;
        const v = (g) =>
            a((x) => ({ performance: { ...x.performance, current: g } })),
          _ = new ke();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => t(l(), g),
          advance: (g, x) => e(g, x, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new IE(),
          pointer: _,
          mouse: _,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  v(g.performance.min),
                (m = setTimeout(
                  () => v(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((x) => ({ ...x, events: { ...x.events, ...g } })),
          setSize: (g, x, S, b, C) => {
            const M = l().camera,
              T = {
                width: g,
                height: x,
                top: b || 0,
                left: C || 0,
                updateStyle: S,
              };
            a((P) => ({ size: T, viewport: { ...P.viewport, ...p(M, u, T) } }));
          },
          setDpr: (g) =>
            a((x) => {
              const S = FD(g);
              return {
                viewport: {
                  ...x.viewport,
                  dpr: S,
                  initialDpr: x.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const x = l().clock;
            x.stop(),
              (x.elapsedTime = 0),
              g !== "never" && (x.start(), (x.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: L.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, x, S) => {
              const b = l().internal;
              return (
                (b.priority = b.priority + (x > 0 ? 1 : 0)),
                b.subscribers.push({ ref: g, priority: x, store: S }),
                (b.subscribers = b.subscribers.sort(
                  (C, M) => C.priority - M.priority
                )),
                () => {
                  const C = l().internal;
                  C != null &&
                    C.subscribers &&
                    ((C.priority = C.priority - (x > 0 ? 1 : 0)),
                    (C.subscribers = C.subscribers.filter((M) => M.ref !== g)));
                }
              );
            },
          },
        };
      }),
      r = n.getState();
    let i = r.size,
      o = r.viewport.dpr,
      s = r.camera;
    return (
      n.subscribe(() => {
        const { camera: a, size: l, viewport: c, gl: u, set: d } = n.getState();
        if (l.width !== i.width || l.height !== i.height || c.dpr !== o) {
          var p;
          (i = l), (o = c.dpr), _9(a, l), u.setPixelRatio(c.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                u.domElement instanceof HTMLCanvasElement;
          u.setSize(l.width, l.height, m);
        }
        a !== s &&
          ((s = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      n.subscribe((a) => t(a)),
      n
    );
  };
let Xg,
  E9 = new Set(),
  M9 = new Set(),
  C9 = new Set();
function x_(t, e) {
  if (t.size) for (const { callback: n } of t.values()) n(e);
}
function kd(t, e) {
  switch (t) {
    case "before":
      return x_(E9, e);
    case "after":
      return x_(M9, e);
    case "tail":
      return x_(C9, e);
  }
}
let __, S_;
function A_(t, e, n) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof t == "number" &&
      ((r = t - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = t)),
      __ = e.internal.subscribers,
      Xg = 0;
    Xg < __.length;
    Xg++
  )
    (S_ = __[Xg]), S_.ref.current(S_.store.getState(), r, n);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function T9(t) {
  let e = !1,
    n = !1,
    r,
    i,
    o;
  function s(c) {
    (i = requestAnimationFrame(s)),
      (e = !0),
      (r = 0),
      kd("before", c),
      (n = !0);
    for (const d of t.values()) {
      var u;
      (o = d.store.getState()),
        o.internal.active &&
          (o.frameloop === "always" || o.internal.frames > 0) &&
          !((u = o.gl.xr) != null && u.isPresenting) &&
          (r += A_(c, o));
    }
    if (((n = !1), kd("after", c), r === 0))
      return kd("tail", c), (e = !1), cancelAnimationFrame(i);
  }
  function a(c, u = 1) {
    var d;
    if (!c) return t.forEach((p) => a(p.store.getState(), u));
    ((d = c.gl.xr) != null && d.isPresenting) ||
      !c.internal.active ||
      c.frameloop === "never" ||
      (u > 1
        ? (c.internal.frames = Math.min(60, c.internal.frames + u))
        : n
        ? (c.internal.frames = 2)
        : (c.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function l(c, u = !0, d, p) {
    if ((u && kd("before", c), d)) A_(c, d, p);
    else for (const m of t.values()) A_(c, m.store.getState());
    u && kd("after", c);
  }
  return { loop: s, invalidate: a, advance: l };
}
function HD() {
  const t = L.useContext(BD);
  if (!t)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return t;
}
function os(t = (n) => n, e) {
  return HD()(t, e);
}
function FE(t, e = 0) {
  const n = HD(),
    r = n.getState().internal.subscribe,
    i = OD(t);
  return zp(() => r(i, e, n), [e, r, n]), null;
}
const UR = new WeakMap();
function VD(t, e) {
  return function (n, ...r) {
    let i = UR.get(n);
    return (
      i || ((i = new n()), UR.set(n, i)),
      t && t(i),
      Promise.all(
        r.map(
          (o) =>
            new Promise((s, a) =>
              i.load(
                o,
                (l) => {
                  l.scene && Object.assign(l, y9(l.scene)), s(l);
                },
                e,
                (l) =>
                  a(
                    new Error(
                      `Could not load ${o}: ${l == null ? void 0 : l.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function oc(t, e, n, r) {
  const i = Array.isArray(e) ? e : [e],
    o = CD(VD(n, r), [t, ...i], { equal: pn.equ });
  return Array.isArray(e) ? o : o[0];
}
oc.preload = function (t, e, n) {
  const r = Array.isArray(e) ? e : [e];
  return l9(VD(n), [t, ...r]);
};
oc.clear = function (t, e) {
  const n = Array.isArray(e) ? e : [e];
  return c9([t, ...n]);
};
const Sf = new Map(),
  { invalidate: kR, advance: zR } = T9(Sf),
  { reconciler: yv, applyProps: Eu } = p9(Sf, S9),
  Mu = { objects: "shallow", strict: !1 },
  R9 = (t, e) => {
    const n = typeof t == "function" ? t(e) : t;
    return zD(n)
      ? n
      : new PN({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...t,
        });
  };
function P9(t, e) {
  const n = typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: o, left: s, updateStyle: a = n } = e;
    return { width: r, height: i, top: o, left: s, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    t instanceof HTMLCanvasElement &&
    t.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: o,
      left: s,
    } = t.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: o, left: s, updateStyle: n };
  } else if (typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
    return {
      width: t.width,
      height: t.height,
      top: 0,
      left: 0,
      updateStyle: n,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function I9(t) {
  const e = Sf.get(t),
    n = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    o = r || w9(kR, zR),
    s =
      n ||
      yv.createContainer(o, Zu.ConcurrentRoot, null, !1, null, "", i, null);
  e || Sf.set(t, { fiber: s, store: o });
  let a,
    l = !1,
    c;
  return {
    configure(u = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: v,
          onCreated: _,
          shadows: y = !1,
          linear: g = !1,
          flat: x = !1,
          legacy: S = !1,
          orthographic: b = !1,
          frameloop: C = "always",
          dpr: M = [1, 2],
          performance: T,
          raycaster: P,
          camera: R,
          onPointerMissed: E,
        } = u,
        O = o.getState(),
        D = O.gl;
      O.gl || O.set({ gl: (D = R9(d, t)) });
      let N = O.raycaster;
      N || O.set({ raycaster: (N = new AD()) });
      const { params: z, ...V } = P || {};
      if (
        (pn.equ(V, N, Mu) || Eu(N, { ...V }),
        pn.equ(z, N.params, Mu) || Eu(N, { params: { ...N.params, ...z } }),
        !O.camera || (O.camera === c && !pn.equ(c, R, Mu)))
      ) {
        c = R;
        const W = R instanceof Lp,
          B = W
            ? R
            : b
            ? new ps(0, 0, 0, 0, 0.1, 1e3)
            : new En(75, 0, 0.1, 1e3);
        W ||
          ((B.position.z = 5),
          R &&
            (Eu(B, R),
            ("aspect" in R ||
              "left" in R ||
              "right" in R ||
              "bottom" in R ||
              "top" in R) &&
              ((B.manual = !0), B.updateProjectionMatrix())),
          !O.camera && !(R != null && R.rotation) && B.lookAt(0, 0, 0)),
          O.set({ camera: B }),
          (N.camera = B);
      }
      if (!O.scene) {
        let W;
        m != null && m.isScene ? (W = m) : ((W = new hE()), m && Eu(W, m)),
          O.set({ scene: Lu(W) });
      }
      if (!O.xr) {
        var G;
        const W = (Z, H) => {
            const X = o.getState();
            X.frameloop !== "never" && zR(Z, !0, X, H);
          },
          B = () => {
            const Z = o.getState();
            (Z.gl.xr.enabled = Z.gl.xr.isPresenting),
              Z.gl.xr.setAnimationLoop(Z.gl.xr.isPresenting ? W : null),
              Z.gl.xr.isPresenting || kR(Z);
          },
          q = {
            connect() {
              const Z = o.getState().gl;
              Z.xr.addEventListener("sessionstart", B),
                Z.xr.addEventListener("sessionend", B);
            },
            disconnect() {
              const Z = o.getState().gl;
              Z.xr.removeEventListener("sessionstart", B),
                Z.xr.removeEventListener("sessionend", B);
            },
          };
        typeof ((G = D.xr) == null ? void 0 : G.addEventListener) ==
          "function" && q.connect(),
          O.set({ xr: q });
      }
      if (D.shadowMap) {
        const W = D.shadowMap.enabled,
          B = D.shadowMap.type;
        if (((D.shadowMap.enabled = !!y), pn.boo(y))) D.shadowMap.type = uh;
        else if (pn.str(y)) {
          var Y;
          const q = { basic: cO, percentage: ey, soft: uh, variance: Lo };
          D.shadowMap.type = (Y = q[y]) != null ? Y : uh;
        } else pn.obj(y) && Object.assign(D.shadowMap, y);
        (W !== D.shadowMap.enabled || B !== D.shadowMap.type) &&
          (D.shadowMap.needsUpdate = !0);
      }
      const U = ID();
      U &&
        ("enabled" in U
          ? (U.enabled = !S)
          : "legacyMode" in U && (U.legacyMode = S)),
        l ||
          Eu(D, { outputEncoding: g ? 3e3 : 3001, toneMapping: x ? hs : Xw }),
        O.legacy !== S && O.set(() => ({ legacy: S })),
        O.linear !== g && O.set(() => ({ linear: g })),
        O.flat !== x && O.set(() => ({ flat: x })),
        d && !pn.fun(d) && !zD(d) && !pn.equ(d, D, Mu) && Eu(D, d),
        v && !O.events.handlers && O.set({ events: v(o) });
      const j = P9(t, p);
      return (
        pn.equ(j, O.size, Mu) ||
          O.setSize(j.width, j.height, j.updateStyle, j.top, j.left),
        M && O.viewport.dpr !== FD(M) && O.setDpr(M),
        O.frameloop !== C && O.setFrameloop(C),
        O.onPointerMissed || O.set({ onPointerMissed: E }),
        T &&
          !pn.equ(T, O.performance, Mu) &&
          O.set((W) => ({ performance: { ...W.performance, ...T } })),
        (a = _),
        (l = !0),
        this
      );
    },
    render(u) {
      return (
        l || this.configure(),
        yv.updateContainer(
          Q.jsx(L9, { store: o, children: u, onCreated: a, rootElement: t }),
          s,
          null,
          () => {}
        ),
        o
      );
    },
    unmount() {
      GD(t);
    },
  };
}
function L9({ store: t, children: e, onCreated: n, rootElement: r }) {
  return (
    zp(() => {
      const i = t.getState();
      i.set((o) => ({ internal: { ...o.internal, active: !0 } })),
        n && n(i),
        t.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    Q.jsx(BD.Provider, { value: t, children: e })
  );
}
function GD(t, e) {
  const n = Sf.get(t),
    r = n == null ? void 0 : n.fiber;
  if (r) {
    const i = n == null ? void 0 : n.store.getState();
    i && (i.internal.active = !1),
      yv.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var o, s, a, l;
              i.events.disconnect == null || i.events.disconnect(),
                (o = i.gl) == null ||
                  (s = o.renderLists) == null ||
                  s.dispose == null ||
                  s.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                x9(i),
                Sf.delete(t);
            } catch {}
          }, 500);
      });
  }
}
yv.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: L.version,
});
const b_ = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function O9(t) {
  const { handlePointer: e } = b9(t);
  return {
    priority: 1,
    enabled: !0,
    compute(n, r, i) {
      r.pointer.set(
        (n.offsetX / r.size.width) * 2 - 1,
        -(n.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(b_).reduce((n, r) => ({ ...n, [r]: e(r) }), {}),
    update: () => {
      var n;
      const { events: r, internal: i } = t.getState();
      (n = i.lastEvent) != null &&
        n.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (n) => {
      var r;
      const { set: i, events: o } = t.getState();
      o.disconnect == null || o.disconnect(),
        i((s) => ({ events: { ...s.events, connected: n } })),
        Object.entries((r = o.handlers) != null ? r : []).forEach(([s, a]) => {
          const [l, c] = b_[s];
          n.addEventListener(l, a, { passive: c });
        });
    },
    disconnect: () => {
      const { set: n, events: r } = t.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([o, s]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = b_[o];
            r.connected.removeEventListener(a, s);
          }
        }),
          n((o) => ({ events: { ...o.events, connected: void 0 } }));
      }
    },
  };
}
function BR(t, e) {
  let n;
  return (...r) => {
    window.clearTimeout(n), (n = window.setTimeout(() => t(...r), e));
  };
}
function N9(
  { debounce: t, scroll: e, polyfill: n, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = n || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, s] = L.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = L.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
      orientationHandler: null,
    }),
    l = t ? (typeof t == "number" ? t : t.scroll) : null,
    c = t ? (typeof t == "number" ? t : t.resize) : null,
    u = L.useRef(!1);
  L.useEffect(() => ((u.current = !0), () => void (u.current = !1)));
  const [d, p, m] = L.useMemo(() => {
    const g = () => {
      if (!a.current.element) return;
      const {
          left: x,
          top: S,
          width: b,
          height: C,
          bottom: M,
          right: T,
          x: P,
          y: R,
        } = a.current.element.getBoundingClientRect(),
        E = {
          left: x,
          top: S,
          width: b,
          height: C,
          bottom: M,
          right: T,
          x: P,
          y: R,
        };
      a.current.element instanceof HTMLElement &&
        r &&
        ((E.height = a.current.element.offsetHeight),
        (E.width = a.current.element.offsetWidth)),
        Object.freeze(E),
        u.current &&
          !k9(a.current.lastBounds, E) &&
          s((a.current.lastBounds = E));
    };
    return [g, c ? BR(g, c) : g, l ? BR(g, l) : g];
  }, [s, r, l, c]);
  function v() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((g) =>
        g.removeEventListener("scroll", m, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function _() {
    a.current.element &&
      ((a.current.resizeObserver = new i(m)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((g) =>
          g.addEventListener("scroll", m, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        m();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const y = (g) => {
    !g ||
      g === a.current.element ||
      (v(), (a.current.element = g), (a.current.scrollContainers = WD(g)), _());
  };
  return (
    F9(m, !!e),
    D9(p),
    L.useEffect(() => {
      v(), _();
    }, [e, m, p]),
    L.useEffect(() => v, []),
    [y, o, d]
  );
}
function D9(t) {
  L.useEffect(() => {
    const e = t;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [t]);
}
function F9(t, e) {
  L.useEffect(() => {
    if (e) {
      const n = t;
      return (
        window.addEventListener("scroll", n, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", n, !0)
      );
    }
  }, [t, e]);
}
function WD(t) {
  const e = [];
  if (!t || t === document.body) return e;
  const {
    overflow: n,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(t);
  return (
    [n, r, i].some((o) => o === "auto" || o === "scroll") && e.push(t),
    [...e, ...WD(t.parentElement)]
  );
}
const U9 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  k9 = (t, e) => U9.every((n) => t[n] === e[n]);
var z9 = Object.defineProperty,
  B9 = Object.defineProperties,
  H9 = Object.getOwnPropertyDescriptors,
  HR = Object.getOwnPropertySymbols,
  V9 = Object.prototype.hasOwnProperty,
  G9 = Object.prototype.propertyIsEnumerable,
  VR = (t, e, n) =>
    e in t
      ? z9(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  GR = (t, e) => {
    for (var n in e || (e = {})) V9.call(e, n) && VR(t, n, e[n]);
    if (HR) for (var n of HR(e)) G9.call(e, n) && VR(t, n, e[n]);
    return t;
  },
  W9 = (t, e) => B9(t, H9(e)),
  WR,
  jR;
typeof window < "u" &&
(((WR = window.document) != null && WR.createElement) ||
  ((jR = window.navigator) == null ? void 0 : jR.product) === "ReactNative")
  ? L.useLayoutEffect
  : L.useEffect;
function jD(t, e, n) {
  if (!t) return;
  if (n(t) === !0) return t;
  let r = t.child;
  for (; r; ) {
    const i = jD(r, e, n);
    if (i) return i;
    r = r.sibling;
  }
}
function $D(t) {
  try {
    return Object.defineProperties(t, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return t;
  }
}
const $R = console.error;
console.error = function () {
  const t = [...arguments].join("");
  if (t != null && t.startsWith("Warning:") && t.includes("useContext")) {
    console.error = $R;
    return;
  }
  return $R.apply(this, arguments);
};
const UE = $D(L.createContext(null));
class XD extends L.Component {
  render() {
    return L.createElement(
      UE.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function j9() {
  const t = L.useContext(UE);
  if (t === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = L.useId();
  return L.useMemo(() => {
    for (const r of [t, t == null ? void 0 : t.alternate]) {
      if (!r) continue;
      const i = jD(r, !1, (o) => {
        let s = o.memoizedState;
        for (; s; ) {
          if (s.memoizedState === e) return !0;
          s = s.next;
        }
      });
      if (i) return i;
    }
  }, [t, e]);
}
function $9() {
  const t = j9(),
    [e] = L.useState(() => new Map());
  e.clear();
  let n = t;
  for (; n; ) {
    if (n.type && typeof n.type == "object") {
      const i =
        n.type._context === void 0 && n.type.Provider === n.type
          ? n.type
          : n.type._context;
      i && i !== UE && !e.has(i) && e.set(i, L.useContext($D(i)));
    }
    n = n.return;
  }
  return e;
}
function X9() {
  const t = $9();
  return L.useMemo(
    () =>
      Array.from(t.keys()).reduce(
        (e, n) => (r) =>
          L.createElement(
            e,
            null,
            L.createElement(n.Provider, W9(GR({}, r), { value: t.get(n) }))
          ),
        (e) => L.createElement(XD, GR({}, e))
      ),
    [t]
  );
}
const Y9 = L.forwardRef(function (
    {
      children: e,
      fallback: n,
      resize: r,
      style: i,
      gl: o,
      events: s = O9,
      eventSource: a,
      eventPrefix: l,
      shadows: c,
      linear: u,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: v,
      dpr: _,
      performance: y,
      raycaster: g,
      camera: x,
      scene: S,
      onPointerMissed: b,
      onCreated: C,
      ...M
    },
    T
  ) {
    L.useMemo(() => h9(r9), []);
    const P = X9(),
      [R, E] = N9({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      O = L.useRef(null),
      D = L.useRef(null);
    L.useImperativeHandle(T, () => O.current);
    const N = OD(b),
      [z, V] = L.useState(!1),
      [G, Y] = L.useState(!1);
    if (z) throw z;
    if (G) throw G;
    const U = L.useRef(null);
    zp(() => {
      const W = O.current;
      E.width > 0 &&
        E.height > 0 &&
        W &&
        (U.current || (U.current = I9(W)),
        U.current.configure({
          gl: o,
          events: s,
          shadows: c,
          linear: u,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: v,
          dpr: _,
          performance: y,
          raycaster: g,
          camera: x,
          scene: S,
          size: E,
          onPointerMissed: (...B) =>
            N.current == null ? void 0 : N.current(...B),
          onCreated: (B) => {
            B.events.connect == null ||
              B.events.connect(a ? (m9(a) ? a.current : a) : D.current),
              l &&
                B.setEvents({
                  compute: (q, Z) => {
                    const H = q[l + "X"],
                      X = q[l + "Y"];
                    Z.pointer.set(
                      (H / Z.size.width) * 2 - 1,
                      -(X / Z.size.height) * 2 + 1
                    ),
                      Z.raycaster.setFromCamera(Z.pointer, Z.camera);
                  },
                }),
              C == null || C(B);
          },
        }),
        U.current.render(
          Q.jsx(P, {
            children: Q.jsx(ND, {
              set: Y,
              children: Q.jsx(L.Suspense, {
                fallback: Q.jsx(g9, { set: V }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      L.useEffect(() => {
        const W = O.current;
        if (W) return () => GD(W);
      }, []);
    const j = a ? "none" : "auto";
    return Q.jsx("div", {
      ref: D,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: j,
        ...i,
      },
      ...M,
      children: Q.jsx("div", {
        ref: R,
        style: { width: "100%", height: "100%" },
        children: Q.jsx("canvas", {
          ref: O,
          style: { display: "block" },
          children: n,
        }),
      }),
    });
  }),
  q9 = L.forwardRef(function (e, n) {
    return Q.jsx(XD, { children: Q.jsx(Y9, { ...e, ref: n }) });
  });
function Bt() {
  return (
    (Bt = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var r in n) ({}).hasOwnProperty.call(n, r) && (t[r] = n[r]);
          }
          return t;
        }),
    Bt.apply(null, arguments)
  );
}
const Bp = new ee(),
  kE = new ee(),
  K9 = new ee(),
  XR = new ke();
function Z9(t, e, n) {
  const r = Bp.setFromMatrixPosition(t.matrixWorld);
  r.project(e);
  const i = n.width / 2,
    o = n.height / 2;
  return [r.x * i + i, -(r.y * o) + o];
}
function J9(t, e) {
  const n = Bp.setFromMatrixPosition(t.matrixWorld),
    r = kE.setFromMatrixPosition(e.matrixWorld),
    i = n.sub(r),
    o = e.getWorldDirection(K9);
  return i.angleTo(o) > Math.PI / 2;
}
function Q9(t, e, n, r) {
  const i = Bp.setFromMatrixPosition(t.matrixWorld),
    o = i.clone();
  o.project(e), XR.set(o.x, o.y), n.setFromCamera(XR, e);
  const s = n.intersectObjects(r, !0);
  if (s.length) {
    const a = s[0].distance;
    return i.distanceTo(n.ray.origin) < a;
  }
  return !0;
}
function e7(t, e) {
  if (e instanceof ps) return e.zoom;
  if (e instanceof En) {
    const n = Bp.setFromMatrixPosition(t.matrixWorld),
      r = kE.setFromMatrixPosition(e.matrixWorld),
      i = (e.fov * Math.PI) / 180,
      o = n.distanceTo(r);
    return 1 / (2 * Math.tan(i / 2) * o);
  } else return 1;
}
function t7(t, e, n) {
  if (e instanceof En || e instanceof ps) {
    const r = Bp.setFromMatrixPosition(t.matrixWorld),
      i = kE.setFromMatrixPosition(e.matrixWorld),
      o = r.distanceTo(i),
      s = (n[1] - n[0]) / (e.far - e.near),
      a = n[1] - s * e.far;
    return Math.round(s * o + a);
  }
}
const WA = (t) => (Math.abs(t) < 1e-10 ? 0 : t);
function YD(t, e, n = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += WA(e[i] * t.elements[i]) + (i !== 15 ? "," : ")");
  return n + r;
}
const n7 = (
    (t) => (e) =>
      YD(e, t)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  r7 = (
    (t) => (e, n) =>
      YD(e, t(n), "translate(-50%,-50%)")
  )((t) => [
    1 / t,
    1 / t,
    1 / t,
    1,
    -1 / t,
    -1 / t,
    -1 / t,
    -1,
    1 / t,
    1 / t,
    1 / t,
    1,
    1,
    1,
    1,
    1,
  ]);
function i7(t) {
  return t && typeof t == "object" && "current" in t;
}
const zd = L.forwardRef(
  (
    {
      children: t,
      eps: e = 0.001,
      style: n,
      className: r,
      prepend: i,
      center: o,
      fullscreen: s,
      portal: a,
      distanceFactor: l,
      sprite: c = !1,
      transform: u = !1,
      occlude: d,
      onOcclude: p,
      castShadow: m,
      receiveShadow: v,
      material: _,
      geometry: y,
      zIndexRange: g = [16777271, 0],
      calculatePosition: x = Z9,
      as: S = "div",
      wrapperClass: b,
      pointerEvents: C = "auto",
      ...M
    },
    T
  ) => {
    const {
        gl: P,
        camera: R,
        scene: E,
        size: O,
        raycaster: D,
        events: N,
        viewport: z,
      } = os(),
      [V] = L.useState(() => document.createElement(S)),
      G = L.useRef(),
      Y = L.useRef(null),
      U = L.useRef(0),
      j = L.useRef([0, 0]),
      W = L.useRef(null),
      B = L.useRef(null),
      q =
        (a == null ? void 0 : a.current) ||
        N.connected ||
        P.domElement.parentNode,
      Z = L.useRef(null),
      H = L.useRef(!1),
      X = L.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && i7(d[0])),
        [d]
      );
    L.useLayoutEffect(() => {
      const te = P.domElement;
      d && d === "blending"
        ? ((te.style.zIndex = `${Math.floor(g[0] / 2)}`),
          (te.style.position = "absolute"),
          (te.style.pointerEvents = "none"))
        : ((te.style.zIndex = null),
          (te.style.position = null),
          (te.style.pointerEvents = null));
    }, [d]),
      L.useLayoutEffect(() => {
        if (Y.current) {
          const te = (G.current = nO(V));
          if ((E.updateMatrixWorld(), u))
            V.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const ge = x(Y.current, R, O);
            V.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${ge[0]}px,${ge[1]}px,0);transform-origin:0 0;`;
          }
          return (
            q && (i ? q.prepend(V) : q.appendChild(V)),
            () => {
              q && q.removeChild(V), te.unmount();
            }
          );
        }
      }, [q, u]),
      L.useLayoutEffect(() => {
        b && (V.className = b);
      }, [b]);
    const ne = L.useMemo(
        () =>
          u
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: O.width,
                height: O.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: o ? "translate3d(-50%,-50%,0)" : "none",
                ...(s && {
                  top: -O.height / 2,
                  left: -O.width / 2,
                  width: O.width,
                  height: O.height,
                }),
                ...n,
              },
        [n, o, s, O, u]
      ),
      oe = L.useMemo(() => ({ position: "absolute", pointerEvents: C }), [C]);
    L.useLayoutEffect(() => {
      if (((H.current = !1), u)) {
        var te;
        (te = G.current) == null ||
          te.render(
            L.createElement(
              "div",
              { ref: W, style: ne },
              L.createElement(
                "div",
                { ref: B, style: oe },
                L.createElement("div", {
                  ref: T,
                  className: r,
                  style: n,
                  children: t,
                })
              )
            )
          );
      } else {
        var ge;
        (ge = G.current) == null ||
          ge.render(
            L.createElement("div", {
              ref: T,
              style: ne,
              className: r,
              children: t,
            })
          );
      }
    });
    const ue = L.useRef(!0);
    FE((te) => {
      if (Y.current) {
        R.updateMatrixWorld(), Y.current.updateWorldMatrix(!0, !1);
        const ge = u ? j.current : x(Y.current, R, O);
        if (
          u ||
          Math.abs(U.current - R.zoom) > e ||
          Math.abs(j.current[0] - ge[0]) > e ||
          Math.abs(j.current[1] - ge[1]) > e
        ) {
          const ie = J9(Y.current, R);
          let pe = !1;
          X &&
            (Array.isArray(d)
              ? (pe = d.map((Ce) => Ce.current))
              : d !== "blending" && (pe = [E]));
          const de = ue.current;
          if (pe) {
            const Ce = Q9(Y.current, R, D, pe);
            ue.current = Ce && !ie;
          } else ue.current = !ie;
          de !== ue.current &&
            (p
              ? p(!ue.current)
              : (V.style.display = ue.current ? "block" : "none"));
          const Ee = Math.floor(g[0] / 2),
            he = d ? (X ? [g[0], Ee] : [Ee - 1, 0]) : g;
          if (((V.style.zIndex = `${t7(Y.current, R, he)}`), u)) {
            const [Ce, _e] = [O.width / 2, O.height / 2],
              $ = R.projectionMatrix.elements[5] * _e,
              {
                isOrthographicCamera: k,
                top: J,
                left: fe,
                bottom: le,
                right: ce,
              } = R,
              we = n7(R.matrixWorldInverse),
              Be = k
                ? `scale(${$})translate(${WA(-(ce + fe) / 2)}px,${WA(
                    (J + le) / 2
                  )}px)`
                : `translateZ(${$}px)`;
            let Me = Y.current.matrixWorld;
            c &&
              ((Me = R.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Me)
                .scale(Y.current.scale)),
              (Me.elements[3] = Me.elements[7] = Me.elements[11] = 0),
              (Me.elements[15] = 1)),
              (V.style.width = O.width + "px"),
              (V.style.height = O.height + "px"),
              (V.style.perspective = k ? "" : `${$}px`),
              W.current &&
                B.current &&
                ((W.current.style.transform = `${Be}${we}translate(${Ce}px,${_e}px)`),
                (B.current.style.transform = r7(Me, 1 / ((l || 10) / 400))));
          } else {
            const Ce = l === void 0 ? 1 : e7(Y.current, R) * l;
            V.style.transform = `translate3d(${ge[0]}px,${ge[1]}px,0) scale(${Ce})`;
          }
          (j.current = ge), (U.current = R.zoom);
        }
      }
      if (!X && Z.current && !H.current)
        if (u) {
          if (W.current) {
            const ge = W.current.children[0];
            if (ge != null && ge.clientWidth && ge != null && ge.clientHeight) {
              const { isOrthographicCamera: ie } = R;
              if (ie || y)
                M.scale &&
                  (Array.isArray(M.scale)
                    ? M.scale instanceof ee
                      ? Z.current.scale.copy(M.scale.clone().divideScalar(1))
                      : Z.current.scale.set(
                          1 / M.scale[0],
                          1 / M.scale[1],
                          1 / M.scale[2]
                        )
                    : Z.current.scale.setScalar(1 / M.scale));
              else {
                const pe = (l || 10) / 400,
                  de = ge.clientWidth * pe,
                  Ee = ge.clientHeight * pe;
                Z.current.scale.set(de, Ee, 1);
              }
              H.current = !0;
            }
          }
        } else {
          const ge = V.children[0];
          if (ge != null && ge.clientWidth && ge != null && ge.clientHeight) {
            const ie = 1 / z.factor,
              pe = ge.clientWidth * ie,
              de = ge.clientHeight * ie;
            Z.current.scale.set(pe, de, 1), (H.current = !0);
          }
          Z.current.lookAt(te.camera.position);
        }
    });
    const Ie = L.useMemo(
      () => ({
        vertexShader: u
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [u]
    );
    return L.createElement(
      "group",
      Bt({}, M, { ref: Y }),
      d &&
        !X &&
        L.createElement(
          "mesh",
          { castShadow: m, receiveShadow: v, ref: Z },
          y || L.createElement("planeGeometry", null),
          _ ||
            L.createElement("shaderMaterial", {
              side: mo,
              vertexShader: Ie.vertexShader,
              fragmentShader: Ie.fragmentShader,
            })
        )
    );
  }
);
var o7 = Object.defineProperty,
  s7 = (t, e, n) =>
    e in t
      ? o7(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  a7 = (t, e, n) => (s7(t, e + "", n), n);
let l7 = class {
  constructor() {
    a7(this, "_listeners");
  }
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(n);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
};
var c7 = Object.defineProperty,
  u7 = (t, e, n) =>
    e in t
      ? c7(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (t[e] = n),
  At = (t, e, n) => (u7(t, typeof e != "symbol" ? e + "" : e, n), n);
const Yg = new Oc(),
  YR = new ks(),
  f7 = Math.cos(70 * (Math.PI / 180)),
  qR = (t, e) => ((t % e) + e) % e;
let d7 = class extends l7 {
  constructor(e, n) {
    super(),
      At(this, "object"),
      At(this, "domElement"),
      At(this, "enabled", !0),
      At(this, "target", new ee()),
      At(this, "minDistance", 0),
      At(this, "maxDistance", 1 / 0),
      At(this, "minZoom", 0),
      At(this, "maxZoom", 1 / 0),
      At(this, "minPolarAngle", 0),
      At(this, "maxPolarAngle", Math.PI),
      At(this, "minAzimuthAngle", -1 / 0),
      At(this, "maxAzimuthAngle", 1 / 0),
      At(this, "enableDamping", !1),
      At(this, "dampingFactor", 0.05),
      At(this, "enableZoom", !0),
      At(this, "zoomSpeed", 1),
      At(this, "enableRotate", !0),
      At(this, "rotateSpeed", 1),
      At(this, "enablePan", !0),
      At(this, "panSpeed", 1),
      At(this, "screenSpacePanning", !0),
      At(this, "keyPanSpeed", 7),
      At(this, "zoomToCursor", !1),
      At(this, "autoRotate", !1),
      At(this, "autoRotateSpeed", 2),
      At(this, "reverseOrbit", !1),
      At(this, "reverseHorizontalOrbit", !1),
      At(this, "reverseVerticalOrbit", !1),
      At(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      At(this, "mouseButtons", {
        LEFT: Wl.ROTATE,
        MIDDLE: Wl.DOLLY,
        RIGHT: Wl.PAN,
      }),
      At(this, "touches", { ONE: jl.ROTATE, TWO: jl.DOLLY_PAN }),
      At(this, "target0"),
      At(this, "position0"),
      At(this, "zoom0"),
      At(this, "_domElementKeyEvents", null),
      At(this, "getPolarAngle"),
      At(this, "getAzimuthalAngle"),
      At(this, "setPolarAngle"),
      At(this, "setAzimuthalAngle"),
      At(this, "getDistance"),
      At(this, "getZoomScale"),
      At(this, "listenToKeyEvents"),
      At(this, "stopListenToKeyEvents"),
      At(this, "saveState"),
      At(this, "reset"),
      At(this, "update"),
      At(this, "connect"),
      At(this, "dispose"),
      At(this, "dollyIn"),
      At(this, "dollyOut"),
      At(this, "getScale"),
      At(this, "setScale"),
      (this.object = e),
      (this.domElement = n),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => u.phi),
      (this.getAzimuthalAngle = () => u.theta),
      (this.setPolarAngle = (ae) => {
        let be = qR(ae, 2 * Math.PI),
          se = u.phi;
        se < 0 && (se += 2 * Math.PI), be < 0 && (be += 2 * Math.PI);
        let Ae = Math.abs(be - se);
        2 * Math.PI - Ae < Ae &&
          (be < se ? (be += 2 * Math.PI) : (se += 2 * Math.PI)),
          (d.phi = be - se),
          r.update();
      }),
      (this.setAzimuthalAngle = (ae) => {
        let be = qR(ae, 2 * Math.PI),
          se = u.theta;
        se < 0 && (se += 2 * Math.PI), be < 0 && (be += 2 * Math.PI);
        let Ae = Math.abs(be - se);
        2 * Math.PI - Ae < Ae &&
          (be < se ? (be += 2 * Math.PI) : (se += 2 * Math.PI)),
          (d.theta = be - se),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (ae) => {
        ae.addEventListener("keydown", Ge), (this._domElementKeyEvents = ae);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Ge),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const ae = new ee(),
          be = new ee(0, 1, 0),
          se = new $r().setFromUnitVectors(e.up, be),
          Ae = se.clone().invert(),
          ye = new ee(),
          He = new $r(),
          qe = 2 * Math.PI;
        return function () {
          const st = r.object.position;
          se.setFromUnitVectors(e.up, be),
            Ae.copy(se).invert(),
            ae.copy(st).sub(r.target),
            ae.applyQuaternion(se),
            u.setFromVector3(ae),
            r.autoRotate && l === a.NONE && z(D()),
            r.enableDamping
              ? ((u.theta += d.theta * r.dampingFactor),
                (u.phi += d.phi * r.dampingFactor))
              : ((u.theta += d.theta), (u.phi += d.phi));
          let ht = r.minAzimuthAngle,
            pt = r.maxAzimuthAngle;
          isFinite(ht) &&
            isFinite(pt) &&
            (ht < -Math.PI ? (ht += qe) : ht > Math.PI && (ht -= qe),
            pt < -Math.PI ? (pt += qe) : pt > Math.PI && (pt -= qe),
            ht <= pt
              ? (u.theta = Math.max(ht, Math.min(pt, u.theta)))
              : (u.theta =
                  u.theta > (ht + pt) / 2
                    ? Math.max(ht, u.theta)
                    : Math.min(pt, u.theta))),
            (u.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, u.phi)
            )),
            u.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(m, r.dampingFactor)
              : r.target.add(m),
            (r.zoomToCursor && R) || r.object.isOrthographicCamera
              ? (u.radius = Z(u.radius))
              : (u.radius = Z(u.radius * p)),
            ae.setFromSpherical(u),
            ae.applyQuaternion(Ae),
            st.copy(r.target).add(ae),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((d.theta *= 1 - r.dampingFactor),
                (d.phi *= 1 - r.dampingFactor),
                m.multiplyScalar(1 - r.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0));
          let Ze = !1;
          if (r.zoomToCursor && R) {
            let Mt = null;
            if (r.object instanceof En && r.object.isPerspectiveCamera) {
              const Rt = ae.length();
              Mt = Z(Rt * p);
              const Yt = Rt - Mt;
              r.object.position.addScaledVector(T, Yt),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const Rt = new ee(P.x, P.y, 0);
              Rt.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix(),
                (Ze = !0);
              const Yt = new ee(P.x, P.y, 0);
              Yt.unproject(r.object),
                r.object.position.sub(Yt).add(Rt),
                r.object.updateMatrixWorld(),
                (Mt = ae.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            Mt !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(Mt)
                    .add(r.object.position)
                : (Yg.origin.copy(r.object.position),
                  Yg.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Yg.direction)) < f7
                    ? e.lookAt(r.target)
                    : (YR.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Yg.intersectPlane(YR, r.target))));
          } else
            r.object instanceof ps &&
              r.object.isOrthographicCamera &&
              ((Ze = p !== 1),
              Ze &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / p)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (p = 1),
            (R = !1),
            Ze ||
            ye.distanceToSquared(r.object.position) > c ||
            8 * (1 - He.dot(r.object.quaternion)) > c
              ? (r.dispatchEvent(i),
                ye.copy(r.object.position),
                He.copy(r.object.quaternion),
                (Ze = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (ae) => {
        (r.domElement = ae),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", Je),
          r.domElement.addEventListener("pointerdown", fe),
          r.domElement.addEventListener("pointercancel", ce),
          r.domElement.addEventListener("wheel", Me);
      }),
      (this.dispose = () => {
        var ae, be, se, Ae, ye, He;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (ae = r.domElement) == null ||
            ae.removeEventListener("contextmenu", Je),
          (be = r.domElement) == null ||
            be.removeEventListener("pointerdown", fe),
          (se = r.domElement) == null ||
            se.removeEventListener("pointercancel", ce),
          (Ae = r.domElement) == null || Ae.removeEventListener("wheel", Me),
          (ye = r.domElement) == null ||
            ye.ownerDocument.removeEventListener("pointermove", le),
          (He = r.domElement) == null ||
            He.ownerDocument.removeEventListener("pointerup", ce),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Ge);
      });
    const r = this,
      i = { type: "change" },
      o = { type: "start" },
      s = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const c = 1e-6,
      u = new BA(),
      d = new BA();
    let p = 1;
    const m = new ee(),
      v = new ke(),
      _ = new ke(),
      y = new ke(),
      g = new ke(),
      x = new ke(),
      S = new ke(),
      b = new ke(),
      C = new ke(),
      M = new ke(),
      T = new ee(),
      P = new ke();
    let R = !1;
    const E = [],
      O = {};
    function D() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function N() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function z(ae) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (d.theta += ae)
        : (d.theta -= ae);
    }
    function V(ae) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (d.phi += ae) : (d.phi -= ae);
    }
    const G = (() => {
        const ae = new ee();
        return function (se, Ae) {
          ae.setFromMatrixColumn(Ae, 0), ae.multiplyScalar(-se), m.add(ae);
        };
      })(),
      Y = (() => {
        const ae = new ee();
        return function (se, Ae) {
          r.screenSpacePanning === !0
            ? ae.setFromMatrixColumn(Ae, 1)
            : (ae.setFromMatrixColumn(Ae, 0), ae.crossVectors(r.object.up, ae)),
            ae.multiplyScalar(se),
            m.add(ae);
        };
      })(),
      U = (() => {
        const ae = new ee();
        return function (se, Ae) {
          const ye = r.domElement;
          if (ye && r.object instanceof En && r.object.isPerspectiveCamera) {
            const He = r.object.position;
            ae.copy(He).sub(r.target);
            let qe = ae.length();
            (qe *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              G((2 * se * qe) / ye.clientHeight, r.object.matrix),
              Y((2 * Ae * qe) / ye.clientHeight, r.object.matrix);
          } else
            ye && r.object instanceof ps && r.object.isOrthographicCamera
              ? (G(
                  (se * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    ye.clientWidth,
                  r.object.matrix
                ),
                Y(
                  (Ae * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    ye.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function j(ae) {
      (r.object instanceof En && r.object.isPerspectiveCamera) ||
      (r.object instanceof ps && r.object.isOrthographicCamera)
        ? (p = ae)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function W(ae) {
      j(p / ae);
    }
    function B(ae) {
      j(p * ae);
    }
    function q(ae) {
      if (!r.zoomToCursor || !r.domElement) return;
      R = !0;
      const be = r.domElement.getBoundingClientRect(),
        se = ae.clientX - be.left,
        Ae = ae.clientY - be.top,
        ye = be.width,
        He = be.height;
      (P.x = (se / ye) * 2 - 1),
        (P.y = -(Ae / He) * 2 + 1),
        T.set(P.x, P.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function Z(ae) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, ae));
    }
    function H(ae) {
      v.set(ae.clientX, ae.clientY);
    }
    function X(ae) {
      q(ae), b.set(ae.clientX, ae.clientY);
    }
    function ne(ae) {
      g.set(ae.clientX, ae.clientY);
    }
    function oe(ae) {
      _.set(ae.clientX, ae.clientY),
        y.subVectors(_, v).multiplyScalar(r.rotateSpeed);
      const be = r.domElement;
      be &&
        (z((2 * Math.PI * y.x) / be.clientHeight),
        V((2 * Math.PI * y.y) / be.clientHeight)),
        v.copy(_),
        r.update();
    }
    function ue(ae) {
      C.set(ae.clientX, ae.clientY),
        M.subVectors(C, b),
        M.y > 0 ? W(N()) : M.y < 0 && B(N()),
        b.copy(C),
        r.update();
    }
    function Ie(ae) {
      x.set(ae.clientX, ae.clientY),
        S.subVectors(x, g).multiplyScalar(r.panSpeed),
        U(S.x, S.y),
        g.copy(x),
        r.update();
    }
    function te(ae) {
      q(ae), ae.deltaY < 0 ? B(N()) : ae.deltaY > 0 && W(N()), r.update();
    }
    function ge(ae) {
      let be = !1;
      switch (ae.code) {
        case r.keys.UP:
          U(0, r.keyPanSpeed), (be = !0);
          break;
        case r.keys.BOTTOM:
          U(0, -r.keyPanSpeed), (be = !0);
          break;
        case r.keys.LEFT:
          U(r.keyPanSpeed, 0), (be = !0);
          break;
        case r.keys.RIGHT:
          U(-r.keyPanSpeed, 0), (be = !0);
          break;
      }
      be && (ae.preventDefault(), r.update());
    }
    function ie() {
      if (E.length == 1) v.set(E[0].pageX, E[0].pageY);
      else {
        const ae = 0.5 * (E[0].pageX + E[1].pageX),
          be = 0.5 * (E[0].pageY + E[1].pageY);
        v.set(ae, be);
      }
    }
    function pe() {
      if (E.length == 1) g.set(E[0].pageX, E[0].pageY);
      else {
        const ae = 0.5 * (E[0].pageX + E[1].pageX),
          be = 0.5 * (E[0].pageY + E[1].pageY);
        g.set(ae, be);
      }
    }
    function de() {
      const ae = E[0].pageX - E[1].pageX,
        be = E[0].pageY - E[1].pageY,
        se = Math.sqrt(ae * ae + be * be);
      b.set(0, se);
    }
    function Ee() {
      r.enableZoom && de(), r.enablePan && pe();
    }
    function he() {
      r.enableZoom && de(), r.enableRotate && ie();
    }
    function Ce(ae) {
      if (E.length == 1) _.set(ae.pageX, ae.pageY);
      else {
        const se = Ve(ae),
          Ae = 0.5 * (ae.pageX + se.x),
          ye = 0.5 * (ae.pageY + se.y);
        _.set(Ae, ye);
      }
      y.subVectors(_, v).multiplyScalar(r.rotateSpeed);
      const be = r.domElement;
      be &&
        (z((2 * Math.PI * y.x) / be.clientHeight),
        V((2 * Math.PI * y.y) / be.clientHeight)),
        v.copy(_);
    }
    function _e(ae) {
      if (E.length == 1) x.set(ae.pageX, ae.pageY);
      else {
        const be = Ve(ae),
          se = 0.5 * (ae.pageX + be.x),
          Ae = 0.5 * (ae.pageY + be.y);
        x.set(se, Ae);
      }
      S.subVectors(x, g).multiplyScalar(r.panSpeed), U(S.x, S.y), g.copy(x);
    }
    function $(ae) {
      const be = Ve(ae),
        se = ae.pageX - be.x,
        Ae = ae.pageY - be.y,
        ye = Math.sqrt(se * se + Ae * Ae);
      C.set(0, ye),
        M.set(0, Math.pow(C.y / b.y, r.zoomSpeed)),
        W(M.y),
        b.copy(C);
    }
    function k(ae) {
      r.enableZoom && $(ae), r.enablePan && _e(ae);
    }
    function J(ae) {
      r.enableZoom && $(ae), r.enableRotate && Ce(ae);
    }
    function fe(ae) {
      var be, se;
      r.enabled !== !1 &&
        (E.length === 0 &&
          ((be = r.domElement) == null ||
            be.ownerDocument.addEventListener("pointermove", le),
          (se = r.domElement) == null ||
            se.ownerDocument.addEventListener("pointerup", ce)),
        Ye(ae),
        ae.pointerType === "touch" ? Le(ae) : we(ae));
    }
    function le(ae) {
      r.enabled !== !1 && (ae.pointerType === "touch" ? je(ae) : Be(ae));
    }
    function ce(ae) {
      var be, se, Ae;
      De(ae),
        E.length === 0 &&
          ((be = r.domElement) == null ||
            be.releasePointerCapture(ae.pointerId),
          (se = r.domElement) == null ||
            se.ownerDocument.removeEventListener("pointermove", le),
          (Ae = r.domElement) == null ||
            Ae.ownerDocument.removeEventListener("pointerup", ce)),
        r.dispatchEvent(s),
        (l = a.NONE);
    }
    function we(ae) {
      let be;
      switch (ae.button) {
        case 0:
          be = r.mouseButtons.LEFT;
          break;
        case 1:
          be = r.mouseButtons.MIDDLE;
          break;
        case 2:
          be = r.mouseButtons.RIGHT;
          break;
        default:
          be = -1;
      }
      switch (be) {
        case Wl.DOLLY:
          if (r.enableZoom === !1) return;
          X(ae), (l = a.DOLLY);
          break;
        case Wl.ROTATE:
          if (ae.ctrlKey || ae.metaKey || ae.shiftKey) {
            if (r.enablePan === !1) return;
            ne(ae), (l = a.PAN);
          } else {
            if (r.enableRotate === !1) return;
            H(ae), (l = a.ROTATE);
          }
          break;
        case Wl.PAN:
          if (ae.ctrlKey || ae.metaKey || ae.shiftKey) {
            if (r.enableRotate === !1) return;
            H(ae), (l = a.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            ne(ae), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(o);
    }
    function Be(ae) {
      if (r.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (r.enableRotate === !1) return;
            oe(ae);
            break;
          case a.DOLLY:
            if (r.enableZoom === !1) return;
            ue(ae);
            break;
          case a.PAN:
            if (r.enablePan === !1) return;
            Ie(ae);
            break;
        }
    }
    function Me(ae) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (ae.preventDefault(), r.dispatchEvent(o), te(ae), r.dispatchEvent(s));
    }
    function Ge(ae) {
      r.enabled === !1 || r.enablePan === !1 || ge(ae);
    }
    function Le(ae) {
      switch ((ze(ae), E.length)) {
        case 1:
          switch (r.touches.ONE) {
            case jl.ROTATE:
              if (r.enableRotate === !1) return;
              ie(), (l = a.TOUCH_ROTATE);
              break;
            case jl.PAN:
              if (r.enablePan === !1) return;
              pe(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case jl.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              Ee(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case jl.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              he(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(o);
    }
    function je(ae) {
      switch ((ze(ae), l)) {
        case a.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          Ce(ae), r.update();
          break;
        case a.TOUCH_PAN:
          if (r.enablePan === !1) return;
          _e(ae), r.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          k(ae), r.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          J(ae), r.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function Je(ae) {
      r.enabled !== !1 && ae.preventDefault();
    }
    function Ye(ae) {
      E.push(ae);
    }
    function De(ae) {
      delete O[ae.pointerId];
      for (let be = 0; be < E.length; be++)
        if (E[be].pointerId == ae.pointerId) {
          E.splice(be, 1);
          return;
        }
    }
    function ze(ae) {
      let be = O[ae.pointerId];
      be === void 0 && ((be = new ke()), (O[ae.pointerId] = be)),
        be.set(ae.pageX, ae.pageY);
    }
    function Ve(ae) {
      const be = ae.pointerId === E[0].pointerId ? E[1] : E[0];
      return O[be.pointerId];
    }
    (this.dollyIn = (ae = N()) => {
      B(ae), r.update();
    }),
      (this.dollyOut = (ae = N()) => {
        W(ae), r.update();
      }),
      (this.getScale = () => p),
      (this.setScale = (ae) => {
        j(ae), r.update();
      }),
      (this.getZoomScale = () => N()),
      n !== void 0 && this.connect(n),
      this.update();
  }
};
function h7() {
  var t = Object.create(null);
  function e(i, o) {
    var s = i.id,
      a = i.name,
      l = i.dependencies;
    l === void 0 && (l = []);
    var c = i.init;
    c === void 0 && (c = function () {});
    var u = i.getTransferables;
    if ((u === void 0 && (u = null), !t[s]))
      try {
        (l = l.map(function (p) {
          return (
            p &&
              p.isWorkerModule &&
              (e(p, function (m) {
                if (m instanceof Error) throw m;
              }),
              (p = t[p.id].value)),
            p
          );
        })),
          (c = r("<" + a + ">.init", c)),
          u && (u = r("<" + a + ">.getTransferables", u));
        var d = null;
        typeof c == "function"
          ? (d = c.apply(void 0, l))
          : console.error("worker module init function failed to rehydrate"),
          (t[s] = { id: s, value: d, getTransferables: u }),
          o(d);
      } catch (p) {
        (p && p.noLog) || console.error(p), o(p);
      }
  }
  function n(i, o) {
    var s,
      a = i.id,
      l = i.args;
    (!t[a] || typeof t[a].value != "function") &&
      o(
        new Error(
          "Worker module " +
            a +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var c = (s = t[a]).value.apply(s, l);
      c && typeof c.then == "function"
        ? c.then(u, function (d) {
            return o(d instanceof Error ? d : new Error("" + d));
          })
        : u(c);
    } catch (d) {
      o(d);
    }
    function u(d) {
      try {
        var p = t[a].getTransferables && t[a].getTransferables(d);
        (!p || !Array.isArray(p) || !p.length) && (p = void 0), o(d, p);
      } catch (m) {
        console.error(m), o(m);
      }
    }
  }
  function r(i, o) {
    var s = void 0;
    self.troikaDefine = function (l) {
      return (s = l);
    };
    var a = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            o +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, s;
  }
  self.addEventListener("message", function (i) {
    var o = i.data,
      s = o.messageId,
      a = o.action,
      l = o.data;
    try {
      a === "registerModule" &&
        e(l, function (c) {
          c instanceof Error
            ? postMessage({ messageId: s, success: !1, error: c.message })
            : postMessage({
                messageId: s,
                success: !0,
                result: { isCallable: typeof c == "function" },
              });
        }),
        a === "callModule" &&
          n(l, function (c, u) {
            c instanceof Error
              ? postMessage({ messageId: s, success: !1, error: c.message })
              : postMessage(
                  { messageId: s, success: !0, result: c },
                  u || void 0
                );
          });
    } catch (c) {
      postMessage({ messageId: s, success: !1, error: c.stack });
    }
  });
}
function p7(t) {
  var e = function () {
    for (var n = [], r = arguments.length; r--; ) n[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, n);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var n = t.dependencies,
        r = t.init;
      n = Array.isArray(n)
        ? n.map(function (o) {
            return (
              o &&
                ((o = o.onMainThread || o),
                o._getInitResult && (o = o._getInitResult())),
              o
            );
          })
        : [];
      var i = Promise.all(n).then(function (o) {
        return r.apply(null, o);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var qD = function () {
    var t = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (t = !0);
      } catch (n) {
        console.log(
          "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
            n.message +
            "]"
        );
      }
    return (
      (qD = function () {
        return t;
      }),
      t
    );
  },
  m7 = 0,
  g7 = 0,
  w_ = !1,
  mh = Object.create(null),
  gh = Object.create(null),
  jA = Object.create(null);
function zf(t) {
  if ((!t || typeof t.init != "function") && !w_)
    throw new Error("requires `options.init` function");
  var e = t.dependencies,
    n = t.init,
    r = t.getTransferables,
    i = t.workerId,
    o = p7(t);
  i == null && (i = "#default");
  var s = "workerModule" + ++m7,
    a = t.name || s,
    l = null;
  e =
    e &&
    e.map(function (u) {
      return (
        typeof u == "function" &&
          !u.workerModuleData &&
          ((w_ = !0),
          (u = zf({
            workerId: i,
            name: "<" + a + "> function dependency: " + u.name,
            init:
              `function(){return (
` +
              L0(u) +
              `
)}`,
          })),
          (w_ = !1)),
        u && u.workerModuleData && (u = u.workerModuleData),
        u
      );
    });
  function c() {
    for (var u = [], d = arguments.length; d--; ) u[d] = arguments[d];
    if (!qD()) return o.apply(void 0, u);
    if (!l) {
      l = KR(i, "registerModule", c.workerModuleData);
      var p = function () {
        (l = null), gh[i].delete(p);
      };
      (gh[i] || (gh[i] = new Set())).add(p);
    }
    return l.then(function (m) {
      var v = m.isCallable;
      if (v) return KR(i, "callModule", { id: s, args: u });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (c.workerModuleData = {
      isWorkerModule: !0,
      id: s,
      name: a,
      dependencies: e,
      init: L0(n),
      getTransferables: r && L0(r),
    }),
    (c.onMainThread = o),
    c
  );
}
function v7(t) {
  gh[t] &&
    gh[t].forEach(function (e) {
      e();
    }),
    mh[t] && (mh[t].terminate(), delete mh[t]);
}
function L0(t) {
  var e = t.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function y7(t) {
  var e = mh[t];
  if (!e) {
    var n = L0(h7);
    (e = mh[t] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                t.replace(/\*/g, "") +
                ` **/

;(` +
                n +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          o = i.messageId,
          s = jA[o];
        if (!s)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete jA[o], s(i);
      });
  }
  return e;
}
function KR(t, e, n) {
  return new Promise(function (r, i) {
    var o = ++g7;
    (jA[o] = function (s) {
      s.success
        ? r(s.result)
        : i(new Error("Error in worker " + e + " call: " + s.error));
    }),
      y7(t).postMessage({ messageId: o, action: e, data: n });
  });
}
function KD() {
  var t = (function (e) {
    function n(j, W, B, q, Z, H, X, ne) {
      var oe = 1 - X;
      (ne.x = oe * oe * j + 2 * oe * X * B + X * X * Z),
        (ne.y = oe * oe * W + 2 * oe * X * q + X * X * H);
    }
    function r(j, W, B, q, Z, H, X, ne, oe, ue) {
      var Ie = 1 - oe;
      (ue.x =
        Ie * Ie * Ie * j +
        3 * Ie * Ie * oe * B +
        3 * Ie * oe * oe * Z +
        oe * oe * oe * X),
        (ue.y =
          Ie * Ie * Ie * W +
          3 * Ie * Ie * oe * q +
          3 * Ie * oe * oe * H +
          oe * oe * oe * ne);
    }
    function i(j, W) {
      for (var B = /([MLQCZ])([^MLQCZ]*)/g, q, Z, H, X, ne; (q = B.exec(j)); ) {
        var oe = q[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (ue) {
            return parseFloat(ue);
          });
        switch (q[1]) {
          case "M":
            (X = Z = oe[0]), (ne = H = oe[1]);
            break;
          case "L":
            (oe[0] !== X || oe[1] !== ne) &&
              W("L", X, ne, (X = oe[0]), (ne = oe[1]));
            break;
          case "Q": {
            W("Q", X, ne, (X = oe[2]), (ne = oe[3]), oe[0], oe[1]);
            break;
          }
          case "C": {
            W(
              "C",
              X,
              ne,
              (X = oe[4]),
              (ne = oe[5]),
              oe[0],
              oe[1],
              oe[2],
              oe[3]
            );
            break;
          }
          case "Z":
            (X !== Z || ne !== H) && W("L", X, ne, Z, H);
            break;
        }
      }
    }
    function o(j, W, B) {
      B === void 0 && (B = 16);
      var q = { x: 0, y: 0 };
      i(j, function (Z, H, X, ne, oe, ue, Ie, te, ge) {
        switch (Z) {
          case "L":
            W(H, X, ne, oe);
            break;
          case "Q": {
            for (var ie = H, pe = X, de = 1; de < B; de++)
              n(H, X, ue, Ie, ne, oe, de / (B - 1), q),
                W(ie, pe, q.x, q.y),
                (ie = q.x),
                (pe = q.y);
            break;
          }
          case "C": {
            for (var Ee = H, he = X, Ce = 1; Ce < B; Ce++)
              r(H, X, ue, Ie, te, ge, ne, oe, Ce / (B - 1), q),
                W(Ee, he, q.x, q.y),
                (Ee = q.x),
                (he = q.y);
            break;
          }
        }
      });
    }
    var s =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      a =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      l = new WeakMap(),
      c = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function u(j, W) {
      var B = j.getContext ? j.getContext("webgl", c) : j,
        q = l.get(B);
      if (!q) {
        let Ee = function (J) {
            var fe = H[J];
            if (!fe && ((fe = H[J] = B.getExtension(J)), !fe))
              throw new Error(J + " not supported");
            return fe;
          },
          he = function (J, fe) {
            var le = B.createShader(fe);
            return B.shaderSource(le, J), B.compileShader(le), le;
          },
          Ce = function (J, fe, le, ce) {
            if (!X[J]) {
              var we = {},
                Be = {},
                Me = B.createProgram();
              B.attachShader(Me, he(fe, B.VERTEX_SHADER)),
                B.attachShader(Me, he(le, B.FRAGMENT_SHADER)),
                B.linkProgram(Me),
                (X[J] = {
                  program: Me,
                  transaction: function (Le) {
                    B.useProgram(Me),
                      Le({
                        setUniform: function (Je, Ye) {
                          for (
                            var De = [], ze = arguments.length - 2;
                            ze-- > 0;

                          )
                            De[ze] = arguments[ze + 2];
                          var Ve =
                            Be[Ye] || (Be[Ye] = B.getUniformLocation(Me, Ye));
                          B["uniform" + Je].apply(B, [Ve].concat(De));
                        },
                        setAttribute: function (Je, Ye, De, ze, Ve) {
                          var ae = we[Je];
                          ae ||
                            (ae = we[Je] =
                              {
                                buf: B.createBuffer(),
                                loc: B.getAttribLocation(Me, Je),
                                data: null,
                              }),
                            B.bindBuffer(B.ARRAY_BUFFER, ae.buf),
                            B.vertexAttribPointer(
                              ae.loc,
                              Ye,
                              B.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            B.enableVertexAttribArray(ae.loc),
                            Z
                              ? B.vertexAttribDivisor(ae.loc, ze)
                              : Ee(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(ae.loc, ze),
                            Ve !== ae.data &&
                              (B.bufferData(B.ARRAY_BUFFER, Ve, De),
                              (ae.data = Ve));
                        },
                      });
                  },
                });
            }
            X[J].transaction(ce);
          },
          _e = function (J, fe) {
            oe++;
            try {
              B.activeTexture(B.TEXTURE0 + oe);
              var le = ne[J];
              le ||
                ((le = ne[J] = B.createTexture()),
                B.bindTexture(B.TEXTURE_2D, le),
                B.texParameteri(B.TEXTURE_2D, B.TEXTURE_MIN_FILTER, B.NEAREST),
                B.texParameteri(B.TEXTURE_2D, B.TEXTURE_MAG_FILTER, B.NEAREST)),
                B.bindTexture(B.TEXTURE_2D, le),
                fe(le, oe);
            } finally {
              oe--;
            }
          },
          $ = function (J, fe, le) {
            var ce = B.createFramebuffer();
            ue.push(ce),
              B.bindFramebuffer(B.FRAMEBUFFER, ce),
              B.activeTexture(B.TEXTURE0 + fe),
              B.bindTexture(B.TEXTURE_2D, J),
              B.framebufferTexture2D(
                B.FRAMEBUFFER,
                B.COLOR_ATTACHMENT0,
                B.TEXTURE_2D,
                J,
                0
              );
            try {
              le(ce);
            } finally {
              B.deleteFramebuffer(ce),
                B.bindFramebuffer(B.FRAMEBUFFER, ue[--ue.length - 1] || null);
            }
          },
          k = function () {
            (H = {}), (X = {}), (ne = {}), (oe = -1), (ue.length = 0);
          };
        var Ie = Ee,
          te = he,
          ge = Ce,
          ie = _e,
          pe = $,
          de = k,
          Z =
            typeof WebGL2RenderingContext < "u" &&
            B instanceof WebGL2RenderingContext,
          H = {},
          X = {},
          ne = {},
          oe = -1,
          ue = [];
        B.canvas.addEventListener(
          "webglcontextlost",
          function (J) {
            k(), J.preventDefault();
          },
          !1
        ),
          l.set(
            B,
            (q = {
              gl: B,
              isWebGL2: Z,
              getExtension: Ee,
              withProgram: Ce,
              withTexture: _e,
              withTextureFramebuffer: $,
              handleContextLoss: k,
            })
          );
      }
      W(q);
    }
    function d(j, W, B, q, Z, H, X, ne) {
      X === void 0 && (X = 15),
        ne === void 0 && (ne = null),
        u(j, function (oe) {
          var ue = oe.gl,
            Ie = oe.withProgram,
            te = oe.withTexture;
          te("copy", function (ge, ie) {
            ue.texImage2D(
              ue.TEXTURE_2D,
              0,
              ue.RGBA,
              Z,
              H,
              0,
              ue.RGBA,
              ue.UNSIGNED_BYTE,
              W
            ),
              Ie("copy", s, a, function (pe) {
                var de = pe.setUniform,
                  Ee = pe.setAttribute;
                Ee(
                  "aUV",
                  2,
                  ue.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  de("1i", "image", ie),
                  ue.bindFramebuffer(ue.FRAMEBUFFER, ne || null),
                  ue.disable(ue.BLEND),
                  ue.colorMask(X & 8, X & 4, X & 2, X & 1),
                  ue.viewport(B, q, Z, H),
                  ue.scissor(B, q, Z, H),
                  ue.drawArrays(ue.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function p(j, W, B) {
      var q = j.width,
        Z = j.height;
      u(j, function (H) {
        var X = H.gl,
          ne = new Uint8Array(q * Z * 4);
        X.readPixels(0, 0, q, Z, X.RGBA, X.UNSIGNED_BYTE, ne),
          (j.width = W),
          (j.height = B),
          d(X, ne, 0, 0, q, Z);
      });
    }
    var m = Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: d,
      resizeWebGLCanvasWithoutClearing: p,
    });
    function v(j, W, B, q, Z, H) {
      H === void 0 && (H = 1);
      var X = new Uint8Array(j * W),
        ne = q[2] - q[0],
        oe = q[3] - q[1],
        ue = [];
      o(B, function (Ee, he, Ce, _e) {
        ue.push({
          x1: Ee,
          y1: he,
          x2: Ce,
          y2: _e,
          minX: Math.min(Ee, Ce),
          minY: Math.min(he, _e),
          maxX: Math.max(Ee, Ce),
          maxY: Math.max(he, _e),
        });
      }),
        ue.sort(function (Ee, he) {
          return Ee.maxX - he.maxX;
        });
      for (var Ie = 0; Ie < j; Ie++)
        for (var te = 0; te < W; te++) {
          var ge = pe(
              q[0] + (ne * (Ie + 0.5)) / j,
              q[1] + (oe * (te + 0.5)) / W
            ),
            ie = Math.pow(1 - Math.abs(ge) / Z, H) / 2;
          ge < 0 && (ie = 1 - ie),
            (ie = Math.max(0, Math.min(255, Math.round(ie * 255)))),
            (X[te * j + Ie] = ie);
        }
      return X;
      function pe(Ee, he) {
        for (var Ce = 1 / 0, _e = 1 / 0, $ = ue.length; $--; ) {
          var k = ue[$];
          if (k.maxX + _e <= Ee) break;
          if (Ee + _e > k.minX && he - _e < k.maxY && he + _e > k.minY) {
            var J = g(Ee, he, k.x1, k.y1, k.x2, k.y2);
            J < Ce && ((Ce = J), (_e = Math.sqrt(Ce)));
          }
        }
        return de(Ee, he) && (_e = -_e), _e;
      }
      function de(Ee, he) {
        for (var Ce = 0, _e = ue.length; _e--; ) {
          var $ = ue[_e];
          if ($.maxX <= Ee) break;
          var k =
            $.y1 > he != $.y2 > he &&
            Ee < (($.x2 - $.x1) * (he - $.y1)) / ($.y2 - $.y1) + $.x1;
          k && (Ce += $.y1 < $.y2 ? 1 : -1);
        }
        return Ce !== 0;
      }
    }
    function _(j, W, B, q, Z, H, X, ne, oe, ue) {
      H === void 0 && (H = 1),
        ne === void 0 && (ne = 0),
        oe === void 0 && (oe = 0),
        ue === void 0 && (ue = 0),
        y(j, W, B, q, Z, H, X, null, ne, oe, ue);
    }
    function y(j, W, B, q, Z, H, X, ne, oe, ue, Ie) {
      H === void 0 && (H = 1),
        oe === void 0 && (oe = 0),
        ue === void 0 && (ue = 0),
        Ie === void 0 && (Ie = 0);
      for (
        var te = v(j, W, B, q, Z, H),
          ge = new Uint8Array(te.length * 4),
          ie = 0;
        ie < te.length;
        ie++
      )
        ge[ie * 4 + Ie] = te[ie];
      d(X, ge, oe, ue, j, W, 1 << (3 - Ie), ne);
    }
    function g(j, W, B, q, Z, H) {
      var X = Z - B,
        ne = H - q,
        oe = X * X + ne * ne,
        ue = oe
          ? Math.max(0, Math.min(1, ((j - B) * X + (W - q) * ne) / oe))
          : 0,
        Ie = j - (B + ue * X),
        te = W - (q + ue * ne);
      return Ie * Ie + te * te;
    }
    var x = Object.freeze({
        __proto__: null,
        generate: v,
        generateIntoCanvas: _,
        generateIntoFramebuffer: y,
      }),
      S =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      b =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      C =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      M = new Float32Array([0, 0, 2, 0, 0, 2]),
      T = null,
      P = !1,
      R = {},
      E = new WeakMap();
    function O(j) {
      if (!P && !V(j)) throw new Error("WebGL generation not supported");
    }
    function D(j, W, B, q, Z, H, X) {
      if (
        (H === void 0 && (H = 1),
        X === void 0 && (X = null),
        !X && ((X = T), !X))
      ) {
        var ne =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!ne) throw new Error("OffscreenCanvas or DOM canvas not supported");
        X = T = ne.getContext("webgl", { depth: !1 });
      }
      O(X);
      var oe = new Uint8Array(j * W * 4);
      u(X, function (ge) {
        var ie = ge.gl,
          pe = ge.withTexture,
          de = ge.withTextureFramebuffer;
        pe("readable", function (Ee, he) {
          ie.texImage2D(
            ie.TEXTURE_2D,
            0,
            ie.RGBA,
            j,
            W,
            0,
            ie.RGBA,
            ie.UNSIGNED_BYTE,
            null
          ),
            de(Ee, he, function (Ce) {
              z(j, W, B, q, Z, H, ie, Ce, 0, 0, 0),
                ie.readPixels(0, 0, j, W, ie.RGBA, ie.UNSIGNED_BYTE, oe);
            });
        });
      });
      for (
        var ue = new Uint8Array(j * W), Ie = 0, te = 0;
        Ie < oe.length;
        Ie += 4
      )
        ue[te++] = oe[Ie];
      return ue;
    }
    function N(j, W, B, q, Z, H, X, ne, oe, ue) {
      H === void 0 && (H = 1),
        ne === void 0 && (ne = 0),
        oe === void 0 && (oe = 0),
        ue === void 0 && (ue = 0),
        z(j, W, B, q, Z, H, X, null, ne, oe, ue);
    }
    function z(j, W, B, q, Z, H, X, ne, oe, ue, Ie) {
      H === void 0 && (H = 1),
        oe === void 0 && (oe = 0),
        ue === void 0 && (ue = 0),
        Ie === void 0 && (Ie = 0),
        O(X);
      var te = [];
      o(B, function (ge, ie, pe, de) {
        te.push(ge, ie, pe, de);
      }),
        (te = new Float32Array(te)),
        u(X, function (ge) {
          var ie = ge.gl,
            pe = ge.isWebGL2,
            de = ge.getExtension,
            Ee = ge.withProgram,
            he = ge.withTexture,
            Ce = ge.withTextureFramebuffer,
            _e = ge.handleContextLoss;
          if (
            (he("rawDistances", function ($, k) {
              (j !== $._lastWidth || W !== $._lastHeight) &&
                ie.texImage2D(
                  ie.TEXTURE_2D,
                  0,
                  ie.RGBA,
                  ($._lastWidth = j),
                  ($._lastHeight = W),
                  0,
                  ie.RGBA,
                  ie.UNSIGNED_BYTE,
                  null
                ),
                Ee("main", S, b, function (J) {
                  var fe = J.setAttribute,
                    le = J.setUniform,
                    ce = !pe && de("ANGLE_instanced_arrays"),
                    we = !pe && de("EXT_blend_minmax");
                  fe("aUV", 2, ie.STATIC_DRAW, 0, M),
                    fe("aLineSegment", 4, ie.DYNAMIC_DRAW, 1, te),
                    le.apply(void 0, ["4f", "uGlyphBounds"].concat(q)),
                    le("1f", "uMaxDistance", Z),
                    le("1f", "uExponent", H),
                    Ce($, k, function (Be) {
                      ie.enable(ie.BLEND),
                        ie.colorMask(!0, !0, !0, !0),
                        ie.viewport(0, 0, j, W),
                        ie.scissor(0, 0, j, W),
                        ie.blendFunc(ie.ONE, ie.ONE),
                        ie.blendEquationSeparate(
                          ie.FUNC_ADD,
                          pe ? ie.MAX : we.MAX_EXT
                        ),
                        ie.clear(ie.COLOR_BUFFER_BIT),
                        pe
                          ? ie.drawArraysInstanced(
                              ie.TRIANGLES,
                              0,
                              3,
                              te.length / 4
                            )
                          : ce.drawArraysInstancedANGLE(
                              ie.TRIANGLES,
                              0,
                              3,
                              te.length / 4
                            );
                    });
                }),
                Ee("post", s, C, function (J) {
                  J.setAttribute("aUV", 2, ie.STATIC_DRAW, 0, M),
                    J.setUniform("1i", "tex", k),
                    ie.bindFramebuffer(ie.FRAMEBUFFER, ne),
                    ie.disable(ie.BLEND),
                    ie.colorMask(Ie === 0, Ie === 1, Ie === 2, Ie === 3),
                    ie.viewport(oe, ue, j, W),
                    ie.scissor(oe, ue, j, W),
                    ie.drawArrays(ie.TRIANGLES, 0, 3);
                });
            }),
            ie.isContextLost())
          )
            throw (_e(), new Error("webgl context lost"));
        });
    }
    function V(j) {
      var W = !j || j === T ? R : j.canvas || j,
        B = E.get(W);
      if (B === void 0) {
        P = !0;
        var q = null;
        try {
          var Z = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            H = D(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, j);
          (B =
            H &&
            Z.length === H.length &&
            H.every(function (X, ne) {
              return X === Z[ne];
            })),
            B || ((q = "bad trial run results"), console.info(Z, H));
        } catch (X) {
          (B = !1), (q = X.message);
        }
        q && console.warn("WebGL SDF generation not supported:", q),
          (P = !1),
          E.set(W, B);
      }
      return B;
    }
    var G = Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: N,
      generateIntoFramebuffer: z,
      isSupported: V,
    });
    function Y(j, W, B, q, Z, H) {
      Z === void 0 && (Z = Math.max(q[2] - q[0], q[3] - q[1]) / 2),
        H === void 0 && (H = 1);
      try {
        return D.apply(G, arguments);
      } catch (X) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", X),
          v.apply(x, arguments)
        );
      }
    }
    function U(j, W, B, q, Z, H, X, ne, oe, ue) {
      Z === void 0 && (Z = Math.max(q[2] - q[0], q[3] - q[1]) / 2),
        H === void 0 && (H = 1),
        ne === void 0 && (ne = 0),
        oe === void 0 && (oe = 0),
        ue === void 0 && (ue = 0);
      try {
        return N.apply(G, arguments);
      } catch (Ie) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Ie),
          _.apply(x, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = Y),
      (e.generateIntoCanvas = U),
      (e.javascript = x),
      (e.pathToLineSegments = o),
      (e.webgl = G),
      (e.webglUtils = m),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return t;
}
function x7() {
  var t = (function (e) {
    var n = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(n).forEach(function (_e, $) {
        (r[_e] = 1 << ($ + 1)), (i[r[_e]] = _e);
      }),
      Object.freeze(r);
    var o = r.LRI | r.RLI | r.FSI,
      s = r.L | r.R | r.AL,
      a = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      l = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      c = r.S | r.WS | r.B | o | r.PDI | l,
      u = null;
    function d() {
      if (!u) {
        u = new Map();
        var _e = function (k) {
          if (n.hasOwnProperty(k)) {
            var J = 0;
            n[k].split(",").forEach(function (fe) {
              var le = fe.split("+"),
                ce = le[0],
                we = le[1];
              (ce = parseInt(ce, 36)),
                (we = we ? parseInt(we, 36) : 0),
                u.set((J += ce), r[k]);
              for (var Be = 0; Be < we; Be++) u.set(++J, r[k]);
            });
          }
        };
        for (var $ in n) _e($);
      }
    }
    function p(_e) {
      return d(), u.get(_e.codePointAt(0)) || r.L;
    }
    function m(_e) {
      return i[p(_e)];
    }
    var v = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function _(_e, $) {
      var k = 36,
        J = 0,
        fe = new Map(),
        le = $ && new Map(),
        ce;
      return (
        _e.split(",").forEach(function we(Be) {
          if (Be.indexOf("+") !== -1) for (var Me = +Be; Me--; ) we(ce);
          else {
            ce = Be;
            var Ge = Be.split(">"),
              Le = Ge[0],
              je = Ge[1];
            (Le = String.fromCodePoint((J += parseInt(Le, k)))),
              (je = String.fromCodePoint((J += parseInt(je, k)))),
              fe.set(Le, je),
              $ && le.set(je, Le);
          }
        }),
        { map: fe, reverseMap: le }
      );
    }
    var y, g, x;
    function S() {
      if (!y) {
        var _e = _(v.pairs, !0),
          $ = _e.map,
          k = _e.reverseMap;
        (y = $), (g = k), (x = _(v.canonical, !1).map);
      }
    }
    function b(_e) {
      return S(), y.get(_e) || null;
    }
    function C(_e) {
      return S(), g.get(_e) || null;
    }
    function M(_e) {
      return S(), x.get(_e) || null;
    }
    var T = r.L,
      P = r.R,
      R = r.EN,
      E = r.ES,
      O = r.ET,
      D = r.AN,
      N = r.CS,
      z = r.B,
      V = r.S,
      G = r.ON,
      Y = r.BN,
      U = r.NSM,
      j = r.AL,
      W = r.LRO,
      B = r.RLO,
      q = r.LRE,
      Z = r.RLE,
      H = r.PDF,
      X = r.LRI,
      ne = r.RLI,
      oe = r.FSI,
      ue = r.PDI;
    function Ie(_e, $) {
      for (
        var k = 125, J = new Uint32Array(_e.length), fe = 0;
        fe < _e.length;
        fe++
      )
        J[fe] = p(_e[fe]);
      var le = new Map();
      function ce(hr, ei) {
        var Bn = J[hr];
        (J[hr] = ei),
          le.set(Bn, le.get(Bn) - 1),
          Bn & a && le.set(a, le.get(a) - 1),
          le.set(ei, (le.get(ei) || 0) + 1),
          ei & a && le.set(a, (le.get(a) || 0) + 1);
      }
      for (
        var we = new Uint8Array(_e.length),
          Be = new Map(),
          Me = [],
          Ge = null,
          Le = 0;
        Le < _e.length;
        Le++
      )
        Ge ||
          Me.push(
            (Ge = {
              start: Le,
              end: _e.length - 1,
              level: $ === "rtl" ? 1 : $ === "ltr" ? 0 : jc(Le, !1),
            })
          ),
          J[Le] & z && ((Ge.end = Le), (Ge = null));
      for (
        var je = Z | q | B | W | o | ue | H | z,
          Je = function (hr) {
            return hr + (hr & 1 ? 1 : 2);
          },
          Ye = function (hr) {
            return hr + (hr & 1 ? 2 : 1);
          },
          De = 0;
        De < Me.length;
        De++
      ) {
        Ge = Me[De];
        var ze = [{ _level: Ge.level, _override: 0, _isolate: 0 }],
          Ve = void 0,
          ae = 0,
          be = 0,
          se = 0;
        le.clear();
        for (var Ae = Ge.start; Ae <= Ge.end; Ae++) {
          var ye = J[Ae];
          if (
            ((Ve = ze[ze.length - 1]),
            le.set(ye, (le.get(ye) || 0) + 1),
            ye & a && le.set(a, (le.get(a) || 0) + 1),
            ye & je)
          )
            if (ye & (Z | q)) {
              we[Ae] = Ve._level;
              var He = (ye === Z ? Ye : Je)(Ve._level);
              He <= k && !ae && !be
                ? ze.push({ _level: He, _override: 0, _isolate: 0 })
                : ae || be++;
            } else if (ye & (B | W)) {
              we[Ae] = Ve._level;
              var qe = (ye === B ? Ye : Je)(Ve._level);
              qe <= k && !ae && !be
                ? ze.push({
                    _level: qe,
                    _override: ye & B ? P : T,
                    _isolate: 0,
                  })
                : ae || be++;
            } else if (ye & o) {
              ye & oe && (ye = jc(Ae + 1, !0) === 1 ? ne : X),
                (we[Ae] = Ve._level),
                Ve._override && ce(Ae, Ve._override);
              var at = (ye === ne ? Ye : Je)(Ve._level);
              at <= k && ae === 0 && be === 0
                ? (se++,
                  ze.push({
                    _level: at,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: Ae,
                  }))
                : ae++;
            } else if (ye & ue) {
              if (ae > 0) ae--;
              else if (se > 0) {
                for (be = 0; !ze[ze.length - 1]._isolate; ) ze.pop();
                var st = ze[ze.length - 1]._isolInitIndex;
                st != null && (Be.set(st, Ae), Be.set(Ae, st)), ze.pop(), se--;
              }
              (Ve = ze[ze.length - 1]),
                (we[Ae] = Ve._level),
                Ve._override && ce(Ae, Ve._override);
            } else
              ye & H
                ? (ae === 0 &&
                    (be > 0
                      ? be--
                      : !Ve._isolate &&
                        ze.length > 1 &&
                        (ze.pop(), (Ve = ze[ze.length - 1]))),
                  (we[Ae] = Ve._level))
                : ye & z && (we[Ae] = Ge.level);
          else
            (we[Ae] = Ve._level),
              Ve._override && ye !== Y && ce(Ae, Ve._override);
        }
        for (var ht = [], pt = null, Ze = Ge.start; Ze <= Ge.end; Ze++) {
          var Mt = J[Ze];
          if (!(Mt & l)) {
            var Rt = we[Ze],
              Yt = Mt & o,
              en = Mt === ue;
            pt && Rt === pt._level
              ? ((pt._end = Ze), (pt._endsWithIsolInit = Yt))
              : ht.push(
                  (pt = {
                    _start: Ze,
                    _end: Ze,
                    _level: Rt,
                    _startsWithPDI: en,
                    _endsWithIsolInit: Yt,
                  })
                );
          }
        }
        for (var Qn = [], cr = 0; cr < ht.length; cr++) {
          var $t = ht[cr];
          if (!$t._startsWithPDI || ($t._startsWithPDI && !Be.has($t._start))) {
            for (
              var ur = [(pt = $t)], fr = void 0;
              pt && pt._endsWithIsolInit && (fr = Be.get(pt._end)) != null;

            )
              for (var Xt = cr + 1; Xt < ht.length; Xt++)
                if (ht[Xt]._start === fr) {
                  ur.push((pt = ht[Xt]));
                  break;
                }
            for (var Vt = [], In = 0; In < ur.length; In++)
              for (var br = ur[In], K = br._start; K <= br._end; K++)
                Vt.push(K);
            for (
              var Se = we[Vt[0]], Oe = Ge.level, Te = Vt[0] - 1;
              Te >= 0;
              Te--
            )
              if (!(J[Te] & l)) {
                Oe = we[Te];
                break;
              }
            var Re = Vt[Vt.length - 1],
              Qe = we[Re],
              ct = Ge.level;
            if (!(J[Re] & o)) {
              for (var nt = Re + 1; nt <= Ge.end; nt++)
                if (!(J[nt] & l)) {
                  ct = we[nt];
                  break;
                }
            }
            Qn.push({
              _seqIndices: Vt,
              _sosType: Math.max(Oe, Se) % 2 ? P : T,
              _eosType: Math.max(ct, Qe) % 2 ? P : T,
            });
          }
        }
        for (var xt = 0; xt < Qn.length; xt++) {
          var Ct = Qn[xt],
            $e = Ct._seqIndices,
            Et = Ct._sosType,
            dn = Ct._eosType,
            cn = we[$e[0]] & 1 ? P : T;
          if (le.get(U))
            for (var Xn = 0; Xn < $e.length; Xn++) {
              var Lr = $e[Xn];
              if (J[Lr] & U) {
                for (var Nt = Et, vt = Xn - 1; vt >= 0; vt--)
                  if (!(J[$e[vt]] & l)) {
                    Nt = J[$e[vt]];
                    break;
                  }
                ce(Lr, Nt & (o | ue) ? G : Nt);
              }
            }
          if (le.get(R))
            for (var Wt = 0; Wt < $e.length; Wt++) {
              var _t = $e[Wt];
              if (J[_t] & R)
                for (var zn = Wt - 1; zn >= -1; zn--) {
                  var Ln = zn === -1 ? Et : J[$e[zn]];
                  if (Ln & s) {
                    Ln === j && ce(_t, D);
                    break;
                  }
                }
            }
          if (le.get(j))
            for (var yn = 0; yn < $e.length; yn++) {
              var hi = $e[yn];
              J[hi] & j && ce(hi, P);
            }
          if (le.get(E) || le.get(N))
            for (var nn = 1; nn < $e.length - 1; nn++) {
              var un = $e[nn];
              if (J[un] & (E | N)) {
                for (
                  var Kr = 0, er = 0, qo = nn - 1;
                  qo >= 0 && ((Kr = J[$e[qo]]), !!(Kr & l));
                  qo--
                );
                for (
                  var Ko = nn + 1;
                  Ko < $e.length && ((er = J[$e[Ko]]), !!(er & l));
                  Ko++
                );
                Kr === er &&
                  (J[un] === E ? Kr === R : Kr & (R | D)) &&
                  ce(un, Kr);
              }
            }
          if (le.get(R))
            for (var Or = 0; Or < $e.length; Or++) {
              var Ri = $e[Or];
              if (J[Ri] & R) {
                for (var Hc = Or - 1; Hc >= 0 && J[$e[Hc]] & (O | l); Hc--)
                  ce($e[Hc], R);
                for (Or++; Or < $e.length && J[$e[Or]] & (O | l | R); Or++)
                  J[$e[Or]] !== R && ce($e[Or], R);
              }
            }
          if (le.get(O) || le.get(E) || le.get(N))
            for (var hl = 0; hl < $e.length; hl++) {
              var Xp = $e[hl];
              if (J[Xp] & (O | E | N)) {
                ce(Xp, G);
                for (var _s = hl - 1; _s >= 0 && J[$e[_s]] & l; _s--)
                  ce($e[_s], G);
                for (var Ss = hl + 1; Ss < $e.length && J[$e[Ss]] & l; Ss++)
                  ce($e[Ss], G);
              }
            }
          if (le.get(R))
            for (var As = 0, pl = Et; As < $e.length; As++) {
              var Yp = $e[As],
                Xf = J[Yp];
              Xf & R ? pl === T && ce(Yp, T) : Xf & s && (pl = Xf);
            }
          if (le.get(a)) {
            var bs = P | R | D,
              Vc = bs | T,
              Zo = [];
            {
              for (var ua = [], Jo = 0; Jo < $e.length; Jo++)
                if (J[$e[Jo]] & a) {
                  var Ht = _e[$e[Jo]],
                    Yf = void 0;
                  if (b(Ht) !== null)
                    if (ua.length < 63) ua.push({ char: Ht, seqIndex: Jo });
                    else break;
                  else if ((Yf = C(Ht)) !== null)
                    for (var ws = ua.length - 1; ws >= 0; ws--) {
                      var Gc = ua[ws].char;
                      if (Gc === Yf || Gc === C(M(Ht)) || b(M(Gc)) === Ht) {
                        Zo.push([ua[ws].seqIndex, Jo]), (ua.length = ws);
                        break;
                      }
                    }
                }
              Zo.sort(function (hr, ei) {
                return hr[0] - ei[0];
              });
            }
            for (var qf = 0; qf < Zo.length; qf++) {
              for (
                var qp = Zo[qf],
                  An = qp[0],
                  ml = qp[1],
                  Kp = !1,
                  Zr = 0,
                  Kf = An + 1;
                Kf < ml;
                Kf++
              ) {
                var gl = $e[Kf];
                if (J[gl] & Vc) {
                  Kp = !0;
                  var Pi = J[gl] & bs ? P : T;
                  if (Pi === cn) {
                    Zr = Pi;
                    break;
                  }
                }
              }
              if (Kp && !Zr) {
                Zr = Et;
                for (var Zf = An - 1; Zf >= 0; Zf--) {
                  var Zp = $e[Zf];
                  if (J[Zp] & Vc) {
                    var Ii = J[Zp] & bs ? P : T;
                    Ii !== cn ? (Zr = Ii) : (Zr = cn);
                    break;
                  }
                }
              }
              if (Zr) {
                if (((J[$e[An]] = J[$e[ml]] = Zr), Zr !== cn)) {
                  for (var Jr = An + 1; Jr < $e.length; Jr++)
                    if (!(J[$e[Jr]] & l)) {
                      p(_e[$e[Jr]]) & U && (J[$e[Jr]] = Zr);
                      break;
                    }
                }
                if (Zr !== cn) {
                  for (var Qo = ml + 1; Qo < $e.length; Qo++)
                    if (!(J[$e[Qo]] & l)) {
                      p(_e[$e[Qo]]) & U && (J[$e[Qo]] = Zr);
                      break;
                    }
                }
              }
            }
            for (var Qi = 0; Qi < $e.length; Qi++)
              if (J[$e[Qi]] & a) {
                for (var Jf = Qi, Qf = Qi, pi = Et, vl = Qi - 1; vl >= 0; vl--)
                  if (J[$e[vl]] & l) Jf = vl;
                  else {
                    pi = J[$e[vl]] & bs ? P : T;
                    break;
                  }
                for (var yl = dn, xl = Qi + 1; xl < $e.length; xl++)
                  if (J[$e[xl]] & (a | l)) Qf = xl;
                  else {
                    yl = J[$e[xl]] & bs ? P : T;
                    break;
                  }
                for (var Qr = Jf; Qr <= Qf; Qr++)
                  J[$e[Qr]] = pi === yl ? pi : cn;
                Qi = Qf;
              }
          }
        }
        for (var dr = Ge.start; dr <= Ge.end; dr++) {
          var Wc = we[dr],
            Eo = J[dr];
          if (
            (Wc & 1
              ? Eo & (T | R | D) && we[dr]++
              : Eo & P
              ? we[dr]++
              : Eo & (D | R) && (we[dr] += 2),
            Eo & l && (we[dr] = dr === 0 ? Ge.level : we[dr - 1]),
            dr === Ge.end || p(_e[dr]) & (V | z))
          )
            for (var fa = dr; fa >= 0 && p(_e[fa]) & c; fa--) we[fa] = Ge.level;
        }
      }
      return { levels: we, paragraphs: Me };
      function jc(hr, ei) {
        for (var Bn = hr; Bn < _e.length; Bn++) {
          var Hn = J[Bn];
          if (Hn & (P | j)) return 1;
          if (Hn & (z | T) || (ei && Hn === ue)) return 0;
          if (Hn & o) {
            var Li = Jp(Bn);
            Bn = Li === -1 ? _e.length : Li;
          }
        }
        return 0;
      }
      function Jp(hr) {
        for (var ei = 1, Bn = hr + 1; Bn < _e.length; Bn++) {
          var Hn = J[Bn];
          if (Hn & z) break;
          if (Hn & ue) {
            if (--ei === 0) return Bn;
          } else Hn & o && ei++;
        }
        return -1;
      }
    }
    var te =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      ge;
    function ie() {
      if (!ge) {
        var _e = _(te, !0),
          $ = _e.map,
          k = _e.reverseMap;
        k.forEach(function (J, fe) {
          $.set(fe, J);
        }),
          (ge = $);
      }
    }
    function pe(_e) {
      return ie(), ge.get(_e) || null;
    }
    function de(_e, $, k, J) {
      var fe = _e.length;
      (k = Math.max(0, k == null ? 0 : +k)),
        (J = Math.min(fe - 1, J == null ? fe - 1 : +J));
      for (var le = new Map(), ce = k; ce <= J; ce++)
        if ($[ce] & 1) {
          var we = pe(_e[ce]);
          we !== null && le.set(ce, we);
        }
      return le;
    }
    function Ee(_e, $, k, J) {
      var fe = _e.length;
      (k = Math.max(0, k == null ? 0 : +k)),
        (J = Math.min(fe - 1, J == null ? fe - 1 : +J));
      var le = [];
      return (
        $.paragraphs.forEach(function (ce) {
          var we = Math.max(k, ce.start),
            Be = Math.min(J, ce.end);
          if (we < Be) {
            for (
              var Me = $.levels.slice(we, Be + 1), Ge = Be;
              Ge >= we && p(_e[Ge]) & c;
              Ge--
            )
              Me[Ge] = ce.level;
            for (var Le = ce.level, je = 1 / 0, Je = 0; Je < Me.length; Je++) {
              var Ye = Me[Je];
              Ye > Le && (Le = Ye), Ye < je && (je = Ye | 1);
            }
            for (var De = Le; De >= je; De--)
              for (var ze = 0; ze < Me.length; ze++)
                if (Me[ze] >= De) {
                  for (var Ve = ze; ze + 1 < Me.length && Me[ze + 1] >= De; )
                    ze++;
                  ze > Ve && le.push([Ve + we, ze + we]);
                }
          }
        }),
        le
      );
    }
    function he(_e, $, k, J) {
      var fe = Ce(_e, $, k, J),
        le = [].concat(_e);
      return (
        fe.forEach(function (ce, we) {
          le[we] = ($.levels[ce] & 1 ? pe(_e[ce]) : null) || _e[ce];
        }),
        le.join("")
      );
    }
    function Ce(_e, $, k, J) {
      for (var fe = Ee(_e, $, k, J), le = [], ce = 0; ce < _e.length; ce++)
        le[ce] = ce;
      return (
        fe.forEach(function (we) {
          for (
            var Be = we[0],
              Me = we[1],
              Ge = le.slice(Be, Me + 1),
              Le = Ge.length;
            Le--;

          )
            le[Me - Le] = Ge[Le];
        }),
        le
      );
    }
    return (
      (e.closingToOpeningBracket = C),
      (e.getBidiCharType = p),
      (e.getBidiCharTypeName = m),
      (e.getCanonicalBracket = M),
      (e.getEmbeddingLevels = Ie),
      (e.getMirroredCharacter = pe),
      (e.getMirroredCharactersMap = de),
      (e.getReorderSegments = Ee),
      (e.getReorderedIndices = Ce),
      (e.getReorderedString = he),
      (e.openingToClosingBracket = b),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return t;
}
const ZD = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function $A(t) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(r, i) {
    let o = Lt[i];
    return o ? $A(o) : r;
  }
  return t.replace(e, n);
}
const Er = [];
for (let t = 0; t < 256; t++) Er[t] = (t < 16 ? "0" : "") + t.toString(16);
function _7() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Er[t & 255] +
    Er[(t >> 8) & 255] +
    Er[(t >> 16) & 255] +
    Er[(t >> 24) & 255] +
    "-" +
    Er[e & 255] +
    Er[(e >> 8) & 255] +
    "-" +
    Er[((e >> 16) & 15) | 64] +
    Er[(e >> 24) & 255] +
    "-" +
    Er[(n & 63) | 128] +
    Er[(n >> 8) & 255] +
    "-" +
    Er[(n >> 16) & 255] +
    Er[(n >> 24) & 255] +
    Er[r & 255] +
    Er[(r >> 8) & 255] +
    Er[(r >> 16) & 255] +
    Er[(r >> 24) & 255]
  ).toUpperCase();
}
const Hl =
    Object.assign ||
    function () {
      let t = arguments[0];
      for (let e = 1, n = arguments.length; e < n; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
      }
      return t;
    },
  S7 = Date.now(),
  ZR = new WeakMap(),
  JR = new Map();
let A7 = 1e10;
function XA(t, e) {
  const n = M7(e);
  let r = ZR.get(t);
  if ((r || ZR.set(t, (r = Object.create(null))), r[n])) return new r[n]();
  const i = `_onBeforeCompile${n}`,
    o = function (c, u) {
      t.onBeforeCompile.call(this, c, u);
      const d =
        this.customProgramCacheKey() +
        "|" +
        c.vertexShader +
        "|" +
        c.fragmentShader;
      let p = JR[d];
      if (!p) {
        const m = b7(this, c, e, n);
        p = JR[d] = m;
      }
      (c.vertexShader = p.vertexShader),
        (c.fragmentShader = p.fragmentShader),
        Hl(c.uniforms, this.uniforms),
        e.timeUniform &&
          (c.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - S7;
            },
          }),
        this[i] && this[i](c);
    },
    s = function () {
      return a(e.chained ? t : t.clone());
    },
    a = function (c) {
      const u = Object.create(c, l);
      return (
        Object.defineProperty(u, "baseMaterial", { value: t }),
        Object.defineProperty(u, "id", { value: A7++ }),
        (u.uuid = _7()),
        (u.uniforms = Hl({}, c.uniforms, e.uniforms)),
        (u.defines = Hl({}, c.defines, e.defines)),
        (u.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = ""),
        (u.extensions = Hl({}, c.extensions, e.extensions)),
        (u._listeners = void 0),
        u
      );
    },
    l = {
      constructor: { value: s },
      isDerivedMaterial: { value: !0 },
      type: {
        get: () => t.type,
        set: (c) => {
          t.type = c;
        },
      },
      isDerivedFrom: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          const u = this.baseMaterial;
          return c === u || (u.isDerivedMaterial && u.isDerivedFrom(c)) || !1;
        },
      },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return t.customProgramCacheKey() + "|" + n;
        },
      },
      onBeforeCompile: {
        get() {
          return o;
        },
        set(c) {
          this[i] = c;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          return (
            t.copy.call(this, c),
            !t.isShaderMaterial &&
              !t.isDerivedMaterial &&
              (Hl(this.extensions, c.extensions),
              Hl(this.defines, c.defines),
              Hl(this.uniforms, uE.clone(c.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const c = new t.constructor();
          return a(c).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._depthMaterial;
          return (
            c ||
              ((c = this._depthMaterial =
                XA(
                  t.isDerivedMaterial
                    ? t.getDepthMaterial()
                    : new sy({ depthPacking: iE }),
                  e
                )),
              (c.defines.IS_DEPTH_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._distanceMaterial;
          return (
            c ||
              ((c = this._distanceMaterial =
                XA(
                  t.isDerivedMaterial ? t.getDistanceMaterial() : new ay(),
                  e
                )),
              (c.defines.IS_DISTANCE_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: c, _distanceMaterial: u } = this;
          c && c.dispose(), u && u.dispose(), t.dispose.call(this);
        },
      },
    };
  return (r[n] = s), new s();
}
function b7(t, { vertexShader: e, fragmentShader: n }, r, i) {
  let {
    vertexDefs: o,
    vertexMainIntro: s,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: d,
    fragmentColorTransform: p,
    customRewriter: m,
    timeUniform: v,
  } = r;
  if (
    ((o = o || ""),
    (s = s || ""),
    (a = a || ""),
    (c = c || ""),
    (u = u || ""),
    (d = d || ""),
    (l || m) && (e = $A(e)),
    (p || m) &&
      ((n = n.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (n = $A(n))),
    m)
  ) {
    let _ = m({ vertexShader: e, fragmentShader: n });
    (e = _.vertexShader), (n = _.fragmentShader);
  }
  if (p) {
    let _ = [];
    (n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (y) => (_.push(y), "")
    )),
      (d = `${p}
${_.join(`
`)}
${d}`);
  }
  if (v) {
    const _ = `
uniform float ${v};
`;
    (o = _ + o), (c = _ + c);
  }
  return (
    l &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (o = `${o}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`),
      (s = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${s}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (_, y, g, x) =>
        /\battribute\s+vec[23]\s+$/.test(x.substr(0, g))
          ? y
          : `troika_${y}_${i}`
      )),
      (t.map && t.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = QR(e, i, o, s, a)),
    (n = QR(n, i, c, u, d)),
    { vertexShader: e, fragmentShader: n }
  );
}
function QR(t, e, n, r, i) {
  return (
    (r || i || n) &&
      ((t = t.replace(
        ZD,
        `
${n}
void troikaOrigMain${e}() {`
      )),
      (t += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    t
  );
}
function w7(t, e) {
  return t === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let E7 = 0;
const eP = new Map();
function M7(t) {
  const e = JSON.stringify(t, w7);
  let n = eP.get(e);
  return n == null && eP.set(e, (n = ++E7)), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function C7() {
  return (
    typeof window > "u" && (self.window = self),
    (function (t) {
      var e = {
        parse: function (i) {
          var o = e._bin,
            s = new Uint8Array(i);
          if (o.readASCII(s, 0, 4) == "ttcf") {
            var a = 4;
            o.readUshort(s, a), (a += 2), o.readUshort(s, a), (a += 2);
            var l = o.readUint(s, a);
            a += 4;
            for (var c = [], u = 0; u < l; u++) {
              var d = o.readUint(s, a);
              (a += 4), c.push(e._readFont(s, d));
            }
            return c;
          }
          return [e._readFont(s, 0)];
        },
        _readFont: function (i, o) {
          var s = e._bin,
            a = o;
          s.readFixed(i, o), (o += 4);
          var l = s.readUshort(i, o);
          (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2);
          for (
            var c = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              u = { _data: i, _offset: a },
              d = {},
              p = 0;
            p < l;
            p++
          ) {
            var m = s.readASCII(i, o, 4);
            (o += 4), s.readUint(i, o), (o += 4);
            var v = s.readUint(i, o);
            o += 4;
            var _ = s.readUint(i, o);
            (o += 4), (d[m] = { offset: v, length: _ });
          }
          for (p = 0; p < c.length; p++) {
            var y = c[p];
            d[y] &&
              (u[y.trim()] = e[y.trim()].parse(i, d[y].offset, d[y].length, u));
          }
          return u;
        },
        _tabOffset: function (i, o, s) {
          for (
            var a = e._bin, l = a.readUshort(i, s + 4), c = s + 12, u = 0;
            u < l;
            u++
          ) {
            var d = a.readASCII(i, c, 4);
            (c += 4), a.readUint(i, c), (c += 4);
            var p = a.readUint(i, c);
            if (((c += 4), a.readUint(i, c), (c += 4), d == o)) return p;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, o) {
          return (
            ((i[o] << 8) | i[o + 1]) + ((i[o + 2] << 8) | i[o + 3]) / 65540
          );
        },
        readF2dot14: function (i, o) {
          return e._bin.readShort(i, o) / 16384;
        },
        readInt: function (i, o) {
          return e._bin._view(i).getInt32(o);
        },
        readInt8: function (i, o) {
          return e._bin._view(i).getInt8(o);
        },
        readShort: function (i, o) {
          return e._bin._view(i).getInt16(o);
        },
        readUshort: function (i, o) {
          return e._bin._view(i).getUint16(o);
        },
        readUshorts: function (i, o, s) {
          for (var a = [], l = 0; l < s; l++)
            a.push(e._bin.readUshort(i, o + 2 * l));
          return a;
        },
        readUint: function (i, o) {
          return e._bin._view(i).getUint32(o);
        },
        readUint64: function (i, o) {
          return 4294967296 * e._bin.readUint(i, o) + e._bin.readUint(i, o + 4);
        },
        readASCII: function (i, o, s) {
          for (var a = "", l = 0; l < s; l++)
            a += String.fromCharCode(i[o + l]);
          return a;
        },
        readUnicode: function (i, o, s) {
          for (var a = "", l = 0; l < s; l++) {
            var c = (i[o++] << 8) | i[o++];
            a += String.fromCharCode(c);
          }
          return a;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, o, s) {
          var a = e._bin._tdec;
          return a && o == 0 && s == i.length
            ? a.decode(i)
            : e._bin.readASCII(i, o, s);
        },
        readBytes: function (i, o, s) {
          for (var a = [], l = 0; l < s; l++) a.push(i[o + l]);
          return a;
        },
        readASCIIArray: function (i, o, s) {
          for (var a = [], l = 0; l < s; l++)
            a.push(String.fromCharCode(i[o + l]));
          return a;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, o, s, a, l) {
          var c = e._bin,
            u = {},
            d = o;
          c.readFixed(i, o), (o += 4);
          var p = c.readUshort(i, o);
          o += 2;
          var m = c.readUshort(i, o);
          o += 2;
          var v = c.readUshort(i, o);
          return (
            (o += 2),
            (u.scriptList = e._lctf.readScriptList(i, d + p)),
            (u.featureList = e._lctf.readFeatureList(i, d + m)),
            (u.lookupList = e._lctf.readLookupList(i, d + v, l)),
            u
          );
        }),
        (e._lctf.readLookupList = function (i, o, s) {
          var a = e._bin,
            l = o,
            c = [],
            u = a.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            var p = a.readUshort(i, o);
            o += 2;
            var m = e._lctf.readLookupTable(i, l + p, s);
            c.push(m);
          }
          return c;
        }),
        (e._lctf.readLookupTable = function (i, o, s) {
          var a = e._bin,
            l = o,
            c = { tabs: [] };
          (c.ltype = a.readUshort(i, o)),
            (o += 2),
            (c.flag = a.readUshort(i, o)),
            (o += 2);
          var u = a.readUshort(i, o);
          o += 2;
          for (var d = c.ltype, p = 0; p < u; p++) {
            var m = a.readUshort(i, o);
            o += 2;
            var v = s(i, d, l + m, c);
            c.tabs.push(v);
          }
          return c;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var o = 0, s = 0; s < 32; s++) (i >>> s) & 1 && o++;
          return o;
        }),
        (e._lctf.readClassDef = function (i, o) {
          var s = e._bin,
            a = [],
            l = s.readUshort(i, o);
          if (((o += 2), l == 1)) {
            var c = s.readUshort(i, o);
            o += 2;
            var u = s.readUshort(i, o);
            o += 2;
            for (var d = 0; d < u; d++)
              a.push(c + d),
                a.push(c + d),
                a.push(s.readUshort(i, o)),
                (o += 2);
          }
          if (l == 2) {
            var p = s.readUshort(i, o);
            for (o += 2, d = 0; d < p; d++)
              a.push(s.readUshort(i, o)),
                (o += 2),
                a.push(s.readUshort(i, o)),
                (o += 2),
                a.push(s.readUshort(i, o)),
                (o += 2);
          }
          return a;
        }),
        (e._lctf.getInterval = function (i, o) {
          for (var s = 0; s < i.length; s += 3) {
            var a = i[s],
              l = i[s + 1];
            if ((i[s + 2], a <= o && o <= l)) return s;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, o) {
          var s = e._bin,
            a = {};
          (a.fmt = s.readUshort(i, o)), (o += 2);
          var l = s.readUshort(i, o);
          return (
            (o += 2),
            a.fmt == 1 && (a.tab = s.readUshorts(i, o, l)),
            a.fmt == 2 && (a.tab = s.readUshorts(i, o, 3 * l)),
            a
          );
        }),
        (e._lctf.coverageIndex = function (i, o) {
          var s = i.tab;
          if (i.fmt == 1) return s.indexOf(o);
          if (i.fmt == 2) {
            var a = e._lctf.getInterval(s, o);
            if (a != -1) return s[a + 2] + (o - s[a]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, o) {
          var s = e._bin,
            a = o,
            l = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = s.readASCII(i, o, 4);
            o += 4;
            var p = s.readUshort(i, o);
            o += 2;
            var m = e._lctf.readFeatureTable(i, a + p);
            (m.tag = d.trim()), l.push(m);
          }
          return l;
        }),
        (e._lctf.readFeatureTable = function (i, o) {
          var s = e._bin,
            a = o,
            l = {},
            c = s.readUshort(i, o);
          (o += 2), c > 0 && (l.featureParams = a + c);
          var u = s.readUshort(i, o);
          (o += 2), (l.tab = []);
          for (var d = 0; d < u; d++) l.tab.push(s.readUshort(i, o + 2 * d));
          return l;
        }),
        (e._lctf.readScriptList = function (i, o) {
          var s = e._bin,
            a = o,
            l = {},
            c = s.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = s.readASCII(i, o, 4);
            o += 4;
            var p = s.readUshort(i, o);
            (o += 2), (l[d.trim()] = e._lctf.readScriptTable(i, a + p));
          }
          return l;
        }),
        (e._lctf.readScriptTable = function (i, o) {
          var s = e._bin,
            a = o,
            l = {},
            c = s.readUshort(i, o);
          (o += 2), c > 0 && (l.default = e._lctf.readLangSysTable(i, a + c));
          var u = s.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            var p = s.readASCII(i, o, 4);
            o += 4;
            var m = s.readUshort(i, o);
            (o += 2), (l[p.trim()] = e._lctf.readLangSysTable(i, a + m));
          }
          return l;
        }),
        (e._lctf.readLangSysTable = function (i, o) {
          var s = e._bin,
            a = {};
          s.readUshort(i, o),
            (o += 2),
            (a.reqFeature = s.readUshort(i, o)),
            (o += 2);
          var l = s.readUshort(i, o);
          return (o += 2), (a.features = s.readUshorts(i, o, l)), a;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, o, s) {
          var a = e._bin;
          (i = new Uint8Array(i.buffer, o, s))[(o = 0)],
            i[++o],
            i[++o],
            i[++o],
            o++;
          var l = [];
          o = e.CFF.readIndex(i, o, l);
          for (var c = [], u = 0; u < l.length - 1; u++)
            c.push(a.readASCII(i, o + l[u], l[u + 1] - l[u]));
          o += l[l.length - 1];
          var d = [];
          o = e.CFF.readIndex(i, o, d);
          var p = [];
          for (u = 0; u < d.length - 1; u++)
            p.push(e.CFF.readDict(i, o + d[u], o + d[u + 1]));
          o += d[d.length - 1];
          var m = p[0],
            v = [];
          o = e.CFF.readIndex(i, o, v);
          var _ = [];
          for (u = 0; u < v.length - 1; u++)
            _.push(a.readASCII(i, o + v[u], v[u + 1] - v[u]));
          if (
            ((o += v[v.length - 1]), e.CFF.readSubrs(i, o, m), m.CharStrings)
          ) {
            (o = m.CharStrings), (v = []), (o = e.CFF.readIndex(i, o, v));
            var y = [];
            for (u = 0; u < v.length - 1; u++)
              y.push(a.readBytes(i, o + v[u], v[u + 1] - v[u]));
            m.CharStrings = y;
          }
          if (m.ROS) {
            o = m.FDArray;
            var g = [];
            for (
              o = e.CFF.readIndex(i, o, g), m.FDArray = [], u = 0;
              u < g.length - 1;
              u++
            ) {
              var x = e.CFF.readDict(i, o + g[u], o + g[u + 1]);
              e.CFF._readFDict(i, x, _), m.FDArray.push(x);
            }
            (o += g[g.length - 1]), (o = m.FDSelect), (m.FDSelect = []);
            var S = i[o];
            if ((o++, S != 3)) throw S;
            var b = a.readUshort(i, o);
            for (o += 2, u = 0; u < b + 1; u++)
              m.FDSelect.push(a.readUshort(i, o), i[o + 2]), (o += 3);
          }
          return (
            m.Encoding &&
              (m.Encoding = e.CFF.readEncoding(
                i,
                m.Encoding,
                m.CharStrings.length
              )),
            m.charset &&
              (m.charset = e.CFF.readCharset(
                i,
                m.charset,
                m.CharStrings.length
              )),
            e.CFF._readFDict(i, m, _),
            m
          );
        }),
        (e.CFF._readFDict = function (i, o, s) {
          var a;
          for (var l in (o.Private &&
            ((a = o.Private[1]),
            (o.Private = e.CFF.readDict(i, a, a + o.Private[0])),
            o.Private.Subrs &&
              e.CFF.readSubrs(i, a + o.Private.Subrs, o.Private)),
          o))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(l) != -1 && (o[l] = s[o[l] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, o, s) {
          var a = e._bin,
            l = [];
          o = e.CFF.readIndex(i, o, l);
          var c,
            u = l.length;
          (c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768),
            (s.Bias = c),
            (s.Subrs = []);
          for (var d = 0; d < l.length - 1; d++)
            s.Subrs.push(a.readBytes(i, o + l[d], l[d + 1] - l[d]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, o) {
          for (var s = 0; s < i.charset.length; s++)
            if (i.charset[s] == o) return s;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, o) {
          return o < 0 || o > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[o]);
        }),
        (e.CFF.readEncoding = function (i, o, s) {
          e._bin;
          var a = [".notdef"],
            l = i[o];
          if ((o++, l != 0)) throw "error: unknown encoding format: " + l;
          var c = i[o];
          o++;
          for (var u = 0; u < c; u++) a.push(i[o + u]);
          return a;
        }),
        (e.CFF.readCharset = function (i, o, s) {
          var a = e._bin,
            l = [".notdef"],
            c = i[o];
          if ((o++, c == 0))
            for (var u = 0; u < s; u++) {
              var d = a.readUshort(i, o);
              (o += 2), l.push(d);
            }
          else {
            if (c != 1 && c != 2) throw "error: format: " + c;
            for (; l.length < s; ) {
              (d = a.readUshort(i, o)), (o += 2);
              var p = 0;
              for (
                c == 1
                  ? ((p = i[o]), o++)
                  : ((p = a.readUshort(i, o)), (o += 2)),
                  u = 0;
                u <= p;
                u++
              )
                l.push(d), d++;
            }
          }
          return l;
        }),
        (e.CFF.readIndex = function (i, o, s) {
          var a = e._bin,
            l = a.readUshort(i, o) + 1,
            c = i[(o += 2)];
          if ((o++, c == 1)) for (var u = 0; u < l; u++) s.push(i[o + u]);
          else if (c == 2)
            for (u = 0; u < l; u++) s.push(a.readUshort(i, o + 2 * u));
          else if (c == 3)
            for (u = 0; u < l; u++)
              s.push(16777215 & a.readUint(i, o + 3 * u - 1));
          else if (l != 1)
            throw "unsupported offset size: " + c + ", count: " + l;
          return (o += l * c) - 1;
        }),
        (e.CFF.getCharString = function (i, o, s) {
          var a = e._bin,
            l = i[o],
            c = i[o + 1];
          i[o + 2], i[o + 3], i[o + 4];
          var u = 1,
            d = null,
            p = null;
          l <= 20 && ((d = l), (u = 1)),
            l == 12 && ((d = 100 * l + c), (u = 2)),
            21 <= l && l <= 27 && ((d = l), (u = 1)),
            l == 28 && ((p = a.readShort(i, o + 1)), (u = 3)),
            29 <= l && l <= 31 && ((d = l), (u = 1)),
            32 <= l && l <= 246 && ((p = l - 139), (u = 1)),
            247 <= l && l <= 250 && ((p = 256 * (l - 247) + c + 108), (u = 2)),
            251 <= l && l <= 254 && ((p = 256 * -(l - 251) - c - 108), (u = 2)),
            l == 255 && ((p = a.readInt(i, o + 1) / 65535), (u = 5)),
            (s.val = p ?? "o" + d),
            (s.size = u);
        }),
        (e.CFF.readCharString = function (i, o, s) {
          for (var a = o + s, l = e._bin, c = []; o < a; ) {
            var u = i[o],
              d = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var p = 1,
              m = null,
              v = null;
            u <= 20 && ((m = u), (p = 1)),
              u == 12 && ((m = 100 * u + d), (p = 2)),
              (u != 19 && u != 20) || ((m = u), (p = 2)),
              21 <= u && u <= 27 && ((m = u), (p = 1)),
              u == 28 && ((v = l.readShort(i, o + 1)), (p = 3)),
              29 <= u && u <= 31 && ((m = u), (p = 1)),
              32 <= u && u <= 246 && ((v = u - 139), (p = 1)),
              247 <= u &&
                u <= 250 &&
                ((v = 256 * (u - 247) + d + 108), (p = 2)),
              251 <= u &&
                u <= 254 &&
                ((v = 256 * -(u - 251) - d - 108), (p = 2)),
              u == 255 && ((v = l.readInt(i, o + 1) / 65535), (p = 5)),
              c.push(v ?? "o" + m),
              (o += p);
          }
          return c;
        }),
        (e.CFF.readDict = function (i, o, s) {
          for (var a = e._bin, l = {}, c = []; o < s; ) {
            var u = i[o],
              d = i[o + 1];
            i[o + 2], i[o + 3], i[o + 4];
            var p = 1,
              m = null,
              v = null;
            if (
              (u == 28 && ((v = a.readShort(i, o + 1)), (p = 3)),
              u == 29 && ((v = a.readInt(i, o + 1)), (p = 5)),
              32 <= u && u <= 246 && ((v = u - 139), (p = 1)),
              247 <= u &&
                u <= 250 &&
                ((v = 256 * (u - 247) + d + 108), (p = 2)),
              251 <= u &&
                u <= 254 &&
                ((v = 256 * -(u - 251) - d - 108), (p = 2)),
              u == 255)
            )
              throw (
                ((v = a.readInt(i, o + 1) / 65535), (p = 5), "unknown number")
              );
            if (u == 30) {
              var _ = [];
              for (p = 1; ; ) {
                var y = i[o + p];
                p++;
                var g = y >> 4,
                  x = 15 & y;
                if ((g != 15 && _.push(g), x != 15 && _.push(x), x == 15))
                  break;
              }
              for (
                var S = "",
                  b = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  C = 0;
                C < _.length;
                C++
              )
                S += b[_[C]];
              v = parseFloat(S);
            }
            u <= 21 &&
              ((m = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][u]),
              (p = 1),
              u == 12 &&
                ((m = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][d]),
                (p = 2))),
              m != null
                ? ((l[m] = c.length == 1 ? c[0] : c), (c = []))
                : c.push(v),
              (o += p);
          }
          return l;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, o, s) {
          (i = new Uint8Array(i.buffer, o, s)), (o = 0);
          var a = e._bin,
            l = {};
          a.readUshort(i, o), (o += 2);
          var c = a.readUshort(i, o);
          o += 2;
          var u = [];
          l.tables = [];
          for (var d = 0; d < c; d++) {
            var p = a.readUshort(i, o);
            o += 2;
            var m = a.readUshort(i, o);
            o += 2;
            var v = a.readUint(i, o);
            o += 4;
            var _ = "p" + p + "e" + m,
              y = u.indexOf(v);
            if (y == -1) {
              var g;
              (y = l.tables.length), u.push(v);
              var x = a.readUshort(i, v);
              x == 0
                ? (g = e.cmap.parse0(i, v))
                : x == 4
                ? (g = e.cmap.parse4(i, v))
                : x == 6
                ? (g = e.cmap.parse6(i, v))
                : x == 12
                ? (g = e.cmap.parse12(i, v))
                : console.debug("unknown format: " + x, p, m, v),
                l.tables.push(g);
            }
            if (l[_] != null) throw "multiple tables for one platform+encoding";
            l[_] = y;
          }
          return l;
        }),
        (e.cmap.parse0 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)), (o += 2);
          var l = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2), (a.map = []);
          for (var c = 0; c < l - 6; c++) a.map.push(i[o + c]);
          return a;
        }),
        (e.cmap.parse4 = function (i, o) {
          var s = e._bin,
            a = o,
            l = {};
          (l.format = s.readUshort(i, o)), (o += 2);
          var c = s.readUshort(i, o);
          (o += 2), s.readUshort(i, o), (o += 2);
          var u = s.readUshort(i, o);
          o += 2;
          var d = u / 2;
          (l.searchRange = s.readUshort(i, o)),
            (o += 2),
            (l.entrySelector = s.readUshort(i, o)),
            (o += 2),
            (l.rangeShift = s.readUshort(i, o)),
            (o += 2),
            (l.endCount = s.readUshorts(i, o, d)),
            (o += 2 * d),
            (o += 2),
            (l.startCount = s.readUshorts(i, o, d)),
            (o += 2 * d),
            (l.idDelta = []);
          for (var p = 0; p < d; p++)
            l.idDelta.push(s.readShort(i, o)), (o += 2);
          for (
            l.idRangeOffset = s.readUshorts(i, o, d),
              o += 2 * d,
              l.glyphIdArray = [];
            o < a + c;

          )
            l.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return l;
        }),
        (e.cmap.parse6 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            s.readUshort(i, o),
            (o += 2),
            (a.firstCode = s.readUshort(i, o)),
            (o += 2);
          var l = s.readUshort(i, o);
          (o += 2), (a.glyphIdArray = []);
          for (var c = 0; c < l; c++)
            a.glyphIdArray.push(s.readUshort(i, o)), (o += 2);
          return a;
        }),
        (e.cmap.parse12 = function (i, o) {
          var s = e._bin,
            a = {};
          (a.format = s.readUshort(i, o)),
            (o += 2),
            (o += 2),
            s.readUint(i, o),
            (o += 4),
            s.readUint(i, o),
            (o += 4);
          var l = s.readUint(i, o);
          (o += 4), (a.groups = []);
          for (var c = 0; c < l; c++) {
            var u = o + 12 * c,
              d = s.readUint(i, u + 0),
              p = s.readUint(i, u + 4),
              m = s.readUint(i, u + 8);
            a.groups.push([d, p, m]);
          }
          return a;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, o, s, a) {
          for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
          return l;
        }),
        (e.glyf._parseGlyf = function (i, o) {
          var s = e._bin,
            a = i._data,
            l = e._tabOffset(a, "glyf", i._offset) + i.loca[o];
          if (i.loca[o] == i.loca[o + 1]) return null;
          var c = {};
          if (
            ((c.noc = s.readShort(a, l)),
            (l += 2),
            (c.xMin = s.readShort(a, l)),
            (l += 2),
            (c.yMin = s.readShort(a, l)),
            (l += 2),
            (c.xMax = s.readShort(a, l)),
            (l += 2),
            (c.yMax = s.readShort(a, l)),
            (l += 2),
            c.xMin >= c.xMax || c.yMin >= c.yMax)
          )
            return null;
          if (c.noc > 0) {
            c.endPts = [];
            for (var u = 0; u < c.noc; u++)
              c.endPts.push(s.readUshort(a, l)), (l += 2);
            var d = s.readUshort(a, l);
            if (((l += 2), a.length - l < d)) return null;
            (c.instructions = s.readBytes(a, l, d)), (l += d);
            var p = c.endPts[c.noc - 1] + 1;
            for (c.flags = [], u = 0; u < p; u++) {
              var m = a[l];
              if ((l++, c.flags.push(m), (8 & m) != 0)) {
                var v = a[l];
                l++;
                for (var _ = 0; _ < v; _++) c.flags.push(m), u++;
              }
            }
            for (c.xs = [], u = 0; u < p; u++) {
              var y = (2 & c.flags[u]) != 0,
                g = (16 & c.flags[u]) != 0;
              y
                ? (c.xs.push(g ? a[l] : -a[l]), l++)
                : g
                ? c.xs.push(0)
                : (c.xs.push(s.readShort(a, l)), (l += 2));
            }
            for (c.ys = [], u = 0; u < p; u++)
              (y = (4 & c.flags[u]) != 0),
                (g = (32 & c.flags[u]) != 0),
                y
                  ? (c.ys.push(g ? a[l] : -a[l]), l++)
                  : g
                  ? c.ys.push(0)
                  : (c.ys.push(s.readShort(a, l)), (l += 2));
            var x = 0,
              S = 0;
            for (u = 0; u < p; u++)
              (x += c.xs[u]), (S += c.ys[u]), (c.xs[u] = x), (c.ys[u] = S);
          } else {
            var b;
            c.parts = [];
            do {
              (b = s.readUshort(a, l)), (l += 2);
              var C = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (c.parts.push(C),
                (C.glyphIndex = s.readUshort(a, l)),
                (l += 2),
                1 & b)
              ) {
                var M = s.readShort(a, l);
                l += 2;
                var T = s.readShort(a, l);
                l += 2;
              } else (M = s.readInt8(a, l)), l++, (T = s.readInt8(a, l)), l++;
              2 & b ? ((C.m.tx = M), (C.m.ty = T)) : ((C.p1 = M), (C.p2 = T)),
                8 & b
                  ? ((C.m.a = C.m.d = s.readF2dot14(a, l)), (l += 2))
                  : 64 & b
                  ? ((C.m.a = s.readF2dot14(a, l)),
                    (l += 2),
                    (C.m.d = s.readF2dot14(a, l)),
                    (l += 2))
                  : 128 & b &&
                    ((C.m.a = s.readF2dot14(a, l)),
                    (l += 2),
                    (C.m.b = s.readF2dot14(a, l)),
                    (l += 2),
                    (C.m.c = s.readF2dot14(a, l)),
                    (l += 2),
                    (C.m.d = s.readF2dot14(a, l)),
                    (l += 2));
            } while (32 & b);
            if (256 & b) {
              var P = s.readUshort(a, l);
              for (l += 2, c.instr = [], u = 0; u < P; u++)
                c.instr.push(a[l]), l++;
            }
          }
          return c;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, o, s, a) {
          var l = o;
          o += 4;
          var c = e._bin.readUshort(i, o);
          return {
            glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, l + c),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, o, s, a) {
          return e._lctf.parse(i, o, s, a, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, o, s, a) {
          var l = e._bin,
            c = s,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, s)),
            (s += 2),
            o == 1 || o == 2 || o == 3 || o == 7 || (o == 8 && u.fmt <= 2))
          ) {
            var d = l.readUshort(i, s);
            (s += 2), (u.coverage = e._lctf.readCoverage(i, d + c));
          }
          if (o == 1 && u.fmt == 1) {
            var p = l.readUshort(i, s);
            (s += 2), p != 0 && (u.pos = e.GPOS.readValueRecord(i, s, p));
          } else if (o == 2 && u.fmt >= 1 && u.fmt <= 2) {
            (p = l.readUshort(i, s)), (s += 2);
            var m = l.readUshort(i, s);
            s += 2;
            var v = e._lctf.numOfOnes(p),
              _ = e._lctf.numOfOnes(m);
            if (u.fmt == 1) {
              u.pairsets = [];
              var y = l.readUshort(i, s);
              s += 2;
              for (var g = 0; g < y; g++) {
                var x = c + l.readUshort(i, s);
                s += 2;
                var S = l.readUshort(i, x);
                x += 2;
                for (var b = [], C = 0; C < S; C++) {
                  var M = l.readUshort(i, x);
                  (x += 2),
                    p != 0 &&
                      ((D = e.GPOS.readValueRecord(i, x, p)), (x += 2 * v)),
                    m != 0 &&
                      ((N = e.GPOS.readValueRecord(i, x, m)), (x += 2 * _)),
                    b.push({ gid2: M, val1: D, val2: N });
                }
                u.pairsets.push(b);
              }
            }
            if (u.fmt == 2) {
              var T = l.readUshort(i, s);
              s += 2;
              var P = l.readUshort(i, s);
              s += 2;
              var R = l.readUshort(i, s);
              s += 2;
              var E = l.readUshort(i, s);
              for (
                s += 2,
                  u.classDef1 = e._lctf.readClassDef(i, c + T),
                  u.classDef2 = e._lctf.readClassDef(i, c + P),
                  u.matrix = [],
                  g = 0;
                g < R;
                g++
              ) {
                var O = [];
                for (C = 0; C < E; C++) {
                  var D = null,
                    N = null;
                  p != 0 &&
                    ((D = e.GPOS.readValueRecord(i, s, p)), (s += 2 * v)),
                    m != 0 &&
                      ((N = e.GPOS.readValueRecord(i, s, m)), (s += 2 * _)),
                    O.push({ val1: D, val2: N });
                }
                u.matrix.push(O);
              }
            }
          } else if (o == 4 && u.fmt == 1)
            (u.markCoverage = e._lctf.readCoverage(i, l.readUshort(i, s) + c)),
              (u.baseCoverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, s + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, s + 4)),
              (u.markArray = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, s + 6) + c
              )),
              (u.baseArray = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, s + 8) + c,
                u.markClassCount
              ));
          else if (o == 6 && u.fmt == 1)
            (u.mark1Coverage = e._lctf.readCoverage(i, l.readUshort(i, s) + c)),
              (u.mark2Coverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, s + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, s + 4)),
              (u.mark1Array = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, s + 6) + c
              )),
              (u.mark2Array = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, s + 8) + c,
                u.markClassCount
              ));
          else {
            if (o == 9 && u.fmt == 1) {
              var z = l.readUshort(i, s);
              s += 2;
              var V = l.readUint(i, s);
              if (((s += 4), a.ltype == 9)) a.ltype = z;
              else if (a.ltype != z) throw "invalid extension substitution";
              return e.GPOS.subt(i, a.ltype, c + V);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              o,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GPOS.readValueRecord = function (i, o, s) {
          var a = e._bin,
            l = [];
          return (
            l.push(1 & s ? a.readShort(i, o) : 0),
            (o += 1 & s ? 2 : 0),
            l.push(2 & s ? a.readShort(i, o) : 0),
            (o += 2 & s ? 2 : 0),
            l.push(4 & s ? a.readShort(i, o) : 0),
            (o += 4 & s ? 2 : 0),
            l.push(8 & s ? a.readShort(i, o) : 0),
            (o += 8 & s ? 2 : 0),
            l
          );
        }),
        (e.GPOS.readBaseArray = function (i, o, s) {
          var a = e._bin,
            l = [],
            c = o,
            u = a.readUshort(i, o);
          o += 2;
          for (var d = 0; d < u; d++) {
            for (var p = [], m = 0; m < s; m++)
              p.push(e.GPOS.readAnchorRecord(i, c + a.readUshort(i, o))),
                (o += 2);
            l.push(p);
          }
          return l;
        }),
        (e.GPOS.readMarkArray = function (i, o) {
          var s = e._bin,
            a = [],
            l = o,
            c = s.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = e.GPOS.readAnchorRecord(i, s.readUshort(i, o + 2) + l);
            (d.markClass = s.readUshort(i, o)), a.push(d), (o += 4);
          }
          return a;
        }),
        (e.GPOS.readAnchorRecord = function (i, o) {
          var s = e._bin,
            a = {};
          return (
            (a.fmt = s.readUshort(i, o)),
            (a.x = s.readShort(i, o + 2)),
            (a.y = s.readShort(i, o + 4)),
            a
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, o, s, a) {
          return e._lctf.parse(i, o, s, a, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, o, s, a) {
          var l = e._bin,
            c = s,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, s)),
            (s += 2),
            o != 1 && o != 2 && o != 4 && o != 5 && o != 6)
          )
            return null;
          if (
            o == 1 ||
            o == 2 ||
            o == 4 ||
            (o == 5 && u.fmt <= 2) ||
            (o == 6 && u.fmt <= 2)
          ) {
            var d = l.readUshort(i, s);
            (s += 2), (u.coverage = e._lctf.readCoverage(i, c + d));
          }
          if (o == 1 && u.fmt >= 1 && u.fmt <= 2) {
            if (u.fmt == 1) (u.delta = l.readShort(i, s)), (s += 2);
            else if (u.fmt == 2) {
              var p = l.readUshort(i, s);
              (s += 2),
                (u.newg = l.readUshorts(i, s, p)),
                (s += 2 * u.newg.length);
            }
          } else if (o == 2 && u.fmt == 1) {
            (p = l.readUshort(i, s)), (s += 2), (u.seqs = []);
            for (var m = 0; m < p; m++) {
              var v = l.readUshort(i, s) + c;
              s += 2;
              var _ = l.readUshort(i, v);
              u.seqs.push(l.readUshorts(i, v + 2, _));
            }
          } else if (o == 4)
            for (
              u.vals = [], p = l.readUshort(i, s), s += 2, m = 0;
              m < p;
              m++
            ) {
              var y = l.readUshort(i, s);
              (s += 2), u.vals.push(e.GSUB.readLigatureSet(i, c + y));
            }
          else if (o == 5 && u.fmt == 2) {
            if (u.fmt == 2) {
              var g = l.readUshort(i, s);
              (s += 2),
                (u.cDef = e._lctf.readClassDef(i, c + g)),
                (u.scset = []);
              var x = l.readUshort(i, s);
              for (s += 2, m = 0; m < x; m++) {
                var S = l.readUshort(i, s);
                (s += 2),
                  u.scset.push(
                    S == 0 ? null : e.GSUB.readSubClassSet(i, c + S)
                  );
              }
            }
          } else if (o == 6 && u.fmt == 3) {
            if (u.fmt == 3) {
              for (m = 0; m < 3; m++) {
                (p = l.readUshort(i, s)), (s += 2);
                for (var b = [], C = 0; C < p; C++)
                  b.push(
                    e._lctf.readCoverage(i, c + l.readUshort(i, s + 2 * C))
                  );
                (s += 2 * p),
                  m == 0 && (u.backCvg = b),
                  m == 1 && (u.inptCvg = b),
                  m == 2 && (u.ahedCvg = b);
              }
              (p = l.readUshort(i, s)),
                (s += 2),
                (u.lookupRec = e.GSUB.readSubstLookupRecords(i, s, p));
            }
          } else {
            if (o == 7 && u.fmt == 1) {
              var M = l.readUshort(i, s);
              s += 2;
              var T = l.readUint(i, s);
              if (((s += 4), a.ltype == 9)) a.ltype = M;
              else if (a.ltype != M) throw "invalid extension substitution";
              return e.GSUB.subt(i, a.ltype, c + T);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              o,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GSUB.readSubClassSet = function (i, o) {
          var s = e._bin.readUshort,
            a = o,
            l = [],
            c = s(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = s(i, o);
            (o += 2), l.push(e.GSUB.readSubClassRule(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readSubClassRule = function (i, o) {
          var s = e._bin.readUshort,
            a = {},
            l = s(i, o),
            c = s(i, (o += 2));
          (o += 2), (a.input = []);
          for (var u = 0; u < l - 1; u++) a.input.push(s(i, o)), (o += 2);
          return (
            (a.substLookupRecords = e.GSUB.readSubstLookupRecords(i, o, c)), a
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, o, s) {
          for (var a = e._bin.readUshort, l = [], c = 0; c < s; c++)
            l.push(a(i, o), a(i, o + 2)), (o += 4);
          return l;
        }),
        (e.GSUB.readChainSubClassSet = function (i, o) {
          var s = e._bin,
            a = o,
            l = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = s.readUshort(i, o);
            (o += 2), l.push(e.GSUB.readChainSubClassRule(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readChainSubClassRule = function (i, o) {
          for (
            var s = e._bin,
              a = {},
              l = ["backtrack", "input", "lookahead"],
              c = 0;
            c < l.length;
            c++
          ) {
            var u = s.readUshort(i, o);
            (o += 2),
              c == 1 && u--,
              (a[l[c]] = s.readUshorts(i, o, u)),
              (o += 2 * a[l[c]].length);
          }
          return (
            (u = s.readUshort(i, o)),
            (o += 2),
            (a.subst = s.readUshorts(i, o, 2 * u)),
            (o += 2 * a.subst.length),
            a
          );
        }),
        (e.GSUB.readLigatureSet = function (i, o) {
          var s = e._bin,
            a = o,
            l = [],
            c = s.readUshort(i, o);
          o += 2;
          for (var u = 0; u < c; u++) {
            var d = s.readUshort(i, o);
            (o += 2), l.push(e.GSUB.readLigature(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readLigature = function (i, o) {
          var s = e._bin,
            a = { chain: [] };
          (a.nglyph = s.readUshort(i, o)), (o += 2);
          var l = s.readUshort(i, o);
          o += 2;
          for (var c = 0; c < l - 1; c++)
            a.chain.push(s.readUshort(i, o)), (o += 2);
          return a;
        }),
        (e.head = {}),
        (e.head.parse = function (i, o, s) {
          var a = e._bin,
            l = {};
          return (
            a.readFixed(i, o),
            (o += 4),
            (l.fontRevision = a.readFixed(i, o)),
            (o += 4),
            a.readUint(i, o),
            (o += 4),
            a.readUint(i, o),
            (o += 4),
            (l.flags = a.readUshort(i, o)),
            (o += 2),
            (l.unitsPerEm = a.readUshort(i, o)),
            (o += 2),
            (l.created = a.readUint64(i, o)),
            (o += 8),
            (l.modified = a.readUint64(i, o)),
            (o += 8),
            (l.xMin = a.readShort(i, o)),
            (o += 2),
            (l.yMin = a.readShort(i, o)),
            (o += 2),
            (l.xMax = a.readShort(i, o)),
            (o += 2),
            (l.yMax = a.readShort(i, o)),
            (o += 2),
            (l.macStyle = a.readUshort(i, o)),
            (o += 2),
            (l.lowestRecPPEM = a.readUshort(i, o)),
            (o += 2),
            (l.fontDirectionHint = a.readShort(i, o)),
            (o += 2),
            (l.indexToLocFormat = a.readShort(i, o)),
            (o += 2),
            (l.glyphDataFormat = a.readShort(i, o)),
            (o += 2),
            l
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, o, s) {
          var a = e._bin,
            l = {};
          return (
            a.readFixed(i, o),
            (o += 4),
            (l.ascender = a.readShort(i, o)),
            (o += 2),
            (l.descender = a.readShort(i, o)),
            (o += 2),
            (l.lineGap = a.readShort(i, o)),
            (o += 2),
            (l.advanceWidthMax = a.readUshort(i, o)),
            (o += 2),
            (l.minLeftSideBearing = a.readShort(i, o)),
            (o += 2),
            (l.minRightSideBearing = a.readShort(i, o)),
            (o += 2),
            (l.xMaxExtent = a.readShort(i, o)),
            (o += 2),
            (l.caretSlopeRise = a.readShort(i, o)),
            (o += 2),
            (l.caretSlopeRun = a.readShort(i, o)),
            (o += 2),
            (l.caretOffset = a.readShort(i, o)),
            (o += 2),
            (o += 8),
            (l.metricDataFormat = a.readShort(i, o)),
            (o += 2),
            (l.numberOfHMetrics = a.readUshort(i, o)),
            (o += 2),
            l
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, o, s, a) {
          for (
            var l = e._bin,
              c = { aWidth: [], lsBearing: [] },
              u = 0,
              d = 0,
              p = 0;
            p < a.maxp.numGlyphs;
            p++
          )
            p < a.hhea.numberOfHMetrics &&
              ((u = l.readUshort(i, o)),
              (o += 2),
              (d = l.readShort(i, o)),
              (o += 2)),
              c.aWidth.push(u),
              c.lsBearing.push(d);
          return c;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, o, s, a) {
          var l = e._bin,
            c = l.readUshort(i, o);
          if (((o += 2), c == 1)) return e.kern.parseV1(i, o - 2, s, a);
          var u = l.readUshort(i, o);
          o += 2;
          for (var d = { glyph1: [], rval: [] }, p = 0; p < u; p++) {
            (o += 2), (s = l.readUshort(i, o)), (o += 2);
            var m = l.readUshort(i, o);
            o += 2;
            var v = m >>> 8;
            if ((v &= 15) != 0) throw "unknown kern table format: " + v;
            o = e.kern.readFormat0(i, o, d);
          }
          return d;
        }),
        (e.kern.parseV1 = function (i, o, s, a) {
          var l = e._bin;
          l.readFixed(i, o), (o += 4);
          var c = l.readUint(i, o);
          o += 4;
          for (var u = { glyph1: [], rval: [] }, d = 0; d < c; d++) {
            l.readUint(i, o), (o += 4);
            var p = l.readUshort(i, o);
            (o += 2), l.readUshort(i, o), (o += 2);
            var m = p >>> 8;
            if ((m &= 15) != 0) throw "unknown kern table format: " + m;
            o = e.kern.readFormat0(i, o, u);
          }
          return u;
        }),
        (e.kern.readFormat0 = function (i, o, s) {
          var a = e._bin,
            l = -1,
            c = a.readUshort(i, o);
          (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2),
            a.readUshort(i, o),
            (o += 2);
          for (var u = 0; u < c; u++) {
            var d = a.readUshort(i, o);
            o += 2;
            var p = a.readUshort(i, o);
            o += 2;
            var m = a.readShort(i, o);
            (o += 2),
              d != l &&
                (s.glyph1.push(d), s.rval.push({ glyph2: [], vals: [] }));
            var v = s.rval[s.rval.length - 1];
            v.glyph2.push(p), v.vals.push(m), (l = d);
          }
          return o;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, o, s, a) {
          var l = e._bin,
            c = [],
            u = a.head.indexToLocFormat,
            d = a.maxp.numGlyphs + 1;
          if (u == 0)
            for (var p = 0; p < d; p++)
              c.push(l.readUshort(i, o + (p << 1)) << 1);
          if (u == 1)
            for (p = 0; p < d; p++) c.push(l.readUint(i, o + (p << 2)));
          return c;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, o, s) {
          var a = e._bin,
            l = {},
            c = a.readUint(i, o);
          return (
            (o += 4),
            (l.numGlyphs = a.readUshort(i, o)),
            (o += 2),
            c == 65536 &&
              ((l.maxPoints = a.readUshort(i, o)),
              (o += 2),
              (l.maxContours = a.readUshort(i, o)),
              (o += 2),
              (l.maxCompositePoints = a.readUshort(i, o)),
              (o += 2),
              (l.maxCompositeContours = a.readUshort(i, o)),
              (o += 2),
              (l.maxZones = a.readUshort(i, o)),
              (o += 2),
              (l.maxTwilightPoints = a.readUshort(i, o)),
              (o += 2),
              (l.maxStorage = a.readUshort(i, o)),
              (o += 2),
              (l.maxFunctionDefs = a.readUshort(i, o)),
              (o += 2),
              (l.maxInstructionDefs = a.readUshort(i, o)),
              (o += 2),
              (l.maxStackElements = a.readUshort(i, o)),
              (o += 2),
              (l.maxSizeOfInstructions = a.readUshort(i, o)),
              (o += 2),
              (l.maxComponentElements = a.readUshort(i, o)),
              (o += 2),
              (l.maxComponentDepth = a.readUshort(i, o)),
              (o += 2)),
            l
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, o, s) {
          var a = e._bin,
            l = {};
          a.readUshort(i, o), (o += 2);
          var c = a.readUshort(i, o);
          (o += 2), a.readUshort(i, o);
          for (
            var u,
              d = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              p = (o += 2),
              m = 0;
            m < c;
            m++
          ) {
            var v = a.readUshort(i, o);
            o += 2;
            var _ = a.readUshort(i, o);
            o += 2;
            var y = a.readUshort(i, o);
            o += 2;
            var g = a.readUshort(i, o);
            o += 2;
            var x = a.readUshort(i, o);
            o += 2;
            var S = a.readUshort(i, o);
            o += 2;
            var b,
              C = d[g],
              M = p + 12 * c + S;
            if (v == 0) b = a.readUnicode(i, M, x / 2);
            else if (v == 3 && _ == 0) b = a.readUnicode(i, M, x / 2);
            else if (_ == 0) b = a.readASCII(i, M, x);
            else if (_ == 1) b = a.readUnicode(i, M, x / 2);
            else if (_ == 3) b = a.readUnicode(i, M, x / 2);
            else {
              if (v != 1) throw "unknown encoding " + _ + ", platformID: " + v;
              (b = a.readASCII(i, M, x)),
                console.debug(
                  "reading unknown MAC encoding " + _ + " as ASCII"
                );
            }
            var T = "p" + v + "," + y.toString(16);
            l[T] == null && (l[T] = {}),
              (l[T][C !== void 0 ? C : g] = b),
              (l[T]._lang = y);
          }
          for (var P in l)
            if (l[P].postScriptName != null && l[P]._lang == 1033) return l[P];
          for (var P in l)
            if (l[P].postScriptName != null && l[P]._lang == 0) return l[P];
          for (var P in l)
            if (l[P].postScriptName != null && l[P]._lang == 3084) return l[P];
          for (var P in l) if (l[P].postScriptName != null) return l[P];
          for (var P in l) {
            u = P;
            break;
          }
          return (
            console.debug("returning name table with languageID " + l[u]._lang),
            l[u]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, o, s) {
          var a = e._bin.readUshort(i, o);
          o += 2;
          var l = {};
          if (a == 0) e["OS/2"].version0(i, o, l);
          else if (a == 1) e["OS/2"].version1(i, o, l);
          else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(i, o, l);
          else {
            if (a != 5) throw "unknown OS/2 table version: " + a;
            e["OS/2"].version5(i, o, l);
          }
          return l;
        }),
        (e["OS/2"].version0 = function (i, o, s) {
          var a = e._bin;
          return (
            (s.xAvgCharWidth = a.readShort(i, o)),
            (o += 2),
            (s.usWeightClass = a.readUshort(i, o)),
            (o += 2),
            (s.usWidthClass = a.readUshort(i, o)),
            (o += 2),
            (s.fsType = a.readUshort(i, o)),
            (o += 2),
            (s.ySubscriptXSize = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYSize = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptXOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySubscriptYOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXSize = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYSize = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptXOffset = a.readShort(i, o)),
            (o += 2),
            (s.ySuperscriptYOffset = a.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutSize = a.readShort(i, o)),
            (o += 2),
            (s.yStrikeoutPosition = a.readShort(i, o)),
            (o += 2),
            (s.sFamilyClass = a.readShort(i, o)),
            (o += 2),
            (s.panose = a.readBytes(i, o, 10)),
            (o += 10),
            (s.ulUnicodeRange1 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange2 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange3 = a.readUint(i, o)),
            (o += 4),
            (s.ulUnicodeRange4 = a.readUint(i, o)),
            (o += 4),
            (s.achVendID = [
              a.readInt8(i, o),
              a.readInt8(i, o + 1),
              a.readInt8(i, o + 2),
              a.readInt8(i, o + 3),
            ]),
            (o += 4),
            (s.fsSelection = a.readUshort(i, o)),
            (o += 2),
            (s.usFirstCharIndex = a.readUshort(i, o)),
            (o += 2),
            (s.usLastCharIndex = a.readUshort(i, o)),
            (o += 2),
            (s.sTypoAscender = a.readShort(i, o)),
            (o += 2),
            (s.sTypoDescender = a.readShort(i, o)),
            (o += 2),
            (s.sTypoLineGap = a.readShort(i, o)),
            (o += 2),
            (s.usWinAscent = a.readUshort(i, o)),
            (o += 2),
            (s.usWinDescent = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version0(i, o, s)),
            (s.ulCodePageRange1 = a.readUint(i, o)),
            (o += 4),
            (s.ulCodePageRange2 = a.readUint(i, o)),
            (o += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version1(i, o, s)),
            (s.sxHeight = a.readShort(i, o)),
            (o += 2),
            (s.sCapHeight = a.readShort(i, o)),
            (o += 2),
            (s.usDefault = a.readUshort(i, o)),
            (o += 2),
            (s.usBreak = a.readUshort(i, o)),
            (o += 2),
            (s.usMaxContext = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, o, s) {
          var a = e._bin;
          return (
            (o = e["OS/2"].version2(i, o, s)),
            (s.usLowerOpticalPointSize = a.readUshort(i, o)),
            (o += 2),
            (s.usUpperOpticalPointSize = a.readUshort(i, o)),
            (o += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, o, s) {
          var a = e._bin,
            l = {};
          return (
            (l.version = a.readFixed(i, o)),
            (o += 4),
            (l.italicAngle = a.readFixed(i, o)),
            (o += 4),
            (l.underlinePosition = a.readShort(i, o)),
            (o += 2),
            (l.underlineThickness = a.readShort(i, o)),
            (o += 2),
            l
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, o) {
          var s = i.cmap,
            a = -1;
          if (
            (s.p0e4 != null
              ? (a = s.p0e4)
              : s.p3e1 != null
              ? (a = s.p3e1)
              : s.p1e0 != null
              ? (a = s.p1e0)
              : s.p0e3 != null && (a = s.p0e3),
            a == -1)
          )
            throw "no familiar platform and encoding!";
          var l = s.tables[a];
          if (l.format == 0) return o >= l.map.length ? 0 : l.map[o];
          if (l.format == 4) {
            for (var c = -1, u = 0; u < l.endCount.length; u++)
              if (o <= l.endCount[u]) {
                c = u;
                break;
              }
            return c == -1 || l.startCount[c] > o
              ? 0
              : 65535 &
                  (l.idRangeOffset[c] != 0
                    ? l.glyphIdArray[
                        o -
                          l.startCount[c] +
                          (l.idRangeOffset[c] >> 1) -
                          (l.idRangeOffset.length - c)
                      ]
                    : o + l.idDelta[c]);
          }
          if (l.format == 12) {
            if (o > l.groups[l.groups.length - 1][1]) return 0;
            for (u = 0; u < l.groups.length; u++) {
              var d = l.groups[u];
              if (d[0] <= o && o <= d[1]) return d[2] + (o - d[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + l.format;
        }),
        (e.U.glyphToPath = function (i, o) {
          var s = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[o]) {
            var a = i.SVG.entries[o];
            return a == null
              ? s
              : (typeof a == "string" &&
                  ((a = e.SVG.toPath(a)), (i.SVG.entries[o] = a)),
                a);
          }
          if (i.CFF) {
            var l = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              c = i.CFF,
              u = i.CFF.Private;
            if (c.ROS) {
              for (var d = 0; c.FDSelect[d + 2] <= o; ) d += 2;
              u = c.FDArray[c.FDSelect[d + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[o], l, c, u, s);
          } else i.glyf && e.U._drawGlyf(o, i, s);
          return s;
        }),
        (e.U._drawGlyf = function (i, o, s) {
          var a = o.glyf[i];
          a == null && (a = o.glyf[i] = e.glyf._parseGlyf(o, i)),
            a != null &&
              (a.noc > -1 ? e.U._simpleGlyph(a, s) : e.U._compoGlyph(a, o, s));
        }),
        (e.U._simpleGlyph = function (i, o) {
          for (var s = 0; s < i.noc; s++) {
            for (
              var a = s == 0 ? 0 : i.endPts[s - 1] + 1, l = i.endPts[s], c = a;
              c <= l;
              c++
            ) {
              var u = c == a ? l : c - 1,
                d = c == l ? a : c + 1,
                p = 1 & i.flags[c],
                m = 1 & i.flags[u],
                v = 1 & i.flags[d],
                _ = i.xs[c],
                y = i.ys[c];
              if (c == a)
                if (p) {
                  if (!m) {
                    e.U.P.moveTo(o, _, y);
                    continue;
                  }
                  e.U.P.moveTo(o, i.xs[u], i.ys[u]);
                } else
                  m
                    ? e.U.P.moveTo(o, i.xs[u], i.ys[u])
                    : e.U.P.moveTo(o, (i.xs[u] + _) / 2, (i.ys[u] + y) / 2);
              p
                ? m && e.U.P.lineTo(o, _, y)
                : v
                ? e.U.P.qcurveTo(o, _, y, i.xs[d], i.ys[d])
                : e.U.P.qcurveTo(o, _, y, (_ + i.xs[d]) / 2, (y + i.ys[d]) / 2);
            }
            e.U.P.closePath(o);
          }
        }),
        (e.U._compoGlyph = function (i, o, s) {
          for (var a = 0; a < i.parts.length; a++) {
            var l = { cmds: [], crds: [] },
              c = i.parts[a];
            e.U._drawGlyf(c.glyphIndex, o, l);
            for (var u = c.m, d = 0; d < l.crds.length; d += 2) {
              var p = l.crds[d],
                m = l.crds[d + 1];
              s.crds.push(p * u.a + m * u.b + u.tx),
                s.crds.push(p * u.c + m * u.d + u.ty);
            }
            for (d = 0; d < l.cmds.length; d++) s.cmds.push(l.cmds[d]);
          }
        }),
        (e.U._getGlyphClass = function (i, o) {
          var s = e._lctf.getInterval(o, i);
          return s == -1 ? 0 : o[s + 2];
        }),
        (e.U._applySubs = function (i, o, s, a) {
          for (var l = i.length - o - 1, c = 0; c < s.tabs.length; c++)
            if (s.tabs[c] != null) {
              var u,
                d = s.tabs[c];
              if (
                !d.coverage ||
                (u = e._lctf.coverageIndex(d.coverage, i[o])) != -1
              ) {
                if (s.ltype == 1)
                  i[o],
                    d.fmt == 1 ? (i[o] = i[o] + d.delta) : (i[o] = d.newg[u]);
                else if (s.ltype == 4)
                  for (var p = d.vals[u], m = 0; m < p.length; m++) {
                    var v = p[m],
                      _ = v.chain.length;
                    if (!(_ > l)) {
                      for (var y = !0, g = 0, x = 0; x < _; x++) {
                        for (; i[o + g + (1 + x)] == -1; ) g++;
                        v.chain[x] != i[o + g + (1 + x)] && (y = !1);
                      }
                      if (y) {
                        for (i[o] = v.nglyph, x = 0; x < _ + g; x++)
                          i[o + x + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (s.ltype == 5 && d.fmt == 2)
                  for (
                    var S = e._lctf.getInterval(d.cDef, i[o]),
                      b = d.cDef[S + 2],
                      C = d.scset[b],
                      M = 0;
                    M < C.length;
                    M++
                  ) {
                    var T = C[M],
                      P = T.input;
                    if (!(P.length > l)) {
                      for (y = !0, x = 0; x < P.length; x++) {
                        var R = e._lctf.getInterval(d.cDef, i[o + 1 + x]);
                        if (S == -1 && d.cDef[R + 2] != P[x]) {
                          y = !1;
                          break;
                        }
                      }
                      if (y) {
                        var E = T.substLookupRecords;
                        for (m = 0; m < E.length; m += 2) E[m], E[m + 1];
                      }
                    }
                  }
                else if (s.ltype == 6 && d.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, d.backCvg, o - d.backCvg.length) ||
                    !e.U._glsCovered(i, d.inptCvg, o) ||
                    !e.U._glsCovered(i, d.ahedCvg, o + d.inptCvg.length)
                  )
                    continue;
                  var O = d.lookupRec;
                  for (M = 0; M < O.length; M += 2) {
                    S = O[M];
                    var D = a[O[M + 1]];
                    e.U._applySubs(i, o + S, D, a);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, o, s) {
          for (var a = 0; a < o.length; a++)
            if (e._lctf.coverageIndex(o[a], i[s + a]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, o, s) {
          for (
            var a = { cmds: [], crds: [] }, l = 0, c = 0;
            c < o.length;
            c++
          ) {
            var u = o[c];
            if (u != -1) {
              for (
                var d = c < o.length - 1 && o[c + 1] != -1 ? o[c + 1] : 0,
                  p = e.U.glyphToPath(i, u),
                  m = 0;
                m < p.crds.length;
                m += 2
              )
                a.crds.push(p.crds[m] + l), a.crds.push(p.crds[m + 1]);
              for (s && a.cmds.push(s), m = 0; m < p.cmds.length; m++)
                a.cmds.push(p.cmds[m]);
              s && a.cmds.push("X"),
                (l += i.hmtx.aWidth[u]),
                c < o.length - 1 && (l += e.U.getPairAdjustment(i, u, d));
            }
          }
          return a;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, o, s) {
          i.cmds.push("M"), i.crds.push(o, s);
        }),
        (e.U.P.lineTo = function (i, o, s) {
          i.cmds.push("L"), i.crds.push(o, s);
        }),
        (e.U.P.curveTo = function (i, o, s, a, l, c, u) {
          i.cmds.push("C"), i.crds.push(o, s, a, l, c, u);
        }),
        (e.U.P.qcurveTo = function (i, o, s, a, l) {
          i.cmds.push("Q"), i.crds.push(o, s, a, l);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, o, s, a, l) {
          for (
            var c = o.stack,
              u = o.nStems,
              d = o.haveWidth,
              p = o.width,
              m = o.open,
              v = 0,
              _ = o.x,
              y = o.y,
              g = 0,
              x = 0,
              S = 0,
              b = 0,
              C = 0,
              M = 0,
              T = 0,
              P = 0,
              R = 0,
              E = 0,
              O = { val: 0, size: 0 };
            v < i.length;

          ) {
            e.CFF.getCharString(i, v, O);
            var D = O.val;
            if (((v += O.size), D == "o1" || D == "o18"))
              c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (D == "o3" || D == "o23")
              c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (D == "o4")
              c.length > 1 &&
                !d &&
                ((p = c.shift() + a.nominalWidthX), (d = !0)),
                m && e.U.P.closePath(l),
                (y += c.pop()),
                e.U.P.moveTo(l, _, y),
                (m = !0);
            else if (D == "o5")
              for (; c.length > 0; )
                (_ += c.shift()), (y += c.shift()), e.U.P.lineTo(l, _, y);
            else if (D == "o6" || D == "o7")
              for (var N = c.length, z = D == "o6", V = 0; V < N; V++) {
                var G = c.shift();
                z ? (_ += G) : (y += G), (z = !z), e.U.P.lineTo(l, _, y);
              }
            else if (D == "o8" || D == "o24") {
              N = c.length;
              for (var Y = 0; Y + 6 <= N; )
                (g = _ + c.shift()),
                  (x = y + c.shift()),
                  (S = g + c.shift()),
                  (b = x + c.shift()),
                  (_ = S + c.shift()),
                  (y = b + c.shift()),
                  e.U.P.curveTo(l, g, x, S, b, _, y),
                  (Y += 6);
              D == "o24" &&
                ((_ += c.shift()), (y += c.shift()), e.U.P.lineTo(l, _, y));
            } else {
              if (D == "o11") break;
              if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237")
                D == "o1234" &&
                  ((x = y),
                  (S = (g = _ + c.shift()) + c.shift()),
                  (E = b = x + c.shift()),
                  (M = b),
                  (P = y),
                  (_ =
                    (T = (C = (R = S + c.shift()) + c.shift()) + c.shift()) +
                    c.shift()),
                  e.U.P.curveTo(l, g, x, S, b, R, E),
                  e.U.P.curveTo(l, C, M, T, P, _, y)),
                  D == "o1235" &&
                    ((g = _ + c.shift()),
                    (x = y + c.shift()),
                    (S = g + c.shift()),
                    (b = x + c.shift()),
                    (R = S + c.shift()),
                    (E = b + c.shift()),
                    (C = R + c.shift()),
                    (M = E + c.shift()),
                    (T = C + c.shift()),
                    (P = M + c.shift()),
                    (_ = T + c.shift()),
                    (y = P + c.shift()),
                    c.shift(),
                    e.U.P.curveTo(l, g, x, S, b, R, E),
                    e.U.P.curveTo(l, C, M, T, P, _, y)),
                  D == "o1236" &&
                    ((g = _ + c.shift()),
                    (x = y + c.shift()),
                    (S = g + c.shift()),
                    (E = b = x + c.shift()),
                    (M = b),
                    (T = (C = (R = S + c.shift()) + c.shift()) + c.shift()),
                    (P = M + c.shift()),
                    (_ = T + c.shift()),
                    e.U.P.curveTo(l, g, x, S, b, R, E),
                    e.U.P.curveTo(l, C, M, T, P, _, y)),
                  D == "o1237" &&
                    ((g = _ + c.shift()),
                    (x = y + c.shift()),
                    (S = g + c.shift()),
                    (b = x + c.shift()),
                    (R = S + c.shift()),
                    (E = b + c.shift()),
                    (C = R + c.shift()),
                    (M = E + c.shift()),
                    (T = C + c.shift()),
                    (P = M + c.shift()),
                    Math.abs(T - _) > Math.abs(P - y)
                      ? (_ = T + c.shift())
                      : (y = P + c.shift()),
                    e.U.P.curveTo(l, g, x, S, b, R, E),
                    e.U.P.curveTo(l, C, M, T, P, _, y));
              else if (D == "o14") {
                if (
                  (c.length > 0 &&
                    !d &&
                    ((p = c.shift() + s.nominalWidthX), (d = !0)),
                  c.length == 4)
                ) {
                  var U = c.shift(),
                    j = c.shift(),
                    W = c.shift(),
                    B = c.shift(),
                    q = e.CFF.glyphBySE(s, W),
                    Z = e.CFF.glyphBySE(s, B);
                  e.U._drawCFF(s.CharStrings[q], o, s, a, l),
                    (o.x = U),
                    (o.y = j),
                    e.U._drawCFF(s.CharStrings[Z], o, s, a, l);
                }
                m && (e.U.P.closePath(l), (m = !1));
              } else if (D == "o19" || D == "o20")
                c.length % 2 != 0 && !d && (p = c.shift() + a.nominalWidthX),
                  (u += c.length >> 1),
                  (c.length = 0),
                  (d = !0),
                  (v += (u + 7) >> 3);
              else if (D == "o21")
                c.length > 2 &&
                  !d &&
                  ((p = c.shift() + a.nominalWidthX), (d = !0)),
                  (y += c.pop()),
                  (_ += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, _, y),
                  (m = !0);
              else if (D == "o22")
                c.length > 1 &&
                  !d &&
                  ((p = c.shift() + a.nominalWidthX), (d = !0)),
                  (_ += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, _, y),
                  (m = !0);
              else if (D == "o25") {
                for (; c.length > 6; )
                  (_ += c.shift()), (y += c.shift()), e.U.P.lineTo(l, _, y);
                (g = _ + c.shift()),
                  (x = y + c.shift()),
                  (S = g + c.shift()),
                  (b = x + c.shift()),
                  (_ = S + c.shift()),
                  (y = b + c.shift()),
                  e.U.P.curveTo(l, g, x, S, b, _, y);
              } else if (D == "o26")
                for (c.length % 2 && (_ += c.shift()); c.length > 0; )
                  (g = _),
                    (x = y + c.shift()),
                    (_ = S = g + c.shift()),
                    (y = (b = x + c.shift()) + c.shift()),
                    e.U.P.curveTo(l, g, x, S, b, _, y);
              else if (D == "o27")
                for (c.length % 2 && (y += c.shift()); c.length > 0; )
                  (x = y),
                    (S = (g = _ + c.shift()) + c.shift()),
                    (b = x + c.shift()),
                    (_ = S + c.shift()),
                    (y = b),
                    e.U.P.curveTo(l, g, x, S, b, _, y);
              else if (D == "o10" || D == "o29") {
                var H = D == "o10" ? a : s;
                if (c.length == 0) console.debug("error: empty stack");
                else {
                  var X = c.pop(),
                    ne = H.Subrs[X + H.Bias];
                  (o.x = _),
                    (o.y = y),
                    (o.nStems = u),
                    (o.haveWidth = d),
                    (o.width = p),
                    (o.open = m),
                    e.U._drawCFF(ne, o, s, a, l),
                    (_ = o.x),
                    (y = o.y),
                    (u = o.nStems),
                    (d = o.haveWidth),
                    (p = o.width),
                    (m = o.open);
                }
              } else if (D == "o30" || D == "o31") {
                var oe = c.length,
                  ue = ((Y = 0), D == "o31");
                for (Y += oe - (N = -3 & oe); Y < N; )
                  ue
                    ? ((x = y),
                      (S = (g = _ + c.shift()) + c.shift()),
                      (y = (b = x + c.shift()) + c.shift()),
                      N - Y == 5 ? ((_ = S + c.shift()), Y++) : (_ = S),
                      (ue = !1))
                    : ((g = _),
                      (x = y + c.shift()),
                      (S = g + c.shift()),
                      (b = x + c.shift()),
                      (_ = S + c.shift()),
                      N - Y == 5 ? ((y = b + c.shift()), Y++) : (y = b),
                      (ue = !0)),
                    e.U.P.curveTo(l, g, x, S, b, _, y),
                    (Y += 4);
              } else {
                if ((D + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + D, i), D);
                c.push(D);
              }
            }
          }
          (o.x = _),
            (o.y = y),
            (o.nStems = u),
            (o.haveWidth = d),
            (o.width = p),
            (o.open = m);
        });
      var n = e,
        r = { Typr: n };
      return (
        (t.Typr = n),
        (t.default = r),
        Object.defineProperty(t, "__esModule", { value: !0 }),
        t
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function T7() {
  return (function (t) {
    var e = Uint8Array,
      n = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      o = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      s = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      a = function (D, N) {
        for (var z = new n(31), V = 0; V < 31; ++V) z[V] = N += 1 << D[V - 1];
        var G = new r(z[30]);
        for (V = 1; V < 30; ++V)
          for (var Y = z[V]; Y < z[V + 1]; ++Y) G[Y] = ((Y - z[V]) << 5) | V;
        return [z, G];
      },
      l = a(i, 2),
      c = l[0],
      u = l[1];
    (c[28] = 258), (u[258] = 28);
    for (var d = a(o, 0)[0], p = new n(32768), m = 0; m < 32768; ++m) {
      var v = ((43690 & m) >>> 1) | ((21845 & m) << 1);
      (v =
        ((61680 & (v = ((52428 & v) >>> 2) | ((13107 & v) << 2))) >>> 4) |
        ((3855 & v) << 4)),
        (p[m] = (((65280 & v) >>> 8) | ((255 & v) << 8)) >>> 1);
    }
    var _ = function (D, N, z) {
        for (var V = D.length, G = 0, Y = new n(N); G < V; ++G) ++Y[D[G] - 1];
        var U,
          j = new n(N);
        for (G = 0; G < N; ++G) j[G] = (j[G - 1] + Y[G - 1]) << 1;
        {
          U = new n(1 << N);
          var W = 15 - N;
          for (G = 0; G < V; ++G)
            if (D[G])
              for (
                var B = (G << 4) | D[G],
                  q = N - D[G],
                  Z = j[D[G] - 1]++ << q,
                  H = Z | ((1 << q) - 1);
                Z <= H;
                ++Z
              )
                U[p[Z] >>> W] = B;
        }
        return U;
      },
      y = new e(288);
    for (m = 0; m < 144; ++m) y[m] = 8;
    for (m = 144; m < 256; ++m) y[m] = 9;
    for (m = 256; m < 280; ++m) y[m] = 7;
    for (m = 280; m < 288; ++m) y[m] = 8;
    var g = new e(32);
    for (m = 0; m < 32; ++m) g[m] = 5;
    var x = _(y, 9),
      S = _(g, 5),
      b = function (D) {
        for (var N = D[0], z = 1; z < D.length; ++z) D[z] > N && (N = D[z]);
        return N;
      },
      C = function (D, N, z) {
        var V = (N / 8) | 0;
        return ((D[V] | (D[V + 1] << 8)) >> (7 & N)) & z;
      },
      M = function (D, N) {
        var z = (N / 8) | 0;
        return (D[z] | (D[z + 1] << 8) | (D[z + 2] << 16)) >> (7 & N);
      },
      T = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      P = function (D, N, z) {
        var V = new Error(N || T[D]);
        if (
          ((V.code = D),
          Error.captureStackTrace && Error.captureStackTrace(V, P),
          !z)
        )
          throw V;
        return V;
      },
      R = function (D, N, z) {
        var V = D.length;
        if (!V || (z && !z.l && V < 5)) return N || new e(0);
        var G = !N || z,
          Y = !z || z.i;
        z || (z = {}), N || (N = new e(3 * V));
        var U,
          j = function (Ve) {
            var ae = N.length;
            if (Ve > ae) {
              var be = new e(Math.max(2 * ae, Ve));
              be.set(N), (N = be);
            }
          },
          W = z.f || 0,
          B = z.p || 0,
          q = z.b || 0,
          Z = z.l,
          H = z.d,
          X = z.m,
          ne = z.n,
          oe = 8 * V;
        do {
          if (!Z) {
            z.f = W = C(D, B, 1);
            var ue = C(D, B + 1, 3);
            if (((B += 3), !ue)) {
              var Ie =
                  D[(k = (((U = B) / 8) | 0) + (7 & U && 1) + 4) - 4] |
                  (D[k - 3] << 8),
                te = k + Ie;
              if (te > V) {
                Y && P(0);
                break;
              }
              G && j(q + Ie),
                N.set(D.subarray(k, te), q),
                (z.b = q += Ie),
                (z.p = B = 8 * te);
              continue;
            }
            if (ue == 1) (Z = x), (H = S), (X = 9), (ne = 5);
            else if (ue == 2) {
              var ge = C(D, B, 31) + 257,
                ie = C(D, B + 10, 15) + 4,
                pe = ge + C(D, B + 5, 31) + 1;
              B += 14;
              for (var de = new e(pe), Ee = new e(19), he = 0; he < ie; ++he)
                Ee[s[he]] = C(D, B + 3 * he, 7);
              B += 3 * ie;
              var Ce = b(Ee),
                _e = (1 << Ce) - 1,
                $ = _(Ee, Ce);
              for (he = 0; he < pe; ) {
                var k,
                  J = $[C(D, B, _e)];
                if (((B += 15 & J), (k = J >>> 4) < 16)) de[he++] = k;
                else {
                  var fe = 0,
                    le = 0;
                  for (
                    k == 16
                      ? ((le = 3 + C(D, B, 3)), (B += 2), (fe = de[he - 1]))
                      : k == 17
                      ? ((le = 3 + C(D, B, 7)), (B += 3))
                      : k == 18 && ((le = 11 + C(D, B, 127)), (B += 7));
                    le--;

                  )
                    de[he++] = fe;
                }
              }
              var ce = de.subarray(0, ge),
                we = de.subarray(ge);
              (X = b(ce)), (ne = b(we)), (Z = _(ce, X)), (H = _(we, ne));
            } else P(1);
            if (B > oe) {
              Y && P(0);
              break;
            }
          }
          G && j(q + 131072);
          for (var Be = (1 << X) - 1, Me = (1 << ne) - 1, Ge = B; ; Ge = B) {
            var Le = (fe = Z[M(D, B) & Be]) >>> 4;
            if ((B += 15 & fe) > oe) {
              Y && P(0);
              break;
            }
            if ((fe || P(2), Le < 256)) N[q++] = Le;
            else {
              if (Le == 256) {
                (Ge = B), (Z = null);
                break;
              }
              var je = Le - 254;
              if (Le > 264) {
                var Je = i[(he = Le - 257)];
                (je = C(D, B, (1 << Je) - 1) + c[he]), (B += Je);
              }
              var Ye = H[M(D, B) & Me],
                De = Ye >>> 4;
              if (
                (Ye || P(3),
                (B += 15 & Ye),
                (we = d[De]),
                De > 3 &&
                  ((Je = o[De]), (we += M(D, B) & ((1 << Je) - 1)), (B += Je)),
                B > oe)
              ) {
                Y && P(0);
                break;
              }
              G && j(q + 131072);
              for (var ze = q + je; q < ze; q += 4)
                (N[q] = N[q - we]),
                  (N[q + 1] = N[q + 1 - we]),
                  (N[q + 2] = N[q + 2 - we]),
                  (N[q + 3] = N[q + 3 - we]);
              q = ze;
            }
          }
          (z.l = Z),
            (z.p = Ge),
            (z.b = q),
            Z && ((W = 1), (z.m = X), (z.d = H), (z.n = ne));
        } while (!W);
        return q == N.length
          ? N
          : (function (Ve, ae, be) {
              (be == null || be > Ve.length) && (be = Ve.length);
              var se = new (Ve instanceof n ? n : Ve instanceof r ? r : e)(
                be - ae
              );
              return se.set(Ve.subarray(ae, be)), se;
            })(N, 0, q);
      },
      E = new e(0),
      O = typeof TextDecoder < "u" && new TextDecoder();
    try {
      O.decode(E, { stream: !0 });
    } catch {}
    return (
      (t.convert_streams = function (D) {
        var N = new DataView(D),
          z = 0;
        function V() {
          var ge = N.getUint16(z);
          return (z += 2), ge;
        }
        function G() {
          var ge = N.getUint32(z);
          return (z += 4), ge;
        }
        function Y(ge) {
          Ie.setUint16(te, ge), (te += 2);
        }
        function U(ge) {
          Ie.setUint32(te, ge), (te += 4);
        }
        for (
          var j = {
              signature: G(),
              flavor: G(),
              length: G(),
              numTables: V(),
              reserved: V(),
              totalSfntSize: G(),
              majorVersion: V(),
              minorVersion: V(),
              metaOffset: G(),
              metaLength: G(),
              metaOrigLength: G(),
              privOffset: G(),
              privLength: G(),
            },
            W = 0;
          Math.pow(2, W) <= j.numTables;

        )
          W++;
        W--;
        for (
          var B = 16 * Math.pow(2, W),
            q = 16 * j.numTables - B,
            Z = 12,
            H = [],
            X = 0;
          X < j.numTables;
          X++
        )
          H.push({
            tag: G(),
            offset: G(),
            compLength: G(),
            origLength: G(),
            origChecksum: G(),
          }),
            (Z += 16);
        var ne,
          oe = new Uint8Array(
            12 +
              16 * H.length +
              H.reduce(function (ge, ie) {
                return ge + ie.origLength + 4;
              }, 0)
          ),
          ue = oe.buffer,
          Ie = new DataView(ue),
          te = 0;
        return (
          U(j.flavor),
          Y(j.numTables),
          Y(B),
          Y(W),
          Y(q),
          H.forEach(function (ge) {
            U(ge.tag),
              U(ge.origChecksum),
              U(Z),
              U(ge.origLength),
              (ge.outOffset = Z),
              (Z += ge.origLength) % 4 != 0 && (Z += 4 - (Z % 4));
          }),
          H.forEach(function (ge) {
            var ie,
              pe = D.slice(ge.offset, ge.offset + ge.compLength);
            if (ge.compLength != ge.origLength) {
              var de = new Uint8Array(ge.origLength);
              (ie = new Uint8Array(pe, 2)), R(ie, de);
            } else de = new Uint8Array(pe);
            oe.set(de, ge.outOffset);
            var Ee = 0;
            (Z = ge.outOffset + ge.origLength) % 4 != 0 && (Ee = 4 - (Z % 4)),
              oe.set(new Uint8Array(Ee).buffer, ge.outOffset + ge.origLength),
              (ne = Z + Ee);
          }),
          ue.slice(0, ne)
        );
      }),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      t
    );
  })({}).convert_streams;
}
function R7(t, e) {
  const n = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    o = 2,
    s = 4,
    a = 8,
    l = 16,
    c = 32;
  let u;
  function d(T) {
    if (!u) {
      const P = { R: o, L: i, D: s, C: l, U: c, T: a };
      u = new Map();
      for (let R in r) {
        let E = 0;
        r[R].split(",").forEach((O) => {
          let [D, N] = O.split("+");
          (D = parseInt(D, 36)),
            (N = N ? parseInt(N, 36) : 0),
            u.set((E += D), P[R]);
          for (let z = N; z--; ) u.set(++E, P[R]);
        });
      }
    }
    return u.get(T) || c;
  }
  const p = 1,
    m = 2,
    v = 3,
    _ = 4,
    y = [null, "isol", "init", "fina", "medi"];
  function g(T) {
    const P = new Uint8Array(T.length);
    let R = c,
      E = p,
      O = -1;
    for (let D = 0; D < T.length; D++) {
      const N = T.codePointAt(D);
      let z = d(N) | 0,
        V = p;
      z & a ||
        (R & (i | s | l)
          ? z & (o | s | l)
            ? ((V = v), (E === p || E === v) && P[O]++)
            : z & (i | c) && (E === m || E === _) && P[O]--
          : R & (o | c) && (E === m || E === _) && P[O]--,
        (E = P[D] = V),
        (R = z),
        (O = D),
        N > 65535 && D++);
    }
    return P;
  }
  function x(T, P) {
    const R = [];
    for (let O = 0; O < P.length; O++) {
      const D = P.codePointAt(O);
      D > 65535 && O++, R.push(t.U.codeToGlyph(T, D));
    }
    const E = T.GSUB;
    if (E) {
      const { lookupList: O, featureList: D } = E;
      let N;
      const z = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        V = [];
      D.forEach((G) => {
        if (z.test(G.tag))
          for (let Y = 0; Y < G.tab.length; Y++) {
            if (V[G.tab[Y]]) continue;
            V[G.tab[Y]] = !0;
            const U = O[G.tab[Y]],
              j = /^(isol|init|fina|medi)$/.test(G.tag);
            j && !N && (N = g(P));
            for (let W = 0; W < R.length; W++)
              (!N || !j || y[N[W]] === G.tag) && t.U._applySubs(R, W, U, O);
          }
      });
    }
    return R;
  }
  function S(T, P) {
    const R = new Int16Array(P.length * 3);
    let E = 0;
    for (; E < P.length; E++) {
      const z = P[E];
      if (z === -1) continue;
      R[E * 3 + 2] = T.hmtx.aWidth[z];
      const V = T.GPOS;
      if (V) {
        const G = V.lookupList;
        for (let Y = 0; Y < G.length; Y++) {
          const U = G[Y];
          for (let j = 0; j < U.tabs.length; j++) {
            const W = U.tabs[j];
            if (U.ltype === 1) {
              if (t._lctf.coverageIndex(W.coverage, z) !== -1 && W.pos) {
                N(W.pos, E);
                break;
              }
            } else if (U.ltype === 2) {
              let B = null,
                q = O();
              if (q !== -1) {
                const Z = t._lctf.coverageIndex(W.coverage, P[q]);
                if (Z !== -1) {
                  if (W.fmt === 1) {
                    const H = W.pairsets[Z];
                    for (let X = 0; X < H.length; X++)
                      H[X].gid2 === z && (B = H[X]);
                  } else if (W.fmt === 2) {
                    const H = t.U._getGlyphClass(P[q], W.classDef1),
                      X = t.U._getGlyphClass(z, W.classDef2);
                    B = W.matrix[H][X];
                  }
                  if (B) {
                    B.val1 && N(B.val1, q), B.val2 && N(B.val2, E);
                    break;
                  }
                }
              }
            } else if (U.ltype === 4) {
              const B = t._lctf.coverageIndex(W.markCoverage, z);
              if (B !== -1) {
                const q = O(D),
                  Z =
                    q === -1 ? -1 : t._lctf.coverageIndex(W.baseCoverage, P[q]);
                if (Z !== -1) {
                  const H = W.markArray[B],
                    X = W.baseArray[Z][H.markClass];
                  (R[E * 3] = X.x - H.x + R[q * 3] - R[q * 3 + 2]),
                    (R[E * 3 + 1] = X.y - H.y + R[q * 3 + 1]);
                  break;
                }
              }
            } else if (U.ltype === 6) {
              const B = t._lctf.coverageIndex(W.mark1Coverage, z);
              if (B !== -1) {
                const q = O();
                if (q !== -1) {
                  const Z = P[q];
                  if (b(T, Z) === 3) {
                    const H = t._lctf.coverageIndex(W.mark2Coverage, Z);
                    if (H !== -1) {
                      const X = W.mark1Array[B],
                        ne = W.mark2Array[H][X.markClass];
                      (R[E * 3] = ne.x - X.x + R[q * 3] - R[q * 3 + 2]),
                        (R[E * 3 + 1] = ne.y - X.y + R[q * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (T.kern && !T.cff) {
        const G = O();
        if (G !== -1) {
          const Y = T.kern.glyph1.indexOf(P[G]);
          if (Y !== -1) {
            const U = T.kern.rval[Y].glyph2.indexOf(z);
            U !== -1 && (R[G * 3 + 2] += T.kern.rval[Y].vals[U]);
          }
        }
      }
    }
    return R;
    function O(z) {
      for (let V = E - 1; V >= 0; V--)
        if (P[V] !== -1 && (!z || z(P[V]))) return V;
      return -1;
    }
    function D(z) {
      return b(T, z) === 1;
    }
    function N(z, V) {
      for (let G = 0; G < 3; G++) R[V * 3 + G] += z[G] || 0;
    }
  }
  function b(T, P) {
    const R = T.GDEF && T.GDEF.glyphClassDef;
    return R ? t.U._getGlyphClass(P, R) : 0;
  }
  function C(...T) {
    for (let P = 0; P < T.length; P++) if (typeof T[P] == "number") return T[P];
  }
  function M(T) {
    const P = Object.create(null),
      R = T["OS/2"],
      E = T.hhea,
      O = T.head.unitsPerEm,
      D = C(R && R.sTypoAscender, E && E.ascender, O),
      N = {
        unitsPerEm: O,
        ascender: D,
        descender: C(R && R.sTypoDescender, E && E.descender, 0),
        capHeight: C(R && R.sCapHeight, D),
        xHeight: C(R && R.sxHeight, D),
        lineGap: C(R && R.sTypoLineGap, E && E.lineGap),
        supportsCodePoint(z) {
          return t.U.codeToGlyph(T, z) > 0;
        },
        forEachGlyph(z, V, G, Y) {
          let U = 0;
          const j = (1 / N.unitsPerEm) * V,
            W = x(T, z);
          let B = 0;
          const q = S(T, W);
          return (
            W.forEach((Z, H) => {
              if (Z !== -1) {
                let X = P[Z];
                if (!X) {
                  const { cmds: ne, crds: oe } = t.U.glyphToPath(T, Z);
                  let ue = "",
                    Ie = 0;
                  for (let de = 0, Ee = ne.length; de < Ee; de++) {
                    const he = n[ne[de]];
                    ue += ne[de];
                    for (let Ce = 1; Ce <= he; Ce++)
                      ue += (Ce > 1 ? "," : "") + oe[Ie++];
                  }
                  let te, ge, ie, pe;
                  if (oe.length) {
                    (te = ge = 1 / 0), (ie = pe = -1 / 0);
                    for (let de = 0, Ee = oe.length; de < Ee; de += 2) {
                      let he = oe[de],
                        Ce = oe[de + 1];
                      he < te && (te = he),
                        Ce < ge && (ge = Ce),
                        he > ie && (ie = he),
                        Ce > pe && (pe = Ce);
                    }
                  } else te = ie = ge = pe = 0;
                  X = P[Z] = {
                    index: Z,
                    advanceWidth: T.hmtx.aWidth[Z],
                    xMin: te,
                    yMin: ge,
                    xMax: ie,
                    yMax: pe,
                    path: ue,
                  };
                }
                Y.call(null, X, U + q[H * 3] * j, q[H * 3 + 1] * j, B),
                  (U += q[H * 3 + 2] * j),
                  G && (U += G * V);
              }
              B += z.codePointAt(B) > 65535 ? 2 : 1;
            }),
            U
          );
        },
      };
    return N;
  }
  return function (P) {
    const R = new Uint8Array(P, 0, 4),
      E = t._bin.readASCII(R, 0, 4);
    if (E === "wOFF") P = e(P);
    else if (E === "wOF2") throw new Error("woff2 fonts not supported");
    return M(t.parse(P)[0]);
  };
}
const P7 = zf({
  name: "Typr Font Parser",
  dependencies: [C7, T7, R7],
  init(t, e, n) {
    const r = t(),
      i = e();
    return n(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function I7() {
  return (function (t) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (S) {
      var b = S >> 5;
      this.buckets.set(b, (this.buckets.get(b) || 0) | (1 << (31 & S)));
    }),
      (e.prototype.has = function (S) {
        var b = this.buckets.get(S >> 5);
        return b !== void 0 && (b & (1 << (31 & S))) != 0;
      }),
      (e.prototype.serialize = function () {
        var S = [];
        return (
          this.buckets.forEach(function (b, C) {
            S.push((+C).toString(36) + ":" + b.toString(36));
          }),
          S.join(",")
        );
      }),
      (e.prototype.deserialize = function (S) {
        var b = this;
        this.buckets.clear(),
          S.split(",").forEach(function (C) {
            var M = C.split(":");
            b.buckets.set(parseInt(M[0], 36), parseInt(M[1], 36));
          });
      });
    var n = Math.pow(2, 8),
      r = n - 1,
      i = ~r;
    function o(S) {
      var b = (function (M) {
          return M & i;
        })(S).toString(16),
        C = (function (M) {
          return (M & i) + n - 1;
        })(S).toString(16);
      return "codepoint-index/plane" + (S >> 16) + "/" + b + "-" + C + ".json";
    }
    function s(S, b) {
      var C = S & r,
        M = b.codePointAt((C / 6) | 0);
      return ((M = (M || 48) - 48) & (1 << C % 6)) != 0;
    }
    function a(S, b) {
      var C;
      ((C = S),
      C.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (M) {
          return M.split("-").map(function (T) {
            return parseInt(T.trim(), 16);
          });
        })).forEach(function (M) {
        var T = M[0],
          P = M[1];
        P === void 0 && (P = T), b(T, P);
      });
    }
    function l(S, b) {
      a(S, function (C, M) {
        for (var T = C; T <= M; T++) b(T);
      });
    }
    var c = {},
      u = {},
      d = new WeakMap(),
      p =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function m(S) {
      var b = d.get(S);
      return (
        b ||
          ((b = new e()),
          l(S.ranges, function (C) {
            return b.add(C);
          }),
          d.set(S, b)),
        b
      );
    }
    var v,
      _ = new Map();
    function y(S, b, C) {
      return S[b]
        ? b
        : S[C]
        ? C
        : (function (M) {
            for (var T in M) return T;
          })(S);
    }
    function g(S, b) {
      var C = b;
      if (!S.includes(C)) {
        C = 1 / 0;
        for (var M = 0; M < S.length; M++)
          Math.abs(S[M] - b) < Math.abs(C - b) && (C = S[M]);
      }
      return C;
    }
    function x(S) {
      return (
        v ||
          ((v = new Set()),
          l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (b) {
            v.add(b);
          })),
        v.has(S)
      );
    }
    return (
      (t.CodePointSet = e),
      (t.clearCache = function () {
        (c = {}), (u = {});
      }),
      (t.getFontsForString = function (S, b) {
        b === void 0 && (b = {});
        var C,
          M = b.lang;
        M === void 0 &&
          (M = new RegExp("\\p{Script=Hangul}", "u").test((C = S))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                C
              )
            ? "ja"
            : "en");
        var T = b.category;
        T === void 0 && (T = "sans-serif");
        var P = b.style;
        P === void 0 && (P = "normal");
        var R = b.weight;
        R === void 0 && (R = 400);
        var E = (b.dataUrl || p).replace(/\/$/g, ""),
          O = new Map(),
          D = new Uint8Array(S.length),
          N = {},
          z = {},
          V = new Array(S.length),
          G = new Map(),
          Y = !1;
        function U(B) {
          var q = _.get(B);
          return (
            q ||
              ((q = fetch(E + "/" + B)
                .then(function (Z) {
                  if (!Z.ok) throw new Error(Z.statusText);
                  return Z.json().then(function (H) {
                    if (!Array.isArray(H) || H[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + H[0]
                      );
                    return H[1];
                  });
                })
                .catch(function (Z) {
                  if (E !== p)
                    return (
                      Y ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            E +
                            '", trying default CDN. ' +
                            Z.message
                        ),
                        (Y = !0)),
                      (E = p),
                      _.delete(B),
                      U(B)
                    );
                  throw Z;
                })),
              _.set(B, q)),
            q
          );
        }
        for (
          var j = function (B) {
              var q = S.codePointAt(B),
                Z = o(q);
              (V[B] = Z),
                c[Z] ||
                  G.has(Z) ||
                  G.set(
                    Z,
                    U(Z).then(function (H) {
                      c[Z] = H;
                    })
                  ),
                q > 65535 && (B++, (W = B));
            },
            W = 0;
          W < S.length;
          W++
        )
          j(W);
        return Promise.all(G.values())
          .then(function () {
            G.clear();
            for (
              var B = function (Z) {
                  var H = S.codePointAt(Z),
                    X = null,
                    ne = c[V[Z]],
                    oe = void 0;
                  for (var ue in ne) {
                    var Ie = z[ue];
                    if (
                      (Ie === void 0 &&
                        (Ie = z[ue] = new RegExp(ue).test(M || "en")),
                      Ie)
                    ) {
                      for (var te in ((oe = ue), ne[ue]))
                        if (s(H, ne[ue][te])) {
                          X = te;
                          break;
                        }
                      break;
                    }
                  }
                  if (!X) {
                    e: for (var ge in ne)
                      if (ge !== oe) {
                        for (var ie in ne[ge])
                          if (s(H, ne[ge][ie])) {
                            X = ie;
                            break e;
                          }
                      }
                  }
                  X ||
                    (console.debug("No font coverage for U+" + H.toString(16)),
                    (X = "latin")),
                    (V[Z] = X),
                    u[X] ||
                      G.has(X) ||
                      G.set(
                        X,
                        U("font-meta/" + X + ".json").then(function (pe) {
                          u[X] = pe;
                        })
                      ),
                    H > 65535 && (Z++, (q = Z));
                },
                q = 0;
              q < S.length;
              q++
            )
              B(q);
            return Promise.all(G.values());
          })
          .then(function () {
            for (var B, q = null, Z = 0; Z < S.length; Z++) {
              var H = S.codePointAt(Z);
              if (q && (x(H) || m(q).has(H))) D[Z] = D[Z - 1];
              else {
                q = u[V[Z]];
                var X = N[q.id];
                if (!X) {
                  var ne = q.typeforms,
                    oe = y(ne, T, "sans-serif"),
                    ue = y(ne[oe], P, "normal"),
                    Ie = g(
                      (B = ne[oe]) === null || B === void 0 ? void 0 : B[ue],
                      R
                    );
                  X = N[q.id] =
                    E +
                    "/font-files/" +
                    q.id +
                    "/" +
                    oe +
                    "." +
                    ue +
                    "." +
                    Ie +
                    ".woff";
                }
                var te = O.get(X);
                te == null && ((te = O.size), O.set(X, te)), (D[Z] = te);
              }
              H > 65535 && (Z++, (D[Z] = D[Z - 1]));
            }
            return { fontUrls: Array.from(O.keys()), chars: D };
          });
      }),
      Object.defineProperty(t, "__esModule", { value: !0 }),
      t
    );
  })({});
}
function L7(t, e) {
  const n = Object.create(null),
    r = Object.create(null);
  function i(s, a) {
    const l = (c) => {
      console.error(`Failure loading font ${s}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", s, !0),
        (c.responseType = "arraybuffer"),
        (c.onload = function () {
          if (c.status >= 400) l(new Error(c.statusText));
          else if (c.status > 0)
            try {
              const u = t(c.response);
              (u.src = s), a(u);
            } catch (u) {
              l(u);
            }
        }),
        (c.onerror = l),
        c.send();
    } catch (c) {
      l(c);
    }
  }
  function o(s, a) {
    let l = n[s];
    l
      ? a(l)
      : r[s]
      ? r[s].push(a)
      : ((r[s] = [a]),
        i(s, (c) => {
          (c.src = s), (n[s] = c), r[s].forEach((u) => u(c)), delete r[s];
        }));
  }
  return function (
    s,
    a,
    {
      lang: l,
      fonts: c = [],
      style: u = "normal",
      weight: d = "normal",
      unicodeFontsURL: p,
    } = {}
  ) {
    const m = new Uint8Array(s.length),
      v = [];
    s.length || x();
    const _ = new Map(),
      y = [];
    if (
      (u !== "italic" && (u = "normal"),
      typeof d != "number" && (d = d === "bold" ? 700 : 400),
      c && !Array.isArray(c) && (c = [c]),
      (c = c
        .slice()
        .filter((b) => !b.lang || b.lang.test(l))
        .reverse()),
      c.length)
    ) {
      let T = 0;
      (function P(R = 0) {
        for (let E = R, O = s.length; E < O; E++) {
          const D = s.codePointAt(E);
          if (
            (T === 1 && v[m[E - 1]].supportsCodePoint(D)) ||
            (E > 0 && /\s/.test(s[E]))
          )
            (m[E] = m[E - 1]), T === 2 && (y[y.length - 1][1] = E);
          else
            for (let N = m[E], z = c.length; N <= z; N++)
              if (N === z) {
                const V = T === 2 ? y[y.length - 1] : (y[y.length] = [E, E]);
                (V[1] = E), (T = 2);
              } else {
                m[E] = N;
                const { src: V, unicodeRange: G } = c[N];
                if (!G || S(D, G)) {
                  const Y = n[V];
                  if (!Y) {
                    o(V, () => {
                      P(E);
                    });
                    return;
                  }
                  if (Y.supportsCodePoint(D)) {
                    let U = _.get(Y);
                    typeof U != "number" &&
                      ((U = v.length), v.push(Y), _.set(Y, U)),
                      (m[E] = U),
                      (T = 1);
                    break;
                  }
                }
              }
          D > 65535 &&
            E + 1 < O &&
            ((m[E + 1] = m[E]), E++, T === 2 && (y[y.length - 1][1] = E));
        }
        g();
      })();
    } else y.push([0, s.length - 1]), g();
    function g() {
      if (y.length) {
        const b = y.map((C) => s.substring(C[0], C[1] + 1)).join(`
`);
        e.getFontsForString(b, {
          lang: l || void 0,
          style: u,
          weight: d,
          dataUrl: p,
        }).then(({ fontUrls: C, chars: M }) => {
          const T = v.length;
          let P = 0;
          y.forEach((E) => {
            for (let O = 0, D = E[1] - E[0]; O <= D; O++)
              m[E[0] + O] = M[P++] + T;
            P++;
          });
          let R = 0;
          C.forEach((E, O) => {
            o(E, (D) => {
              (v[O + T] = D), ++R === C.length && x();
            });
          });
        });
      } else x();
    }
    function x() {
      a({ chars: m, fonts: v });
    }
    function S(b, C) {
      for (let M = 0; M < C.length; M++) {
        const [T, P = T] = C[M];
        if (T <= b && b <= P) return !0;
      }
      return !1;
    }
  };
}
const O7 = zf({
  name: "FontResolver",
  dependencies: [L7, P7, I7],
  init(t, e, n) {
    return t(e, n());
  },
});
function N7(t, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    o = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function s(
    {
      text: v,
      lang: _,
      fonts: y,
      style: g,
      weight: x,
      preResolvedFonts: S,
      unicodeFontsURL: b,
    },
    C
  ) {
    const M = ({ chars: T, fonts: P }) => {
      let R, E;
      const O = [];
      for (let D = 0; D < T.length; D++)
        T[D] !== E
          ? ((E = T[D]), O.push((R = { start: D, end: D, fontObj: P[T[D]] })))
          : (R.end = D);
      C(O);
    };
    S
      ? M(S)
      : t(v, M, { lang: _, fonts: y, style: g, weight: x, unicodeFontsURL: b });
  }
  function a(
    {
      text: v = "",
      font: _,
      lang: y,
      sdfGlyphSize: g = 64,
      fontSize: x = 400,
      fontWeight: S = 1,
      fontStyle: b = "normal",
      letterSpacing: C = 0,
      lineHeight: M = "normal",
      maxWidth: T = 1 / 0,
      direction: P,
      textAlign: R = "left",
      textIndent: E = 0,
      whiteSpace: O = "normal",
      overflowWrap: D = "normal",
      anchorX: N = 0,
      anchorY: z = 0,
      metricsOnly: V = !1,
      unicodeFontsURL: G,
      preResolvedFonts: Y = null,
      includeCaretPositions: U = !1,
      chunkedBoundsSize: j = 8192,
      colorRanges: W = null,
    },
    B
  ) {
    const q = d(),
      Z = { fontLoad: 0, typesetting: 0 };
    v.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (v = v
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (x = +x),
      (C = +C),
      (T = +T),
      (M = M || "normal"),
      (E = +E),
      s(
        {
          text: v,
          lang: y,
          style: b,
          weight: S,
          fonts: typeof _ == "string" ? [{ src: _ }] : _,
          unicodeFontsURL: G,
          preResolvedFonts: Y,
        },
        (H) => {
          Z.fontLoad = d() - q;
          const X = isFinite(T);
          let ne = null,
            oe = null,
            ue = null,
            Ie = null,
            te = null,
            ge = null,
            ie = null,
            pe = null,
            de = 0,
            Ee = 0,
            he = O !== "nowrap";
          const Ce = new Map(),
            _e = d();
          let $ = E,
            k = 0,
            J = new p();
          const fe = [J];
          H.forEach((Me) => {
            const { fontObj: Ge } = Me,
              {
                ascender: Le,
                descender: je,
                unitsPerEm: Je,
                lineGap: Ye,
                capHeight: De,
                xHeight: ze,
              } = Ge;
            let Ve = Ce.get(Ge);
            if (!Ve) {
              const ye = x / Je,
                He = M === "normal" ? (Le - je + Ye) * ye : M * x,
                qe = (He - (Le - je) * ye) / 2,
                at = Math.min(He, (Le - je) * ye),
                st = ((Le + je) / 2) * ye + at / 2;
              (Ve = {
                index: Ce.size,
                src: Ge.src,
                fontObj: Ge,
                fontSizeMult: ye,
                unitsPerEm: Je,
                ascender: Le * ye,
                descender: je * ye,
                capHeight: De * ye,
                xHeight: ze * ye,
                lineHeight: He,
                baseline: -qe - Le * ye,
                caretTop: st,
                caretBottom: st - at,
              }),
                Ce.set(Ge, Ve);
            }
            const { fontSizeMult: ae } = Ve,
              be = v.slice(Me.start, Me.end + 1);
            let se, Ae;
            Ge.forEachGlyph(be, x, C, (ye, He, qe, at) => {
              (He += k), (at += Me.start), (se = He), (Ae = ye);
              const st = v.charAt(at),
                ht = ye.advanceWidth * ae,
                pt = J.count;
              let Ze;
              if (
                ("isEmpty" in ye ||
                  ((ye.isWhitespace = !!st && new RegExp(i).test(st)),
                  (ye.canBreakAfter = !!st && o.test(st)),
                  (ye.isEmpty =
                    ye.xMin === ye.xMax || ye.yMin === ye.yMax || r.test(st))),
                !ye.isWhitespace && !ye.isEmpty && Ee++,
                he && X && !ye.isWhitespace && He + ht + $ > T && pt)
              ) {
                if (J.glyphAt(pt - 1).glyphObj.canBreakAfter)
                  (Ze = new p()), ($ = -He);
                else
                  for (let Rt = pt; Rt--; )
                    if (Rt === 0 && D === "break-word") {
                      (Ze = new p()), ($ = -He);
                      break;
                    } else if (J.glyphAt(Rt).glyphObj.canBreakAfter) {
                      Ze = J.splitAt(Rt + 1);
                      const Yt = Ze.glyphAt(0).x;
                      $ -= Yt;
                      for (let en = Ze.count; en--; ) Ze.glyphAt(en).x -= Yt;
                      break;
                    }
                Ze && ((J.isSoftWrapped = !0), (J = Ze), fe.push(J), (de = T));
              }
              let Mt = J.glyphAt(J.count);
              (Mt.glyphObj = ye),
                (Mt.x = He + $),
                (Mt.y = qe),
                (Mt.width = ht),
                (Mt.charIndex = at),
                (Mt.fontData = Ve),
                st ===
                  `
` && ((J = new p()), fe.push(J), ($ = -(He + ht + C * x) + E));
            }),
              (k = se + Ae.advanceWidth * ae + C * x);
          });
          let le = 0;
          fe.forEach((Me) => {
            let Ge = !0;
            for (let Le = Me.count; Le--; ) {
              const je = Me.glyphAt(Le);
              Ge &&
                !je.glyphObj.isWhitespace &&
                ((Me.width = je.x + je.width),
                Me.width > de && (de = Me.width),
                (Ge = !1));
              let {
                lineHeight: Je,
                capHeight: Ye,
                xHeight: De,
                baseline: ze,
              } = je.fontData;
              Je > Me.lineHeight && (Me.lineHeight = Je);
              const Ve = ze - Me.baseline;
              Ve < 0 && ((Me.baseline += Ve), (Me.cap += Ve), (Me.ex += Ve)),
                (Me.cap = Math.max(Me.cap, Me.baseline + Ye)),
                (Me.ex = Math.max(Me.ex, Me.baseline + De));
            }
            (Me.baseline -= le),
              (Me.cap -= le),
              (Me.ex -= le),
              (le += Me.lineHeight);
          });
          let ce = 0,
            we = 0;
          if (
            (N &&
              (typeof N == "number"
                ? (ce = -N)
                : typeof N == "string" &&
                  (ce =
                    -de *
                    (N === "left"
                      ? 0
                      : N === "center"
                      ? 0.5
                      : N === "right"
                      ? 1
                      : c(N)))),
            z &&
              (typeof z == "number"
                ? (we = -z)
                : typeof z == "string" &&
                  (we =
                    z === "top"
                      ? 0
                      : z === "top-baseline"
                      ? -fe[0].baseline
                      : z === "top-cap"
                      ? -fe[0].cap
                      : z === "top-ex"
                      ? -fe[0].ex
                      : z === "middle"
                      ? le / 2
                      : z === "bottom"
                      ? le
                      : z === "bottom-baseline"
                      ? -fe[fe.length - 1].baseline
                      : c(z) * le)),
            !V)
          ) {
            const Me = e.getEmbeddingLevels(v, P);
            (ne = new Uint16Array(Ee)),
              (oe = new Uint8Array(Ee)),
              (ue = new Float32Array(Ee * 2)),
              (Ie = {}),
              (ie = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (pe = []),
              U && (ge = new Float32Array(v.length * 4)),
              W && (te = new Uint8Array(Ee * 3));
            let Ge = 0,
              Le = -1,
              je = -1,
              Je,
              Ye;
            if (
              (fe.forEach((De, ze) => {
                let { count: Ve, width: ae } = De;
                if (Ve > 0) {
                  let be = 0;
                  for (
                    let at = Ve;
                    at-- && De.glyphAt(at).glyphObj.isWhitespace;

                  )
                    be++;
                  let se = 0,
                    Ae = 0;
                  if (R === "center") se = (de - ae) / 2;
                  else if (R === "right") se = de - ae;
                  else if (R === "justify" && De.isSoftWrapped) {
                    let at = 0;
                    for (let st = Ve - be; st--; )
                      De.glyphAt(st).glyphObj.isWhitespace && at++;
                    Ae = (de - ae) / at;
                  }
                  if (Ae || se) {
                    let at = 0;
                    for (let st = 0; st < Ve; st++) {
                      let ht = De.glyphAt(st);
                      const pt = ht.glyphObj;
                      (ht.x += se + at),
                        Ae !== 0 &&
                          pt.isWhitespace &&
                          st < Ve - be &&
                          ((at += Ae), (ht.width += Ae));
                    }
                  }
                  const ye = e.getReorderSegments(
                    v,
                    Me,
                    De.glyphAt(0).charIndex,
                    De.glyphAt(De.count - 1).charIndex
                  );
                  for (let at = 0; at < ye.length; at++) {
                    const [st, ht] = ye[at];
                    let pt = 1 / 0,
                      Ze = -1 / 0;
                    for (let Mt = 0; Mt < Ve; Mt++)
                      if (De.glyphAt(Mt).charIndex >= st) {
                        let Rt = Mt,
                          Yt = Mt;
                        for (; Yt < Ve; Yt++) {
                          let en = De.glyphAt(Yt);
                          if (en.charIndex > ht) break;
                          Yt < Ve - be &&
                            ((pt = Math.min(pt, en.x)),
                            (Ze = Math.max(Ze, en.x + en.width)));
                        }
                        for (let en = Rt; en < Yt; en++) {
                          const Qn = De.glyphAt(en);
                          Qn.x = Ze - (Qn.x + Qn.width - pt);
                        }
                        break;
                      }
                  }
                  let He;
                  const qe = (at) => (He = at);
                  for (let at = 0; at < Ve; at++) {
                    const st = De.glyphAt(at);
                    He = st.glyphObj;
                    const ht = He.index,
                      pt = Me.levels[st.charIndex] & 1;
                    if (pt) {
                      const Ze = e.getMirroredCharacter(v[st.charIndex]);
                      Ze && st.fontData.fontObj.forEachGlyph(Ze, 0, 0, qe);
                    }
                    if (U) {
                      const { charIndex: Ze, fontData: Mt } = st,
                        Rt = st.x + ce,
                        Yt = st.x + st.width + ce;
                      (ge[Ze * 4] = pt ? Yt : Rt),
                        (ge[Ze * 4 + 1] = pt ? Rt : Yt),
                        (ge[Ze * 4 + 2] = De.baseline + Mt.caretBottom + we),
                        (ge[Ze * 4 + 3] = De.baseline + Mt.caretTop + we);
                      const en = Ze - Le;
                      en > 1 && u(ge, Le, en), (Le = Ze);
                    }
                    if (W) {
                      const { charIndex: Ze } = st;
                      for (; Ze > je; )
                        je++, W.hasOwnProperty(je) && (Ye = W[je]);
                    }
                    if (!He.isWhitespace && !He.isEmpty) {
                      const Ze = Ge++,
                        { fontSizeMult: Mt, src: Rt, index: Yt } = st.fontData,
                        en = Ie[Rt] || (Ie[Rt] = {});
                      en[ht] ||
                        (en[ht] = {
                          path: He.path,
                          pathBounds: [He.xMin, He.yMin, He.xMax, He.yMax],
                        });
                      const Qn = st.x + ce,
                        cr = st.y + De.baseline + we;
                      (ue[Ze * 2] = Qn), (ue[Ze * 2 + 1] = cr);
                      const $t = Qn + He.xMin * Mt,
                        ur = cr + He.yMin * Mt,
                        fr = Qn + He.xMax * Mt,
                        Xt = cr + He.yMax * Mt;
                      $t < ie[0] && (ie[0] = $t),
                        ur < ie[1] && (ie[1] = ur),
                        fr > ie[2] && (ie[2] = fr),
                        Xt > ie[3] && (ie[3] = Xt),
                        Ze % j === 0 &&
                          ((Je = {
                            start: Ze,
                            end: Ze,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          pe.push(Je)),
                        Je.end++;
                      const Vt = Je.rect;
                      if (
                        ($t < Vt[0] && (Vt[0] = $t),
                        ur < Vt[1] && (Vt[1] = ur),
                        fr > Vt[2] && (Vt[2] = fr),
                        Xt > Vt[3] && (Vt[3] = Xt),
                        (ne[Ze] = ht),
                        (oe[Ze] = Yt),
                        W)
                      ) {
                        const In = Ze * 3;
                        (te[In] = (Ye >> 16) & 255),
                          (te[In + 1] = (Ye >> 8) & 255),
                          (te[In + 2] = Ye & 255);
                      }
                    }
                  }
                }
              }),
              ge)
            ) {
              const De = v.length - Le;
              De > 1 && u(ge, Le, De);
            }
          }
          const Be = [];
          Ce.forEach(
            ({
              index: Me,
              src: Ge,
              unitsPerEm: Le,
              ascender: je,
              descender: Je,
              lineHeight: Ye,
              capHeight: De,
              xHeight: ze,
            }) => {
              Be[Me] = {
                src: Ge,
                unitsPerEm: Le,
                ascender: je,
                descender: Je,
                lineHeight: Ye,
                capHeight: De,
                xHeight: ze,
              };
            }
          ),
            (Z.typesetting = d() - _e),
            B({
              glyphIds: ne,
              glyphFontIndices: oe,
              glyphPositions: ue,
              glyphData: Ie,
              fontData: Be,
              caretPositions: ge,
              glyphColors: te,
              chunkedBounds: pe,
              fontSize: x,
              topBaseline: we + fe[0].baseline,
              blockBounds: [ce, we - le, ce + de, we],
              visibleBounds: ie,
              timings: Z,
            });
        }
      );
  }
  function l(v, _) {
    a({ ...v, metricsOnly: !0 }, (y) => {
      const [g, x, S, b] = y.blockBounds;
      _({ width: S - g, height: b - x });
    });
  }
  function c(v) {
    let _ = v.match(/^([\d.]+)%$/),
      y = _ ? parseFloat(_[1]) : NaN;
    return isNaN(y) ? 0 : y / 100;
  }
  function u(v, _, y) {
    const g = v[_ * 4],
      x = v[_ * 4 + 1],
      S = v[_ * 4 + 2],
      b = v[_ * 4 + 3],
      C = (x - g) / y;
    for (let M = 0; M < y; M++) {
      const T = (_ + M) * 4;
      (v[T] = g + C * M),
        (v[T + 1] = g + C * (M + 1)),
        (v[T + 2] = S),
        (v[T + 3] = b);
    }
  }
  function d() {
    return (self.performance || Date).now();
  }
  function p() {
    this.data = [];
  }
  const m = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (p.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / m.length);
      },
      glyphAt(v) {
        let _ = p.flyweight;
        return (_.data = this.data), (_.index = v), _;
      },
      splitAt(v) {
        let _ = new p();
        return (_.data = this.data.splice(v * m.length)), _;
      },
    }),
    (p.flyweight = m.reduce(
      (v, _, y, g) => (
        Object.defineProperty(v, _, {
          get() {
            return this.data[this.index * m.length + y];
          },
          set(x) {
            this.data[this.index * m.length + y] = x;
          },
        }),
        v
      ),
      { data: null, index: 0 }
    )),
    { typeset: a, measure: l }
  );
}
const mc = () => (self.performance || Date).now(),
  Ty = KD();
let tP;
function D7(t, e, n, r, i, o, s, a, l, c, u = !0) {
  return u
    ? U7(t, e, n, r, i, o, s, a, l, c).then(
        null,
        (d) => (
          tP ||
            (console.warn("WebGL SDF generation failed, falling back to JS", d),
            (tP = !0)),
          rP(t, e, n, r, i, o, s, a, l, c)
        )
      )
    : rP(t, e, n, r, i, o, s, a, l, c);
}
const O0 = [],
  F7 = 5;
let YA = 0;
function JD() {
  const t = mc();
  for (; O0.length && mc() - t < F7; ) O0.shift()();
  YA = O0.length ? setTimeout(JD, 0) : 0;
}
const U7 = (...t) =>
    new Promise((e, n) => {
      O0.push(() => {
        const r = mc();
        try {
          Ty.webgl.generateIntoCanvas(...t), e({ timing: mc() - r });
        } catch (i) {
          n(i);
        }
      }),
        YA || (YA = setTimeout(JD, 0));
    }),
  k7 = 4,
  z7 = 2e3,
  nP = {};
let B7 = 0;
function rP(t, e, n, r, i, o, s, a, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + (B7++ % k7);
  let d = nP[u];
  return (
    d ||
      (d = nP[u] =
        {
          workerModule: zf({
            name: u,
            workerId: u,
            dependencies: [KD, mc],
            init(p, m) {
              const v = p().javascript.generate;
              return function (..._) {
                const y = m();
                return { textureData: v(..._), timing: m() - y };
              };
            },
            getTransferables(p) {
              return [p.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    d.requests++,
    clearTimeout(d.idleTimer),
    d.workerModule(t, e, n, r, i, o).then(({ textureData: p, timing: m }) => {
      const v = mc(),
        _ = new Uint8Array(p.length * 4);
      for (let y = 0; y < p.length; y++) _[y * 4 + c] = p[y];
      return (
        Ty.webglUtils.renderImageData(s, _, a, l, t, e, 1 << (3 - c)),
        (m += mc() - v),
        --d.requests === 0 &&
          (d.idleTimer = setTimeout(() => {
            v7(u);
          }, z7)),
        { timing: m }
      );
    })
  );
}
function H7(t) {
  t._warm || (Ty.webgl.isSupported(t), (t._warm = !0));
}
const V7 = Ty.webglUtils.resizeWebGLCanvasWithoutClearing,
  qd = {
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  G7 = new it();
function Cu() {
  return (self.performance || Date).now();
}
const iP = Object.create(null);
function QD(t, e) {
  t = $7({}, t);
  const n = Cu(),
    r = [];
  if (
    (t.font && r.push({ label: "user", src: X7(t.font) }),
    (t.font = r),
    (t.text = "" + t.text),
    (t.sdfGlyphSize = t.sdfGlyphSize || qd.sdfGlyphSize),
    (t.unicodeFontsURL = t.unicodeFontsURL || qd.unicodeFontsURL),
    t.colorRanges != null)
  ) {
    let p = {};
    for (let m in t.colorRanges)
      if (t.colorRanges.hasOwnProperty(m)) {
        let v = t.colorRanges[m];
        typeof v != "number" && (v = G7.set(v).getHex()), (p[m] = v);
      }
    t.colorRanges = p;
  }
  Object.freeze(t);
  const { textureWidth: i, sdfExponent: o } = qd,
    { sdfGlyphSize: s } = t,
    a = (i / s) * 4;
  let l = iP[s];
  if (!l) {
    const p = document.createElement("canvas");
    (p.width = i),
      (p.height = (s * 256) / a),
      (l = iP[s] =
        {
          glyphCount: 0,
          sdfGlyphSize: s,
          sdfCanvas: p,
          sdfTexture: new lr(p, void 0, void 0, void 0, kn, kn),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (l.sdfTexture.generateMipmaps = !1),
      W7(l);
  }
  const { sdfTexture: c, sdfCanvas: u } = l;
  nF(t).then((p) => {
    const {
        glyphIds: m,
        glyphFontIndices: v,
        fontData: _,
        glyphPositions: y,
        fontSize: g,
        timings: x,
      } = p,
      S = [],
      b = new Float32Array(m.length * 4);
    let C = 0,
      M = 0;
    const T = Cu(),
      P = _.map((N) => {
        let z = l.glyphsByFont.get(N.src);
        return z || l.glyphsByFont.set(N.src, (z = new Map())), z;
      });
    m.forEach((N, z) => {
      const V = v[z],
        { src: G, unitsPerEm: Y } = _[V];
      let U = P[V].get(N);
      if (!U) {
        const { path: Z, pathBounds: H } = p.glyphData[G][N],
          X =
            (Math.max(H[2] - H[0], H[3] - H[1]) / s) * (qd.sdfMargin * s + 0.5),
          ne = l.glyphCount++,
          oe = [H[0] - X, H[1] - X, H[2] + X, H[3] + X];
        P[V].set(N, (U = { path: Z, atlasIndex: ne, sdfViewBox: oe })),
          S.push(U);
      }
      const { sdfViewBox: j } = U,
        W = y[M++],
        B = y[M++],
        q = g / Y;
      (b[C++] = W + j[0] * q),
        (b[C++] = B + j[1] * q),
        (b[C++] = W + j[2] * q),
        (b[C++] = B + j[3] * q),
        (m[z] = U.atlasIndex);
    }),
      (x.quads = (x.quads || 0) + (Cu() - T));
    const R = Cu();
    x.sdf = {};
    const E = u.height,
      O = Math.ceil(l.glyphCount / a),
      D = Math.pow(2, Math.ceil(Math.log2(O * s)));
    D > E &&
      (console.info(`Increasing SDF texture size ${E}->${D}`),
      V7(u, i, D),
      c.dispose()),
      Promise.all(
        S.map((N) =>
          eF(N, l, t.gpuAccelerateSDF).then(({ timing: z }) => {
            x.sdf[N.atlasIndex] = z;
          })
        )
      ).then(() => {
        S.length && !l.contextLost && (tF(l), (c.needsUpdate = !0)),
          (x.sdfTotal = Cu() - R),
          (x.total = Cu() - n),
          e(
            Object.freeze({
              parameters: t,
              sdfTexture: c,
              sdfGlyphSize: s,
              sdfExponent: o,
              glyphBounds: b,
              glyphAtlasIndices: m,
              glyphColors: p.glyphColors,
              caretPositions: p.caretPositions,
              chunkedBounds: p.chunkedBounds,
              ascender: p.ascender,
              descender: p.descender,
              lineHeight: p.lineHeight,
              capHeight: p.capHeight,
              xHeight: p.xHeight,
              topBaseline: p.topBaseline,
              blockBounds: p.blockBounds,
              visibleBounds: p.visibleBounds,
              timings: p.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      l.contextLost || H7(u);
    });
}
function eF(
  { path: t, atlasIndex: e, sdfViewBox: n },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: o },
  s
) {
  if (o) return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: l } = qd,
    c = Math.max(n[2] - n[0], n[3] - n[1]),
    u = Math.floor(e / 4),
    d = (u % (a / r)) * r,
    p = Math.floor(u / (a / r)) * r,
    m = e % 4;
  return D7(r, r, t, n, c, l, i, d, p, m, s);
}
function W7(t) {
  const e = t.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), (t.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (n) => {
      console.log("Context Restored", n), (t.contextLost = !1);
      const r = [];
      t.glyphsByFont.forEach((i) => {
        i.forEach((o) => {
          r.push(eF(o, t, !0));
        });
      }),
        Promise.all(r).then(() => {
          tF(t), (t.sdfTexture.needsUpdate = !0);
        });
    });
}
function j7({ font: t, characters: e, sdfGlyphSize: n }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  QD({ font: t, sdfGlyphSize: n, text: i }, r);
}
function $7(t, e) {
  for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
  return t;
}
let qg;
function X7(t) {
  return (
    qg || (qg = typeof document > "u" ? {} : document.createElement("a")),
    (qg.href = t),
    qg.href
  );
}
function tF(t) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = t,
      { width: r, height: i } = e,
      o = t.sdfCanvas.getContext("webgl");
    let s = n.image.data;
    (!s || s.length !== r * i * 4) &&
      ((s = new Uint8Array(r * i * 4)),
      (n.image = { width: r, height: i, data: s }),
      (n.flipY = !1),
      (n.isDataTexture = !0)),
      o.readPixels(0, 0, r, i, o.RGBA, o.UNSIGNED_BYTE, s);
  }
}
const Y7 = zf({
    name: "Typesetter",
    dependencies: [N7, O7, x7],
    init(t, e, n) {
      return t(e, n());
    },
  }),
  nF = zf({
    name: "Typesetter",
    dependencies: [Y7],
    init(t) {
      return function (e) {
        return new Promise((n) => {
          t.typeset(e, n);
        });
      };
    },
    getTransferables(t) {
      const e = [];
      for (let n in t) t[n] && t[n].buffer && e.push(t[n].buffer);
      return e;
    },
  });
nF.onMainThread;
const oP = {};
function q7(t) {
  let e = oP[t];
  return e || (e = oP[t] = new aa(1, 1, t, t).translate(0.5, 0.5, 0)), e;
}
const K7 = "aTroikaGlyphBounds",
  sP = "aTroikaGlyphIndex",
  Z7 = "aTroikaGlyphColor";
class J7 extends RE {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new Pr()),
      (this.boundingBox = new Rr());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let n = q7(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = n.attributes[r].clone();
      }),
        this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, n, r, i, o) {
    this.updateAttributeData(K7, e, 4),
      this.updateAttributeData(sP, n, 1),
      this.updateAttributeData(Z7, o, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = n.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: r } = this;
      if (n) {
        const { PI: i, floor: o, min: s, max: a, sin: l, cos: c } = Math,
          u = i / 2,
          d = i * 2,
          p = Math.abs(n),
          m = e[0] / p,
          v = e[2] / p,
          _ = o((m + u) / d) !== o((v + u) / d) ? -p : s(l(m) * p, l(v) * p),
          y = o((m - u) / d) !== o((v - u) / d) ? p : a(l(m) * p, l(v) * p),
          g =
            o((m + i) / d) !== o((v + i) / d)
              ? p * 2
              : a(p - c(m) * p, p - c(v) * p);
        r.min.set(_, e[1], n < 0 ? -g : 0), r.max.set(y, e[3], n < 0 ? 0 : g);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let n = this.getAttribute(sP).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        n = r[i].end;
        let o = r[i].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x) break;
      }
    this.instanceCount = n;
  }
  updateAttributeData(e, n, r) {
    const i = this.getAttribute(e);
    n
      ? i && i.array.length === n.length
        ? (i.array.set(n), (i.needsUpdate = !0))
        : (this.setAttribute(e, new Mc(n, r)),
          delete this._maxInstanceCount,
          this.dispose())
      : i && this.deleteAttribute(e);
  }
}
const Q7 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  e$ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  t$ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  n$ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function r$(t) {
  const e = XA(t, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new ke() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new tn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new tn(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new ke() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new it() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Dt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: Q7,
    vertexTransform: e$,
    fragmentDefs: t$,
    fragmentColorTransform: n$,
    customRewriter({ vertexShader: n, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(n) ||
            (n = n.replace(
              ZD,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: n, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    (e.forceSinglePass = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const zE = new sa({ color: 16777215, side: mo, transparent: !0 }),
  aP = 8421504,
  lP = new wt(),
  Kg = new ee(),
  E_ = new ee(),
  Bd = [],
  i$ = new ee(),
  M_ = "+x+y";
function cP(t) {
  return Array.isArray(t) ? t[0] : t;
}
let rF = () => {
    const t = new Cn(new aa(1, 1), zE);
    return (rF = () => t), t;
  },
  iF = () => {
    const t = new Cn(new aa(1, 1, 32, 1), zE);
    return (iF = () => t), t;
  };
const o$ = { type: "syncstart" },
  s$ = { type: "synccomplete" },
  oF = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  a$ = oF.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let sF = class extends Cn {
  constructor() {
    const e = new J7();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = aP),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = M_),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(o$),
          QD(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (n) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = n),
                this.geometry.updateGlyphs(
                  n.glyphBounds,
                  n.glyphAtlasIndices,
                  n.blockBounds,
                  n.chunkedBounds,
                  n.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(s$),
                e && e();
            }
          )));
  }
  onBeforeRender(e, n, r, i, o, s) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  createDerivedMaterial(e) {
    return r$(e);
  }
  get material() {
    let e = this._derivedMaterial;
    const n =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = zE.clone());
    if (
      ((!e || !e.isDerivedFrom(n)) &&
        ((e = this._derivedMaterial = this.createDerivedMaterial(n)),
        n.addEventListener("dispose", function r() {
          n.removeEventListener("dispose", r), e.dispose();
        })),
      this.hasOutline())
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  hasOutline() {
    return !!(
      this.outlineWidth ||
      this.outlineBlur ||
      this.outlineOffsetX ||
      this.outlineOffsetY
    );
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return cP(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {}
  get customDistanceMaterial() {
    return cP(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {}
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: a, blockBounds: l } = i;
      (r.uTroikaSDFTexture.value = a),
        r.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(l),
        (r.uTroikaUseGlyphColors.value = !n && !!i.glyphColors);
      let c = 0,
        u = 0,
        d = 0,
        p,
        m,
        v,
        _ = 0,
        y = 0;
      if (n) {
        let {
          outlineWidth: x,
          outlineOffsetX: S,
          outlineOffsetY: b,
          outlineBlur: C,
          outlineOpacity: M,
        } = this;
        (c = this._parsePercent(x) || 0),
          (u = Math.max(0, this._parsePercent(C) || 0)),
          (p = M),
          (_ = this._parsePercent(S) || 0),
          (y = this._parsePercent(b) || 0);
      } else
        (d = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          d &&
            ((v = this.strokeColor),
            r.uTroikaStrokeColor.value.set(v ?? aP),
            (m = this.strokeOpacity),
            m == null && (m = 1)),
          (p = this.fillOpacity);
      (r.uTroikaEdgeOffset.value = c),
        r.uTroikaPositionOffset.value.set(_, y),
        (r.uTroikaBlurRadius.value = u),
        (r.uTroikaStrokeWidth.value = d),
        (r.uTroikaStrokeOpacity.value = m),
        (r.uTroikaFillOpacity.value = p ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let g = this.clipRect;
      if (g && Array.isArray(g) && g.length === 4)
        r.uTroikaClipRect.value.fromArray(g);
      else {
        const x = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(l[0] - x, l[1] - x, l[2] + x, l[3] + x);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null) delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : (e.color = new it());
      (o !== a._input || typeof o == "object") && a.set((a._input = o));
    }
    let s = this.orientation || M_;
    if (s !== e._orientation) {
      let a = r.uTroikaOrient.value;
      s = s.replace(/[^-+xyz]/g, "");
      let l = s !== M_ && s.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, d, p] = l;
        (Kg.set(0, 0, 0)[u] = c === "-" ? 1 : -1),
          (E_.set(0, 0, 0)[p] = d === "-" ? -1 : 1),
          lP.lookAt(i$, Kg.cross(E_), E_),
          a.setFromMatrix4(lP);
      } else a.identity();
      e._orientation = s;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/),
        r = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, n = new ke()) {
    n.copy(e);
    const r = this.curveRadius;
    return (
      r && (n.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), n
    );
  }
  worldPositionToTextCoords(e, n = new ke()) {
    return Kg.copy(e), this.localPositionToTextCoords(this.worldToLocal(Kg), n);
  }
  raycast(e, n) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const o = r.blockBounds,
        s = i ? iF() : rF(),
        a = s.geometry,
        { position: l, uv: c } = a.attributes;
      for (let u = 0; u < c.count; u++) {
        let d = o[0] + c.getX(u) * (o[2] - o[0]);
        const p = o[1] + c.getY(u) * (o[3] - o[1]);
        let m = 0;
        i && ((m = i - Math.cos(d / i) * i), (d = Math.sin(d / i) * i)),
          l.setXYZ(u, d, p, m);
      }
      (a.boundingSphere = this.geometry.boundingSphere),
        (a.boundingBox = this.geometry.boundingBox),
        (s.matrixWorld = this.matrixWorld),
        (s.material.side = this.material.side),
        (Bd.length = 0),
        s.raycast(e, Bd);
      for (let u = 0; u < Bd.length; u++) (Bd[u].object = this), n.push(Bd[u]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return (
      super.copy(e),
      (this.geometry = n),
      a$.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
oF.forEach((t) => {
  const e = "_private_" + t;
  Object.defineProperty(sF.prototype, t, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && ((this[e] = n), (this._needsSync = !0));
    },
  });
});
new Rr();
new it();
const Dn = L.forwardRef(
    (
      {
        sdfGlyphSize: t = 64,
        anchorX: e = "center",
        anchorY: n = "middle",
        font: r,
        fontSize: i = 1,
        children: o,
        characters: s,
        onSync: a,
        ...l
      },
      c
    ) => {
      const u = os(({ invalidate: v }) => v),
        [d] = L.useState(() => new sF()),
        [p, m] = L.useMemo(() => {
          const v = [];
          let _ = "";
          return (
            L.Children.forEach(o, (y) => {
              typeof y == "string" || typeof y == "number"
                ? (_ += y)
                : v.push(y);
            }),
            [v, _]
          );
        }, [o]);
      return (
        CD(
          () => new Promise((v) => j7({ font: r, characters: s }, v)),
          ["troika-text", r, s]
        ),
        L.useLayoutEffect(
          () =>
            void d.sync(() => {
              u(), a && a(d);
            })
        ),
        L.useEffect(() => () => d.dispose(), [d]),
        L.createElement(
          "primitive",
          Bt(
            {
              object: d,
              ref: c,
              font: r,
              text: m,
              anchorX: e,
              anchorY: n,
              fontSize: i,
              sdfGlyphSize: t,
            },
            l
          ),
          p
        )
      );
    }
  ),
  l$ = L.forwardRef(
    (
      {
        makeDefault: t,
        camera: e,
        regress: n,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: o = !1,
        onChange: s,
        onStart: a,
        onEnd: l,
        ...c
      },
      u
    ) => {
      const d = os((M) => M.invalidate),
        p = os((M) => M.camera),
        m = os((M) => M.gl),
        v = os((M) => M.events),
        _ = os((M) => M.setEvents),
        y = os((M) => M.set),
        g = os((M) => M.get),
        x = os((M) => M.performance),
        S = e || p,
        b = r || v.connected || m.domElement,
        C = L.useMemo(() => new d7(S), [S]);
      return (
        FE(() => {
          C.enabled && C.update();
        }, -1),
        L.useEffect(
          () => (
            o && C.connect(o === !0 ? b : o),
            C.connect(b),
            () => void C.dispose()
          ),
          [o, b, n, C, d]
        ),
        L.useEffect(() => {
          const M = (R) => {
              d(), n && x.regress(), s && s(R);
            },
            T = (R) => {
              a && a(R);
            },
            P = (R) => {
              l && l(R);
            };
          return (
            C.addEventListener("change", M),
            C.addEventListener("start", T),
            C.addEventListener("end", P),
            () => {
              C.removeEventListener("start", T),
                C.removeEventListener("end", P),
                C.removeEventListener("change", M);
            }
          );
        }, [s, a, l, C, d, _]),
        L.useEffect(() => {
          if (t) {
            const M = g().controls;
            return y({ controls: C }), () => y({ controls: M });
          }
        }, [t, C]),
        L.createElement(
          "primitive",
          Bt({ ref: u, object: C, enableDamping: i }, c)
        )
      );
    }
  );
var aF = { exports: {} },
  c$ = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  u$ = c$,
  f$ = u$;
function lF() {}
function cF() {}
cF.resetWarningCache = lF;
var d$ = function () {
  function t(r, i, o, s, a, l) {
    if (l !== f$) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  t.isRequired = t;
  function e() {
    return t;
  }
  var n = {
    array: t,
    bigint: t,
    bool: t,
    func: t,
    number: t,
    object: t,
    string: t,
    symbol: t,
    any: t,
    arrayOf: e,
    element: t,
    elementType: t,
    instanceOf: e,
    node: t,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: cF,
    resetWarningCache: lF,
  };
  return (n.PropTypes = n), n;
};
aF.exports = d$();
var h$ = aF.exports;
const La = Ap(h$);
function p$(t, e) {
  const n = t + "Geometry";
  return L.forwardRef(({ args: r, children: i, ...o }, s) => {
    const a = L.useRef(null);
    return (
      L.useImperativeHandle(s, () => a.current),
      L.useLayoutEffect(() => void (e == null ? void 0 : e(a.current))),
      L.createElement(
        "mesh",
        Bt({ ref: a }, o),
        L.createElement(n, { attach: "geometry", args: r }),
        i
      )
    );
  });
}
const Wn = p$("box"),
  uP = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      this.enabled !== !1 && (this.files[t] = e);
    },
    get: function (t) {
      if (this.enabled !== !1) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
class m$ {
  constructor(e, n, r) {
    const i = this;
    let o = !1,
      s = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = n),
      (this.onError = r),
      (this.itemStart = function (u) {
        a++, o === !1 && i.onStart !== void 0 && i.onStart(u, s, a), (o = !0);
      }),
      (this.itemEnd = function (u) {
        s++,
          i.onProgress !== void 0 && i.onProgress(u, s, a),
          s === a && ((o = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, p = c.length; d < p; d += 2) {
          const m = c[d],
            v = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return v;
        }
        return null;
      });
  }
}
const g$ = new m$();
class BE {
  constructor(e) {
    (this.manager = e !== void 0 ? e : g$),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, n) {
    const r = this;
    return new Promise(function (i, o) {
      r.load(e, i, n, o);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
BE.DEFAULT_MATERIAL_NAME = "__DEFAULT";
function qA(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
class v$ extends BE {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const o = this,
      s = uP.get(e);
    if (s !== void 0)
      return (
        o.manager.itemStart(e),
        setTimeout(function () {
          n && n(s), o.manager.itemEnd(e);
        }, 0),
        s
      );
    const a = qA("img");
    function l() {
      u(), uP.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      o.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class y$ {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(n) === -1 && r[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(n);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let o = 0, s = i.length; o < s; o++) i[o].call(this, e);
      e.target = null;
    }
  }
}
const uF = 300,
  fP = 1e3,
  Zg = 1001,
  dP = 1002,
  x$ = 1006,
  _$ = 1008,
  S$ = 1009,
  A$ = 1023,
  b$ = "",
  Gr = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
function fF() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Gr[t & 255] +
    Gr[(t >> 8) & 255] +
    Gr[(t >> 16) & 255] +
    Gr[(t >> 24) & 255] +
    "-" +
    Gr[e & 255] +
    Gr[(e >> 8) & 255] +
    "-" +
    Gr[((e >> 16) & 15) | 64] +
    Gr[(e >> 24) & 255] +
    "-" +
    Gr[(n & 63) | 128] +
    Gr[(n >> 8) & 255] +
    "-" +
    Gr[(n >> 16) & 255] +
    Gr[(n >> 24) & 255] +
    Gr[r & 255] +
    Gr[(r >> 8) & 255] +
    Gr[(r >> 16) & 255] +
    Gr[(r >> 24) & 255]
  ).toLowerCase();
}
function w$(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
class vh {
  constructor(e = 0, n = 0) {
    (vh.prototype.isVector2 = !0), (this.x = e), (this.y = n);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return (this.x = e), (this.y = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, n) {
    return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, n) {
    return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * n + i[3] * r + i[6]),
      (this.y = i[1] * n + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      this
    );
  }
  clampLength(e, n) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(n, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const r = this.dot(e) / n;
    return Math.acos(w$(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      r = this.y - e.y;
    return n * n + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this;
  }
  lerpVectors(e, n, r) {
    return (
      (this.x = e.x + (n.x - e.x) * r), (this.y = e.y + (n.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), e;
  }
  fromBufferAttribute(e, n) {
    return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
  }
  rotateAround(e, n) {
    const r = Math.cos(n),
      i = Math.sin(n),
      o = this.x - e.x,
      s = this.y - e.y;
    return (this.x = o * r - s * i + e.x), (this.y = o * i + s * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ry {
  constructor(e, n, r, i, o, s, a, l, c) {
    (Ry.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, r, i, o, s, a, l, c);
  }
  set(e, n, r, i, o, s, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = a),
      (u[3] = n),
      (u[4] = o),
      (u[5] = l),
      (u[6] = r),
      (u[7] = s),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements,
      r = e.elements;
    return (
      (n[0] = r[0]),
      (n[1] = r[1]),
      (n[2] = r[2]),
      (n[3] = r[3]),
      (n[4] = r[4]),
      (n[5] = r[5]),
      (n[6] = r[6]),
      (n[7] = r[7]),
      (n[8] = r[8]),
      this
    );
  }
  extractBasis(e, n, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      n.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return (
      this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const r = e.elements,
      i = n.elements,
      o = this.elements,
      s = r[0],
      a = r[3],
      l = r[6],
      c = r[1],
      u = r[4],
      d = r[7],
      p = r[2],
      m = r[5],
      v = r[8],
      _ = i[0],
      y = i[3],
      g = i[6],
      x = i[1],
      S = i[4],
      b = i[7],
      C = i[2],
      M = i[5],
      T = i[8];
    return (
      (o[0] = s * _ + a * x + l * C),
      (o[3] = s * y + a * S + l * M),
      (o[6] = s * g + a * b + l * T),
      (o[1] = c * _ + u * x + d * C),
      (o[4] = c * y + u * S + d * M),
      (o[7] = c * g + u * b + d * T),
      (o[2] = p * _ + m * x + v * C),
      (o[5] = p * y + m * S + v * M),
      (o[8] = p * g + m * b + v * T),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      (n[2] *= e),
      (n[5] *= e),
      (n[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      n * s * u - n * a * c - r * o * u + r * a * l + i * o * c - i * s * l
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      r = e[1],
      i = e[2],
      o = e[3],
      s = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * s - a * c,
      p = a * l - u * o,
      m = c * o - s * l,
      v = n * d + r * p + i * m;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / v;
    return (
      (e[0] = d * _),
      (e[1] = (i * c - u * r) * _),
      (e[2] = (a * r - i * s) * _),
      (e[3] = p * _),
      (e[4] = (u * n - i * l) * _),
      (e[5] = (i * o - a * n) * _),
      (e[6] = m * _),
      (e[7] = (r * l - c * n) * _),
      (e[8] = (s * n - r * o) * _),
      this
    );
  }
  transpose() {
    let e;
    const n = this.elements;
    return (
      (e = n[1]),
      (n[1] = n[3]),
      (n[3] = e),
      (e = n[2]),
      (n[2] = n[6]),
      (n[6] = e),
      (e = n[5]),
      (n[5] = n[7]),
      (n[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[3]),
      (e[2] = n[6]),
      (e[3] = n[1]),
      (e[4] = n[4]),
      (e[5] = n[7]),
      (e[6] = n[2]),
      (e[7] = n[5]),
      (e[8] = n[8]),
      this
    );
  }
  setUvTransform(e, n, r, i, o, s, a) {
    const l = Math.cos(o),
      c = Math.sin(o);
    return (
      this.set(
        r * l,
        r * c,
        -r * (l * s + c * a) + s + e,
        -i * c,
        i * l,
        -i * (-c * s + l * a) + a + n,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, n) {
    return this.premultiply(C_.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(C_.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(C_.makeTranslation(e, n)), this;
  }
  makeTranslation(e, n) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const n = Math.cos(e),
      r = Math.sin(e);
    return this.set(n, -r, 0, r, n, 0, 0, 0, 1), this;
  }
  makeScale(e, n) {
    return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
  }
  equals(e) {
    const n = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (n[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const r = this.elements;
    return (
      (e[n] = r[0]),
      (e[n + 1] = r[1]),
      (e[n + 2] = r[2]),
      (e[n + 3] = r[3]),
      (e[n + 4] = r[4]),
      (e[n + 5] = r[5]),
      (e[n + 6] = r[6]),
      (e[n + 7] = r[7]),
      (e[n + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const C_ = new Ry();
function T_(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
let Tu;
class E$ {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      Tu === void 0 && (Tu = qA("canvas")),
        (Tu.width = e.width),
        (Tu.height = e.height);
      const r = Tu.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (n = Tu);
    }
    return n.width > 2048 || n.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        n.toDataURL("image/jpeg", 0.6))
      : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const n = qA("canvas");
      (n.width = e.width), (n.height = e.height);
      const r = n.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        o = i.data;
      for (let s = 0; s < o.length; s++) o[s] = T_(o[s] / 255) * 255;
      return r.putImageData(i, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let r = 0; r < n.length; r++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray
          ? (n[r] = Math.floor(T_(n[r] / 255) * 255))
          : (n[r] = T_(n[r]));
      return { data: n, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let M$ = 0;
class C$ {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: M$++ }),
      (this.uuid = fF()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let s = 0, a = i.length; s < a; s++)
          i[s].isDataTexture ? o.push(R_(i[s].image)) : o.push(R_(i[s]));
      } else o = R_(i);
      r.url = o;
    }
    return n || (e.images[this.uuid] = r), r;
  }
}
function R_(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? E$.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let T$ = 0;
class Za extends y$ {
  constructor(
    e = Za.DEFAULT_IMAGE,
    n = Za.DEFAULT_MAPPING,
    r = Zg,
    i = Zg,
    o = x$,
    s = _$,
    a = A$,
    l = S$,
    c = Za.DEFAULT_ANISOTROPY,
    u = b$
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: T$++ }),
      (this.uuid = fF()),
      (this.name = ""),
      (this.source = new C$(e)),
      (this.mipmaps = []),
      (this.mapping = n),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = o),
      (this.minFilter = s),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new vh(0, 0)),
      (this.repeat = new vh(1, 1)),
      (this.center = new vh(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Ry()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      n || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== uF) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case fP:
          e.x = e.x - Math.floor(e.x);
          break;
        case Zg:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case dP:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case fP:
          e.y = e.y - Math.floor(e.y);
          break;
        case Zg:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case dP:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Za.DEFAULT_IMAGE = null;
Za.DEFAULT_MAPPING = uF;
Za.DEFAULT_ANISOTROPY = 1;
class Kd extends BE {
  constructor(e) {
    super(e);
  }
  load(e, n, r, i) {
    const o = new Za(),
      s = new v$(this.manager);
    return (
      s.setCrossOrigin(this.crossOrigin),
      s.setPath(this.path),
      s.load(
        e,
        function (a) {
          (o.image = a), (o.needsUpdate = !0), n !== void 0 && n(o);
        },
        r,
        i
      ),
      o
    );
  }
}
const R$ =
    "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4QDQRXhpZgAASUkqAAgAAAADAA4BAgCGAAAAMgAAABoBBQABAAAAuAAAABsBBQABAAAAwAAAAAAAAABQb3N0ZXIgb2Ygb2xkIGZpbG0gLSB2aW50YWdlIHN0eWxlLiBEYXJrIGdyZXkgYmxhbmsgYmFja2Ryb3AgYmFubmVyIHdpdGggZHVzdCwgc2NyYXRjaCwgc2N1ZmYuIFRvcCB2aWV3IG9mIGNvbmNyZXRlLCBtZXRhbCwgd29vZCB0YWJsZSwBAAABAAAALAEAAAEAAAD/4QX2aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj4KCTxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CgkJPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczpJcHRjNHhtcENvcmU9Imh0dHA6Ly9pcHRjLm9yZy9zdGQvSXB0YzR4bXBDb3JlLzEuMC94bWxucy8iICAgeG1sbnM6R2V0dHlJbWFnZXNHSUZUPSJodHRwOi8veG1wLmdldHR5aW1hZ2VzLmNvbS9naWZ0LzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGx1cz0iaHR0cDovL25zLnVzZXBsdXMub3JnL2xkZi94bXAvMS4wLyIgIHhtbG5zOmlwdGNFeHQ9Imh0dHA6Ly9pcHRjLm9yZy9zdGQvSXB0YzR4bXBFeHQvMjAwOC0wMi0yOS8iIHhtbG5zOnhtcFJpZ2h0cz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3JpZ2h0cy8iIHBob3Rvc2hvcDpDcmVkaXQ9IkdldHR5IEltYWdlcyIgR2V0dHlJbWFnZXNHSUZUOkFzc2V0SUQ9IjEwNTA0NDMwODIiIHhtcFJpZ2h0czpXZWJTdGF0ZW1lbnQ9Imh0dHBzOi8vd3d3LmlzdG9ja3Bob3RvLmNvbS9sZWdhbC9saWNlbnNlLWFncmVlbWVudD91dG1fbWVkaXVtPW9yZ2FuaWMmYW1wO3V0bV9zb3VyY2U9Z29vZ2xlJmFtcDt1dG1fY2FtcGFpZ249aXB0Y3VybCIgcGx1czpEYXRhTWluaW5nPSJodHRwOi8vbnMudXNlcGx1cy5vcmcvbGRmL3ZvY2FiL0RNSS1QUk9ISUJJVEVELUVYQ0VQVFNFQVJDSEVOR0lORUlOREVYSU5HIiA+CjxkYzpjcmVhdG9yPjxyZGY6U2VxPjxyZGY6bGk+YWxlbmFzcGw8L3JkZjpsaT48L3JkZjpTZXE+PC9kYzpjcmVhdG9yPjxkYzpkZXNjcmlwdGlvbj48cmRmOkFsdD48cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPlBvc3RlciBvZiBvbGQgZmlsbSAtIHZpbnRhZ2Ugc3R5bGUuIERhcmsgZ3JleSBibGFuayBiYWNrZHJvcCBiYW5uZXIgd2l0aCBkdXN0LCBzY3JhdGNoLCBzY3VmZi4gVG9wIHZpZXcgb2YgY29uY3JldGUsIG1ldGFsLCB3b29kIHRhYmxlPC9yZGY6bGk+PC9yZGY6QWx0PjwvZGM6ZGVzY3JpcHRpb24+CjxwbHVzOkxpY2Vuc29yPjxyZGY6U2VxPjxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPjxwbHVzOkxpY2Vuc29yVVJMPmh0dHBzOi8vd3d3LmlzdG9ja3Bob3RvLmNvbS9waG90by9saWNlbnNlLWdtMTA1MDQ0MzA4Mi0/dXRtX21lZGl1bT1vcmdhbmljJmFtcDt1dG1fc291cmNlPWdvb2dsZSZhbXA7dXRtX2NhbXBhaWduPWlwdGN1cmw8L3BsdXM6TGljZW5zb3JVUkw+PC9yZGY6bGk+PC9yZGY6U2VxPjwvcGx1czpMaWNlbnNvcj4KCQk8L3JkZjpEZXNjcmlwdGlvbj4KCTwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9InciPz4K/+0AxlBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAACpHAJQAAhhbGVuYXNwbBwCeACGUG9zdGVyIG9mIG9sZCBmaWxtIC0gdmludGFnZSBzdHlsZS4gRGFyayBncmV5IGJsYW5rIGJhY2tkcm9wIGJhbm5lciB3aXRoIGR1c3QsIHNjcmF0Y2gsIHNjdWZmLiBUb3AgdmlldyBvZiBjb25jcmV0ZSwgbWV0YWwsIHdvb2QgdGFibGUcAm4ADEdldHR5IEltYWdlcwD/2wBDAAgICAkICQsLCwsLCw0MDQ0NDQ0NDQ0NDQ0ODg4REREODg4NDQ4OEBARERITEhERERETExQUFBgYFxccHB0iIin/xABSAAEBAQEAAAAAAAAAAAAAAAAAAQIHAQEAAAAAAAAAAAAAAAAAAAAAEAEBAQEBAQAAAAAAAAAAAAAAAREhMUERAQAAAAAAAAAAAAAAAAAAAAD/wAARCAFoAoADASIAAhIAAxIA/9oADAMBAAIRAxEAPwDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKgAAAACoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKALEWJQABQBEVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAFAAVkUAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAEUAEUoAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAoAA1IvEtqzoAzWW6zQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAFBoAT1fDAAZ20aZAAAAQFAEAAAFAEUABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABTGpAAgAAiY3xABINVkARFqAAAAAAAoIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqCgCqzoANxKyoAirLiAArKgCCoAIAACoACooAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKp8QAVAAFiCACqgAKgAAgAACgAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAogAKIoAigAAAAIAAAAAqAAoAAioAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0yoAiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIAD//2Q==",
  P$ = "images/display-BfKZ46GT.png",
  I$ = "images/nature-Ckd5Zzvw.jpg",
  L$ = "images/linux-DR6-HlGt.png";
function Mr(t) {
  return `Minified Redux error #${t}; visit https://redux.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
var O$ = (typeof Symbol == "function" && Symbol.observable) || "@@observable",
  hP = O$,
  P_ = () => Math.random().toString(36).substring(7).split("").join("."),
  N$ = {
    INIT: `@@redux/INIT${P_()}`,
    REPLACE: `@@redux/REPLACE${P_()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${P_()}`,
  },
  xv = N$;
function HE(t) {
  if (typeof t != "object" || t === null) return !1;
  let e = t;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(t) === e || Object.getPrototypeOf(t) === null;
}
function dF(t, e, n) {
  if (typeof t != "function") throw new Error(Mr(2));
  if (
    (typeof e == "function" && typeof n == "function") ||
    (typeof n == "function" && typeof arguments[3] == "function")
  )
    throw new Error(Mr(0));
  if (
    (typeof e == "function" && typeof n > "u" && ((n = e), (e = void 0)),
    typeof n < "u")
  ) {
    if (typeof n != "function") throw new Error(Mr(1));
    return n(dF)(t, e);
  }
  let r = t,
    i = e,
    o = new Map(),
    s = o,
    a = 0,
    l = !1;
  function c() {
    s === o &&
      ((s = new Map()),
      o.forEach((y, g) => {
        s.set(g, y);
      }));
  }
  function u() {
    if (l) throw new Error(Mr(3));
    return i;
  }
  function d(y) {
    if (typeof y != "function") throw new Error(Mr(4));
    if (l) throw new Error(Mr(5));
    let g = !0;
    c();
    const x = a++;
    return (
      s.set(x, y),
      function () {
        if (g) {
          if (l) throw new Error(Mr(6));
          (g = !1), c(), s.delete(x), (o = null);
        }
      }
    );
  }
  function p(y) {
    if (!HE(y)) throw new Error(Mr(7));
    if (typeof y.type > "u") throw new Error(Mr(8));
    if (typeof y.type != "string") throw new Error(Mr(17));
    if (l) throw new Error(Mr(9));
    try {
      (l = !0), (i = r(i, y));
    } finally {
      l = !1;
    }
    return (
      (o = s).forEach((x) => {
        x();
      }),
      y
    );
  }
  function m(y) {
    if (typeof y != "function") throw new Error(Mr(10));
    (r = y), p({ type: xv.REPLACE });
  }
  function v() {
    const y = d;
    return {
      subscribe(g) {
        if (typeof g != "object" || g === null) throw new Error(Mr(11));
        function x() {
          const b = g;
          b.next && b.next(u());
        }
        return x(), { unsubscribe: y(x) };
      },
      [hP]() {
        return this;
      },
    };
  }
  return (
    p({ type: xv.INIT }),
    { dispatch: p, subscribe: d, getState: u, replaceReducer: m, [hP]: v }
  );
}
function D$(t) {
  Object.keys(t).forEach((e) => {
    const n = t[e];
    if (typeof n(void 0, { type: xv.INIT }) > "u") throw new Error(Mr(12));
    if (typeof n(void 0, { type: xv.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(Mr(13));
  });
}
function F$(t) {
  const e = Object.keys(t),
    n = {};
  for (let o = 0; o < e.length; o++) {
    const s = e[o];
    typeof t[s] == "function" && (n[s] = t[s]);
  }
  const r = Object.keys(n);
  let i;
  try {
    D$(n);
  } catch (o) {
    i = o;
  }
  return function (s = {}, a) {
    if (i) throw i;
    let l = !1;
    const c = {};
    for (let u = 0; u < r.length; u++) {
      const d = r[u],
        p = n[d],
        m = s[d],
        v = p(m, a);
      if (typeof v > "u") throw (a && a.type, new Error(Mr(14)));
      (c[d] = v), (l = l || v !== m);
    }
    return (l = l || r.length !== Object.keys(s).length), l ? c : s;
  };
}
function _v(...t) {
  return t.length === 0
    ? (e) => e
    : t.length === 1
    ? t[0]
    : t.reduce(
        (e, n) =>
          (...r) =>
            e(n(...r))
      );
}
function U$(...t) {
  return (e) => (n, r) => {
    const i = e(n, r);
    let o = () => {
      throw new Error(Mr(15));
    };
    const s = { getState: i.getState, dispatch: (l, ...c) => o(l, ...c) },
      a = t.map((l) => l(s));
    return (o = _v(...a)(i.dispatch)), { ...i, dispatch: o };
  };
}
function k$(t) {
  return HE(t) && "type" in t && typeof t.type == "string";
}
var hF = Symbol.for("immer-nothing"),
  pP = Symbol.for("immer-draftable"),
  Ki = Symbol.for("immer-state");
function ko(t, ...e) {
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Af = Object.getPrototypeOf;
function Tc(t) {
  return !!t && !!t[Ki];
}
function ta(t) {
  var e;
  return t
    ? pF(t) ||
        Array.isArray(t) ||
        !!t[pP] ||
        !!((e = t.constructor) != null && e[pP]) ||
        Hp(t) ||
        Iy(t)
    : !1;
}
var z$ = Object.prototype.constructor.toString();
function pF(t) {
  if (!t || typeof t != "object") return !1;
  const e = Af(t);
  if (e === null) return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object
    ? !0
    : typeof n == "function" && Function.toString.call(n) === z$;
}
function Sv(t, e) {
  Py(t) === 0
    ? Reflect.ownKeys(t).forEach((n) => {
        e(n, t[n], t);
      })
    : t.forEach((n, r) => e(r, n, t));
}
function Py(t) {
  const e = t[Ki];
  return e ? e.type_ : Array.isArray(t) ? 1 : Hp(t) ? 2 : Iy(t) ? 3 : 0;
}
function KA(t, e) {
  return Py(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function mF(t, e, n) {
  const r = Py(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : (t[e] = n);
}
function B$(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function Hp(t) {
  return t instanceof Map;
}
function Iy(t) {
  return t instanceof Set;
}
function Yl(t) {
  return t.copy_ || t.base_;
}
function ZA(t, e) {
  if (Hp(t)) return new Map(t);
  if (Iy(t)) return new Set(t);
  if (Array.isArray(t)) return Array.prototype.slice.call(t);
  const n = pF(t);
  if (e === !0 || (e === "class_only" && !n)) {
    const r = Object.getOwnPropertyDescriptors(t);
    delete r[Ki];
    let i = Reflect.ownKeys(r);
    for (let o = 0; o < i.length; o++) {
      const s = i[o],
        a = r[s];
      a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
        (a.get || a.set) &&
          (r[s] = {
            configurable: !0,
            writable: !0,
            enumerable: a.enumerable,
            value: t[s],
          });
    }
    return Object.create(Af(t), r);
  } else {
    const r = Af(t);
    if (r !== null && n) return { ...t };
    const i = Object.create(r);
    return Object.assign(i, t);
  }
}
function VE(t, e = !1) {
  return (
    Ly(t) ||
      Tc(t) ||
      !ta(t) ||
      (Py(t) > 1 &&
        Object.defineProperties(t, {
          set: { value: Jg },
          add: { value: Jg },
          clear: { value: Jg },
          delete: { value: Jg },
        }),
      Object.freeze(t),
      e && Object.values(t).forEach((n) => VE(n, !0))),
    t
  );
}
function Jg() {
  ko(2);
}
function Ly(t) {
  return Object.isFrozen(t);
}
var H$ = {};
function Rc(t) {
  const e = H$[t];
  return e || ko(0, t), e;
}
var sp;
function gF() {
  return sp;
}
function V$(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
  };
}
function mP(t, e) {
  e &&
    (Rc("Patches"),
    (t.patches_ = []),
    (t.inversePatches_ = []),
    (t.patchListener_ = e));
}
function JA(t) {
  QA(t), t.drafts_.forEach(G$), (t.drafts_ = null);
}
function QA(t) {
  t === sp && (sp = t.parent_);
}
function gP(t) {
  return (sp = V$(sp, t));
}
function G$(t) {
  const e = t[Ki];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : (e.revoked_ = !0);
}
function vP(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const n = e.drafts_[0];
  return (
    t !== void 0 && t !== n
      ? (n[Ki].modified_ && (JA(e), ko(4)),
        ta(t) && ((t = Av(e, t)), e.parent_ || bv(e, t)),
        e.patches_ &&
          Rc("Patches").generateReplacementPatches_(
            n[Ki].base_,
            t,
            e.patches_,
            e.inversePatches_
          ))
      : (t = Av(e, n, [])),
    JA(e),
    e.patches_ && e.patchListener_(e.patches_, e.inversePatches_),
    t !== hF ? t : void 0
  );
}
function Av(t, e, n) {
  if (Ly(e)) return e;
  const r = e[Ki];
  if (!r) return Sv(e, (i, o) => yP(t, r, e, i, o, n)), e;
  if (r.scope_ !== t) return e;
  if (!r.modified_) return bv(t, r.base_, !0), r.base_;
  if (!r.finalized_) {
    (r.finalized_ = !0), r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i,
      s = !1;
    r.type_ === 3 && ((o = new Set(i)), i.clear(), (s = !0)),
      Sv(o, (a, l) => yP(t, r, i, a, l, n, s)),
      bv(t, i, !1),
      n &&
        t.patches_ &&
        Rc("Patches").generatePatches_(r, n, t.patches_, t.inversePatches_);
  }
  return r.copy_;
}
function yP(t, e, n, r, i, o, s) {
  if (Tc(i)) {
    const a =
        o && e && e.type_ !== 3 && !KA(e.assigned_, r) ? o.concat(r) : void 0,
      l = Av(t, i, a);
    if ((mF(n, r, l), Tc(l))) t.canAutoFreeze_ = !1;
    else return;
  } else s && n.add(i);
  if (ta(i) && !Ly(i)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1) return;
    Av(t, i),
      (!e || !e.scope_.parent_) &&
        typeof r != "symbol" &&
        (Hp(n) ? n.has(r) : Object.prototype.propertyIsEnumerable.call(n, r)) &&
        bv(t, i);
  }
}
function bv(t, e, n = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && VE(e, n);
}
function W$(t, e) {
  const n = Array.isArray(t),
    r = {
      type_: n ? 1 : 0,
      scope_: e ? e.scope_ : gF(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: e,
      base_: t,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    };
  let i = r,
    o = GE;
  n && ((i = [r]), (o = ap));
  const { revoke: s, proxy: a } = Proxy.revocable(i, o);
  return (r.draft_ = a), (r.revoke_ = s), a;
}
var GE = {
    get(t, e) {
      if (e === Ki) return t;
      const n = Yl(t);
      if (!KA(n, e)) return j$(t, n, e);
      const r = n[e];
      return t.finalized_ || !ta(r)
        ? r
        : r === I_(t.base_, e)
        ? (L_(t), (t.copy_[e] = tb(r, t)))
        : r;
    },
    has(t, e) {
      return e in Yl(t);
    },
    ownKeys(t) {
      return Reflect.ownKeys(Yl(t));
    },
    set(t, e, n) {
      const r = vF(Yl(t), e);
      if (r != null && r.set) return r.set.call(t.draft_, n), !0;
      if (!t.modified_) {
        const i = I_(Yl(t), e),
          o = i == null ? void 0 : i[Ki];
        if (o && o.base_ === n)
          return (t.copy_[e] = n), (t.assigned_[e] = !1), !0;
        if (B$(n, i) && (n !== void 0 || KA(t.base_, e))) return !0;
        L_(t), eb(t);
      }
      return (
        (t.copy_[e] === n && (n !== void 0 || e in t.copy_)) ||
          (Number.isNaN(n) && Number.isNaN(t.copy_[e])) ||
          ((t.copy_[e] = n), (t.assigned_[e] = !0)),
        !0
      );
    },
    deleteProperty(t, e) {
      return (
        I_(t.base_, e) !== void 0 || e in t.base_
          ? ((t.assigned_[e] = !1), L_(t), eb(t))
          : delete t.assigned_[e],
        t.copy_ && delete t.copy_[e],
        !0
      );
    },
    getOwnPropertyDescriptor(t, e) {
      const n = Yl(t),
        r = Reflect.getOwnPropertyDescriptor(n, e);
      return (
        r && {
          writable: !0,
          configurable: t.type_ !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: n[e],
        }
      );
    },
    defineProperty() {
      ko(11);
    },
    getPrototypeOf(t) {
      return Af(t.base_);
    },
    setPrototypeOf() {
      ko(12);
    },
  },
  ap = {};
Sv(GE, (t, e) => {
  ap[t] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
});
ap.deleteProperty = function (t, e) {
  return ap.set.call(this, t, e, void 0);
};
ap.set = function (t, e, n) {
  return GE.set.call(this, t[0], e, n, t[0]);
};
function I_(t, e) {
  const n = t[Ki];
  return (n ? Yl(n) : t)[e];
}
function j$(t, e, n) {
  var i;
  const r = vF(e, n);
  return r
    ? "value" in r
      ? r.value
      : (i = r.get) == null
      ? void 0
      : i.call(t.draft_)
    : void 0;
}
function vF(t, e) {
  if (!(e in t)) return;
  let n = Af(t);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    if (r) return r;
    n = Af(n);
  }
}
function eb(t) {
  t.modified_ || ((t.modified_ = !0), t.parent_ && eb(t.parent_));
}
function L_(t) {
  t.copy_ || (t.copy_ = ZA(t.base_, t.scope_.immer_.useStrictShallowCopy_));
}
var $$ = class {
  constructor(t) {
    (this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (e, n, r) => {
        if (typeof e == "function" && typeof n != "function") {
          const o = n;
          n = e;
          const s = this;
          return function (l = o, ...c) {
            return s.produce(l, (u) => n.call(this, u, ...c));
          };
        }
        typeof n != "function" && ko(6),
          r !== void 0 && typeof r != "function" && ko(7);
        let i;
        if (ta(e)) {
          const o = gP(this),
            s = tb(e, void 0);
          let a = !0;
          try {
            (i = n(s)), (a = !1);
          } finally {
            a ? JA(o) : QA(o);
          }
          return mP(o, r), vP(i, o);
        } else if (!e || typeof e != "object") {
          if (
            ((i = n(e)),
            i === void 0 && (i = e),
            i === hF && (i = void 0),
            this.autoFreeze_ && VE(i, !0),
            r)
          ) {
            const o = [],
              s = [];
            Rc("Patches").generateReplacementPatches_(e, i, o, s), r(o, s);
          }
          return i;
        } else ko(1, e);
      }),
      (this.produceWithPatches = (e, n) => {
        if (typeof e == "function")
          return (s, ...a) => this.produceWithPatches(s, (l) => e(l, ...a));
        let r, i;
        return [
          this.produce(e, n, (s, a) => {
            (r = s), (i = a);
          }),
          r,
          i,
        ];
      }),
      typeof (t == null ? void 0 : t.autoFreeze) == "boolean" &&
        this.setAutoFreeze(t.autoFreeze),
      typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" &&
        this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    ta(t) || ko(8), Tc(t) && (t = X$(t));
    const e = gP(this),
      n = tb(t, void 0);
    return (n[Ki].isManual_ = !0), QA(e), n;
  }
  finishDraft(t, e) {
    const n = t && t[Ki];
    (!n || !n.isManual_) && ko(9);
    const { scope_: r } = n;
    return mP(r, e), vP(void 0, r);
  }
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let n;
    for (n = e.length - 1; n >= 0; n--) {
      const i = e[n];
      if (i.path.length === 0 && i.op === "replace") {
        t = i.value;
        break;
      }
    }
    n > -1 && (e = e.slice(n + 1));
    const r = Rc("Patches").applyPatches_;
    return Tc(t) ? r(t, e) : this.produce(t, (i) => r(i, e));
  }
};
function tb(t, e) {
  const n = Hp(t)
    ? Rc("MapSet").proxyMap_(t, e)
    : Iy(t)
    ? Rc("MapSet").proxySet_(t, e)
    : W$(t, e);
  return (e ? e.scope_ : gF()).drafts_.push(n), n;
}
function X$(t) {
  return Tc(t) || ko(10, t), yF(t);
}
function yF(t) {
  if (!ta(t) || Ly(t)) return t;
  const e = t[Ki];
  let n;
  if (e) {
    if (!e.modified_) return e.base_;
    (e.finalized_ = !0), (n = ZA(t, e.scope_.immer_.useStrictShallowCopy_));
  } else n = ZA(t, !0);
  return (
    Sv(n, (r, i) => {
      mF(n, r, yF(i));
    }),
    e && (e.finalized_ = !1),
    n
  );
}
var Y$ = new $$(),
  xF = Y$.produce;
function _F(t) {
  return ({ dispatch: n, getState: r }) =>
    (i) =>
    (o) =>
      typeof o == "function" ? o(n, r, t) : i(o);
}
var q$ = _F(),
  K$ = _F,
  Z$ =
    typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
      : function () {
          if (arguments.length !== 0)
            return typeof arguments[0] == "object"
              ? _v
              : _v.apply(null, arguments);
        };
function xP(t, e) {
  function n(...r) {
    if (e) {
      let i = e(...r);
      if (!i) throw new Error($s(0));
      return {
        type: t,
        payload: i.payload,
        ...("meta" in i && { meta: i.meta }),
        ...("error" in i && { error: i.error }),
      };
    }
    return { type: t, payload: r[0] };
  }
  return (
    (n.toString = () => `${t}`),
    (n.type = t),
    (n.match = (r) => k$(r) && r.type === t),
    n
  );
}
var SF = class Zd extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Zd.prototype);
  }
  static get [Symbol.species]() {
    return Zd;
  }
  concat(...e) {
    return super.concat.apply(this, e);
  }
  prepend(...e) {
    return e.length === 1 && Array.isArray(e[0])
      ? new Zd(...e[0].concat(this))
      : new Zd(...e.concat(this));
  }
};
function _P(t) {
  return ta(t) ? xF(t, () => {}) : t;
}
function Qg(t, e, n) {
  return t.has(e) ? t.get(e) : t.set(e, n(e)).get(e);
}
function J$(t) {
  return typeof t == "boolean";
}
var Q$ = () =>
    function (e) {
      const {
        thunk: n = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: o = !0,
      } = e ?? {};
      let s = new SF();
      return n && (J$(n) ? s.push(q$) : s.push(K$(n.extraArgument))), s;
    },
  eX = "RTK_autoBatch",
  SP = (t) => (e) => {
    setTimeout(e, t);
  },
  tX =
    (t = { type: "raf" }) =>
    (e) =>
    (...n) => {
      const r = e(...n);
      let i = !0,
        o = !1,
        s = !1;
      const a = new Set(),
        l =
          t.type === "tick"
            ? queueMicrotask
            : t.type === "raf"
            ? typeof window < "u" && window.requestAnimationFrame
              ? window.requestAnimationFrame
              : SP(10)
            : t.type === "callback"
            ? t.queueNotification
            : SP(t.timeout),
        c = () => {
          (s = !1), o && ((o = !1), a.forEach((u) => u()));
        };
      return Object.assign({}, r, {
        subscribe(u) {
          const d = () => i && u(),
            p = r.subscribe(d);
          return (
            a.add(u),
            () => {
              p(), a.delete(u);
            }
          );
        },
        dispatch(u) {
          var d;
          try {
            return (
              (i = !((d = u == null ? void 0 : u.meta) != null && d[eX])),
              (o = !i),
              o && (s || ((s = !0), l(c))),
              r.dispatch(u)
            );
          } finally {
            i = !0;
          }
        },
      });
    },
  nX = (t) =>
    function (n) {
      const { autoBatch: r = !0 } = n ?? {};
      let i = new SF(t);
      return r && i.push(tX(typeof r == "object" ? r : void 0)), i;
    };
function rX(t) {
  const e = Q$(),
    {
      reducer: n = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: o = void 0,
      enhancers: s = void 0,
    } = t || {};
  let a;
  if (typeof n == "function") a = n;
  else if (HE(n)) a = F$(n);
  else throw new Error($s(1));
  let l;
  typeof r == "function" ? (l = r(e)) : (l = e());
  let c = _v;
  i && (c = Z$({ trace: !1, ...(typeof i == "object" && i) }));
  const u = U$(...l),
    d = nX(u);
  let p = typeof s == "function" ? s(d) : d();
  const m = c(...p);
  return dF(a, o, m);
}
function AF(t) {
  const e = {},
    n = [];
  let r;
  const i = {
    addCase(o, s) {
      const a = typeof o == "string" ? o : o.type;
      if (!a) throw new Error($s(28));
      if (a in e) throw new Error($s(29));
      return (e[a] = s), i;
    },
    addAsyncThunk(o, s) {
      return (
        s.pending && (e[o.pending.type] = s.pending),
        s.rejected && (e[o.rejected.type] = s.rejected),
        s.fulfilled && (e[o.fulfilled.type] = s.fulfilled),
        s.settled && n.push({ matcher: o.settled, reducer: s.settled }),
        i
      );
    },
    addMatcher(o, s) {
      return n.push({ matcher: o, reducer: s }), i;
    },
    addDefaultCase(o) {
      return (r = o), i;
    },
  };
  return t(i), [e, n, r];
}
function iX(t) {
  return typeof t == "function";
}
function oX(t, e) {
  let [n, r, i] = AF(e),
    o;
  if (iX(t)) o = () => _P(t());
  else {
    const a = _P(t);
    o = () => a;
  }
  function s(a = o(), l) {
    let c = [
      n[l.type],
      ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u),
    ];
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, d) => {
        if (d)
          if (Tc(u)) {
            const m = d(u, l);
            return m === void 0 ? u : m;
          } else {
            if (ta(u)) return xF(u, (p) => d(p, l));
            {
              const p = d(u, l);
              if (p === void 0) {
                if (u === null) return u;
                throw Error(
                  "A case reducer on a non-draftable value must not return undefined"
                );
              }
              return p;
            }
          }
        return u;
      }, a)
    );
  }
  return (s.getInitialState = o), s;
}
var sX = Symbol.for("rtk-slice-createasyncthunk");
function aX(t, e) {
  return `${t}/${e}`;
}
function lX({ creators: t } = {}) {
  var n;
  const e = (n = t == null ? void 0 : t.asyncThunk) == null ? void 0 : n[sX];
  return function (i) {
    const { name: o, reducerPath: s = o } = i;
    if (!o) throw new Error($s(11));
    const a =
        (typeof i.reducers == "function" ? i.reducers(fX()) : i.reducers) || {},
      l = Object.keys(a),
      c = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: [],
      },
      u = {
        addCase(b, C) {
          const M = typeof b == "string" ? b : b.type;
          if (!M) throw new Error($s(12));
          if (M in c.sliceCaseReducersByType) throw new Error($s(13));
          return (c.sliceCaseReducersByType[M] = C), u;
        },
        addMatcher(b, C) {
          return c.sliceMatchers.push({ matcher: b, reducer: C }), u;
        },
        exposeAction(b, C) {
          return (c.actionCreators[b] = C), u;
        },
        exposeCaseReducer(b, C) {
          return (c.sliceCaseReducersByName[b] = C), u;
        },
      };
    l.forEach((b) => {
      const C = a[b],
        M = {
          reducerName: b,
          type: aX(o, b),
          createNotation: typeof i.reducers == "function",
        };
      hX(C) ? mX(M, C, u, e) : dX(M, C, u);
    });
    function d() {
      const [b = {}, C = [], M = void 0] =
          typeof i.extraReducers == "function"
            ? AF(i.extraReducers)
            : [i.extraReducers],
        T = { ...b, ...c.sliceCaseReducersByType };
      return oX(i.initialState, (P) => {
        for (let R in T) P.addCase(R, T[R]);
        for (let R of c.sliceMatchers) P.addMatcher(R.matcher, R.reducer);
        for (let R of C) P.addMatcher(R.matcher, R.reducer);
        M && P.addDefaultCase(M);
      });
    }
    const p = (b) => b,
      m = new Map(),
      v = new WeakMap();
    let _;
    function y(b, C) {
      return _ || (_ = d()), _(b, C);
    }
    function g() {
      return _ || (_ = d()), _.getInitialState();
    }
    function x(b, C = !1) {
      function M(P) {
        let R = P[b];
        return typeof R > "u" && C && (R = Qg(v, M, g)), R;
      }
      function T(P = p) {
        const R = Qg(m, C, () => new WeakMap());
        return Qg(R, P, () => {
          const E = {};
          for (const [O, D] of Object.entries(i.selectors ?? {}))
            E[O] = cX(D, P, () => Qg(v, P, g), C);
          return E;
        });
      }
      return {
        reducerPath: b,
        getSelectors: T,
        get selectors() {
          return T(M);
        },
        selectSlice: M,
      };
    }
    const S = {
      name: o,
      reducer: y,
      actions: c.actionCreators,
      caseReducers: c.sliceCaseReducersByName,
      getInitialState: g,
      ...x(s),
      injectInto(b, { reducerPath: C, ...M } = {}) {
        const T = C ?? s;
        return (
          b.inject({ reducerPath: T, reducer: y }, M), { ...S, ...x(T, !0) }
        );
      },
    };
    return S;
  };
}
function cX(t, e, n, r) {
  function i(o, ...s) {
    let a = e(o);
    return typeof a > "u" && r && (a = n()), t(a, ...s);
  }
  return (i.unwrapped = t), i;
}
var uX = lX();
function fX() {
  function t(e, n) {
    return { _reducerDefinitionType: "asyncThunk", payloadCreator: e, ...n };
  }
  return (
    (t.withTypes = () => t),
    {
      reducer(e) {
        return Object.assign(
          {
            [e.name](...n) {
              return e(...n);
            },
          }[e.name],
          { _reducerDefinitionType: "reducer" }
        );
      },
      preparedReducer(e, n) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare: e,
          reducer: n,
        };
      },
      asyncThunk: t,
    }
  );
}
function dX({ type: t, reducerName: e, createNotation: n }, r, i) {
  let o, s;
  if ("reducer" in r) {
    if (n && !pX(r)) throw new Error($s(17));
    (o = r.reducer), (s = r.prepare);
  } else o = r;
  i.addCase(t, o)
    .exposeCaseReducer(e, o)
    .exposeAction(e, s ? xP(t, s) : xP(t));
}
function hX(t) {
  return t._reducerDefinitionType === "asyncThunk";
}
function pX(t) {
  return t._reducerDefinitionType === "reducerWithPrepare";
}
function mX({ type: t, reducerName: e }, n, r, i) {
  if (!i) throw new Error($s(18));
  const {
      payloadCreator: o,
      fulfilled: s,
      pending: a,
      rejected: l,
      settled: c,
      options: u,
    } = n,
    d = i(t, o, u);
  r.exposeAction(e, d),
    s && r.addCase(d.fulfilled, s),
    a && r.addCase(d.pending, a),
    l && r.addCase(d.rejected, l),
    c && r.addMatcher(d.settled, c),
    r.exposeCaseReducer(e, {
      fulfilled: s || e0,
      pending: a || e0,
      rejected: l || e0,
      settled: c || e0,
    });
}
function e0() {}
function $s(t) {
  return `Minified Redux Toolkit error #${t}; visit https://redux-toolkit.js.org/Errors?code=${t} for the full message or use the non-minified dev environment for full errors. `;
}
const gX = {
    checkedValue: "1",
    openTaskManger: !1,
    DumbFile: !1,
    showDumb: "",
    step: ["1"],
    isFileTransfered: !1,
    stepType: "step-1",
    dumbFileDetails: {
      fileName: "",
      profileName: "",
      systemOffset: "",
      samOffset: "",
      hashFile: "",
    },
    volitilitySteps: ["1"],
    analyseStep: "",
    isCracked: !1,
    openComputer: !1,
    openFolder: !1,
    openImage: !1,
    carckedData: "",
    instructionIncludes: [0, 1],
    activeAccordien: ["1"],
    instructions: [],
    steps: [
      [
        "Click the “MemoryDump tool” button to generate a memorydump file.Copy the filename for Step 3.",
      ],
    ],
  },
  bF = uX({
    name: "expOne",
    initialState: gX,
    reducers: {
      updateCheckedValue: (t, e) => ({
        ...t,
        checkedValue: e.payload,
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        isCracked: !1,
      }),
      updateTaskManager: (t, e) => ({ ...t, openTaskManger: e.payload }),
      createDumbFile: (t, e) => ({ ...t, DumbFile: e.payload }),
      showDumbFile: (t, e) => ({ ...t, showDumb: e.payload }),
      updateStep: (t, e) => ({ ...t, step: [...t.step, e.payload] }),
      updateIsTransfer: (t, e) => ({ ...t, isFileTransfered: e.payload }),
      updateStepType: (t, e) => ({ ...t, stepType: e.payload }),
      updateDumbFileDetails: (t, e) => ({ ...t, dumbFileDetails: e.payload }),
      updateVolitilitySteps: (t, e) => ({
        ...t,
        volitilitySteps: [...t.volitilitySteps, e.payload],
      }),
      updateAnalyseStep: (t, e) => ({ ...t, analyseStep: e.payload }),
      updateCrackedHashes: (t, e) => ({ ...t, isCracked: e.payload }),
      updateOpenComputer: (t, e) => ({ ...t, openComputer: e.payload }),
      updateOpenFolder: (t, e) => ({ ...t, openFolder: e.payload }),
      updateOpenImage: (t, e) => ({ ...t, openImage: e.payload }),
      updateCreackedData: (t, e) => ({ ...t, carckedData: e.payload }),
      updateInstructionIncludes: (t, e) => {
        t.instructionIncludes = [...t.instructionIncludes, e.payload];
      },
      updateInstructions: (t, e) => {
        t.instructions.push(...e.payload);
      },
      updateSteps: (t, e) => {
        t.steps.push(e.payload);
      },
      updateActiveKey: (t, e) => {
        t.activeAccordien = e.payload;
      },
      onResetAnalyse: (t, e) => ({
        ...t,
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        volitilitySteps: ["1"],
        analyseStep: "",
        openComputer: !1,
        openFolder: !1,
        openImage: !1,
        steps: [t.steps[0], t.steps[1]],
        activeAccordien: ["3"],
      }),
      onClear: (t, e) => ({
        ...t,
        checkedValue: "1",
        openTaskManger: !1,
        DumbFile: !1,
        showDumb: "",
        step: ["1"],
        isFileTransfered: !1,
        stepType: "step-1",
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        volitilitySteps: ["1"],
        analyseStep: "",
        instructionIncludes: [0, 1],
        steps: [
          [
            "Click the “MemoryDump tool” button to generate a memorydump file.Copy the filename for Step 3.",
          ],
        ],
        activeAccordien: ["1"],
      }),
    },
  }),
  {
    updateAnalyseStep: gc,
    updateCheckedValue: vX,
    updateActiveKey: Vp,
    updateTaskManager: yX,
    createDumbFile: wF,
    showDumbFile: xX,
    updateStep: nb,
    updateIsTransfer: EF,
    updateStepType: t0,
    updateDumbFileDetails: MF,
    updateVolitilitySteps: n0,
    updateCrackedHashes: dre,
    onResetAnalyse: CF,
    updateOpenComputer: _X,
    updateOpenFolder: SX,
    onClear: AX,
    updateOpenImage: rb,
    updateInstructionIncludes: wv,
    updateCreackedData: bX,
    updateSteps: Oa,
    updateInstructions: hre,
  } = bF.actions,
  wX = bF.reducer,
  EX = "images/dmb-Ap2zo5EP.jpg",
  MX = "images/rar-BSi_Kgt5.png",
  CX = () => {
    const { isFileTransfered: t, checkedValue: e } = Mi((s) => s.exp),
      r = oc(Kd, e === "1" ? EX : MX),
      i = L.useRef(null),
      o = $o();
    return (
      FE(() => {
        let s;
        return (
          t &&
            (i.current.position && (i.current.position.x += 0.02),
            (s = setTimeout(() => {
              i.current.position !== null &&
                ((i.current.position.x = 4), o(nb("3")), o(EF(!1)));
            }, 4e3))),
          () => {
            clearTimeout(s);
          }
        );
      }),
      Q.jsxs(Wn, {
        ref: i,
        args: [0.4, 0.5, 0],
        position: [-0.7, 0, 0.5],
        scale: 0.5,
        children: [
          Q.jsx("meshBasicMaterial", { map: r }),
          Q.jsx(Dn, {
            scale: 0.1,
            fontWeight: 600,
            position: [0, -0.35, 0],
            children: "memory.dump",
          }),
        ],
      })
    );
  },
  TX = Q.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      Q.jsx("br", {}),
      "Profile(s) : ",
      Q.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      ", Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418,",
      Q.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      Q.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      Q.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      Q.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      Q.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      Q.jsx("br", {}),
      "Number of Processors :2",
      Q.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      Q.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      Q.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      Q.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      Q.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      Q.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  RX = Q.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      Q.jsx("br", {}),
      "Profile(s) : ",
      Q.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      ", Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418",
      Q.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      Q.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      Q.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      Q.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      Q.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      Q.jsx("br", {}),
      "Number of Processors :2",
      Q.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      Q.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      Q.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      Q.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      Q.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      Q.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  PX = Q.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      Q.jsx("br", {}),
      "Profile(s) : ",
      Q.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      "Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418,",
      Q.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      Q.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      Q.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      Q.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      Q.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      Q.jsx("br", {}),
      "Number of Processors :2",
      Q.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      Q.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      Q.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      Q.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      Q.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      Q.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  IX = [TX, RX, PX],
  LX = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  OX = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  NX = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  DX = [LX, OX, NX],
  FX = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  UX = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  kX = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  zX = [FX, UX, kX],
  BX = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x00000000049ce8e0      2      1 R--rwd \\$Extend\\$ObjId
0x00000000049cedd0      1      1 R--r-d \\Windows\\System32\\en-US\\vsstrace.dll.mui
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  HX = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  VX = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  GX = [BX, HX, VX],
  WX = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  jX = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  $X = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  XX = [WX, jX, $X],
  YX = "nature.jpg.dat",
  qX = "nature.jpg.dat",
  KX = "nature.jpg.dat",
  ZX = [YX, qX, KX],
  JX = [
    { id: 1, title: "Retrieving account credentials", value: "1" },
    { id: 2, title: "Dumping cached files", value: "2" },
  ],
  QX = [
    { id: 1, title: "var", position: [-0.1, 0.3, 0.3] },
    { id: 2, title: "opt", position: [0.2, 0.3, 0.3] },
    { id: 1, title: "home", position: [0.5, 0.3, 0.3] },
  ],
  eY = () => ({ step1: !1, step2: !1, step3: !1, step4: !1 }),
  Jd = ({ position: t, title: e, scale: n, isNeed: r, isForensic: i }) => {
    const o = oc(Kd, R$),
      s = oc(Kd, P$),
      a = oc(Kd, I$),
      l = oc(Kd, L$),
      {
        openTaskManger: c,
        DumbFile: u,
        showDumb: d,
        step: p,
        stepType: m,
        steps: v,
        activeAccordien: _,
        dumbFileDetails: y,
        analyseStep: g,
        isCracked: x,
        checkedValue: S,
        openComputer: b,
        openFolder: C,
        openImage: M,
      } = Mi((G) => G.exp),
      {
        fileName: T,
        profileName: P,
        systemOffset: R,
        samOffset: E,
        hashFile: O,
      } = y,
      D = Math.floor(Math.random() * 3) + 0,
      N = $o(),
      [z, V] = L.useState(eY());
    return (
      L.useEffect(() => {
        let G;
        return (
          u &&
            (G = setTimeout(() => {
              N(yX(!1)), N(wF(!1)), N(xX(!0)), N(nb("2"));
            }, 3e3)),
          () => {
            clearTimeout(G);
          }
        );
      }, [c, u]),
      console.log(g),
      L.useEffect(() => {
        let G;
        return (
          g === "1"
            ? (G = setTimeout(() => {
                V((Y) => ({ ...Y, step1: !0 })),
                  N(n0("2")),
                  S === "1" &&
                    N(
                      Oa([
                        "hivelist is a Volatility plugin which can be used to list the addresses of the registry hives from the memory dump. Enter the Profile name to run this plugin. Copy the Virtual Offsets of SAM and SYSTEM required for the next step",
                      ])
                    ),
                  S === "2" &&
                    N(
                      Oa([
                        "Volatility’s filescan plugin scans for files in the memory which were open at the time the memory dump was taken. Locate the JPG image extension file from the listing and copy it’s corresponding virtual address.",
                      ])
                    );
              }, 3e3))
            : g === "2"
            ? (G = setTimeout(() => {
                V((Y) => ({ ...Y, step1: !1, step2: !0 })),
                  N(n0("3")),
                  S === "1" &&
                    N(
                      Oa([
                        "Paste the SAM and SYSTEM hive offsets in the box.",
                        "The SAM and SYSTEM hive offsets are used as input in this step to run hashdump plugin which will print the password hashes. Copy the resulting hashes for the final step.",
                      ])
                    ),
                  S === "2" &&
                    N(
                      Oa([
                        "Enter the virtual address of the JPG image file. The dumpfiles plugin extracts files that were open or recently accessed on the system at the time the memory dump was taken. ",
                      ])
                    );
              }, 3e3))
            : g === "3"
            ? (G = setTimeout(() => {
                V((Y) => ({ ...Y, step1: !1, step2: !1, step3: !0 })),
                  N(n0("4")),
                  N(gc("4")),
                  S === "1" && N(Oa(["Paste the hash to crack the password."])),
                  S === "2" &&
                    N(
                      Oa([
                        "Press the “Open Image” button to view the image file extracted from the memorydump.",
                      ])
                    ),
                  N(Vp(["4"]));
              }, 3e3))
            : g === "4" &&
              (G = setTimeout(() => {
                V((Y) => ({
                  ...Y,
                  step1: !1,
                  step2: !1,
                  step3: !1,
                  step4: !0,
                })),
                  N(n0("5")),
                  N(nb("4"));
              }, 3e3)),
          V((Y) => ({ ...Y, step1: !1, step2: !1, step3: !1, step4: !1 })),
          () => {
            clearTimeout(G);
          }
        );
      }, [g]),
      console.log(_, p, g, "hi"),
      Q.jsxs("group", {
        position: t,
        scale: n,
        children: [
          Q.jsx(Dn, { scale: 0.1, position: [0, 1.5, 0], children: e }),
          Q.jsx(Wn, {
            name: "display",
            args: [3, 2, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: r ? s : l }),
          }),
          Q.jsxs(Wn, {
            name: "display",
            position: [0, 0, -0.1],
            args: [3, 2, 0.2],
            children: [
              Q.jsx("meshBasicMaterial", { map: o }),
              d && r && Q.jsx(CX, {}),
            ],
          }),
          Q.jsx(Wn, {
            name: "sideTop",
            position: [0, 1.05, 0],
            args: [3, 0.1, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: o }),
          }),
          Q.jsx(Wn, {
            name: "sideBotton",
            position: [0, -1.05, 0],
            args: [3, 0.1, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: o }),
          }),
          Q.jsx(Wn, {
            name: "sideRight",
            position: [1.55, 0, 0],
            args: [0.1, 2.2, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: o }),
          }),
          Q.jsx(Wn, {
            name: "sideLeft",
            position: [-1.55, 0, 0],
            args: [0.1, 2.2, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: o }),
          }),
          Q.jsx(Wn, {
            name: "stand",
            position: [0, -1.3, 0],
            args: [0.2, 0.5, 0.2],
            children: Q.jsx("meshBasicMaterial", { map: o }),
          }),
          Q.jsx(Wn, {
            name: "keyboard",
            position: [0, -1.5, 0],
            args: [2, 0.2, 0.2],
            children: Q.jsx("meshBasicMaterial", { color: "black" }),
          }),
          c &&
            Q.jsxs(Wn, {
              args: [2.2, 1.2, 0],
              position: [0, 0, 0.11],
              children: [
                Q.jsxs(Wn, {
                  args: [2.2, 0.1, 0],
                  position: [0, 0.55, 0.001],
                  children: [
                    Q.jsx("meshBasicMaterial", { color: "#341128" }),
                    Q.jsx(Dn, {
                      scale: 0.05,
                      color: "white",
                      position: [0, 0, 0.01],
                      children: "Memory Dump tool",
                    }),
                  ],
                }),
                Q.jsxs(Wn, {
                  args: [1, 0.2, 0],
                  position: [0, 0, 0.001],
                  children: [
                    Q.jsx("meshBasicMaterial", { color: u ? "grey" : "blue" }),
                    Q.jsx(Dn, {
                      fontWeight: 800,
                      scale: 0.05,
                      color: "white",
                      position: [0, 0, 0.02],
                      children: "Create memory dump File",
                    }),
                  ],
                }),
              ],
            }),
          u &&
            Q.jsx("group", {
              args: [2.2, 1.2, 0],
              position: [0, 0.2, 0.15],
              children: Q.jsx(Dn, {
                scale: 0.08,
                color: "black",
                children: "Loading...",
              }),
            }),
          ((p.includes("3") && _.includes("3")) || x) &&
            Q.jsx("group", {
              children: Q.jsxs(Wn, {
                name: "command",
                position: [0, 0, 0.07],
                args: [2.7, 1.7, 0.1],
                children: [
                  Q.jsx("meshBasicMaterial", { color: "#341128" }),
                  Q.jsxs(Wn, {
                    name: "topbar",
                    position: [0, 0.76, 0.08],
                    args: [2.65, 0.15, 0],
                    children: [
                      Q.jsx(Dn, { scale: 0.05, children: "Command prompt" }),
                      Q.jsx("meshBasicMaterial", { color: "#4d4c49" }),
                    ],
                  }),
                  Q.jsx(Dn, {
                    position: [-1, 0.6, 0.09],
                    color: "#85c12e",
                    fontWeight: 800,
                    fontSize: 0.05,
                    children: "root@linux-desktop:~$",
                  }),
                  g === "1" &&
                    Q.jsxs("group", {
                      children: [
                        Q.jsx(Dn, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children:
                            S === "2"
                              ? `volatility  -f ${T} imageinfo`
                              : `volatility  -f ${T} imageinfo`,
                        }),
                        z.step1
                          ? Q.jsx(Dn, {
                              position: [-1.2, 0.65, 0.09],
                              color: "white",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: Q.jsx(zd, {
                                children: Q.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 10.5,
                                    display: "flex",
                                    flexWrap: "wrap",
                                    alignItems: "center",
                                  },
                                  children: IX[D],
                                }),
                              }),
                            })
                          : Q.jsx(Dn, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  g === "2" &&
                    Q.jsxs("group", {
                      children: [
                        Q.jsx(Dn, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children:
                            S === "2"
                              ? `Volatility -f  ${T} --profile= ${P}`
                              : `Volatility -f ${T} hivelist --profile= ${P}`,
                        }),
                        z.step2
                          ? Q.jsx(Dn, {
                              position: [-1.1, 0.6, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.03,
                              anchorX: -2,
                              anchorY: -0.05,
                              children: Q.jsx(zd, {
                                position: [-0.1, 0, 0],
                                children: Q.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 10.5,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children: S === "2" ? GX[D] : DX[D],
                                }),
                              }),
                            })
                          : Q.jsx(Dn, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  g === "3" &&
                    !M &&
                    Q.jsxs("group", {
                      children: [
                        Q.jsx(Dn, {
                          position: [-0.7, 0.66, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.2,
                          anchorY: -0.03,
                          children: Q.jsx(zd, {
                            children: Q.jsx("pre", {
                              style: {
                                width: 600,
                                color: "green",
                                fontSize: 10.5,
                              },
                              children:
                                S === "2"
                                  ? `volatility -f  ${T} --profile= ${P} 
 dumpfiles -Q ${R} `
                                  : ` volatility -f ${T} hivelist --profile= ${P} hashdumb 
 -y ${R}  -s ${E} `,
                            }),
                          }),
                        }),
                        z.step3
                          ? Q.jsx(Dn, {
                              position: [-1.2, 0.3, 0.09],
                              color: "white",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.06,
                              children: Q.jsx(zd, {
                                children: Q.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 11,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children:
                                    S === "2"
                                      ? XX[D]
                                      : "Hashed password retrived successfully",
                                }),
                              }),
                            })
                          : Q.jsx(Dn, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  g === "4" &&
                    S === "2" &&
                    Q.jsxs("group", {
                      children: [
                        Q.jsxs(Dn, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children: [S === "2" ? "ls" : "cat", " ", O],
                        }),
                        z.step4
                          ? Q.jsx(Dn, {
                              position: [-1.25, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.05,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: Q.jsx(zd, {
                                children: Q.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 12,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children: S === "2" ? ZX[D] : zX[D],
                                }),
                              }),
                            })
                          : Q.jsx(Dn, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                ],
              }),
            }),
          M &&
            Q.jsx(Wn, {
              position: [0.1, 0, 1],
              args: [1.2, 0.5, 0.1],
              children: Q.jsx("meshBasicMaterial", { map: a }),
            }),
          b &&
            Q.jsx(Wn, {
              args: [2.2, 1.5, 0.5],
              children: Q.jsxs(Wn, {
                position: [-0.55, 0, 0],
                args: [1.1, 1.5, 0.5],
                children: [
                  Q.jsx("meshBasicMaterial", { color: "white" }),
                  Q.jsx(Wn, {
                    position: [0.555, 0.6679, 0.3],
                    args: [2.11, 0.1, 0],
                    children: Q.jsx("meshBasicMaterial", { color: "#624456" }),
                  }),
                  C &&
                    Q.jsxs(Wn, {
                      position: [0.6, -0.01, 0.4],
                      args: [1.5, 1.1, 0],
                      children: [
                        Q.jsx("meshBasicMaterial", { color: "white" }),
                        Q.jsxs(Wn, {
                          position: [-0.8, 0.4, 0],
                          args: [0.2, 0.2, 0],
                          children: [
                            Q.jsx("meshBasicMaterial", { map: a }),
                            Q.jsx(Dn, {
                              position: [0, -0.13, -1],
                              color: "black",
                              fontWeight: 500,
                              fontSize: 0.03,
                              children: "nature.jpg.dat",
                            }),
                          ],
                        }),
                      ],
                    }),
                  QX.map((G) =>
                    Q.jsxs(
                      Wn,
                      {
                        position: G.position,
                        args: [0.2, 0.2, 0],
                        children: [
                          Q.jsx("meshBasicMaterial", { color: "skyblue" }),
                          Q.jsx(Dn, {
                            color: "black",
                            fontWeight: 500,
                            fontSize: 0.03,
                            children: G.title,
                          }),
                        ],
                      },
                      G.id
                    )
                  ),
                  Q.jsxs(Dn, {
                    position: [0.25, 0.5, 0.5],
                    color: "white",
                    fontWeight: 500,
                    fontSize: 0.03,
                    anchorX: 0.5,
                    anchorY: -0.07,
                    children: [" ", "My Computer ", C && "/ opt"],
                  }),
                ],
              }),
            }),
        ],
      })
    );
  };
Jd.propTypes = {
  title: La.string.isRequired,
  scale: La.number,
  position: La.arrayOf(La.number),
  isNeed: La.bool,
  isForensic: La.bool,
};
const tY = () => {
  const { stepType: t, checkedValue: e, activeAccordien: n } = Mi((r) => r.exp);
  return Q.jsx("div", {
    className: "playground-container",
    children: Q.jsxs(q9, {
      camera: { position: [0, 0, 1], fov: 110 },
      children: [
        Q.jsx("pointLight", {}),
        Q.jsx(l$, { enableRotate: !1 }),
        Q.jsx("color", { attach: "background", args: ["#00122e"] }),
        n.includes("1") &&
          (e === "1" || e === "2") &&
          Q.jsx(Jd, {
            title: "Crime Scene Computer",
            scale: 0.5,
            position: [-0.1, 0, 0],
            isNeed: !0,
          }),
        n.includes("2") &&
          Q.jsxs("group", {
            children: [
              Q.jsx(Jd, {
                title: "Crime Scene Computer",
                scale: 0.3,
                position: [-0.8, 0, 0],
                isNeed: !0,
              }),
              Q.jsx(Jd, {
                title: "Forensic Computer",
                scale: 0.3,
                position: [0.8, 0, 0],
                isForensic: !0,
              }),
            ],
          }),
        (n.includes("3") || n.includes("4")) &&
          Q.jsx("group", {
            children: Q.jsx(Jd, {
              title: "Forensic Computer",
              scale: n.includes("4") ? 0.5 : 0.6,
              position: [-0.1, 0, 0],
            }),
          }),
      ],
    }),
  });
};
var TF = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (t) {
  (function () {
    var e = {}.hasOwnProperty;
    function n() {
      for (var o = "", s = 0; s < arguments.length; s++) {
        var a = arguments[s];
        a && (o = i(o, r(a)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number") return o;
      if (typeof o != "object") return "";
      if (Array.isArray(o)) return n.apply(null, o);
      if (
        o.toString !== Object.prototype.toString &&
        !o.toString.toString().includes("[native code]")
      )
        return o.toString();
      var s = "";
      for (var a in o) e.call(o, a) && o[a] && (s = i(s, a));
      return s;
    }
    function i(o, s) {
      return s ? (o ? o + " " + s : o + s) : o;
    }
    t.exports ? ((n.default = n), (t.exports = n)) : (window.classNames = n);
  })();
})(TF);
var nY = TF.exports;
const ft = Ap(nY);
function bt(t) {
  "@babel/helpers - typeof";
  return (
    (bt =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    bt(t)
  );
}
var rY = Symbol.for("react.element"),
  iY = Symbol.for("react.transitional.element"),
  oY = Symbol.for("react.fragment");
function RF(t) {
  return (
    t &&
    bt(t) === "object" &&
    (t.$$typeof === rY || t.$$typeof === iY) &&
    t.type === oY
  );
}
function bf(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = [];
  return (
    We.Children.forEach(t, function (r) {
      (r == null && !e.keepEmpty) ||
        (Array.isArray(r)
          ? (n = n.concat(bf(r)))
          : RF(r) && r.props
          ? (n = n.concat(bf(r.props.children, e)))
          : n.push(r));
    }),
    n
  );
}
var ib = {},
  sY = function (e) {};
function aY(t, e) {}
function lY(t, e) {}
function cY() {
  ib = {};
}
function PF(t, e, n) {
  !e && !ib[n] && (t(!1, n), (ib[n] = !0));
}
function Ei(t, e) {
  PF(aY, t, e);
}
function uY(t, e) {
  PF(lY, t, e);
}
Ei.preMessage = sY;
Ei.resetWarned = cY;
Ei.noteOnce = uY;
function fY(t, e) {
  if (bt(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e);
    if (bt(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function IF(t) {
  var e = fY(t, "string");
  return bt(e) == "symbol" ? e : e + "";
}
function ve(t, e, n) {
  return (
    (e = IF(e)) in t
      ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (t[e] = n),
    t
  );
}
function AP(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(t, i).enumerable;
      })),
      n.push.apply(n, r);
  }
  return n;
}
function Fe(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? AP(Object(n), !0).forEach(function (r) {
          ve(t, r, n[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n))
      : AP(Object(n)).forEach(function (r) {
          Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
        });
  }
  return t;
}
function bP(t) {
  return t instanceof HTMLElement || t instanceof SVGElement;
}
function dY(t) {
  return t && bt(t) === "object" && bP(t.nativeElement)
    ? t.nativeElement
    : bP(t)
    ? t
    : null;
}
function N0(t) {
  var e = dY(t);
  if (e) return e;
  if (t instanceof We.Component) {
    var n;
    return (n = JS.findDOMNode) === null || n === void 0
      ? void 0
      : n.call(JS, t);
  }
  return null;
}
var LF = { exports: {} },
  an = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var WE = Symbol.for("react.element"),
  jE = Symbol.for("react.portal"),
  Oy = Symbol.for("react.fragment"),
  Ny = Symbol.for("react.strict_mode"),
  Dy = Symbol.for("react.profiler"),
  Fy = Symbol.for("react.provider"),
  Uy = Symbol.for("react.context"),
  hY = Symbol.for("react.server_context"),
  ky = Symbol.for("react.forward_ref"),
  zy = Symbol.for("react.suspense"),
  By = Symbol.for("react.suspense_list"),
  Hy = Symbol.for("react.memo"),
  Vy = Symbol.for("react.lazy"),
  pY = Symbol.for("react.offscreen"),
  OF;
OF = Symbol.for("react.module.reference");
function wo(t) {
  if (typeof t == "object" && t !== null) {
    var e = t.$$typeof;
    switch (e) {
      case WE:
        switch (((t = t.type), t)) {
          case Oy:
          case Dy:
          case Ny:
          case zy:
          case By:
            return t;
          default:
            switch (((t = t && t.$$typeof), t)) {
              case hY:
              case Uy:
              case ky:
              case Vy:
              case Hy:
              case Fy:
                return t;
              default:
                return e;
            }
        }
      case jE:
        return e;
    }
  }
}
an.ContextConsumer = Uy;
an.ContextProvider = Fy;
an.Element = WE;
an.ForwardRef = ky;
an.Fragment = Oy;
an.Lazy = Vy;
an.Memo = Hy;
an.Portal = jE;
an.Profiler = Dy;
an.StrictMode = Ny;
an.Suspense = zy;
an.SuspenseList = By;
an.isAsyncMode = function () {
  return !1;
};
an.isConcurrentMode = function () {
  return !1;
};
an.isContextConsumer = function (t) {
  return wo(t) === Uy;
};
an.isContextProvider = function (t) {
  return wo(t) === Fy;
};
an.isElement = function (t) {
  return typeof t == "object" && t !== null && t.$$typeof === WE;
};
an.isForwardRef = function (t) {
  return wo(t) === ky;
};
an.isFragment = function (t) {
  return wo(t) === Oy;
};
an.isLazy = function (t) {
  return wo(t) === Vy;
};
an.isMemo = function (t) {
  return wo(t) === Hy;
};
an.isPortal = function (t) {
  return wo(t) === jE;
};
an.isProfiler = function (t) {
  return wo(t) === Dy;
};
an.isStrictMode = function (t) {
  return wo(t) === Ny;
};
an.isSuspense = function (t) {
  return wo(t) === zy;
};
an.isSuspenseList = function (t) {
  return wo(t) === By;
};
an.isValidElementType = function (t) {
  return (
    typeof t == "string" ||
    typeof t == "function" ||
    t === Oy ||
    t === Dy ||
    t === Ny ||
    t === zy ||
    t === By ||
    t === pY ||
    (typeof t == "object" &&
      t !== null &&
      (t.$$typeof === Vy ||
        t.$$typeof === Hy ||
        t.$$typeof === Fy ||
        t.$$typeof === Uy ||
        t.$$typeof === ky ||
        t.$$typeof === OF ||
        t.getModuleId !== void 0))
  );
};
an.typeOf = wo;
LF.exports = an;
var O_ = LF.exports;
function $E(t, e, n) {
  var r = L.useRef({});
  return (
    (!("value" in r.current) || n(r.current.condition, e)) &&
      ((r.current.value = t()), (r.current.condition = e)),
    r.current.value
  );
}
var mY = Number(L.version.split(".")[0]),
  NF = function (e, n) {
    typeof e == "function"
      ? e(n)
      : bt(e) === "object" && e && "current" in e && (e.current = n);
  },
  kc = function () {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    var i = n.filter(Boolean);
    return i.length <= 1
      ? i[0]
      : function (o) {
          n.forEach(function (s) {
            NF(s, o);
          });
        };
  },
  DF = function () {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return $E(
      function () {
        return kc.apply(void 0, n);
      },
      n,
      function (i, o) {
        return (
          i.length !== o.length ||
          i.every(function (s, a) {
            return s !== o[a];
          })
        );
      }
    );
  },
  XE = function (e) {
    var n, r;
    if (!e) return !1;
    if (FF(e) && mY >= 19) return !0;
    var i = O_.isMemo(e) ? e.type.type : e.type;
    return !(
      (typeof i == "function" &&
        !((n = i.prototype) !== null && n !== void 0 && n.render) &&
        i.$$typeof !== O_.ForwardRef) ||
      (typeof e == "function" &&
        !((r = e.prototype) !== null && r !== void 0 && r.render) &&
        e.$$typeof !== O_.ForwardRef)
    );
  };
function FF(t) {
  return L.isValidElement(t) && !RF(t);
}
var YE = function (e) {
    if (e && FF(e)) {
      var n = e;
      return n.props.propertyIsEnumerable("ref") ? n.props.ref : n.ref;
    }
    return null;
  },
  ob = L.createContext(null);
function gY(t) {
  var e = t.children,
    n = t.onBatchResize,
    r = L.useRef(0),
    i = L.useRef([]),
    o = L.useContext(ob),
    s = L.useCallback(
      function (a, l, c) {
        r.current += 1;
        var u = r.current;
        i.current.push({ size: a, element: l, data: c }),
          Promise.resolve().then(function () {
            u === r.current && (n == null || n(i.current), (i.current = []));
          }),
          o == null || o(a, l, c);
      },
      [n, o]
    );
  return L.createElement(ob.Provider, { value: s }, e);
}
var UF = (function () {
    if (typeof Map < "u") return Map;
    function t(e, n) {
      var r = -1;
      return (
        e.some(function (i, o) {
          return i[0] === n ? ((r = o), !0) : !1;
        }),
        r
      );
    }
    return (function () {
      function e() {
        this.__entries__ = [];
      }
      return (
        Object.defineProperty(e.prototype, "size", {
          get: function () {
            return this.__entries__.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.get = function (n) {
          var r = t(this.__entries__, n),
            i = this.__entries__[r];
          return i && i[1];
        }),
        (e.prototype.set = function (n, r) {
          var i = t(this.__entries__, n);
          ~i ? (this.__entries__[i][1] = r) : this.__entries__.push([n, r]);
        }),
        (e.prototype.delete = function (n) {
          var r = this.__entries__,
            i = t(r, n);
          ~i && r.splice(i, 1);
        }),
        (e.prototype.has = function (n) {
          return !!~t(this.__entries__, n);
        }),
        (e.prototype.clear = function () {
          this.__entries__.splice(0);
        }),
        (e.prototype.forEach = function (n, r) {
          r === void 0 && (r = null);
          for (var i = 0, o = this.__entries__; i < o.length; i++) {
            var s = o[i];
            n.call(r, s[1], s[0]);
          }
        }),
        e
      );
    })();
  })(),
  sb =
    typeof window < "u" &&
    typeof document < "u" &&
    window.document === document,
  Ev = (function () {
    return typeof global < "u" && global.Math === Math
      ? global
      : typeof self < "u" && self.Math === Math
      ? self
      : typeof window < "u" && window.Math === Math
      ? window
      : Function("return this")();
  })(),
  vY = (function () {
    return typeof requestAnimationFrame == "function"
      ? requestAnimationFrame.bind(Ev)
      : function (t) {
          return setTimeout(function () {
            return t(Date.now());
          }, 1e3 / 60);
        };
  })(),
  yY = 2;
function xY(t, e) {
  var n = !1,
    r = !1,
    i = 0;
  function o() {
    n && ((n = !1), t()), r && a();
  }
  function s() {
    vY(o);
  }
  function a() {
    var l = Date.now();
    if (n) {
      if (l - i < yY) return;
      r = !0;
    } else (n = !0), (r = !1), setTimeout(s, e);
    i = l;
  }
  return a;
}
var _Y = 20,
  SY = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
  AY = typeof MutationObserver < "u",
  bY = (function () {
    function t() {
      (this.connected_ = !1),
        (this.mutationEventsAdded_ = !1),
        (this.mutationsObserver_ = null),
        (this.observers_ = []),
        (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
        (this.refresh = xY(this.refresh.bind(this), _Y));
    }
    return (
      (t.prototype.addObserver = function (e) {
        ~this.observers_.indexOf(e) || this.observers_.push(e),
          this.connected_ || this.connect_();
      }),
      (t.prototype.removeObserver = function (e) {
        var n = this.observers_,
          r = n.indexOf(e);
        ~r && n.splice(r, 1),
          !n.length && this.connected_ && this.disconnect_();
      }),
      (t.prototype.refresh = function () {
        var e = this.updateObservers_();
        e && this.refresh();
      }),
      (t.prototype.updateObservers_ = function () {
        var e = this.observers_.filter(function (n) {
          return n.gatherActive(), n.hasActive();
        });
        return (
          e.forEach(function (n) {
            return n.broadcastActive();
          }),
          e.length > 0
        );
      }),
      (t.prototype.connect_ = function () {
        !sb ||
          this.connected_ ||
          (document.addEventListener("transitionend", this.onTransitionEnd_),
          window.addEventListener("resize", this.refresh),
          AY
            ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
              this.mutationsObserver_.observe(document, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0,
              }))
            : (document.addEventListener("DOMSubtreeModified", this.refresh),
              (this.mutationEventsAdded_ = !0)),
          (this.connected_ = !0));
      }),
      (t.prototype.disconnect_ = function () {
        !sb ||
          !this.connected_ ||
          (document.removeEventListener("transitionend", this.onTransitionEnd_),
          window.removeEventListener("resize", this.refresh),
          this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
          this.mutationEventsAdded_ &&
            document.removeEventListener("DOMSubtreeModified", this.refresh),
          (this.mutationsObserver_ = null),
          (this.mutationEventsAdded_ = !1),
          (this.connected_ = !1));
      }),
      (t.prototype.onTransitionEnd_ = function (e) {
        var n = e.propertyName,
          r = n === void 0 ? "" : n,
          i = SY.some(function (o) {
            return !!~r.indexOf(o);
          });
        i && this.refresh();
      }),
      (t.getInstance = function () {
        return this.instance_ || (this.instance_ = new t()), this.instance_;
      }),
      (t.instance_ = null),
      t
    );
  })(),
  kF = function (t, e) {
    for (var n = 0, r = Object.keys(e); n < r.length; n++) {
      var i = r[n];
      Object.defineProperty(t, i, {
        value: e[i],
        enumerable: !1,
        writable: !1,
        configurable: !0,
      });
    }
    return t;
  },
  wf = function (t) {
    var e = t && t.ownerDocument && t.ownerDocument.defaultView;
    return e || Ev;
  },
  zF = Gy(0, 0, 0, 0);
function Mv(t) {
  return parseFloat(t) || 0;
}
function wP(t) {
  for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
  return e.reduce(function (r, i) {
    var o = t["border-" + i + "-width"];
    return r + Mv(o);
  }, 0);
}
function wY(t) {
  for (
    var e = ["top", "right", "bottom", "left"], n = {}, r = 0, i = e;
    r < i.length;
    r++
  ) {
    var o = i[r],
      s = t["padding-" + o];
    n[o] = Mv(s);
  }
  return n;
}
function EY(t) {
  var e = t.getBBox();
  return Gy(0, 0, e.width, e.height);
}
function MY(t) {
  var e = t.clientWidth,
    n = t.clientHeight;
  if (!e && !n) return zF;
  var r = wf(t).getComputedStyle(t),
    i = wY(r),
    o = i.left + i.right,
    s = i.top + i.bottom,
    a = Mv(r.width),
    l = Mv(r.height);
  if (
    (r.boxSizing === "border-box" &&
      (Math.round(a + o) !== e && (a -= wP(r, "left", "right") + o),
      Math.round(l + s) !== n && (l -= wP(r, "top", "bottom") + s)),
    !TY(t))
  ) {
    var c = Math.round(a + o) - e,
      u = Math.round(l + s) - n;
    Math.abs(c) !== 1 && (a -= c), Math.abs(u) !== 1 && (l -= u);
  }
  return Gy(i.left, i.top, a, l);
}
var CY = (function () {
  return typeof SVGGraphicsElement < "u"
    ? function (t) {
        return t instanceof wf(t).SVGGraphicsElement;
      }
    : function (t) {
        return t instanceof wf(t).SVGElement && typeof t.getBBox == "function";
      };
})();
function TY(t) {
  return t === wf(t).document.documentElement;
}
function RY(t) {
  return sb ? (CY(t) ? EY(t) : MY(t)) : zF;
}
function PY(t) {
  var e = t.x,
    n = t.y,
    r = t.width,
    i = t.height,
    o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
    s = Object.create(o.prototype);
  return (
    kF(s, {
      x: e,
      y: n,
      width: r,
      height: i,
      top: n,
      right: e + r,
      bottom: i + n,
      left: e,
    }),
    s
  );
}
function Gy(t, e, n, r) {
  return { x: t, y: e, width: n, height: r };
}
var IY = (function () {
    function t(e) {
      (this.broadcastWidth = 0),
        (this.broadcastHeight = 0),
        (this.contentRect_ = Gy(0, 0, 0, 0)),
        (this.target = e);
    }
    return (
      (t.prototype.isActive = function () {
        var e = RY(this.target);
        return (
          (this.contentRect_ = e),
          e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
        );
      }),
      (t.prototype.broadcastRect = function () {
        var e = this.contentRect_;
        return (
          (this.broadcastWidth = e.width), (this.broadcastHeight = e.height), e
        );
      }),
      t
    );
  })(),
  LY = (function () {
    function t(e, n) {
      var r = PY(n);
      kF(this, { target: e, contentRect: r });
    }
    return t;
  })(),
  OY = (function () {
    function t(e, n, r) {
      if (
        ((this.activeObservations_ = []),
        (this.observations_ = new UF()),
        typeof e != "function")
      )
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      (this.callback_ = e), (this.controller_ = n), (this.callbackCtx_ = r);
    }
    return (
      (t.prototype.observe = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof wf(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var n = this.observations_;
          n.has(e) ||
            (n.set(e, new IY(e)),
            this.controller_.addObserver(this),
            this.controller_.refresh());
        }
      }),
      (t.prototype.unobserve = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof wf(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var n = this.observations_;
          n.has(e) &&
            (n.delete(e), n.size || this.controller_.removeObserver(this));
        }
      }),
      (t.prototype.disconnect = function () {
        this.clearActive(),
          this.observations_.clear(),
          this.controller_.removeObserver(this);
      }),
      (t.prototype.gatherActive = function () {
        var e = this;
        this.clearActive(),
          this.observations_.forEach(function (n) {
            n.isActive() && e.activeObservations_.push(n);
          });
      }),
      (t.prototype.broadcastActive = function () {
        if (this.hasActive()) {
          var e = this.callbackCtx_,
            n = this.activeObservations_.map(function (r) {
              return new LY(r.target, r.broadcastRect());
            });
          this.callback_.call(e, n, e), this.clearActive();
        }
      }),
      (t.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      }),
      (t.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      }),
      t
    );
  })(),
  BF = typeof WeakMap < "u" ? new WeakMap() : new UF(),
  HF = (function () {
    function t(e) {
      if (!(this instanceof t))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = bY.getInstance(),
        r = new OY(e, n, this);
      BF.set(this, r);
    }
    return t;
  })();
["observe", "unobserve", "disconnect"].forEach(function (t) {
  HF.prototype[t] = function () {
    var e;
    return (e = BF.get(this))[t].apply(e, arguments);
  };
});
var NY = (function () {
    return typeof Ev.ResizeObserver < "u" ? Ev.ResizeObserver : HF;
  })(),
  za = new Map();
function DY(t) {
  t.forEach(function (e) {
    var n,
      r = e.target;
    (n = za.get(r)) === null ||
      n === void 0 ||
      n.forEach(function (i) {
        return i(r);
      });
  });
}
var VF = new NY(DY);
function FY(t, e) {
  za.has(t) || (za.set(t, new Set()), VF.observe(t)), za.get(t).add(e);
}
function UY(t, e) {
  za.has(t) &&
    (za.get(t).delete(e), za.get(t).size || (VF.unobserve(t), za.delete(t)));
}
function Sr(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function EP(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(t, IF(r.key), r);
  }
}
function Ar(t, e, n) {
  return (
    e && EP(t.prototype, e),
    n && EP(t, n),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    t
  );
}
function lp(t, e) {
  return (
    (lp = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (n, r) {
          return (n.__proto__ = r), n;
        }),
    lp(t, e)
  );
}
function ul(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  (t.prototype = Object.create(e && e.prototype, {
    constructor: { value: t, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(t, "prototype", { writable: !1 }),
    e && lp(t, e);
}
function cp(t) {
  return (
    (cp = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        }),
    cp(t)
  );
}
function qE() {
  try {
    var t = !Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    );
  } catch {}
  return (qE = function () {
    return !!t;
  })();
}
function zt(t) {
  if (t === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return t;
}
function kY(t, e) {
  if (e && (bt(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    );
  return zt(t);
}
function fl(t) {
  var e = qE();
  return function () {
    var n,
      r = cp(t);
    if (e) {
      var i = cp(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else n = r.apply(this, arguments);
    return kY(this, n);
  };
}
var zY = (function (t) {
  ul(n, t);
  var e = fl(n);
  function n() {
    return Sr(this, n), e.apply(this, arguments);
  }
  return (
    Ar(n, [
      {
        key: "render",
        value: function () {
          return this.props.children;
        },
      },
    ]),
    n
  );
})(L.Component);
function BY(t, e) {
  var n = t.children,
    r = t.disabled,
    i = L.useRef(null),
    o = L.useRef(null),
    s = L.useContext(ob),
    a = typeof n == "function",
    l = a ? n(i) : n,
    c = L.useRef({ width: -1, height: -1, offsetWidth: -1, offsetHeight: -1 }),
    u = !a && L.isValidElement(l) && XE(l),
    d = u ? YE(l) : null,
    p = DF(d, i),
    m = function () {
      var g;
      return (
        N0(i.current) ||
        (i.current && bt(i.current) === "object"
          ? N0(
              (g = i.current) === null || g === void 0
                ? void 0
                : g.nativeElement
            )
          : null) ||
        N0(o.current)
      );
    };
  L.useImperativeHandle(e, function () {
    return m();
  });
  var v = L.useRef(t);
  v.current = t;
  var _ = L.useCallback(function (y) {
    var g = v.current,
      x = g.onResize,
      S = g.data,
      b = y.getBoundingClientRect(),
      C = b.width,
      M = b.height,
      T = y.offsetWidth,
      P = y.offsetHeight,
      R = Math.floor(C),
      E = Math.floor(M);
    if (
      c.current.width !== R ||
      c.current.height !== E ||
      c.current.offsetWidth !== T ||
      c.current.offsetHeight !== P
    ) {
      var O = { width: R, height: E, offsetWidth: T, offsetHeight: P };
      c.current = O;
      var D = T === Math.round(C) ? C : T,
        N = P === Math.round(M) ? M : P,
        z = Fe(Fe({}, O), {}, { offsetWidth: D, offsetHeight: N });
      s == null || s(z, y, S),
        x &&
          Promise.resolve().then(function () {
            x(z, y);
          });
    }
  }, []);
  return (
    L.useEffect(
      function () {
        var y = m();
        return (
          y && !r && FY(y, _),
          function () {
            return UY(y, _);
          }
        );
      },
      [i.current, r]
    ),
    L.createElement(zY, { ref: o }, u ? L.cloneElement(l, { ref: p }) : l)
  );
}
var HY = L.forwardRef(BY),
  VY = "rc-observer-key";
function GY(t, e) {
  var n = t.children,
    r = typeof n == "function" ? [n] : bf(n);
  return r.map(function (i, o) {
    var s = (i == null ? void 0 : i.key) || "".concat(VY, "-").concat(o);
    return L.createElement(
      HY,
      Bt({}, t, { key: s, ref: o === 0 ? e : void 0 }),
      i
    );
  });
}
var GF = L.forwardRef(GY);
GF.Collection = gY;
function ab(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = Array(e); n < e; n++) r[n] = t[n];
  return r;
}
function WY(t) {
  if (Array.isArray(t)) return ab(t);
}
function WF(t) {
  if (
    (typeof Symbol < "u" && t[Symbol.iterator] != null) ||
    t["@@iterator"] != null
  )
    return Array.from(t);
}
function KE(t, e) {
  if (t) {
    if (typeof t == "string") return ab(t, e);
    var n = {}.toString.call(t).slice(8, -1);
    return (
      n === "Object" && t.constructor && (n = t.constructor.name),
      n === "Map" || n === "Set"
        ? Array.from(t)
        : n === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
        ? ab(t, e)
        : void 0
    );
  }
}
function jY() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yt(t) {
  return WY(t) || WF(t) || KE(t) || jY();
}
var jF = function (e) {
    return +setTimeout(e, 16);
  },
  $F = function (e) {
    return clearTimeout(e);
  };
typeof window < "u" &&
  "requestAnimationFrame" in window &&
  ((jF = function (e) {
    return window.requestAnimationFrame(e);
  }),
  ($F = function (e) {
    return window.cancelAnimationFrame(e);
  }));
var MP = 0,
  ZE = new Map();
function XF(t) {
  ZE.delete(t);
}
var Ao = function (e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  MP += 1;
  var r = MP;
  function i(o) {
    if (o === 0) XF(r), e();
    else {
      var s = jF(function () {
        i(o - 1);
      });
      ZE.set(r, s);
    }
  }
  return i(n), r;
};
Ao.cancel = function (t) {
  var e = ZE.get(t);
  return XF(t), $F(e);
};
function YF(t) {
  if (Array.isArray(t)) return t;
}
function $Y(t, e) {
  var n =
    t == null
      ? null
      : (typeof Symbol < "u" && t[Symbol.iterator]) || t["@@iterator"];
  if (n != null) {
    var r,
      i,
      o,
      s,
      a = [],
      l = !0,
      c = !1;
    try {
      if (((o = (n = n.call(t)).next), e === 0)) {
        if (Object(n) !== n) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (a.push(r.value), a.length !== e);
          l = !0
        );
    } catch (u) {
      (c = !0), (i = u);
    } finally {
      try {
        if (!l && n.return != null && ((s = n.return()), Object(s) !== s))
          return;
      } finally {
        if (c) throw i;
      }
    }
    return a;
  }
}
function qF() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ot(t, e) {
  return YF(t) || $Y(t, e) || KE(t, e) || qF();
}
function up(t) {
  for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
    (n =
      (t.charCodeAt(r) & 255) |
      ((t.charCodeAt(++r) & 255) << 8) |
      ((t.charCodeAt(++r) & 255) << 16) |
      ((t.charCodeAt(++r) & 255) << 24)),
      (n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
      (n ^= n >>> 24),
      (e =
        ((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (t.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= t.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
function la() {
  return !!(
    typeof window < "u" &&
    window.document &&
    window.document.createElement
  );
}
function XY(t, e) {
  if (!t) return !1;
  if (t.contains) return t.contains(e);
  for (var n = e; n; ) {
    if (n === t) return !0;
    n = n.parentNode;
  }
  return !1;
}
var CP = "data-rc-order",
  TP = "data-rc-priority",
  YY = "rc-util-key",
  lb = new Map();
function KF() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = t.mark;
  return e ? (e.startsWith("data-") ? e : "data-".concat(e)) : YY;
}
function Wy(t) {
  if (t.attachTo) return t.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function qY(t) {
  return t === "queue" ? "prependQueue" : t ? "prepend" : "append";
}
function JE(t) {
  return Array.from((lb.get(t) || t).children).filter(function (e) {
    return e.tagName === "STYLE";
  });
}
function ZF(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!la()) return null;
  var n = e.csp,
    r = e.prepend,
    i = e.priority,
    o = i === void 0 ? 0 : i,
    s = qY(r),
    a = s === "prependQueue",
    l = document.createElement("style");
  l.setAttribute(CP, s),
    a && o && l.setAttribute(TP, "".concat(o)),
    n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce),
    (l.innerHTML = t);
  var c = Wy(e),
    u = c.firstChild;
  if (r) {
    if (a) {
      var d = (e.styles || JE(c)).filter(function (p) {
        if (!["prepend", "prependQueue"].includes(p.getAttribute(CP)))
          return !1;
        var m = Number(p.getAttribute(TP) || 0);
        return o >= m;
      });
      if (d.length) return c.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    c.insertBefore(l, u);
  } else c.appendChild(l);
  return l;
}
function JF(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = Wy(e);
  return (e.styles || JE(n)).find(function (r) {
    return r.getAttribute(KF(e)) === t;
  });
}
function QF(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = JF(t, e);
  if (n) {
    var r = Wy(e);
    r.removeChild(n);
  }
}
function KY(t, e) {
  var n = lb.get(t);
  if (!n || !XY(document, n)) {
    var r = ZF("", e),
      i = r.parentNode;
    lb.set(t, i), t.removeChild(r);
  }
}
function vc(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = Wy(n),
    i = JE(r),
    o = Fe(Fe({}, n), {}, { styles: i });
  KY(r, o);
  var s = JF(e, o);
  if (s) {
    var a, l;
    if (
      (a = o.csp) !== null &&
      a !== void 0 &&
      a.nonce &&
      s.nonce !== ((l = o.csp) === null || l === void 0 ? void 0 : l.nonce)
    ) {
      var c;
      s.nonce = (c = o.csp) === null || c === void 0 ? void 0 : c.nonce;
    }
    return s.innerHTML !== t && (s.innerHTML = t), s;
  }
  var u = ZF(t, o);
  return u.setAttribute(KF(o), e), u;
}
function ZY(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r)) {
      if (e.indexOf(r) !== -1) continue;
      n[r] = t[r];
    }
  return n;
}
function sr(t, e) {
  if (t == null) return {};
  var n,
    r,
    i = ZY(t, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    for (r = 0; r < o.length; r++)
      (n = o[r]),
        e.indexOf(n) === -1 &&
          {}.propertyIsEnumerable.call(t, n) &&
          (i[n] = t[n]);
  }
  return i;
}
function cb(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = new Set();
  function i(o, s) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
      l = r.has(o);
    if ((Ei(!l, "Warning: There may be circular references"), l)) return !1;
    if (o === s) return !0;
    if (n && a > 1) return !1;
    r.add(o);
    var c = a + 1;
    if (Array.isArray(o)) {
      if (!Array.isArray(s) || o.length !== s.length) return !1;
      for (var u = 0; u < o.length; u++) if (!i(o[u], s[u], c)) return !1;
      return !0;
    }
    if (o && s && bt(o) === "object" && bt(s) === "object") {
      var d = Object.keys(o);
      return d.length !== Object.keys(s).length
        ? !1
        : d.every(function (p) {
            return i(o[p], s[p], c);
          });
    }
    return !1;
  }
  return i(t, e);
}
var JY = "%";
function ub(t) {
  return t.join(JY);
}
var QY = (function () {
    function t(e) {
      Sr(this, t),
        ve(this, "instanceId", void 0),
        ve(this, "cache", new Map()),
        ve(this, "extracted", new Set()),
        (this.instanceId = e);
    }
    return (
      Ar(t, [
        {
          key: "get",
          value: function (n) {
            return this.opGet(ub(n));
          },
        },
        {
          key: "opGet",
          value: function (n) {
            return this.cache.get(n) || null;
          },
        },
        {
          key: "update",
          value: function (n, r) {
            return this.opUpdate(ub(n), r);
          },
        },
        {
          key: "opUpdate",
          value: function (n, r) {
            var i = this.cache.get(n),
              o = r(i);
            o === null ? this.cache.delete(n) : this.cache.set(n, o);
          },
        },
      ]),
      t
    );
  })(),
  Ef = "data-token-hash",
  Ho = "data-css-hash",
  Ba = "__cssinjs_instance__";
function eq() {
  var t = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var e = document.body.querySelectorAll("style[".concat(Ho, "]")) || [],
      n = document.head.firstChild;
    Array.from(e).forEach(function (i) {
      (i[Ba] = i[Ba] || t), i[Ba] === t && document.head.insertBefore(i, n);
    });
    var r = {};
    Array.from(document.querySelectorAll("style[".concat(Ho, "]"))).forEach(
      function (i) {
        var o = i.getAttribute(Ho);
        if (r[o]) {
          if (i[Ba] === t) {
            var s;
            (s = i.parentNode) === null || s === void 0 || s.removeChild(i);
          }
        } else r[o] = !0;
      }
    );
  }
  return new QY(t);
}
var Gp = L.createContext({
  hashPriority: "low",
  cache: eq(),
  defaultCache: !0,
});
function tq(t, e) {
  if (t.length !== e.length) return !1;
  for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
var QE = (function () {
  function t() {
    Sr(this, t),
      ve(this, "cache", void 0),
      ve(this, "keys", void 0),
      ve(this, "cacheCallTimes", void 0),
      (this.cache = new Map()),
      (this.keys = []),
      (this.cacheCallTimes = 0);
  }
  return (
    Ar(t, [
      {
        key: "size",
        value: function () {
          return this.keys.length;
        },
      },
      {
        key: "internalGet",
        value: function (n) {
          var r,
            i,
            o =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !1,
            s = { map: this.cache };
          return (
            n.forEach(function (a) {
              if (!s) s = void 0;
              else {
                var l;
                s =
                  (l = s) === null ||
                  l === void 0 ||
                  (l = l.map) === null ||
                  l === void 0
                    ? void 0
                    : l.get(a);
              }
            }),
            (r = s) !== null &&
              r !== void 0 &&
              r.value &&
              o &&
              (s.value[1] = this.cacheCallTimes++),
            (i = s) === null || i === void 0 ? void 0 : i.value
          );
        },
      },
      {
        key: "get",
        value: function (n) {
          var r;
          return (r = this.internalGet(n, !0)) === null || r === void 0
            ? void 0
            : r[0];
        },
      },
      {
        key: "has",
        value: function (n) {
          return !!this.internalGet(n);
        },
      },
      {
        key: "set",
        value: function (n, r) {
          var i = this;
          if (!this.has(n)) {
            if (this.size() + 1 > t.MAX_CACHE_SIZE + t.MAX_CACHE_OFFSET) {
              var o = this.keys.reduce(
                  function (c, u) {
                    var d = ot(c, 2),
                      p = d[1];
                    return i.internalGet(u)[1] < p
                      ? [u, i.internalGet(u)[1]]
                      : c;
                  },
                  [this.keys[0], this.cacheCallTimes]
                ),
                s = ot(o, 1),
                a = s[0];
              this.delete(a);
            }
            this.keys.push(n);
          }
          var l = this.cache;
          n.forEach(function (c, u) {
            if (u === n.length - 1)
              l.set(c, { value: [r, i.cacheCallTimes++] });
            else {
              var d = l.get(c);
              d ? d.map || (d.map = new Map()) : l.set(c, { map: new Map() }),
                (l = l.get(c).map);
            }
          });
        },
      },
      {
        key: "deleteByPath",
        value: function (n, r) {
          var i = n.get(r[0]);
          if (r.length === 1) {
            var o;
            return (
              i.map ? n.set(r[0], { map: i.map }) : n.delete(r[0]),
              (o = i.value) === null || o === void 0 ? void 0 : o[0]
            );
          }
          var s = this.deleteByPath(i.map, r.slice(1));
          return (!i.map || i.map.size === 0) && !i.value && n.delete(r[0]), s;
        },
      },
      {
        key: "delete",
        value: function (n) {
          if (this.has(n))
            return (
              (this.keys = this.keys.filter(function (r) {
                return !tq(r, n);
              })),
              this.deleteByPath(this.cache, n)
            );
        },
      },
    ]),
    t
  );
})();
ve(QE, "MAX_CACHE_SIZE", 20);
ve(QE, "MAX_CACHE_OFFSET", 5);
var RP = 0,
  eU = (function () {
    function t(e) {
      Sr(this, t),
        ve(this, "derivatives", void 0),
        ve(this, "id", void 0),
        (this.derivatives = Array.isArray(e) ? e : [e]),
        (this.id = RP),
        e.length === 0 && (e.length > 0, void 0),
        (RP += 1);
    }
    return (
      Ar(t, [
        {
          key: "getDerivativeToken",
          value: function (n) {
            return this.derivatives.reduce(function (r, i) {
              return i(n, r);
            }, void 0);
          },
        },
      ]),
      t
    );
  })(),
  N_ = new QE();
function fb(t) {
  var e = Array.isArray(t) ? t : [t];
  return N_.has(e) || N_.set(e, new eU(e)), N_.get(e);
}
var nq = new WeakMap(),
  D_ = {};
function rq(t, e) {
  for (var n = nq, r = 0; r < e.length; r += 1) {
    var i = e[r];
    n.has(i) || n.set(i, new WeakMap()), (n = n.get(i));
  }
  return n.has(D_) || n.set(D_, t()), n.get(D_);
}
var PP = new WeakMap();
function yh(t) {
  var e = PP.get(t) || "";
  return (
    e ||
      (Object.keys(t).forEach(function (n) {
        var r = t[n];
        (e += n),
          r instanceof eU
            ? (e += r.id)
            : r && bt(r) === "object"
            ? (e += yh(r))
            : (e += r);
      }),
      (e = up(e)),
      PP.set(t, e)),
    e
  );
}
function IP(t, e) {
  return up("".concat(e, "_").concat(yh(t)));
}
var db = la();
function Tt(t) {
  return typeof t == "number" ? "".concat(t, "px") : t;
}
function Cv(t, e, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
    i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (i) return t;
  var o = Fe(Fe({}, r), {}, ve(ve({}, Ef, e), Ho, n)),
    s = Object.keys(o)
      .map(function (a) {
        var l = o[a];
        return l ? "".concat(a, '="').concat(l, '"') : null;
      })
      .filter(function (a) {
        return a;
      })
      .join(" ");
  return "<style ".concat(s, ">").concat(t, "</style>");
}
var D0 = function (e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "--"
      .concat(n ? "".concat(n, "-") : "")
      .concat(e)
      .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
      .replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2")
      .replace(/([a-z])([A-Z0-9])/g, "$1-$2")
      .toLowerCase();
  },
  iq = function (e, n, r) {
    return Object.keys(e).length
      ? "."
          .concat(n)
          .concat(r != null && r.scope ? ".".concat(r.scope) : "", "{")
          .concat(
            Object.entries(e)
              .map(function (i) {
                var o = ot(i, 2),
                  s = o[0],
                  a = o[1];
                return "".concat(s, ":").concat(a, ";");
              })
              .join(""),
            "}"
          )
      : "";
  },
  tU = function (e, n, r) {
    var i = {},
      o = {};
    return (
      Object.entries(e).forEach(function (s) {
        var a,
          l,
          c = ot(s, 2),
          u = c[0],
          d = c[1];
        if (r != null && (a = r.preserve) !== null && a !== void 0 && a[u])
          o[u] = d;
        else if (
          (typeof d == "string" || typeof d == "number") &&
          !(r != null && (l = r.ignore) !== null && l !== void 0 && l[u])
        ) {
          var p,
            m = D0(u, r == null ? void 0 : r.prefix);
          (i[m] =
            typeof d == "number" &&
            !(r != null && (p = r.unitless) !== null && p !== void 0 && p[u])
              ? "".concat(d, "px")
              : String(d)),
            (o[u] = "var(".concat(m, ")"));
        }
      }),
      [o, iq(i, n, { scope: r == null ? void 0 : r.scope })]
    );
  },
  LP = la() ? L.useLayoutEffect : L.useEffect,
  fp = function (e, n) {
    var r = L.useRef(!0);
    LP(function () {
      return e(r.current);
    }, n),
      LP(function () {
        return (
          (r.current = !1),
          function () {
            r.current = !0;
          }
        );
      }, []);
  },
  OP = function (e, n) {
    fp(function (r) {
      if (!r) return e();
    }, n);
  },
  oq = Fe({}, Fv),
  NP = oq.useInsertionEffect,
  sq = function (e, n, r) {
    L.useMemo(e, r),
      fp(function () {
        return n(!0);
      }, r);
  },
  aq = NP
    ? function (t, e, n) {
        return NP(function () {
          return t(), e();
        }, n);
      }
    : sq,
  lq = Fe({}, Fv),
  cq = lq.useInsertionEffect,
  uq = function (e) {
    var n = [],
      r = !1;
    function i(o) {
      r || n.push(o);
    }
    return (
      L.useEffect(function () {
        return (
          (r = !1),
          function () {
            (r = !0),
              n.length &&
                n.forEach(function (o) {
                  return o();
                });
          }
        );
      }, e),
      i
    );
  },
  fq = function () {
    return function (e) {
      e();
    };
  },
  dq = typeof cq < "u" ? uq : fq;
function eM(t, e, n, r, i) {
  var o = L.useContext(Gp),
    s = o.cache,
    a = [t].concat(yt(e)),
    l = ub(a),
    c = dq([l]),
    u = function (v) {
      s.opUpdate(l, function (_) {
        var y = _ || [void 0, void 0],
          g = ot(y, 2),
          x = g[0],
          S = x === void 0 ? 0 : x,
          b = g[1],
          C = b,
          M = C || n(),
          T = [S, M];
        return v ? v(T) : T;
      });
    };
  L.useMemo(
    function () {
      u();
    },
    [l]
  );
  var d = s.opGet(l),
    p = d[1];
  return (
    aq(
      function () {
        i == null || i(p);
      },
      function (m) {
        return (
          u(function (v) {
            var _ = ot(v, 2),
              y = _[0],
              g = _[1];
            return m && y === 0 && (i == null || i(p)), [y + 1, g];
          }),
          function () {
            s.opUpdate(l, function (v) {
              var _ = v || [],
                y = ot(_, 2),
                g = y[0],
                x = g === void 0 ? 0 : g,
                S = y[1],
                b = x - 1;
              return b === 0
                ? (c(function () {
                    (m || !s.opGet(l)) && (r == null || r(S, !1));
                  }),
                  null)
                : [x - 1, S];
            });
          }
        );
      },
      [l]
    ),
    p
  );
}
var hq = {},
  pq = "css",
  Kl = new Map();
function mq(t) {
  Kl.set(t, (Kl.get(t) || 0) + 1);
}
function gq(t, e) {
  if (typeof document < "u") {
    var n = document.querySelectorAll(
      "style[".concat(Ef, '="').concat(t, '"]')
    );
    n.forEach(function (r) {
      if (r[Ba] === e) {
        var i;
        (i = r.parentNode) === null || i === void 0 || i.removeChild(r);
      }
    });
  }
}
var vq = 0;
function yq(t, e) {
  Kl.set(t, (Kl.get(t) || 0) - 1);
  var n = new Set();
  Kl.forEach(function (r, i) {
    r <= 0 && n.add(i);
  }),
    Kl.size - n.size > vq &&
      n.forEach(function (r) {
        gq(r, e), Kl.delete(r);
      });
}
var xq = function (e, n, r, i) {
    var o = r.getDerivativeToken(e),
      s = Fe(Fe({}, o), n);
    return i && (s = i(s)), s;
  },
  nU = "token";
function _q(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = L.useContext(Gp),
    i = r.cache.instanceId,
    o = r.container,
    s = n.salt,
    a = s === void 0 ? "" : s,
    l = n.override,
    c = l === void 0 ? hq : l,
    u = n.formatToken,
    d = n.getComputedToken,
    p = n.cssVar,
    m = rq(function () {
      return Object.assign.apply(Object, [{}].concat(yt(e)));
    }, e),
    v = yh(m),
    _ = yh(c),
    y = p ? yh(p) : "",
    g = eM(
      nU,
      [a, t.id, v, _, y],
      function () {
        var x,
          S = d ? d(m, c, t) : xq(m, c, t, u),
          b = Fe({}, S),
          C = "";
        if (p) {
          var M = tU(S, p.key, {
              prefix: p.prefix,
              ignore: p.ignore,
              unitless: p.unitless,
              preserve: p.preserve,
            }),
            T = ot(M, 2);
          (S = T[0]), (C = T[1]);
        }
        var P = IP(S, a);
        (S._tokenKey = P), (b._tokenKey = IP(b, a));
        var R =
          (x = p == null ? void 0 : p.key) !== null && x !== void 0 ? x : P;
        (S._themeKey = R), mq(R);
        var E = "".concat(pq, "-").concat(up(P));
        return (
          (S._hashId = E), [S, E, b, C, (p == null ? void 0 : p.key) || ""]
        );
      },
      function (x) {
        yq(x[0]._themeKey, i);
      },
      function (x) {
        var S = ot(x, 4),
          b = S[0],
          C = S[3];
        if (p && C) {
          var M = vc(C, up("css-variables-".concat(b._themeKey)), {
            mark: Ho,
            prepend: "queue",
            attachTo: o,
            priority: -999,
          });
          (M[Ba] = i), M.setAttribute(Ef, b._themeKey);
        }
      }
    );
  return g;
}
var Sq = function (e, n, r) {
    var i = ot(e, 5),
      o = i[2],
      s = i[3],
      a = i[4],
      l = r || {},
      c = l.plain;
    if (!s) return null;
    var u = o._tokenKey,
      d = -999,
      p = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(d) },
      m = Cv(s, a, u, p, c);
    return [d, u, m];
  },
  Aq = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  rU = "comm",
  iU = "rule",
  oU = "decl",
  bq = "@import",
  wq = "@namespace",
  Eq = "@keyframes",
  Mq = "@layer",
  sU = Math.abs,
  tM = String.fromCharCode;
function aU(t) {
  return t.trim();
}
function F0(t, e, n) {
  return t.replace(e, n);
}
function Cq(t, e, n) {
  return t.indexOf(e, n);
}
function cf(t, e) {
  return t.charCodeAt(e) | 0;
}
function Mf(t, e, n) {
  return t.slice(e, n);
}
function ss(t) {
  return t.length;
}
function Tq(t) {
  return t.length;
}
function r0(t, e) {
  return e.push(t), t;
}
var jy = 1,
  Cf = 1,
  lU = 0,
  bo = 0,
  Zn = 0,
  Bf = "";
function nM(t, e, n, r, i, o, s, a) {
  return {
    value: t,
    root: e,
    parent: n,
    type: r,
    props: i,
    children: o,
    line: jy,
    column: Cf,
    length: s,
    return: "",
    siblings: a,
  };
}
function Rq() {
  return Zn;
}
function Pq() {
  return (
    (Zn = bo > 0 ? cf(Bf, --bo) : 0), Cf--, Zn === 10 && ((Cf = 1), jy--), Zn
  );
}
function Vo() {
  return (
    (Zn = bo < lU ? cf(Bf, bo++) : 0), Cf++, Zn === 10 && ((Cf = 1), jy++), Zn
  );
}
function Ha() {
  return cf(Bf, bo);
}
function U0() {
  return bo;
}
function $y(t, e) {
  return Mf(Bf, t, e);
}
function dp(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Iq(t) {
  return (jy = Cf = 1), (lU = ss((Bf = t))), (bo = 0), [];
}
function Lq(t) {
  return (Bf = ""), t;
}
function F_(t) {
  return aU($y(bo - 1, hb(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function Oq(t) {
  for (; (Zn = Ha()) && Zn < 33; ) Vo();
  return dp(t) > 2 || dp(Zn) > 3 ? "" : " ";
}
function Nq(t, e) {
  for (
    ;
    --e &&
    Vo() &&
    !(Zn < 48 || Zn > 102 || (Zn > 57 && Zn < 65) || (Zn > 70 && Zn < 97));

  );
  return $y(t, U0() + (e < 6 && Ha() == 32 && Vo() == 32));
}
function hb(t) {
  for (; Vo(); )
    switch (Zn) {
      case t:
        return bo;
      case 34:
      case 39:
        t !== 34 && t !== 39 && hb(Zn);
        break;
      case 40:
        t === 41 && hb(t);
        break;
      case 92:
        Vo();
        break;
    }
  return bo;
}
function Dq(t, e) {
  for (; Vo() && t + Zn !== 57; ) if (t + Zn === 84 && Ha() === 47) break;
  return "/*" + $y(e, bo - 1) + "*" + tM(t === 47 ? t : Vo());
}
function Fq(t) {
  for (; !dp(Ha()); ) Vo();
  return $y(t, bo);
}
function Uq(t) {
  return Lq(k0("", null, null, null, [""], (t = Iq(t)), 0, [0], t));
}
function k0(t, e, n, r, i, o, s, a, l) {
  for (
    var c = 0,
      u = 0,
      d = s,
      p = 0,
      m = 0,
      v = 0,
      _ = 1,
      y = 1,
      g = 1,
      x = 0,
      S = "",
      b = i,
      C = o,
      M = r,
      T = S;
    y;

  )
    switch (((v = x), (x = Vo()))) {
      case 40:
        if (v != 108 && cf(T, d - 1) == 58) {
          Cq((T += F0(F_(x), "&", "&\f")), "&\f", sU(c ? a[c - 1] : 0)) != -1 &&
            (g = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        T += F_(x);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        T += Oq(v);
        break;
      case 92:
        T += Nq(U0() - 1, 7);
        continue;
      case 47:
        switch (Ha()) {
          case 42:
          case 47:
            r0(kq(Dq(Vo(), U0()), e, n, l), l),
              (dp(v || 1) == 5 || dp(Ha() || 1) == 5) &&
                ss(T) &&
                Mf(T, -1, void 0) !== " " &&
                (T += " ");
            break;
          default:
            T += "/";
        }
        break;
      case 123 * _:
        a[c++] = ss(T) * g;
      case 125 * _:
      case 59:
      case 0:
        switch (x) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            g == -1 && (T = F0(T, /\f/g, "")),
              m > 0 &&
                (ss(T) - d || (_ === 0 && v === 47)) &&
                r0(
                  m > 32
                    ? FP(T + ";", r, n, d - 1, l)
                    : FP(F0(T, " ", "") + ";", r, n, d - 2, l),
                  l
                );
            break;
          case 59:
            T += ";";
          default:
            if (
              (r0(
                (M = DP(T, e, n, c, u, i, a, S, (b = []), (C = []), d, o)),
                o
              ),
              x === 123)
            )
              if (u === 0) k0(T, e, M, M, b, o, d, a, C);
              else {
                switch (p) {
                  case 99:
                    if (cf(T, 3) === 110) break;
                  case 108:
                    if (cf(T, 2) === 97) break;
                  default:
                    u = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                u
                  ? k0(
                      t,
                      M,
                      M,
                      r && r0(DP(t, M, M, 0, 0, i, a, S, i, (b = []), d, C), C),
                      i,
                      C,
                      d,
                      a,
                      r ? b : C
                    )
                  : k0(T, M, M, M, [""], C, 0, a, C);
              }
        }
        (c = u = m = 0), (_ = g = 1), (S = T = ""), (d = s);
        break;
      case 58:
        (d = 1 + ss(T)), (m = v);
      default:
        if (_ < 1) {
          if (x == 123) --_;
          else if (x == 125 && _++ == 0 && Pq() == 125) continue;
        }
        switch (((T += tM(x)), x * _)) {
          case 38:
            g = u > 0 ? 1 : ((T += "\f"), -1);
            break;
          case 44:
            (a[c++] = (ss(T) - 1) * g), (g = 1);
            break;
          case 64:
            Ha() === 45 && (T += F_(Vo())),
              (p = Ha()),
              (u = d = ss((S = T += Fq(U0())))),
              x++;
            break;
          case 45:
            v === 45 && ss(T) == 2 && (_ = 0);
        }
    }
  return o;
}
function DP(t, e, n, r, i, o, s, a, l, c, u, d) {
  for (
    var p = i - 1, m = i === 0 ? o : [""], v = Tq(m), _ = 0, y = 0, g = 0;
    _ < r;
    ++_
  )
    for (var x = 0, S = Mf(t, p + 1, (p = sU((y = s[_])))), b = t; x < v; ++x)
      (b = aU(y > 0 ? m[x] + " " + S : F0(S, /&\f/g, m[x]))) && (l[g++] = b);
  return nM(t, e, n, i === 0 ? iU : a, l, c, u, d);
}
function kq(t, e, n, r) {
  return nM(t, e, n, rU, tM(Rq()), Mf(t, 2, -2), 0, r);
}
function FP(t, e, n, r, i) {
  return nM(t, e, n, oU, Mf(t, 0, r), Mf(t, r + 1, -1), r, i);
}
function pb(t, e) {
  for (var n = "", r = 0; r < t.length; r++) n += e(t[r], r, t, e) || "";
  return n;
}
function zq(t, e, n, r) {
  switch (t.type) {
    case Mq:
      if (t.children.length) break;
    case bq:
    case wq:
    case oU:
      return (t.return = t.return || t.value);
    case rU:
      return "";
    case Eq:
      return (t.return = t.value + "{" + pb(t.children, r) + "}");
    case iU:
      if (!ss((t.value = t.props.join(",")))) return "";
  }
  return ss((n = pb(t.children, r)))
    ? (t.return = t.value + "{" + n + "}")
    : "";
}
var UP = "data-ant-cssinjs-cache-path",
  cU = "_FILE_STYLE__",
  yc,
  uU = !0;
function Bq() {
  if (!yc && ((yc = {}), la())) {
    var t = document.createElement("div");
    (t.className = UP),
      (t.style.position = "fixed"),
      (t.style.visibility = "hidden"),
      (t.style.top = "-9999px"),
      document.body.appendChild(t);
    var e = getComputedStyle(t).content || "";
    (e = e.replace(/^"/, "").replace(/"$/, "")),
      e.split(";").forEach(function (i) {
        var o = i.split(":"),
          s = ot(o, 2),
          a = s[0],
          l = s[1];
        yc[a] = l;
      });
    var n = document.querySelector("style[".concat(UP, "]"));
    if (n) {
      var r;
      (uU = !1),
        (r = n.parentNode) === null || r === void 0 || r.removeChild(n);
    }
    document.body.removeChild(t);
  }
}
function Hq(t) {
  return Bq(), !!yc[t];
}
function Vq(t) {
  var e = yc[t],
    n = null;
  if (e && la())
    if (uU) n = cU;
    else {
      var r = document.querySelector(
        "style[".concat(Ho, '="').concat(yc[t], '"]')
      );
      r ? (n = r.innerHTML) : delete yc[t];
    }
  return [n, e];
}
var Gq = "_skip_check_",
  fU = "_multi_value_";
function z0(t) {
  var e = pb(Uq(t), zq);
  return e.replace(/\{%%%\:[^;];}/g, ";");
}
function Wq(t) {
  return bt(t) === "object" && t && (Gq in t || fU in t);
}
function kP(t, e, n) {
  if (!e) return t;
  var r = ".".concat(e),
    i = n === "low" ? ":where(".concat(r, ")") : r,
    o = t.split(",").map(function (s) {
      var a,
        l = s.trim().split(/\s+/),
        c = l[0] || "",
        u =
          ((a = c.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) ||
          "";
      return (
        (c = "".concat(u).concat(i).concat(c.slice(u.length))),
        [c].concat(yt(l.slice(1))).join(" ")
      );
    });
  return o.join(",");
}
var jq = function t(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r =
      arguments.length > 2 && arguments[2] !== void 0
        ? arguments[2]
        : { root: !0, parentSelectors: [] },
    i = r.root,
    o = r.injectHash,
    s = r.parentSelectors,
    a = n.hashId,
    l = n.layer;
  n.path;
  var c = n.hashPriority,
    u = n.transformers,
    d = u === void 0 ? [] : u;
  n.linters;
  var p = "",
    m = {};
  function v(g) {
    var x = g.getName(a);
    if (!m[x]) {
      var S = t(g.style, n, { root: !1, parentSelectors: s }),
        b = ot(S, 1),
        C = b[0];
      m[x] = "@keyframes ".concat(g.getName(a)).concat(C);
    }
  }
  function _(g) {
    var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return (
      g.forEach(function (S) {
        Array.isArray(S) ? _(S, x) : S && x.push(S);
      }),
      x
    );
  }
  var y = _(Array.isArray(e) ? e : [e]);
  return (
    y.forEach(function (g) {
      var x = typeof g == "string" && !i ? {} : g;
      if (typeof x == "string")
        p += "".concat(
          x,
          `
`
        );
      else if (x._keyframe) v(x);
      else {
        var S = d.reduce(function (b, C) {
          var M;
          return (
            (C == null || (M = C.visit) === null || M === void 0
              ? void 0
              : M.call(C, b)) || b
          );
        }, x);
        Object.keys(S).forEach(function (b) {
          var C = S[b];
          if (
            bt(C) === "object" &&
            C &&
            (b !== "animationName" || !C._keyframe) &&
            !Wq(C)
          ) {
            var M = !1,
              T = b.trim(),
              P = !1;
            (i || o) && a
              ? T.startsWith("@")
                ? (M = !0)
                : T === "&"
                ? (T = kP("", a, c))
                : (T = kP(b, a, c))
              : i && !a && (T === "&" || T === "") && ((T = ""), (P = !0));
            var R = t(C, n, {
                root: P,
                injectHash: M,
                parentSelectors: [].concat(yt(s), [T]),
              }),
              E = ot(R, 2),
              O = E[0],
              D = E[1];
            (m = Fe(Fe({}, m), D)), (p += "".concat(T).concat(O));
          } else {
            let V = function (G, Y) {
              var U = G.replace(/[A-Z]/g, function (W) {
                  return "-".concat(W.toLowerCase());
                }),
                j = Y;
              !Aq[G] &&
                typeof j == "number" &&
                j !== 0 &&
                (j = "".concat(j, "px")),
                G === "animationName" &&
                  Y !== null &&
                  Y !== void 0 &&
                  Y._keyframe &&
                  (v(Y), (j = Y.getName(a))),
                (p += "".concat(U, ":").concat(j, ";"));
            };
            var N,
              z =
                (N = C == null ? void 0 : C.value) !== null && N !== void 0
                  ? N
                  : C;
            bt(C) === "object" &&
            C !== null &&
            C !== void 0 &&
            C[fU] &&
            Array.isArray(z)
              ? z.forEach(function (G) {
                  V(b, G);
                })
              : V(b, z);
          }
        });
      }
    }),
    i
      ? l &&
        (p && (p = "@layer ".concat(l.name, " {").concat(p, "}")),
        l.dependencies &&
          (m["@layer ".concat(l.name)] = l.dependencies.map(function (g) {
            return "@layer ".concat(g, ", ").concat(l.name, ";");
          }).join(`
`)))
      : (p = "{".concat(p, "}")),
    [p, m]
  );
};
function dU(t, e) {
  return up("".concat(t.join("%")).concat(e));
}
function $q() {
  return null;
}
var hU = "style";
function mb(t, e) {
  var n = t.token,
    r = t.path,
    i = t.hashId,
    o = t.layer,
    s = t.nonce,
    a = t.clientOnly,
    l = t.order,
    c = l === void 0 ? 0 : l,
    u = L.useContext(Gp),
    d = u.autoClear;
  u.mock;
  var p = u.defaultCache,
    m = u.hashPriority,
    v = u.container,
    _ = u.ssrInline,
    y = u.transformers,
    g = u.linters,
    x = u.cache,
    S = u.layer,
    b = n._tokenKey,
    C = [b];
  S && C.push("layer"), C.push.apply(C, yt(r));
  var M = db,
    T = eM(
      hU,
      C,
      function () {
        var D = C.join("|");
        if (Hq(D)) {
          var N = Vq(D),
            z = ot(N, 2),
            V = z[0],
            G = z[1];
          if (V) return [V, b, G, {}, a, c];
        }
        var Y = e(),
          U = jq(Y, {
            hashId: i,
            hashPriority: m,
            layer: S ? o : void 0,
            path: r.join("-"),
            transformers: y,
            linters: g,
          }),
          j = ot(U, 2),
          W = j[0],
          B = j[1],
          q = z0(W),
          Z = dU(C, q);
        return [q, b, Z, B, a, c];
      },
      function (D, N) {
        var z = ot(D, 3),
          V = z[2];
        (N || d) && db && QF(V, { mark: Ho, attachTo: v });
      },
      function (D) {
        var N = ot(D, 4),
          z = N[0];
        N[1];
        var V = N[2],
          G = N[3];
        if (M && z !== cU) {
          var Y = {
              mark: Ho,
              prepend: S ? !1 : "queue",
              attachTo: v,
              priority: c,
            },
            U = typeof s == "function" ? s() : s;
          U && (Y.csp = { nonce: U });
          var j = [],
            W = [];
          Object.keys(G).forEach(function (q) {
            q.startsWith("@layer") ? j.push(q) : W.push(q);
          }),
            j.forEach(function (q) {
              vc(
                z0(G[q]),
                "_layer-".concat(q),
                Fe(Fe({}, Y), {}, { prepend: !0 })
              );
            });
          var B = vc(z, V, Y);
          (B[Ba] = x.instanceId),
            B.setAttribute(Ef, b),
            W.forEach(function (q) {
              vc(z0(G[q]), "_effect-".concat(q), Y);
            });
        }
      }
    ),
    P = ot(T, 3),
    R = P[0],
    E = P[1],
    O = P[2];
  return function (D) {
    var N;
    return (
      !_ || M || !p
        ? (N = L.createElement($q, null))
        : (N = L.createElement(
            "style",
            Bt({}, ve(ve({}, Ef, E), Ho, O), {
              dangerouslySetInnerHTML: { __html: R },
            })
          )),
      L.createElement(L.Fragment, null, N, D)
    );
  };
}
var Xq = function (e, n, r) {
    var i = ot(e, 6),
      o = i[0],
      s = i[1],
      a = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = r || {},
      p = d.plain;
    if (c) return null;
    var m = o,
      v = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) };
    return (
      (m = Cv(o, s, a, v, p)),
      l &&
        Object.keys(l).forEach(function (_) {
          if (!n[_]) {
            n[_] = !0;
            var y = z0(l[_]),
              g = Cv(y, s, "_effect-".concat(_), v, p);
            _.startsWith("@layer") ? (m = g + m) : (m += g);
          }
        }),
      [u, a, m]
    );
  },
  pU = "cssVar",
  Yq = function (e, n) {
    var r = e.key,
      i = e.prefix,
      o = e.unitless,
      s = e.ignore,
      a = e.token,
      l = e.scope,
      c = l === void 0 ? "" : l,
      u = L.useContext(Gp),
      d = u.cache.instanceId,
      p = u.container,
      m = a._tokenKey,
      v = [].concat(yt(e.path), [r, c, m]),
      _ = eM(
        pU,
        v,
        function () {
          var y = n(),
            g = tU(y, r, { prefix: i, unitless: o, ignore: s, scope: c }),
            x = ot(g, 2),
            S = x[0],
            b = x[1],
            C = dU(v, b);
          return [S, b, C, r];
        },
        function (y) {
          var g = ot(y, 3),
            x = g[2];
          db && QF(x, { mark: Ho, attachTo: p });
        },
        function (y) {
          var g = ot(y, 3),
            x = g[1],
            S = g[2];
          if (x) {
            var b = vc(x, S, {
              mark: Ho,
              prepend: "queue",
              attachTo: p,
              priority: -999,
            });
            (b[Ba] = d), b.setAttribute(Ef, r);
          }
        }
      );
    return _;
  },
  qq = function (e, n, r) {
    var i = ot(e, 4),
      o = i[1],
      s = i[2],
      a = i[3],
      l = r || {},
      c = l.plain;
    if (!o) return null;
    var u = -999,
      d = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) },
      p = Cv(o, a, s, d, c);
    return [u, s, p];
  };
ve(ve(ve({}, hU, Xq), nU, Sq), pU, qq);
var zP = (function () {
  function t(e, n) {
    Sr(this, t),
      ve(this, "name", void 0),
      ve(this, "style", void 0),
      ve(this, "_keyframe", !0),
      (this.name = e),
      (this.style = n);
  }
  return (
    Ar(t, [
      {
        key: "getName",
        value: function () {
          var n =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return n ? "".concat(n, "-").concat(this.name) : this.name;
        },
      },
    ]),
    t
  );
})();
function Ru(t) {
  return (t.notSplit = !0), t;
}
Ru(["borderTop", "borderBottom"]),
  Ru(["borderTop"]),
  Ru(["borderBottom"]),
  Ru(["borderLeft", "borderRight"]),
  Ru(["borderLeft"]),
  Ru(["borderRight"]);
var rM = L.createContext({});
function Kq(t) {
  return YF(t) || WF(t) || KE(t) || qF();
}
function us(t, e) {
  for (var n = t, r = 0; r < e.length; r += 1) {
    if (n == null) return;
    n = n[e[r]];
  }
  return n;
}
function mU(t, e, n, r) {
  if (!e.length) return n;
  var i = Kq(e),
    o = i[0],
    s = i.slice(1),
    a;
  return (
    !t && typeof o == "number"
      ? (a = [])
      : Array.isArray(t)
      ? (a = yt(t))
      : (a = Fe({}, t)),
    r && n === void 0 && s.length === 1
      ? delete a[o][s[0]]
      : (a[o] = mU(a[o], s, n, r)),
    a
  );
}
function No(t, e, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return e.length && r && n === void 0 && !us(t, e.slice(0, -1))
    ? t
    : mU(t, e, n, r);
}
function Zq(t) {
  return (
    bt(t) === "object" &&
    t !== null &&
    Object.getPrototypeOf(t) === Object.prototype
  );
}
function BP(t) {
  return Array.isArray(t) ? [] : {};
}
var Jq = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function Ju() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var r = BP(e[0]);
  return (
    e.forEach(function (i) {
      function o(s, a) {
        var l = new Set(a),
          c = us(i, s),
          u = Array.isArray(c);
        if (u || Zq(c)) {
          if (!l.has(c)) {
            l.add(c);
            var d = us(r, s);
            u
              ? (r = No(r, s, []))
              : (!d || bt(d) !== "object") && (r = No(r, s, BP(c))),
              Jq(c).forEach(function (p) {
                o([].concat(yt(s), [p]), l);
              });
          }
        } else r = No(r, s, c);
      }
      o([]);
    }),
    r
  );
}
const Qq = L.createContext({}),
  eK = L.createContext(void 0),
  zi = "${label} is not a valid ${type}",
  Xy = {
    Modal: { okText: "OK", cancelText: "Cancel", justOkText: "OK" },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date",
        },
        types: {
          string: zi,
          method: zi,
          array: zi,
          object: zi,
          number: zi,
          date: zi,
          boolean: zi,
          integer: zi,
          float: zi,
          regexp: zi,
          email: zi,
          url: zi,
          hex: zi,
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters",
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}",
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}",
        },
        pattern: { mismatch: "${label} does not match the pattern ${pattern}" },
      },
    },
  };
Object.assign({}, Xy.Modal);
let B0 = [];
const HP = () =>
  B0.reduce((t, e) => Object.assign(Object.assign({}, t), e), Xy.Modal);
function tK(t) {
  if (t) {
    const e = Object.assign({}, t);
    return (
      B0.push(e),
      HP(),
      () => {
        (B0 = B0.filter((n) => n !== e)), HP();
      }
    );
  }
  Object.assign({}, Xy.Modal);
}
const gU = L.createContext(void 0),
  nK = "internalMark",
  rK = (t) => {
    const { locale: e = {}, children: n, _ANT_MARK__: r } = t;
    L.useEffect(() => tK(e == null ? void 0 : e.Modal), [e]);
    const i = L.useMemo(
      () => Object.assign(Object.assign({}, e), { exist: !0 }),
      [e]
    );
    return L.createElement(gU.Provider, { value: i }, n);
  },
  vU = {
    blue: "#1677FF",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#EB2F96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911",
  },
  hp = Object.assign(Object.assign({}, vU), {
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode:
      "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
    fontSize: 14,
    lineWidth: 1,
    lineType: "solid",
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
    motion: !0,
  }),
  vr = Math.round;
function U_(t, e) {
  const n =
      t
        .replace(/^[^(]*\((.*)/, "$1")
        .replace(/\).*/, "")
        .match(/\d*\.?\d+%?/g) || [],
    r = n.map((i) => parseFloat(i));
  for (let i = 0; i < 3; i += 1) r[i] = e(r[i] || 0, n[i] || "", i);
  return n[3] ? (r[3] = n[3].includes("%") ? r[3] / 100 : r[3]) : (r[3] = 1), r;
}
const VP = (t, e, n) => (n === 0 ? t : t / 100);
function Hd(t, e) {
  const n = e || 255;
  return t > n ? n : t < 0 ? 0 : t;
}
class Tn {
  constructor(e) {
    ve(this, "isValid", !0),
      ve(this, "r", 0),
      ve(this, "g", 0),
      ve(this, "b", 0),
      ve(this, "a", 1),
      ve(this, "_h", void 0),
      ve(this, "_s", void 0),
      ve(this, "_l", void 0),
      ve(this, "_v", void 0),
      ve(this, "_max", void 0),
      ve(this, "_min", void 0),
      ve(this, "_brightness", void 0);
    function n(i) {
      return i[0] in e && i[1] in e && i[2] in e;
    }
    if (e)
      if (typeof e == "string") {
        let o = function (s) {
          return i.startsWith(s);
        };
        var r = o;
        const i = e.trim();
        /^#?[A-F\d]{3,8}$/i.test(i)
          ? this.fromHexString(i)
          : o("rgb")
          ? this.fromRgbString(i)
          : o("hsl")
          ? this.fromHslString(i)
          : (o("hsv") || o("hsb")) && this.fromHsvString(i);
      } else if (e instanceof Tn)
        (this.r = e.r),
          (this.g = e.g),
          (this.b = e.b),
          (this.a = e.a),
          (this._h = e._h),
          (this._s = e._s),
          (this._l = e._l),
          (this._v = e._v);
      else if (n("rgb"))
        (this.r = Hd(e.r)),
          (this.g = Hd(e.g)),
          (this.b = Hd(e.b)),
          (this.a = typeof e.a == "number" ? Hd(e.a, 1) : 1);
      else if (n("hsl")) this.fromHsl(e);
      else if (n("hsv")) this.fromHsv(e);
      else
        throw new Error(
          "@ant-design/fast-color: unsupported input " + JSON.stringify(e)
        );
  }
  setR(e) {
    return this._sc("r", e);
  }
  setG(e) {
    return this._sc("g", e);
  }
  setB(e) {
    return this._sc("b", e);
  }
  setA(e) {
    return this._sc("a", e, 1);
  }
  setHue(e) {
    const n = this.toHsv();
    return (n.h = e), this._c(n);
  }
  getLuminance() {
    function e(o) {
      const s = o / 255;
      return s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4);
    }
    const n = e(this.r),
      r = e(this.g),
      i = e(this.b);
    return 0.2126 * n + 0.7152 * r + 0.0722 * i;
  }
  getHue() {
    if (typeof this._h > "u") {
      const e = this.getMax() - this.getMin();
      e === 0
        ? (this._h = 0)
        : (this._h = vr(
            60 *
              (this.r === this.getMax()
                ? (this.g - this.b) / e + (this.g < this.b ? 6 : 0)
                : this.g === this.getMax()
                ? (this.b - this.r) / e + 2
                : (this.r - this.g) / e + 4)
          ));
    }
    return this._h;
  }
  getSaturation() {
    if (typeof this._s > "u") {
      const e = this.getMax() - this.getMin();
      e === 0 ? (this._s = 0) : (this._s = e / this.getMax());
    }
    return this._s;
  }
  getLightness() {
    return (
      typeof this._l > "u" && (this._l = (this.getMax() + this.getMin()) / 510),
      this._l
    );
  }
  getValue() {
    return typeof this._v > "u" && (this._v = this.getMax() / 255), this._v;
  }
  getBrightness() {
    return (
      typeof this._brightness > "u" &&
        (this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1e3),
      this._brightness
    );
  }
  darken(e = 10) {
    const n = this.getHue(),
      r = this.getSaturation();
    let i = this.getLightness() - e / 100;
    return i < 0 && (i = 0), this._c({ h: n, s: r, l: i, a: this.a });
  }
  lighten(e = 10) {
    const n = this.getHue(),
      r = this.getSaturation();
    let i = this.getLightness() + e / 100;
    return i > 1 && (i = 1), this._c({ h: n, s: r, l: i, a: this.a });
  }
  mix(e, n = 50) {
    const r = this._c(e),
      i = n / 100,
      o = (a) => (r[a] - this[a]) * i + this[a],
      s = {
        r: vr(o("r")),
        g: vr(o("g")),
        b: vr(o("b")),
        a: vr(o("a") * 100) / 100,
      };
    return this._c(s);
  }
  tint(e = 10) {
    return this.mix({ r: 255, g: 255, b: 255, a: 1 }, e);
  }
  shade(e = 10) {
    return this.mix({ r: 0, g: 0, b: 0, a: 1 }, e);
  }
  onBackground(e) {
    const n = this._c(e),
      r = this.a + n.a * (1 - this.a),
      i = (o) => vr((this[o] * this.a + n[o] * n.a * (1 - this.a)) / r);
    return this._c({ r: i("r"), g: i("g"), b: i("b"), a: r });
  }
  isDark() {
    return this.getBrightness() < 128;
  }
  isLight() {
    return this.getBrightness() >= 128;
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  clone() {
    return this._c(this);
  }
  toHexString() {
    let e = "#";
    const n = (this.r || 0).toString(16);
    e += n.length === 2 ? n : "0" + n;
    const r = (this.g || 0).toString(16);
    e += r.length === 2 ? r : "0" + r;
    const i = (this.b || 0).toString(16);
    if (
      ((e += i.length === 2 ? i : "0" + i),
      typeof this.a == "number" && this.a >= 0 && this.a < 1)
    ) {
      const o = vr(this.a * 255).toString(16);
      e += o.length === 2 ? o : "0" + o;
    }
    return e;
  }
  toHsl() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      l: this.getLightness(),
      a: this.a,
    };
  }
  toHslString() {
    const e = this.getHue(),
      n = vr(this.getSaturation() * 100),
      r = vr(this.getLightness() * 100);
    return this.a !== 1
      ? `hsla(${e},${n}%,${r}%,${this.a})`
      : `hsl(${e},${n}%,${r}%)`;
  }
  toHsv() {
    return {
      h: this.getHue(),
      s: this.getSaturation(),
      v: this.getValue(),
      a: this.a,
    };
  }
  toRgb() {
    return { r: this.r, g: this.g, b: this.b, a: this.a };
  }
  toRgbString() {
    return this.a !== 1
      ? `rgba(${this.r},${this.g},${this.b},${this.a})`
      : `rgb(${this.r},${this.g},${this.b})`;
  }
  toString() {
    return this.toRgbString();
  }
  _sc(e, n, r) {
    const i = this.clone();
    return (i[e] = Hd(n, r)), i;
  }
  _c(e) {
    return new this.constructor(e);
  }
  getMax() {
    return (
      typeof this._max > "u" && (this._max = Math.max(this.r, this.g, this.b)),
      this._max
    );
  }
  getMin() {
    return (
      typeof this._min > "u" && (this._min = Math.min(this.r, this.g, this.b)),
      this._min
    );
  }
  fromHexString(e) {
    const n = e.replace("#", "");
    function r(i, o) {
      return parseInt(n[i] + n[o || i], 16);
    }
    n.length < 6
      ? ((this.r = r(0)),
        (this.g = r(1)),
        (this.b = r(2)),
        (this.a = n[3] ? r(3) / 255 : 1))
      : ((this.r = r(0, 1)),
        (this.g = r(2, 3)),
        (this.b = r(4, 5)),
        (this.a = n[6] ? r(6, 7) / 255 : 1));
  }
  fromHsl({ h: e, s: n, l: r, a: i }) {
    if (
      ((this._h = e % 360),
      (this._s = n),
      (this._l = r),
      (this.a = typeof i == "number" ? i : 1),
      n <= 0)
    ) {
      const p = vr(r * 255);
      (this.r = p), (this.g = p), (this.b = p);
    }
    let o = 0,
      s = 0,
      a = 0;
    const l = e / 60,
      c = (1 - Math.abs(2 * r - 1)) * n,
      u = c * (1 - Math.abs((l % 2) - 1));
    l >= 0 && l < 1
      ? ((o = c), (s = u))
      : l >= 1 && l < 2
      ? ((o = u), (s = c))
      : l >= 2 && l < 3
      ? ((s = c), (a = u))
      : l >= 3 && l < 4
      ? ((s = u), (a = c))
      : l >= 4 && l < 5
      ? ((o = u), (a = c))
      : l >= 5 && l < 6 && ((o = c), (a = u));
    const d = r - c / 2;
    (this.r = vr((o + d) * 255)),
      (this.g = vr((s + d) * 255)),
      (this.b = vr((a + d) * 255));
  }
  fromHsv({ h: e, s: n, v: r, a: i }) {
    (this._h = e % 360),
      (this._s = n),
      (this._v = r),
      (this.a = typeof i == "number" ? i : 1);
    const o = vr(r * 255);
    if (((this.r = o), (this.g = o), (this.b = o), n <= 0)) return;
    const s = e / 60,
      a = Math.floor(s),
      l = s - a,
      c = vr(r * (1 - n) * 255),
      u = vr(r * (1 - n * l) * 255),
      d = vr(r * (1 - n * (1 - l)) * 255);
    switch (a) {
      case 0:
        (this.g = d), (this.b = c);
        break;
      case 1:
        (this.r = u), (this.b = c);
        break;
      case 2:
        (this.r = c), (this.b = d);
        break;
      case 3:
        (this.r = c), (this.g = u);
        break;
      case 4:
        (this.r = d), (this.g = c);
        break;
      case 5:
      default:
        (this.g = c), (this.b = u);
        break;
    }
  }
  fromHsvString(e) {
    const n = U_(e, VP);
    this.fromHsv({ h: n[0], s: n[1], v: n[2], a: n[3] });
  }
  fromHslString(e) {
    const n = U_(e, VP);
    this.fromHsl({ h: n[0], s: n[1], l: n[2], a: n[3] });
  }
  fromRgbString(e) {
    const n = U_(e, (r, i) => (i.includes("%") ? vr((r / 100) * 255) : r));
    (this.r = n[0]), (this.g = n[1]), (this.b = n[2]), (this.a = n[3]);
  }
}
var i0 = 2,
  GP = 0.16,
  iK = 0.05,
  oK = 0.05,
  sK = 0.15,
  yU = 5,
  xU = 4,
  aK = [
    { index: 7, amount: 15 },
    { index: 6, amount: 25 },
    { index: 5, amount: 30 },
    { index: 5, amount: 45 },
    { index: 5, amount: 65 },
    { index: 5, amount: 85 },
    { index: 4, amount: 90 },
    { index: 3, amount: 95 },
    { index: 2, amount: 97 },
    { index: 1, amount: 98 },
  ];
function WP(t, e, n) {
  var r;
  return (
    Math.round(t.h) >= 60 && Math.round(t.h) <= 240
      ? (r = n ? Math.round(t.h) - i0 * e : Math.round(t.h) + i0 * e)
      : (r = n ? Math.round(t.h) + i0 * e : Math.round(t.h) - i0 * e),
    r < 0 ? (r += 360) : r >= 360 && (r -= 360),
    r
  );
}
function jP(t, e, n) {
  if (t.h === 0 && t.s === 0) return t.s;
  var r;
  return (
    n ? (r = t.s - GP * e) : e === xU ? (r = t.s + GP) : (r = t.s + iK * e),
    r > 1 && (r = 1),
    n && e === yU && r > 0.1 && (r = 0.1),
    r < 0.06 && (r = 0.06),
    Math.round(r * 100) / 100
  );
}
function $P(t, e, n) {
  var r;
  return (
    n ? (r = t.v + oK * e) : (r = t.v - sK * e),
    (r = Math.max(0, Math.min(1, r))),
    Math.round(r * 100) / 100
  );
}
function pp(t) {
  for (
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      n = [],
      r = new Tn(t),
      i = r.toHsv(),
      o = yU;
    o > 0;
    o -= 1
  ) {
    var s = new Tn({ h: WP(i, o, !0), s: jP(i, o, !0), v: $P(i, o, !0) });
    n.push(s);
  }
  n.push(r);
  for (var a = 1; a <= xU; a += 1) {
    var l = new Tn({ h: WP(i, a), s: jP(i, a), v: $P(i, a) });
    n.push(l);
  }
  return e.theme === "dark"
    ? aK.map(function (c) {
        var u = c.index,
          d = c.amount;
        return new Tn(e.backgroundColor || "#141414")
          .mix(n[u], d)
          .toHexString();
      })
    : n.map(function (c) {
        return c.toHexString();
      });
}
var k_ = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666",
  },
  gb = [
    "#fff1f0",
    "#ffccc7",
    "#ffa39e",
    "#ff7875",
    "#ff4d4f",
    "#f5222d",
    "#cf1322",
    "#a8071a",
    "#820014",
    "#5c0011",
  ];
gb.primary = gb[5];
var vb = [
  "#fff2e8",
  "#ffd8bf",
  "#ffbb96",
  "#ff9c6e",
  "#ff7a45",
  "#fa541c",
  "#d4380d",
  "#ad2102",
  "#871400",
  "#610b00",
];
vb.primary = vb[5];
var yb = [
  "#fff7e6",
  "#ffe7ba",
  "#ffd591",
  "#ffc069",
  "#ffa940",
  "#fa8c16",
  "#d46b08",
  "#ad4e00",
  "#873800",
  "#612500",
];
yb.primary = yb[5];
var xb = [
  "#fffbe6",
  "#fff1b8",
  "#ffe58f",
  "#ffd666",
  "#ffc53d",
  "#faad14",
  "#d48806",
  "#ad6800",
  "#874d00",
  "#613400",
];
xb.primary = xb[5];
var _b = [
  "#feffe6",
  "#ffffb8",
  "#fffb8f",
  "#fff566",
  "#ffec3d",
  "#fadb14",
  "#d4b106",
  "#ad8b00",
  "#876800",
  "#614700",
];
_b.primary = _b[5];
var Sb = [
  "#fcffe6",
  "#f4ffb8",
  "#eaff8f",
  "#d3f261",
  "#bae637",
  "#a0d911",
  "#7cb305",
  "#5b8c00",
  "#3f6600",
  "#254000",
];
Sb.primary = Sb[5];
var Ab = [
  "#f6ffed",
  "#d9f7be",
  "#b7eb8f",
  "#95de64",
  "#73d13d",
  "#52c41a",
  "#389e0d",
  "#237804",
  "#135200",
  "#092b00",
];
Ab.primary = Ab[5];
var bb = [
  "#e6fffb",
  "#b5f5ec",
  "#87e8de",
  "#5cdbd3",
  "#36cfc9",
  "#13c2c2",
  "#08979c",
  "#006d75",
  "#00474f",
  "#002329",
];
bb.primary = bb[5];
var Tv = [
  "#e6f4ff",
  "#bae0ff",
  "#91caff",
  "#69b1ff",
  "#4096ff",
  "#1677ff",
  "#0958d9",
  "#003eb3",
  "#002c8c",
  "#001d66",
];
Tv.primary = Tv[5];
var wb = [
  "#f0f5ff",
  "#d6e4ff",
  "#adc6ff",
  "#85a5ff",
  "#597ef7",
  "#2f54eb",
  "#1d39c4",
  "#10239e",
  "#061178",
  "#030852",
];
wb.primary = wb[5];
var Eb = [
  "#f9f0ff",
  "#efdbff",
  "#d3adf7",
  "#b37feb",
  "#9254de",
  "#722ed1",
  "#531dab",
  "#391085",
  "#22075e",
  "#120338",
];
Eb.primary = Eb[5];
var Mb = [
  "#fff0f6",
  "#ffd6e7",
  "#ffadd2",
  "#ff85c0",
  "#f759ab",
  "#eb2f96",
  "#c41d7f",
  "#9e1068",
  "#780650",
  "#520339",
];
Mb.primary = Mb[5];
var Cb = [
  "#a6a6a6",
  "#999999",
  "#8c8c8c",
  "#808080",
  "#737373",
  "#666666",
  "#404040",
  "#1a1a1a",
  "#000000",
  "#000000",
];
Cb.primary = Cb[5];
var z_ = {
  red: gb,
  volcano: vb,
  orange: yb,
  gold: xb,
  yellow: _b,
  lime: Sb,
  green: Ab,
  cyan: bb,
  blue: Tv,
  geekblue: wb,
  purple: Eb,
  magenta: Mb,
  grey: Cb,
};
function lK(t, { generateColorPalettes: e, generateNeutralColorPalettes: n }) {
  const {
      colorSuccess: r,
      colorWarning: i,
      colorError: o,
      colorInfo: s,
      colorPrimary: a,
      colorBgBase: l,
      colorTextBase: c,
    } = t,
    u = e(a),
    d = e(r),
    p = e(i),
    m = e(o),
    v = e(s),
    _ = n(l, c),
    y = t.colorLink || t.colorInfo,
    g = e(y),
    x = new Tn(m[1]).mix(new Tn(m[3]), 50).toHexString();
  return Object.assign(Object.assign({}, _), {
    colorPrimaryBg: u[1],
    colorPrimaryBgHover: u[2],
    colorPrimaryBorder: u[3],
    colorPrimaryBorderHover: u[4],
    colorPrimaryHover: u[5],
    colorPrimary: u[6],
    colorPrimaryActive: u[7],
    colorPrimaryTextHover: u[8],
    colorPrimaryText: u[9],
    colorPrimaryTextActive: u[10],
    colorSuccessBg: d[1],
    colorSuccessBgHover: d[2],
    colorSuccessBorder: d[3],
    colorSuccessBorderHover: d[4],
    colorSuccessHover: d[4],
    colorSuccess: d[6],
    colorSuccessActive: d[7],
    colorSuccessTextHover: d[8],
    colorSuccessText: d[9],
    colorSuccessTextActive: d[10],
    colorErrorBg: m[1],
    colorErrorBgHover: m[2],
    colorErrorBgFilledHover: x,
    colorErrorBgActive: m[3],
    colorErrorBorder: m[3],
    colorErrorBorderHover: m[4],
    colorErrorHover: m[5],
    colorError: m[6],
    colorErrorActive: m[7],
    colorErrorTextHover: m[8],
    colorErrorText: m[9],
    colorErrorTextActive: m[10],
    colorWarningBg: p[1],
    colorWarningBgHover: p[2],
    colorWarningBorder: p[3],
    colorWarningBorderHover: p[4],
    colorWarningHover: p[4],
    colorWarning: p[6],
    colorWarningActive: p[7],
    colorWarningTextHover: p[8],
    colorWarningText: p[9],
    colorWarningTextActive: p[10],
    colorInfoBg: v[1],
    colorInfoBgHover: v[2],
    colorInfoBorder: v[3],
    colorInfoBorderHover: v[4],
    colorInfoHover: v[4],
    colorInfo: v[6],
    colorInfoActive: v[7],
    colorInfoTextHover: v[8],
    colorInfoText: v[9],
    colorInfoTextActive: v[10],
    colorLinkHover: g[4],
    colorLink: g[6],
    colorLinkActive: g[7],
    colorBgMask: new Tn("#000").setA(0.45).toRgbString(),
    colorWhite: "#fff",
  });
}
const cK = (t) => {
  let e = t,
    n = t,
    r = t,
    i = t;
  return (
    t < 6 && t >= 5
      ? (e = t + 1)
      : t < 16 && t >= 6
      ? (e = t + 2)
      : t >= 16 && (e = 16),
    t < 7 && t >= 5
      ? (n = 4)
      : t < 8 && t >= 7
      ? (n = 5)
      : t < 14 && t >= 8
      ? (n = 6)
      : t < 16 && t >= 14
      ? (n = 7)
      : t >= 16 && (n = 8),
    t < 6 && t >= 2 ? (r = 1) : t >= 6 && (r = 2),
    t > 4 && t < 8 ? (i = 4) : t >= 8 && (i = 6),
    {
      borderRadius: t,
      borderRadiusXS: r,
      borderRadiusSM: n,
      borderRadiusLG: e,
      borderRadiusOuter: i,
    }
  );
};
function uK(t) {
  const { motionUnit: e, motionBase: n, borderRadius: r, lineWidth: i } = t;
  return Object.assign(
    {
      motionDurationFast: `${(n + e).toFixed(1)}s`,
      motionDurationMid: `${(n + e * 2).toFixed(1)}s`,
      motionDurationSlow: `${(n + e * 3).toFixed(1)}s`,
      lineWidthBold: i + 1,
    },
    cK(r)
  );
}
const fK = (t) => {
  const { controlHeight: e } = t;
  return {
    controlHeightSM: e * 0.75,
    controlHeightXS: e * 0.5,
    controlHeightLG: e * 1.25,
  };
};
function H0(t) {
  return (t + 8) / t;
}
function dK(t) {
  const e = Array.from({ length: 10 }).map((n, r) => {
    const i = r - 1,
      o = t * Math.pow(Math.E, i / 5),
      s = r > 1 ? Math.floor(o) : Math.ceil(o);
    return Math.floor(s / 2) * 2;
  });
  return (e[1] = t), e.map((n) => ({ size: n, lineHeight: H0(n) }));
}
const hK = (t) => {
  const e = dK(t),
    n = e.map((u) => u.size),
    r = e.map((u) => u.lineHeight),
    i = n[1],
    o = n[0],
    s = n[2],
    a = r[1],
    l = r[0],
    c = r[2];
  return {
    fontSizeSM: o,
    fontSize: i,
    fontSizeLG: s,
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: a,
    lineHeightLG: c,
    lineHeightSM: l,
    fontHeight: Math.round(a * i),
    fontHeightLG: Math.round(c * s),
    fontHeightSM: Math.round(l * o),
    lineHeightHeading1: r[6],
    lineHeightHeading2: r[5],
    lineHeightHeading3: r[4],
    lineHeightHeading4: r[3],
    lineHeightHeading5: r[2],
  };
};
function pK(t) {
  const { sizeUnit: e, sizeStep: n } = t;
  return {
    sizeXXL: e * (n + 8),
    sizeXL: e * (n + 4),
    sizeLG: e * (n + 2),
    sizeMD: e * (n + 1),
    sizeMS: e * n,
    size: e * n,
    sizeSM: e * (n - 1),
    sizeXS: e * (n - 2),
    sizeXXS: e * (n - 3),
  };
}
const lo = (t, e) => new Tn(t).setA(e).toRgbString(),
  Vd = (t, e) => new Tn(t).darken(e).toHexString(),
  mK = (t) => {
    const e = pp(t);
    return {
      1: e[0],
      2: e[1],
      3: e[2],
      4: e[3],
      5: e[4],
      6: e[5],
      7: e[6],
      8: e[4],
      9: e[5],
      10: e[6],
    };
  },
  gK = (t, e) => {
    const n = t || "#fff",
      r = e || "#000";
    return {
      colorBgBase: n,
      colorTextBase: r,
      colorText: lo(r, 0.88),
      colorTextSecondary: lo(r, 0.65),
      colorTextTertiary: lo(r, 0.45),
      colorTextQuaternary: lo(r, 0.25),
      colorFill: lo(r, 0.15),
      colorFillSecondary: lo(r, 0.06),
      colorFillTertiary: lo(r, 0.04),
      colorFillQuaternary: lo(r, 0.02),
      colorBgSolid: lo(r, 1),
      colorBgSolidHover: lo(r, 0.75),
      colorBgSolidActive: lo(r, 0.95),
      colorBgLayout: Vd(n, 4),
      colorBgContainer: Vd(n, 0),
      colorBgElevated: Vd(n, 0),
      colorBgSpotlight: lo(r, 0.85),
      colorBgBlur: "transparent",
      colorBorder: Vd(n, 15),
      colorBorderSecondary: Vd(n, 6),
    };
  };
function vK(t) {
  (k_.pink = k_.magenta), (z_.pink = z_.magenta);
  const e = Object.keys(vU)
    .map((n) => {
      const r = t[n] === k_[n] ? z_[n] : pp(t[n]);
      return Array.from({ length: 10 }, () => 1).reduce(
        (i, o, s) => (
          (i[`${n}-${s + 1}`] = r[s]), (i[`${n}${s + 1}`] = r[s]), i
        ),
        {}
      );
    })
    .reduce((n, r) => ((n = Object.assign(Object.assign({}, n), r)), n), {});
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, t), e),
            lK(t, {
              generateColorPalettes: mK,
              generateNeutralColorPalettes: gK,
            })
          ),
          hK(t.fontSize)
        ),
        pK(t)
      ),
      fK(t)
    ),
    uK(t)
  );
}
const _U = fb(vK),
  Tb = { token: hp, override: { override: hp }, hashed: !0 },
  SU = We.createContext(Tb),
  mp = "ant",
  Yy = "anticon",
  yK = ["outlined", "borderless", "filled", "underlined"],
  xK = (t, e) => e || (t ? `${mp}-${t}` : mp),
  Sn = L.createContext({ getPrefixCls: xK, iconPrefixCls: Yy }),
  { Consumer: pre } = Sn,
  XP = {};
function qy(t) {
  const e = L.useContext(Sn),
    { getPrefixCls: n, direction: r, getPopupContainer: i } = e,
    o = e[t];
  return Object.assign(Object.assign({ classNames: XP, styles: XP }, o), {
    getPrefixCls: n,
    direction: r,
    getPopupContainer: i,
  });
}
const _K = `-ant-${Date.now()}-${Math.random()}`;
function SK(t, e) {
  const n = {},
    r = (s, a) => {
      let l = s.clone();
      return (l = (a == null ? void 0 : a(l)) || l), l.toRgbString();
    },
    i = (s, a) => {
      const l = new Tn(s),
        c = pp(l.toRgbString());
      (n[`${a}-color`] = r(l)),
        (n[`${a}-color-disabled`] = c[1]),
        (n[`${a}-color-hover`] = c[4]),
        (n[`${a}-color-active`] = c[6]),
        (n[`${a}-color-outline`] = l.clone().setA(0.2).toRgbString()),
        (n[`${a}-color-deprecated-bg`] = c[0]),
        (n[`${a}-color-deprecated-border`] = c[2]);
    };
  if (e.primaryColor) {
    i(e.primaryColor, "primary");
    const s = new Tn(e.primaryColor),
      a = pp(s.toRgbString());
    a.forEach((c, u) => {
      n[`primary-${u + 1}`] = c;
    }),
      (n["primary-color-deprecated-l-35"] = r(s, (c) => c.lighten(35))),
      (n["primary-color-deprecated-l-20"] = r(s, (c) => c.lighten(20))),
      (n["primary-color-deprecated-t-20"] = r(s, (c) => c.tint(20))),
      (n["primary-color-deprecated-t-50"] = r(s, (c) => c.tint(50))),
      (n["primary-color-deprecated-f-12"] = r(s, (c) => c.setA(c.a * 0.12)));
    const l = new Tn(a[0]);
    (n["primary-color-active-deprecated-f-30"] = r(l, (c) =>
      c.setA(c.a * 0.3)
    )),
      (n["primary-color-active-deprecated-d-02"] = r(l, (c) => c.darken(2)));
  }
  return (
    e.successColor && i(e.successColor, "success"),
    e.warningColor && i(e.warningColor, "warning"),
    e.errorColor && i(e.errorColor, "error"),
    e.infoColor && i(e.infoColor, "info"),
    `
  :root {
    ${Object.keys(n).map((s) => `--${t}-${s}: ${n[s]};`).join(`
`)}
  }
  `.trim()
  );
}
function AK(t, e) {
  const n = SK(t, e);
  la() && vc(n, `${_K}-dynamic-theme`);
}
const rl = L.createContext(!1),
  bK = ({ children: t, disabled: e }) => {
    const n = L.useContext(rl);
    return L.createElement(rl.Provider, { value: e ?? n }, t);
  },
  Tf = L.createContext(void 0),
  wK = ({ children: t, size: e }) => {
    const n = L.useContext(Tf);
    return L.createElement(Tf.Provider, { value: e || n }, t);
  };
function EK() {
  const t = L.useContext(rl),
    e = L.useContext(Tf);
  return { componentDisabled: t, componentSize: e };
}
var AU = Ar(function t() {
    Sr(this, t);
  }),
  bU = "CALC_UNIT",
  MK = new RegExp(bU, "g");
function B_(t) {
  return typeof t == "number" ? "".concat(t).concat(bU) : t;
}
var CK = (function (t) {
    ul(n, t);
    var e = fl(n);
    function n(r, i) {
      var o;
      Sr(this, n),
        (o = e.call(this)),
        ve(zt(o), "result", ""),
        ve(zt(o), "unitlessCssVar", void 0),
        ve(zt(o), "lowPriority", void 0);
      var s = bt(r);
      return (
        (o.unitlessCssVar = i),
        r instanceof n
          ? (o.result = "(".concat(r.result, ")"))
          : s === "number"
          ? (o.result = B_(r))
          : s === "string" && (o.result = r),
        o
      );
    }
    return (
      Ar(n, [
        {
          key: "add",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result = ""
                    .concat(this.result, " + ")
                    .concat(i.getResult()))
                : (typeof i == "number" || typeof i == "string") &&
                  (this.result = "".concat(this.result, " + ").concat(B_(i))),
              (this.lowPriority = !0),
              this
            );
          },
        },
        {
          key: "sub",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result = ""
                    .concat(this.result, " - ")
                    .concat(i.getResult()))
                : (typeof i == "number" || typeof i == "string") &&
                  (this.result = "".concat(this.result, " - ").concat(B_(i))),
              (this.lowPriority = !0),
              this
            );
          },
        },
        {
          key: "mul",
          value: function (i) {
            return (
              this.lowPriority && (this.result = "(".concat(this.result, ")")),
              i instanceof n
                ? (this.result = ""
                    .concat(this.result, " * ")
                    .concat(i.getResult(!0)))
                : (typeof i == "number" || typeof i == "string") &&
                  (this.result = "".concat(this.result, " * ").concat(i)),
              (this.lowPriority = !1),
              this
            );
          },
        },
        {
          key: "div",
          value: function (i) {
            return (
              this.lowPriority && (this.result = "(".concat(this.result, ")")),
              i instanceof n
                ? (this.result = ""
                    .concat(this.result, " / ")
                    .concat(i.getResult(!0)))
                : (typeof i == "number" || typeof i == "string") &&
                  (this.result = "".concat(this.result, " / ").concat(i)),
              (this.lowPriority = !1),
              this
            );
          },
        },
        {
          key: "getResult",
          value: function (i) {
            return this.lowPriority || i
              ? "(".concat(this.result, ")")
              : this.result;
          },
        },
        {
          key: "equal",
          value: function (i) {
            var o = this,
              s = i || {},
              a = s.unit,
              l = !0;
            return (
              typeof a == "boolean"
                ? (l = a)
                : Array.from(this.unitlessCssVar).some(function (c) {
                    return o.result.includes(c);
                  }) && (l = !1),
              (this.result = this.result.replace(MK, l ? "px" : "")),
              typeof this.lowPriority < "u"
                ? "calc(".concat(this.result, ")")
                : this.result
            );
          },
        },
      ]),
      n
    );
  })(AU),
  TK = (function (t) {
    ul(n, t);
    var e = fl(n);
    function n(r) {
      var i;
      return (
        Sr(this, n),
        (i = e.call(this)),
        ve(zt(i), "result", 0),
        r instanceof n
          ? (i.result = r.result)
          : typeof r == "number" && (i.result = r),
        i
      );
    }
    return (
      Ar(n, [
        {
          key: "add",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result += i.result)
                : typeof i == "number" && (this.result += i),
              this
            );
          },
        },
        {
          key: "sub",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result -= i.result)
                : typeof i == "number" && (this.result -= i),
              this
            );
          },
        },
        {
          key: "mul",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result *= i.result)
                : typeof i == "number" && (this.result *= i),
              this
            );
          },
        },
        {
          key: "div",
          value: function (i) {
            return (
              i instanceof n
                ? (this.result /= i.result)
                : typeof i == "number" && (this.result /= i),
              this
            );
          },
        },
        {
          key: "equal",
          value: function () {
            return this.result;
          },
        },
      ]),
      n
    );
  })(AU),
  RK = function (e, n) {
    var r = e === "css" ? CK : TK;
    return function (i) {
      return new r(i, n);
    };
  },
  YP = function (e, n) {
    return "".concat(
      [
        n,
        e
          .replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2")
          .replace(/([a-z])([A-Z])/g, "$1-$2"),
      ]
        .filter(Boolean)
        .join("-")
    );
  };
function na(t) {
  var e = L.useRef();
  e.current = t;
  var n = L.useCallback(function () {
    for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return (r = e.current) === null || r === void 0
      ? void 0
      : r.call.apply(r, [e].concat(o));
  }, []);
  return n;
}
function gp(t) {
  var e = L.useRef(!1),
    n = L.useState(t),
    r = ot(n, 2),
    i = r[0],
    o = r[1];
  L.useEffect(function () {
    return (
      (e.current = !1),
      function () {
        e.current = !0;
      }
    );
  }, []);
  function s(a, l) {
    (l && e.current) || o(a);
  }
  return [i, s];
}
function H_(t) {
  return t !== void 0;
}
function Hf(t, e) {
  var n = e || {},
    r = n.defaultValue,
    i = n.value,
    o = n.onChange,
    s = n.postState,
    a = gp(function () {
      return H_(i)
        ? i
        : H_(r)
        ? typeof r == "function"
          ? r()
          : r
        : typeof t == "function"
        ? t()
        : t;
    }),
    l = ot(a, 2),
    c = l[0],
    u = l[1],
    d = i !== void 0 ? i : c,
    p = s ? s(d) : d,
    m = na(o),
    v = gp([d]),
    _ = ot(v, 2),
    y = _[0],
    g = _[1];
  OP(
    function () {
      var S = y[0];
      c !== S && m(c, S);
    },
    [y]
  ),
    OP(
      function () {
        H_(i) || u(i);
      },
      [i]
    );
  var x = na(function (S, b) {
    u(S, b), g([d], b);
  });
  return [p, x];
}
function qP(t, e, n, r) {
  var i = Fe({}, e[t]);
  if (r != null && r.deprecatedTokens) {
    var o = r.deprecatedTokens;
    o.forEach(function (a) {
      var l = ot(a, 2),
        c = l[0],
        u = l[1];
      if ((i != null && i[c]) || (i != null && i[u])) {
        var d;
        ((d = i[u]) !== null && d !== void 0) ||
          (i[u] = i == null ? void 0 : i[c]);
      }
    });
  }
  var s = Fe(Fe({}, n), i);
  return (
    Object.keys(s).forEach(function (a) {
      s[a] === e[a] && delete s[a];
    }),
    s
  );
}
var wU = typeof CSSINJS_STATISTIC < "u",
  Rb = !0;
function di() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  if (!wU) return Object.assign.apply(Object, [{}].concat(e));
  Rb = !1;
  var r = {};
  return (
    e.forEach(function (i) {
      if (bt(i) === "object") {
        var o = Object.keys(i);
        o.forEach(function (s) {
          Object.defineProperty(r, s, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              return i[s];
            },
          });
        });
      }
    }),
    (Rb = !0),
    r
  );
}
var KP = {};
function PK() {}
var IK = function (e) {
  var n,
    r = e,
    i = PK;
  return (
    wU &&
      typeof Proxy < "u" &&
      ((n = new Set()),
      (r = new Proxy(e, {
        get: function (s, a) {
          if (Rb) {
            var l;
            (l = n) === null || l === void 0 || l.add(a);
          }
          return s[a];
        },
      })),
      (i = function (s, a) {
        var l;
        KP[s] = {
          global: Array.from(n),
          component: Fe(
            Fe({}, (l = KP[s]) === null || l === void 0 ? void 0 : l.component),
            a
          ),
        };
      })),
    { token: r, keys: n, flush: i }
  );
};
function ZP(t, e, n) {
  if (typeof n == "function") {
    var r;
    return n(di(e, (r = e[t]) !== null && r !== void 0 ? r : {}));
  }
  return n ?? {};
}
function LK(t) {
  return t === "js"
    ? { max: Math.max, min: Math.min }
    : {
        max: function () {
          for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
            r[i] = arguments[i];
          return "max(".concat(
            r
              .map(function (o) {
                return Tt(o);
              })
              .join(","),
            ")"
          );
        },
        min: function () {
          for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
            r[i] = arguments[i];
          return "min(".concat(
            r
              .map(function (o) {
                return Tt(o);
              })
              .join(","),
            ")"
          );
        },
      };
}
var OK = 1e3 * 60 * 10,
  NK = (function () {
    function t() {
      Sr(this, t),
        ve(this, "map", new Map()),
        ve(this, "objectIDMap", new WeakMap()),
        ve(this, "nextID", 0),
        ve(this, "lastAccessBeat", new Map()),
        ve(this, "accessBeat", 0);
    }
    return (
      Ar(t, [
        {
          key: "set",
          value: function (n, r) {
            this.clear();
            var i = this.getCompositeKey(n);
            this.map.set(i, r), this.lastAccessBeat.set(i, Date.now());
          },
        },
        {
          key: "get",
          value: function (n) {
            var r = this.getCompositeKey(n),
              i = this.map.get(r);
            return (
              this.lastAccessBeat.set(r, Date.now()), (this.accessBeat += 1), i
            );
          },
        },
        {
          key: "getCompositeKey",
          value: function (n) {
            var r = this,
              i = n.map(function (o) {
                return o && bt(o) === "object"
                  ? "obj_".concat(r.getObjectID(o))
                  : "".concat(bt(o), "_").concat(o);
              });
            return i.join("|");
          },
        },
        {
          key: "getObjectID",
          value: function (n) {
            if (this.objectIDMap.has(n)) return this.objectIDMap.get(n);
            var r = this.nextID;
            return this.objectIDMap.set(n, r), (this.nextID += 1), r;
          },
        },
        {
          key: "clear",
          value: function () {
            var n = this;
            if (this.accessBeat > 1e4) {
              var r = Date.now();
              this.lastAccessBeat.forEach(function (i, o) {
                r - i > OK && (n.map.delete(o), n.lastAccessBeat.delete(o));
              }),
                (this.accessBeat = 0);
            }
          },
        },
      ]),
      t
    );
  })(),
  JP = new NK();
function DK(t, e) {
  return We.useMemo(function () {
    var n = JP.get(e);
    if (n) return n;
    var r = t();
    return JP.set(e, r), r;
  }, e);
}
var FK = function () {
  return {};
};
function UK(t) {
  var e = t.useCSP,
    n = e === void 0 ? FK : e,
    r = t.useToken,
    i = t.usePrefix,
    o = t.getResetStyles,
    s = t.getCommonStyle,
    a = t.getCompUnitless;
  function l(p, m, v, _) {
    var y = Array.isArray(p) ? p[0] : p;
    function g(P) {
      return ""
        .concat(String(y))
        .concat(P.slice(0, 1).toUpperCase())
        .concat(P.slice(1));
    }
    var x = (_ == null ? void 0 : _.unitless) || {},
      S = typeof a == "function" ? a(p) : {},
      b = Fe(Fe({}, S), {}, ve({}, g("zIndexPopup"), !0));
    Object.keys(x).forEach(function (P) {
      b[g(P)] = x[P];
    });
    var C = Fe(Fe({}, _), {}, { unitless: b, prefixToken: g }),
      M = u(p, m, v, C),
      T = c(y, v, C);
    return function (P) {
      var R =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : P,
        E = M(P, R),
        O = ot(E, 2),
        D = O[1],
        N = T(R),
        z = ot(N, 2),
        V = z[0],
        G = z[1];
      return [V, D, G];
    };
  }
  function c(p, m, v) {
    var _ = v.unitless,
      y = v.injectStyle,
      g = y === void 0 ? !0 : y,
      x = v.prefixToken,
      S = v.ignore,
      b = function (T) {
        var P = T.rootCls,
          R = T.cssVar,
          E = R === void 0 ? {} : R,
          O = r(),
          D = O.realToken;
        return (
          Yq(
            {
              path: [p],
              prefix: E.prefix,
              key: E.key,
              unitless: _,
              ignore: S,
              token: D,
              scope: P,
            },
            function () {
              var N = ZP(p, D, m),
                z = qP(p, D, N, {
                  deprecatedTokens: v == null ? void 0 : v.deprecatedTokens,
                });
              return (
                Object.keys(N).forEach(function (V) {
                  (z[x(V)] = z[V]), delete z[V];
                }),
                z
              );
            }
          ),
          null
        );
      },
      C = function (T) {
        var P = r(),
          R = P.cssVar;
        return [
          function (E) {
            return g && R
              ? We.createElement(
                  We.Fragment,
                  null,
                  We.createElement(b, { rootCls: T, cssVar: R, component: p }),
                  E
                )
              : E;
          },
          R == null ? void 0 : R.key,
        ];
      };
    return C;
  }
  function u(p, m, v) {
    var _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
      y = Array.isArray(p) ? p : [p, p],
      g = ot(y, 1),
      x = g[0],
      S = y.join("-"),
      b = t.layer || { name: "antd" };
    return function (C) {
      var M =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : C,
        T = r(),
        P = T.theme,
        R = T.realToken,
        E = T.hashId,
        O = T.token,
        D = T.cssVar,
        N = i(),
        z = N.rootPrefixCls,
        V = N.iconPrefixCls,
        G = n(),
        Y = D ? "css" : "js",
        U = DK(
          function () {
            var H = new Set();
            return (
              D &&
                Object.keys(_.unitless || {}).forEach(function (X) {
                  H.add(D0(X, D.prefix)), H.add(D0(X, YP(x, D.prefix)));
                }),
              RK(Y, H)
            );
          },
          [Y, x, D == null ? void 0 : D.prefix]
        ),
        j = LK(Y),
        W = j.max,
        B = j.min,
        q = {
          theme: P,
          token: O,
          hashId: E,
          nonce: function () {
            return G.nonce;
          },
          clientOnly: _.clientOnly,
          layer: b,
          order: _.order || -999,
        };
      typeof o == "function" &&
        mb(
          Fe(Fe({}, q), {}, { clientOnly: !1, path: ["Shared", z] }),
          function () {
            return o(O, {
              prefix: { rootPrefixCls: z, iconPrefixCls: V },
              csp: G,
            });
          }
        );
      var Z = mb(Fe(Fe({}, q), {}, { path: [S, C, V] }), function () {
        if (_.injectStyle === !1) return [];
        var H = IK(O),
          X = H.token,
          ne = H.flush,
          oe = ZP(x, R, v),
          ue = ".".concat(C),
          Ie = qP(x, R, oe, { deprecatedTokens: _.deprecatedTokens });
        D &&
          oe &&
          bt(oe) === "object" &&
          Object.keys(oe).forEach(function (pe) {
            oe[pe] = "var(".concat(D0(pe, YP(x, D.prefix)), ")");
          });
        var te = di(
            X,
            {
              componentCls: ue,
              prefixCls: C,
              iconCls: ".".concat(V),
              antCls: ".".concat(z),
              calc: U,
              max: W,
              min: B,
            },
            D ? oe : Ie
          ),
          ge = m(te, {
            hashId: E,
            prefixCls: C,
            rootPrefixCls: z,
            iconPrefixCls: V,
          });
        ne(x, Ie);
        var ie = typeof s == "function" ? s(te, C, M, _.resetFont) : null;
        return [_.resetStyle === !1 ? null : ie, ge];
      });
      return [Z, E];
    };
  }
  function d(p, m, v) {
    var _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
      y = u(p, m, v, Fe({ resetStyle: !1, order: -998 }, _)),
      g = function (S) {
        var b = S.prefixCls,
          C = S.rootCls,
          M = C === void 0 ? b : C;
        return y(b, M), null;
      };
    return g;
  }
  return {
    genStyleHooks: l,
    genSubStyleComponent: d,
    genComponentStyleHook: u,
  };
}
const iM = [
    "blue",
    "purple",
    "cyan",
    "green",
    "magenta",
    "pink",
    "red",
    "orange",
    "yellow",
    "volcano",
    "geekblue",
    "lime",
    "gold",
  ],
  kK = "5.27.2";
function V_(t) {
  return t >= 0 && t <= 255;
}
function Qd(t, e) {
  const { r: n, g: r, b: i, a: o } = new Tn(t).toRgb();
  if (o < 1) return t;
  const { r: s, g: a, b: l } = new Tn(e).toRgb();
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((n - s * (1 - c)) / c),
      d = Math.round((r - a * (1 - c)) / c),
      p = Math.round((i - l * (1 - c)) / c);
    if (V_(u) && V_(d) && V_(p))
      return new Tn({
        r: u,
        g: d,
        b: p,
        a: Math.round(c * 100) / 100,
      }).toRgbString();
  }
  return new Tn({ r: n, g: r, b: i, a: 1 }).toRgbString();
}
var zK = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function EU(t) {
  const { override: e } = t,
    n = zK(t, ["override"]),
    r = Object.assign({}, e);
  Object.keys(hp).forEach((p) => {
    delete r[p];
  });
  const i = Object.assign(Object.assign({}, n), r),
    o = 480,
    s = 576,
    a = 768,
    l = 992,
    c = 1200,
    u = 1600;
  if (i.motion === !1) {
    const p = "0s";
    (i.motionDurationFast = p),
      (i.motionDurationMid = p),
      (i.motionDurationSlow = p);
  }
  return Object.assign(
    Object.assign(Object.assign({}, i), {
      colorFillContent: i.colorFillSecondary,
      colorFillContentHover: i.colorFill,
      colorFillAlter: i.colorFillQuaternary,
      colorBgContainerDisabled: i.colorFillTertiary,
      colorBorderBg: i.colorBgContainer,
      colorSplit: Qd(i.colorBorderSecondary, i.colorBgContainer),
      colorTextPlaceholder: i.colorTextQuaternary,
      colorTextDisabled: i.colorTextQuaternary,
      colorTextHeading: i.colorText,
      colorTextLabel: i.colorTextSecondary,
      colorTextDescription: i.colorTextTertiary,
      colorTextLightSolid: i.colorWhite,
      colorHighlight: i.colorError,
      colorBgTextHover: i.colorFillSecondary,
      colorBgTextActive: i.colorFill,
      colorIcon: i.colorTextTertiary,
      colorIconHover: i.colorText,
      colorErrorOutline: Qd(i.colorErrorBg, i.colorBgContainer),
      colorWarningOutline: Qd(i.colorWarningBg, i.colorBgContainer),
      fontSizeIcon: i.fontSizeSM,
      lineWidthFocus: i.lineWidth * 3,
      lineWidth: i.lineWidth,
      controlOutlineWidth: i.lineWidth * 2,
      controlInteractiveSize: i.controlHeight / 2,
      controlItemBgHover: i.colorFillTertiary,
      controlItemBgActive: i.colorPrimaryBg,
      controlItemBgActiveHover: i.colorPrimaryBgHover,
      controlItemBgActiveDisabled: i.colorFill,
      controlTmpOutline: i.colorFillQuaternary,
      controlOutline: Qd(i.colorPrimaryBg, i.colorBgContainer),
      lineType: i.lineType,
      borderRadius: i.borderRadius,
      borderRadiusXS: i.borderRadiusXS,
      borderRadiusSM: i.borderRadiusSM,
      borderRadiusLG: i.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: i.sizeXXS,
      paddingXS: i.sizeXS,
      paddingSM: i.sizeSM,
      padding: i.size,
      paddingMD: i.sizeMD,
      paddingLG: i.sizeLG,
      paddingXL: i.sizeXL,
      paddingContentHorizontalLG: i.sizeLG,
      paddingContentVerticalLG: i.sizeMS,
      paddingContentHorizontal: i.sizeMS,
      paddingContentVertical: i.sizeSM,
      paddingContentHorizontalSM: i.size,
      paddingContentVerticalSM: i.sizeXS,
      marginXXS: i.sizeXXS,
      marginXS: i.sizeXS,
      marginSM: i.sizeSM,
      margin: i.size,
      marginMD: i.sizeMD,
      marginLG: i.sizeLG,
      marginXL: i.sizeXL,
      marginXXL: i.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS: o,
      screenXSMin: o,
      screenXSMax: s - 1,
      screenSM: s,
      screenSMMin: s,
      screenSMMax: a - 1,
      screenMD: a,
      screenMDMin: a,
      screenMDMax: l - 1,
      screenLG: l,
      screenLGMin: l,
      screenLGMax: c - 1,
      screenXL: c,
      screenXLMin: c,
      screenXLMax: u - 1,
      screenXXL: u,
      screenXXLMin: u,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new Tn("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Tn("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Tn("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    }),
    r
  );
}
var QP = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const MU = {
    lineHeight: !0,
    lineHeightSM: !0,
    lineHeightLG: !0,
    lineHeightHeading1: !0,
    lineHeightHeading2: !0,
    lineHeightHeading3: !0,
    lineHeightHeading4: !0,
    lineHeightHeading5: !0,
    opacityLoading: !0,
    fontWeightStrong: !0,
    zIndexPopupBase: !0,
    zIndexBase: !0,
    opacityImage: !0,
  },
  BK = { motionBase: !0, motionUnit: !0 },
  HK = {
    screenXS: !0,
    screenXSMin: !0,
    screenXSMax: !0,
    screenSM: !0,
    screenSMMin: !0,
    screenSMMax: !0,
    screenMD: !0,
    screenMDMin: !0,
    screenMDMax: !0,
    screenLG: !0,
    screenLGMin: !0,
    screenLGMax: !0,
    screenXL: !0,
    screenXLMin: !0,
    screenXLMax: !0,
    screenXXL: !0,
    screenXXLMin: !0,
  },
  CU = (t, e, n) => {
    const r = n.getDerivativeToken(t),
      { override: i } = e,
      o = QP(e, ["override"]);
    let s = Object.assign(Object.assign({}, r), { override: i });
    return (
      (s = EU(s)),
      o &&
        Object.entries(o).forEach(([a, l]) => {
          const { theme: c } = l,
            u = QP(l, ["theme"]);
          let d = u;
          c &&
            (d = CU(
              Object.assign(Object.assign({}, s), u),
              { override: u },
              c
            )),
            (s[a] = d);
        }),
      s
    );
  };
function Vf() {
  const {
      token: t,
      hashed: e,
      theme: n,
      override: r,
      cssVar: i,
    } = We.useContext(SU),
    o = `${kK}-${e || ""}`,
    s = n || _U,
    [a, l, c] = _q(s, [hp, t], {
      salt: o,
      override: r,
      getComputedToken: CU,
      formatToken: EU,
      cssVar: i && {
        prefix: i.prefix,
        key: i.key,
        unitless: MU,
        ignore: BK,
        preserve: HK,
      },
    });
  return [s, c, e ? l : "", a, i];
}
const Pc = (t, e = !1) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: t.colorText,
    fontSize: t.fontSize,
    lineHeight: t.lineHeight,
    listStyle: "none",
    fontFamily: e ? "inherit" : t.fontFamily,
  }),
  oM = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": { lineHeight: 1 },
    svg: { display: "inline-block" },
  }),
  VK = () => ({
    "&::before": { display: "table", content: '""' },
    "&::after": { display: "table", clear: "both", content: '""' },
  }),
  GK = (t) => ({
    a: {
      color: t.colorLink,
      textDecoration: t.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${t.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": { color: t.colorLinkHover },
      "&:active": { color: t.colorLinkActive },
      "&:active, &:hover": {
        textDecoration: t.linkHoverDecoration,
        outline: 0,
      },
      "&:focus": { textDecoration: t.linkFocusDecoration, outline: 0 },
      "&[disabled]": { color: t.colorTextDisabled, cursor: "not-allowed" },
    },
  }),
  WK = (t, e, n, r) => {
    const i = `[class^="${e}"], [class*=" ${e}"]`,
      o = n ? `.${n}` : i,
      s = {
        boxSizing: "border-box",
        "&::before, &::after": { boxSizing: "border-box" },
      };
    let a = {};
    return (
      r !== !1 && (a = { fontFamily: t.fontFamily, fontSize: t.fontSize }),
      { [o]: Object.assign(Object.assign(Object.assign({}, a), s), { [i]: s }) }
    );
  },
  sM = (t, e) => ({
    outline: `${Tt(t.lineWidthFocus)} solid ${t.colorPrimaryBorder}`,
    outlineOffset: e ?? 1,
    transition: "outline-offset 0s, outline 0s",
  }),
  TU = (t, e) => ({ "&:focus-visible": sM(t, e) }),
  RU = (t) => ({
    [`.${t}`]: Object.assign(Object.assign({}, oM()), {
      [`.${t} .${t}-icon`]: { display: "block" },
    }),
  }),
  {
    genStyleHooks: dl,
    genComponentStyleHook: jK,
    genSubStyleComponent: $K,
  } = UK({
    usePrefix: () => {
      const { getPrefixCls: t, iconPrefixCls: e } = L.useContext(Sn);
      return { rootPrefixCls: t(), iconPrefixCls: e };
    },
    useToken: () => {
      const [t, e, n, r, i] = Vf();
      return { theme: t, realToken: e, hashId: n, token: r, cssVar: i };
    },
    useCSP: () => {
      const { csp: t } = L.useContext(Sn);
      return t ?? {};
    },
    getResetStyles: (t, e) => {
      var n;
      const r = GK(t);
      return [
        r,
        { "&": r },
        RU(
          (n = e == null ? void 0 : e.prefix.iconPrefixCls) !== null &&
            n !== void 0
            ? n
            : Yy
        ),
      ];
    },
    getCommonStyle: WK,
    getCompUnitless: () => MU,
  }),
  XK = (t, e) => {
    const [n, r] = Vf();
    return mb(
      {
        token: r,
        hashId: "",
        path: ["ant-design-icons", t],
        nonce: () => (e == null ? void 0 : e.nonce),
        layer: { name: "antd" },
      },
      () => RU(t)
    );
  },
  YK = Object.assign({}, Fv),
  { useId: e3 } = YK,
  qK = () => "",
  KK = typeof e3 > "u" ? qK : e3;
function ZK(t, e, n) {
  var r;
  const i = t || {},
    o =
      i.inherit === !1 || !e
        ? Object.assign(Object.assign({}, Tb), {
            hashed:
              (r = e == null ? void 0 : e.hashed) !== null && r !== void 0
                ? r
                : Tb.hashed,
            cssVar: e == null ? void 0 : e.cssVar,
          })
        : e,
    s = KK();
  return $E(
    () => {
      var a, l;
      if (!t) return e;
      const c = Object.assign({}, o.components);
      Object.keys(t.components || {}).forEach((p) => {
        c[p] = Object.assign(Object.assign({}, c[p]), t.components[p]);
      });
      const u = `css-var-${s.replace(/:/g, "")}`,
        d =
          ((a = i.cssVar) !== null && a !== void 0 ? a : o.cssVar) &&
          Object.assign(
            Object.assign(
              Object.assign(
                { prefix: n == null ? void 0 : n.prefixCls },
                typeof o.cssVar == "object" ? o.cssVar : {}
              ),
              typeof i.cssVar == "object" ? i.cssVar : {}
            ),
            {
              key:
                (typeof i.cssVar == "object" &&
                  ((l = i.cssVar) === null || l === void 0 ? void 0 : l.key)) ||
                u,
            }
          );
      return Object.assign(Object.assign(Object.assign({}, o), i), {
        token: Object.assign(Object.assign({}, o.token), i.token),
        components: c,
        cssVar: d,
      });
    },
    [i, o],
    (a, l) =>
      a.some((c, u) => {
        const d = l[u];
        return !cb(c, d, !0);
      })
  );
}
var JK = ["children"],
  PU = L.createContext({});
function QK(t) {
  var e = t.children,
    n = sr(t, JK);
  return L.createElement(PU.Provider, { value: n }, e);
}
var eZ = (function (t) {
  ul(n, t);
  var e = fl(n);
  function n() {
    return Sr(this, n), e.apply(this, arguments);
  }
  return (
    Ar(n, [
      {
        key: "render",
        value: function () {
          return this.props.children;
        },
      },
    ]),
    n
  );
})(L.Component);
function tZ(t) {
  var e = L.useReducer(function (a) {
      return a + 1;
    }, 0),
    n = ot(e, 2),
    r = n[1],
    i = L.useRef(t),
    o = na(function () {
      return i.current;
    }),
    s = na(function (a) {
      (i.current = typeof a == "function" ? a(i.current) : a), r();
    });
  return [o, s];
}
var Ra = "none",
  o0 = "appear",
  s0 = "enter",
  a0 = "leave",
  t3 = "none",
  Do = "prepare",
  Qu = "start",
  ef = "active",
  aM = "end",
  IU = "prepared";
function n3(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit".concat(t)] = "webkit".concat(e)),
    (n["Moz".concat(t)] = "moz".concat(e)),
    (n["ms".concat(t)] = "MS".concat(e)),
    (n["O".concat(t)] = "o".concat(e.toLowerCase())),
    n
  );
}
function nZ(t, e) {
  var n = {
    animationend: n3("Animation", "AnimationEnd"),
    transitionend: n3("Transition", "TransitionEnd"),
  };
  return (
    t &&
      ("AnimationEvent" in e || delete n.animationend.animation,
      "TransitionEvent" in e || delete n.transitionend.transition),
    n
  );
}
var rZ = nZ(la(), typeof window < "u" ? window : {}),
  LU = {};
if (la()) {
  var iZ = document.createElement("div");
  LU = iZ.style;
}
var l0 = {};
function OU(t) {
  if (l0[t]) return l0[t];
  var e = rZ[t];
  if (e)
    for (var n = Object.keys(e), r = n.length, i = 0; i < r; i += 1) {
      var o = n[i];
      if (Object.prototype.hasOwnProperty.call(e, o) && o in LU)
        return (l0[t] = e[o]), l0[t];
    }
  return "";
}
var NU = OU("animationend"),
  DU = OU("transitionend"),
  FU = !!(NU && DU),
  r3 = NU || "animationend",
  i3 = DU || "transitionend";
function o3(t, e) {
  if (!t) return null;
  if (bt(t) === "object") {
    var n = e.replace(/-\w/g, function (r) {
      return r[1].toUpperCase();
    });
    return t[n];
  }
  return "".concat(t, "-").concat(e);
}
const oZ = function (t) {
  var e = L.useRef();
  function n(i) {
    i && (i.removeEventListener(i3, t), i.removeEventListener(r3, t));
  }
  function r(i) {
    e.current && e.current !== i && n(e.current),
      i &&
        i !== e.current &&
        (i.addEventListener(i3, t), i.addEventListener(r3, t), (e.current = i));
  }
  return (
    L.useEffect(function () {
      return function () {
        n(e.current);
      };
    }, []),
    [r, n]
  );
};
var UU = la() ? L.useLayoutEffect : L.useEffect;
const sZ = function () {
  var t = L.useRef(null);
  function e() {
    Ao.cancel(t.current);
  }
  function n(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var o = Ao(function () {
      i <= 1
        ? r({
            isCanceled: function () {
              return o !== t.current;
            },
          })
        : n(r, i - 1);
    });
    t.current = o;
  }
  return (
    L.useEffect(function () {
      return function () {
        e();
      };
    }, []),
    [n, e]
  );
};
var aZ = [Do, Qu, ef, aM],
  lZ = [Do, IU],
  kU = !1,
  cZ = !0;
function zU(t) {
  return t === ef || t === aM;
}
const uZ = function (t, e, n) {
  var r = gp(t3),
    i = ot(r, 2),
    o = i[0],
    s = i[1],
    a = sZ(),
    l = ot(a, 2),
    c = l[0],
    u = l[1];
  function d() {
    s(Do, !0);
  }
  var p = e ? lZ : aZ;
  return (
    UU(
      function () {
        if (o !== t3 && o !== aM) {
          var m = p.indexOf(o),
            v = p[m + 1],
            _ = n(o);
          _ === kU
            ? s(v, !0)
            : v &&
              c(function (y) {
                function g() {
                  y.isCanceled() || s(v, !0);
                }
                _ === !0 ? g() : Promise.resolve(_).then(g);
              });
        }
      },
      [t, o]
    ),
    L.useEffect(function () {
      return function () {
        u();
      };
    }, []),
    [d, o]
  );
};
function fZ(t, e, n, r) {
  var i = r.motionEnter,
    o = i === void 0 ? !0 : i,
    s = r.motionAppear,
    a = s === void 0 ? !0 : s,
    l = r.motionLeave,
    c = l === void 0 ? !0 : l,
    u = r.motionDeadline,
    d = r.motionLeaveImmediately,
    p = r.onAppearPrepare,
    m = r.onEnterPrepare,
    v = r.onLeavePrepare,
    _ = r.onAppearStart,
    y = r.onEnterStart,
    g = r.onLeaveStart,
    x = r.onAppearActive,
    S = r.onEnterActive,
    b = r.onLeaveActive,
    C = r.onAppearEnd,
    M = r.onEnterEnd,
    T = r.onLeaveEnd,
    P = r.onVisibleChanged,
    R = gp(),
    E = ot(R, 2),
    O = E[0],
    D = E[1],
    N = tZ(Ra),
    z = ot(N, 2),
    V = z[0],
    G = z[1],
    Y = gp(null),
    U = ot(Y, 2),
    j = U[0],
    W = U[1],
    B = V(),
    q = L.useRef(!1),
    Z = L.useRef(null);
  function H() {
    return n();
  }
  var X = L.useRef(!1);
  function ne() {
    G(Ra), W(null, !0);
  }
  var oe = na(function (J) {
      var fe = V();
      if (fe !== Ra) {
        var le = H();
        if (!(J && !J.deadline && J.target !== le)) {
          var ce = X.current,
            we;
          fe === o0 && ce
            ? (we = C == null ? void 0 : C(le, J))
            : fe === s0 && ce
            ? (we = M == null ? void 0 : M(le, J))
            : fe === a0 && ce && (we = T == null ? void 0 : T(le, J)),
            ce && we !== !1 && ne();
        }
      }
    }),
    ue = oZ(oe),
    Ie = ot(ue, 1),
    te = Ie[0],
    ge = function (fe) {
      switch (fe) {
        case o0:
          return ve(ve(ve({}, Do, p), Qu, _), ef, x);
        case s0:
          return ve(ve(ve({}, Do, m), Qu, y), ef, S);
        case a0:
          return ve(ve(ve({}, Do, v), Qu, g), ef, b);
        default:
          return {};
      }
    },
    ie = L.useMemo(
      function () {
        return ge(B);
      },
      [B]
    ),
    pe = uZ(B, !t, function (J) {
      if (J === Do) {
        var fe = ie[Do];
        return fe ? fe(H()) : kU;
      }
      if (he in ie) {
        var le;
        W(
          ((le = ie[he]) === null || le === void 0
            ? void 0
            : le.call(ie, H(), null)) || null
        );
      }
      return (
        he === ef &&
          B !== Ra &&
          (te(H()),
          u > 0 &&
            (clearTimeout(Z.current),
            (Z.current = setTimeout(function () {
              oe({ deadline: !0 });
            }, u)))),
        he === IU && ne(),
        cZ
      );
    }),
    de = ot(pe, 2),
    Ee = de[0],
    he = de[1],
    Ce = zU(he);
  X.current = Ce;
  var _e = L.useRef(null);
  UU(
    function () {
      if (!(q.current && _e.current === e)) {
        D(e);
        var J = q.current;
        q.current = !0;
        var fe;
        !J && e && a && (fe = o0),
          J && e && o && (fe = s0),
          ((J && !e && c) || (!J && d && !e && c)) && (fe = a0);
        var le = ge(fe);
        fe && (t || le[Do]) ? (G(fe), Ee()) : G(Ra), (_e.current = e);
      }
    },
    [e]
  ),
    L.useEffect(
      function () {
        ((B === o0 && !a) || (B === s0 && !o) || (B === a0 && !c)) && G(Ra);
      },
      [a, o, c]
    ),
    L.useEffect(function () {
      return function () {
        (q.current = !1), clearTimeout(Z.current);
      };
    }, []);
  var $ = L.useRef(!1);
  L.useEffect(
    function () {
      O && ($.current = !0),
        O !== void 0 &&
          B === Ra &&
          (($.current || O) && (P == null || P(O)), ($.current = !0));
    },
    [O, B]
  );
  var k = j;
  return (
    ie[Do] && he === Qu && (k = Fe({ transition: "none" }, k)),
    [B, he, k, O ?? e]
  );
}
function dZ(t) {
  var e = t;
  bt(t) === "object" && (e = t.transitionSupport);
  function n(i, o) {
    return !!(i.motionName && e && o !== !1);
  }
  var r = L.forwardRef(function (i, o) {
    var s = i.visible,
      a = s === void 0 ? !0 : s,
      l = i.removeOnLeave,
      c = l === void 0 ? !0 : l,
      u = i.forceRender,
      d = i.children,
      p = i.motionName,
      m = i.leavedClassName,
      v = i.eventProps,
      _ = L.useContext(PU),
      y = _.motion,
      g = n(i, y),
      x = L.useRef(),
      S = L.useRef();
    function b() {
      try {
        return x.current instanceof HTMLElement ? x.current : N0(S.current);
      } catch {
        return null;
      }
    }
    var C = fZ(g, a, b, i),
      M = ot(C, 4),
      T = M[0],
      P = M[1],
      R = M[2],
      E = M[3],
      O = L.useRef(E);
    E && (O.current = !0);
    var D = L.useCallback(
        function (U) {
          (x.current = U), NF(o, U);
        },
        [o]
      ),
      N,
      z = Fe(Fe({}, v), {}, { visible: a });
    if (!d) N = null;
    else if (T === Ra)
      E
        ? (N = d(Fe({}, z), D))
        : !c && O.current && m
        ? (N = d(Fe(Fe({}, z), {}, { className: m }), D))
        : u || (!c && !m)
        ? (N = d(Fe(Fe({}, z), {}, { style: { display: "none" } }), D))
        : (N = null);
    else {
      var V;
      P === Do
        ? (V = "prepare")
        : zU(P)
        ? (V = "active")
        : P === Qu && (V = "start");
      var G = o3(p, "".concat(T, "-").concat(V));
      N = d(
        Fe(
          Fe({}, z),
          {},
          {
            className: ft(
              o3(p, T),
              ve(ve({}, G, G && V), p, typeof p == "string")
            ),
            style: R,
          }
        ),
        D
      );
    }
    if (L.isValidElement(N) && XE(N)) {
      var Y = YE(N);
      Y || (N = L.cloneElement(N, { ref: D }));
    }
    return L.createElement(eZ, { ref: S }, N);
  });
  return (r.displayName = "CSSMotion"), r;
}
const Ky = dZ(FU);
var Pb = "add",
  Ib = "keep",
  Lb = "remove",
  G_ = "removed";
function hZ(t) {
  var e;
  return (
    t && bt(t) === "object" && "key" in t ? (e = t) : (e = { key: t }),
    Fe(Fe({}, e), {}, { key: String(e.key) })
  );
}
function Ob() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return t.map(hZ);
}
function pZ() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    n = [],
    r = 0,
    i = e.length,
    o = Ob(t),
    s = Ob(e);
  o.forEach(function (c) {
    for (var u = !1, d = r; d < i; d += 1) {
      var p = s[d];
      if (p.key === c.key) {
        r < d &&
          ((n = n.concat(
            s.slice(r, d).map(function (m) {
              return Fe(Fe({}, m), {}, { status: Pb });
            })
          )),
          (r = d)),
          n.push(Fe(Fe({}, p), {}, { status: Ib })),
          (r += 1),
          (u = !0);
        break;
      }
    }
    u || n.push(Fe(Fe({}, c), {}, { status: Lb }));
  }),
    r < i &&
      (n = n.concat(
        s.slice(r).map(function (c) {
          return Fe(Fe({}, c), {}, { status: Pb });
        })
      ));
  var a = {};
  n.forEach(function (c) {
    var u = c.key;
    a[u] = (a[u] || 0) + 1;
  });
  var l = Object.keys(a).filter(function (c) {
    return a[c] > 1;
  });
  return (
    l.forEach(function (c) {
      (n = n.filter(function (u) {
        var d = u.key,
          p = u.status;
        return d !== c || p !== Lb;
      })),
        n.forEach(function (u) {
          u.key === c && (u.status = Ib);
        });
    }),
    n
  );
}
var mZ = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  gZ = ["status"],
  vZ = [
    "eventProps",
    "visible",
    "children",
    "motionName",
    "motionAppear",
    "motionEnter",
    "motionLeave",
    "motionLeaveImmediately",
    "motionDeadline",
    "removeOnLeave",
    "leavedClassName",
    "onAppearPrepare",
    "onAppearStart",
    "onAppearActive",
    "onAppearEnd",
    "onEnterStart",
    "onEnterActive",
    "onEnterEnd",
    "onLeaveStart",
    "onLeaveActive",
    "onLeaveEnd",
  ];
function yZ(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ky,
    n = (function (r) {
      ul(o, r);
      var i = fl(o);
      function o() {
        var s;
        Sr(this, o);
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
          l[c] = arguments[c];
        return (
          (s = i.call.apply(i, [this].concat(l))),
          ve(zt(s), "state", { keyEntities: [] }),
          ve(zt(s), "removeKey", function (u) {
            s.setState(
              function (d) {
                var p = d.keyEntities.map(function (m) {
                  return m.key !== u ? m : Fe(Fe({}, m), {}, { status: G_ });
                });
                return { keyEntities: p };
              },
              function () {
                var d = s.state.keyEntities,
                  p = d.filter(function (m) {
                    var v = m.status;
                    return v !== G_;
                  }).length;
                p === 0 && s.props.onAllRemoved && s.props.onAllRemoved();
              }
            );
          }),
          s
        );
      }
      return (
        Ar(
          o,
          [
            {
              key: "render",
              value: function () {
                var a = this,
                  l = this.state.keyEntities,
                  c = this.props,
                  u = c.component,
                  d = c.children,
                  p = c.onVisibleChanged;
                c.onAllRemoved;
                var m = sr(c, mZ),
                  v = u || L.Fragment,
                  _ = {};
                return (
                  vZ.forEach(function (y) {
                    (_[y] = m[y]), delete m[y];
                  }),
                  delete m.keys,
                  L.createElement(
                    v,
                    m,
                    l.map(function (y, g) {
                      var x = y.status,
                        S = sr(y, gZ),
                        b = x === Pb || x === Ib;
                      return L.createElement(
                        e,
                        Bt({}, _, {
                          key: S.key,
                          visible: b,
                          eventProps: S,
                          onVisibleChanged: function (M) {
                            p == null || p(M, { key: S.key }),
                              M || a.removeKey(S.key);
                          },
                        }),
                        function (C, M) {
                          return d(Fe(Fe({}, C), {}, { index: g }), M);
                        }
                      );
                    })
                  )
                );
              },
            },
          ],
          [
            {
              key: "getDerivedStateFromProps",
              value: function (a, l) {
                var c = a.keys,
                  u = l.keyEntities,
                  d = Ob(c),
                  p = pZ(u, d);
                return {
                  keyEntities: p.filter(function (m) {
                    var v = u.find(function (_) {
                      var y = _.key;
                      return m.key === y;
                    });
                    return !(v && v.status === G_ && m.status === Lb);
                  }),
                };
              },
            },
          ]
        ),
        o
      );
    })(L.Component);
  return ve(n, "defaultProps", { component: "div" }), n;
}
const xZ = yZ(FU),
  s3 = L.createContext(!0);
function _Z(t) {
  const e = L.useContext(s3),
    { children: n } = t,
    [, r] = Vf(),
    { motion: i } = r,
    o = L.useRef(!1);
  return (
    o.current || (o.current = e !== i),
    o.current
      ? L.createElement(
          s3.Provider,
          { value: i },
          L.createElement(QK, { motion: i }, n)
        )
      : n
  );
}
const SZ = () => null;
var AZ = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const bZ = [
  "getTargetContainer",
  "getPopupContainer",
  "renderEmpty",
  "input",
  "pagination",
  "form",
  "select",
  "button",
];
let Rv, BU, HU, VU;
function V0() {
  return Rv || mp;
}
function wZ() {
  return BU || Yy;
}
function EZ(t) {
  return Object.keys(t).some((e) => e.endsWith("Color"));
}
const MZ = (t) => {
    const { prefixCls: e, iconPrefixCls: n, theme: r, holderRender: i } = t;
    e !== void 0 && (Rv = e),
      n !== void 0 && (BU = n),
      "holderRender" in t && (VU = i),
      r && (EZ(r) ? AK(V0(), r) : (HU = r));
  },
  CZ = () => ({
    getPrefixCls: (t, e) => e || (t ? `${V0()}-${t}` : V0()),
    getIconPrefixCls: wZ,
    getRootPrefixCls: () => Rv || V0(),
    getTheme: () => HU,
    holderRender: VU,
  }),
  TZ = (t) => {
    const {
        children: e,
        csp: n,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: o,
        form: s,
        locale: a,
        componentSize: l,
        direction: c,
        space: u,
        splitter: d,
        virtual: p,
        dropdownMatchSelectWidth: m,
        popupMatchSelectWidth: v,
        popupOverflow: _,
        legacyLocale: y,
        parentContext: g,
        iconPrefixCls: x,
        theme: S,
        componentDisabled: b,
        segmented: C,
        statistic: M,
        spin: T,
        calendar: P,
        carousel: R,
        cascader: E,
        collapse: O,
        typography: D,
        checkbox: N,
        descriptions: z,
        divider: V,
        drawer: G,
        skeleton: Y,
        steps: U,
        image: j,
        layout: W,
        list: B,
        mentions: q,
        modal: Z,
        progress: H,
        result: X,
        slider: ne,
        breadcrumb: oe,
        menu: ue,
        pagination: Ie,
        input: te,
        textArea: ge,
        empty: ie,
        badge: pe,
        radio: de,
        rate: Ee,
        switch: he,
        transfer: Ce,
        avatar: _e,
        message: $,
        tag: k,
        table: J,
        card: fe,
        tabs: le,
        timeline: ce,
        timePicker: we,
        upload: Be,
        notification: Me,
        tree: Ge,
        colorPicker: Le,
        datePicker: je,
        rangePicker: Je,
        flex: Ye,
        wave: De,
        dropdown: ze,
        warning: Ve,
        tour: ae,
        tooltip: be,
        popover: se,
        popconfirm: Ae,
        floatButton: ye,
        floatButtonGroup: He,
        variant: qe,
        inputNumber: at,
        treeSelect: st,
      } = t,
      ht = L.useCallback(
        (Xt, Vt) => {
          const { prefixCls: In } = t;
          if (Vt) return Vt;
          const br = In || g.getPrefixCls("");
          return Xt ? `${br}-${Xt}` : br;
        },
        [g.getPrefixCls, t.prefixCls]
      ),
      pt = x || g.iconPrefixCls || Yy,
      Ze = n || g.csp;
    XK(pt, Ze);
    const Mt = ZK(S, g.theme, { prefixCls: ht("") }),
      Rt = {
        csp: Ze,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: o,
        locale: a || y,
        direction: c,
        space: u,
        splitter: d,
        virtual: p,
        popupMatchSelectWidth: v ?? m,
        popupOverflow: _,
        getPrefixCls: ht,
        iconPrefixCls: pt,
        theme: Mt,
        segmented: C,
        statistic: M,
        spin: T,
        calendar: P,
        carousel: R,
        cascader: E,
        collapse: O,
        typography: D,
        checkbox: N,
        descriptions: z,
        divider: V,
        drawer: G,
        skeleton: Y,
        steps: U,
        image: j,
        input: te,
        textArea: ge,
        layout: W,
        list: B,
        mentions: q,
        modal: Z,
        progress: H,
        result: X,
        slider: ne,
        breadcrumb: oe,
        menu: ue,
        pagination: Ie,
        empty: ie,
        badge: pe,
        radio: de,
        rate: Ee,
        switch: he,
        transfer: Ce,
        avatar: _e,
        message: $,
        tag: k,
        table: J,
        card: fe,
        tabs: le,
        timeline: ce,
        timePicker: we,
        upload: Be,
        notification: Me,
        tree: Ge,
        colorPicker: Le,
        datePicker: je,
        rangePicker: Je,
        flex: Ye,
        wave: De,
        dropdown: ze,
        warning: Ve,
        tour: ae,
        tooltip: be,
        popover: se,
        popconfirm: Ae,
        floatButton: ye,
        floatButtonGroup: He,
        variant: qe,
        inputNumber: at,
        treeSelect: st,
      },
      Yt = Object.assign({}, g);
    Object.keys(Rt).forEach((Xt) => {
      Rt[Xt] !== void 0 && (Yt[Xt] = Rt[Xt]);
    }),
      bZ.forEach((Xt) => {
        const Vt = t[Xt];
        Vt && (Yt[Xt] = Vt);
      }),
      typeof r < "u" &&
        (Yt.button = Object.assign({ autoInsertSpace: r }, Yt.button));
    const en = $E(
        () => Yt,
        Yt,
        (Xt, Vt) => {
          const In = Object.keys(Xt),
            br = Object.keys(Vt);
          return In.length !== br.length || In.some((K) => Xt[K] !== Vt[K]);
        }
      ),
      { layer: Qn } = L.useContext(Gp),
      cr = L.useMemo(
        () => ({ prefixCls: pt, csp: Ze, layer: Qn ? "antd" : void 0 }),
        [pt, Ze, Qn]
      );
    let $t = L.createElement(
      L.Fragment,
      null,
      L.createElement(SZ, { dropdownMatchSelectWidth: m }),
      e
    );
    const ur = L.useMemo(() => {
      var Xt, Vt, In, br;
      return Ju(
        ((Xt = Xy.Form) === null || Xt === void 0
          ? void 0
          : Xt.defaultValidateMessages) || {},
        ((In =
          (Vt = en.locale) === null || Vt === void 0 ? void 0 : Vt.Form) ===
          null || In === void 0
          ? void 0
          : In.defaultValidateMessages) || {},
        ((br = en.form) === null || br === void 0
          ? void 0
          : br.validateMessages) || {},
        (s == null ? void 0 : s.validateMessages) || {}
      );
    }, [en, s == null ? void 0 : s.validateMessages]);
    Object.keys(ur).length > 0 &&
      ($t = L.createElement(eK.Provider, { value: ur }, $t)),
      a && ($t = L.createElement(rK, { locale: a, _ANT_MARK__: nK }, $t)),
      ($t = L.createElement(rM.Provider, { value: cr }, $t)),
      l && ($t = L.createElement(wK, { size: l }, $t)),
      ($t = L.createElement(_Z, null, $t));
    const fr = L.useMemo(() => {
      const Xt = Mt || {},
        { algorithm: Vt, token: In, components: br, cssVar: K } = Xt,
        Se = AZ(Xt, ["algorithm", "token", "components", "cssVar"]),
        Oe = Vt && (!Array.isArray(Vt) || Vt.length > 0) ? fb(Vt) : _U,
        Te = {};
      Object.entries(br || {}).forEach(([Qe, ct]) => {
        const nt = Object.assign({}, ct);
        "algorithm" in nt &&
          (nt.algorithm === !0
            ? (nt.theme = Oe)
            : (Array.isArray(nt.algorithm) ||
                typeof nt.algorithm == "function") &&
              (nt.theme = fb(nt.algorithm)),
          delete nt.algorithm),
          (Te[Qe] = nt);
      });
      const Re = Object.assign(Object.assign({}, hp), In);
      return Object.assign(Object.assign({}, Se), {
        theme: Oe,
        token: Re,
        components: Te,
        override: Object.assign({ override: Re }, Te),
        cssVar: K,
      });
    }, [Mt]);
    return (
      S && ($t = L.createElement(SU.Provider, { value: fr }, $t)),
      en.warning &&
        ($t = L.createElement(Qq.Provider, { value: en.warning }, $t)),
      b !== void 0 && ($t = L.createElement(bK, { disabled: b }, $t)),
      L.createElement(Sn.Provider, { value: en }, $t)
    );
  },
  Gf = (t) => {
    const e = L.useContext(Sn),
      n = L.useContext(gU);
    return L.createElement(
      TZ,
      Object.assign({ parentContext: e, legacyLocale: n }, t)
    );
  };
Gf.ConfigContext = Sn;
Gf.SizeContext = Tf;
Gf.config = MZ;
Gf.useConfig = EK;
Object.defineProperty(Gf, "SizeContext", { get: () => Tf });
var RZ = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z",
        },
      },
    ],
  },
  name: "check-circle",
  theme: "filled",
};
function GU(t) {
  var e;
  return t == null || (e = t.getRootNode) === null || e === void 0
    ? void 0
    : e.call(t);
}
function PZ(t) {
  return GU(t) instanceof ShadowRoot;
}
function IZ(t) {
  return PZ(t) ? GU(t) : null;
}
function LZ(t) {
  return t.replace(/-(.)/g, function (e, n) {
    return n.toUpperCase();
  });
}
function OZ(t, e) {
  Ei(t, "[@ant-design/icons] ".concat(e));
}
function a3(t) {
  return (
    bt(t) === "object" &&
    typeof t.name == "string" &&
    typeof t.theme == "string" &&
    (bt(t.icon) === "object" || typeof t.icon == "function")
  );
}
function l3() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(t).reduce(function (e, n) {
    var r = t[n];
    switch (n) {
      case "class":
        (e.className = r), delete e.class;
        break;
      default:
        delete e[n], (e[LZ(n)] = r);
    }
    return e;
  }, {});
}
function Nb(t, e, n) {
  return n
    ? We.createElement(
        t.tag,
        Fe(Fe({ key: e }, l3(t.attrs)), n),
        (t.children || []).map(function (r, i) {
          return Nb(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
        })
      )
    : We.createElement(
        t.tag,
        Fe({ key: e }, l3(t.attrs)),
        (t.children || []).map(function (r, i) {
          return Nb(r, "".concat(e, "-").concat(t.tag, "-").concat(i));
        })
      );
}
function WU(t) {
  return pp(t)[0];
}
function jU(t) {
  return t ? (Array.isArray(t) ? t : [t]) : [];
}
var NZ = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`,
  DZ = function (e) {
    var n = L.useContext(rM),
      r = n.csp,
      i = n.prefixCls,
      o = n.layer,
      s = NZ;
    i && (s = s.replace(/anticon/g, i)),
      o &&
        (s = "@layer "
          .concat(
            o,
            ` {
`
          )
          .concat(
            s,
            `
}`
          )),
      L.useEffect(function () {
        var a = e.current,
          l = IZ(a);
        vc(s, "@ant-design-icons", { prepend: !o, csp: r, attachTo: l });
      }, []);
  },
  FZ = [
    "icon",
    "className",
    "onClick",
    "style",
    "primaryColor",
    "secondaryColor",
  ],
  xh = { primaryColor: "#333", secondaryColor: "#E6E6E6", calculated: !1 };
function UZ(t) {
  var e = t.primaryColor,
    n = t.secondaryColor;
  (xh.primaryColor = e),
    (xh.secondaryColor = n || WU(e)),
    (xh.calculated = !!n);
}
function kZ() {
  return Fe({}, xh);
}
var Wf = function (e) {
  var n = e.icon,
    r = e.className,
    i = e.onClick,
    o = e.style,
    s = e.primaryColor,
    a = e.secondaryColor,
    l = sr(e, FZ),
    c = L.useRef(),
    u = xh;
  if (
    (s && (u = { primaryColor: s, secondaryColor: a || WU(s) }),
    DZ(c),
    OZ(a3(n), "icon should be icon definiton, but got ".concat(n)),
    !a3(n))
  )
    return null;
  var d = n;
  return (
    d &&
      typeof d.icon == "function" &&
      (d = Fe(
        Fe({}, d),
        {},
        { icon: d.icon(u.primaryColor, u.secondaryColor) }
      )),
    Nb(
      d.icon,
      "svg-".concat(d.name),
      Fe(
        Fe(
          {
            className: r,
            onClick: i,
            style: o,
            "data-icon": d.name,
            width: "1em",
            height: "1em",
            fill: "currentColor",
            "aria-hidden": "true",
          },
          l
        ),
        {},
        { ref: c }
      )
    )
  );
};
Wf.displayName = "IconReact";
Wf.getTwoToneColors = kZ;
Wf.setTwoToneColors = UZ;
function $U(t) {
  var e = jU(t),
    n = ot(e, 2),
    r = n[0],
    i = n[1];
  return Wf.setTwoToneColors({ primaryColor: r, secondaryColor: i });
}
function zZ() {
  var t = Wf.getTwoToneColors();
  return t.calculated ? [t.primaryColor, t.secondaryColor] : t.primaryColor;
}
var BZ = [
  "className",
  "icon",
  "spin",
  "rotate",
  "tabIndex",
  "onClick",
  "twoToneColor",
];
$U(Tv.primary);
var Ti = L.forwardRef(function (t, e) {
  var n = t.className,
    r = t.icon,
    i = t.spin,
    o = t.rotate,
    s = t.tabIndex,
    a = t.onClick,
    l = t.twoToneColor,
    c = sr(t, BZ),
    u = L.useContext(rM),
    d = u.prefixCls,
    p = d === void 0 ? "anticon" : d,
    m = u.rootClassName,
    v = ft(
      m,
      p,
      ve(
        ve({}, "".concat(p, "-").concat(r.name), !!r.name),
        "".concat(p, "-spin"),
        !!i || r.name === "loading"
      ),
      n
    ),
    _ = s;
  _ === void 0 && a && (_ = -1);
  var y = o
      ? {
          msTransform: "rotate(".concat(o, "deg)"),
          transform: "rotate(".concat(o, "deg)"),
        }
      : void 0,
    g = jU(l),
    x = ot(g, 2),
    S = x[0],
    b = x[1];
  return L.createElement(
    "span",
    Bt({ role: "img", "aria-label": r.name }, c, {
      ref: e,
      tabIndex: _,
      onClick: a,
      className: v,
    }),
    L.createElement(Wf, {
      icon: r,
      primaryColor: S,
      secondaryColor: b,
      style: y,
    })
  );
});
Ti.displayName = "AntdIcon";
Ti.getTwoToneColor = zZ;
Ti.setTwoToneColor = $U;
var HZ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: RZ }));
  },
  VZ = L.forwardRef(HZ),
  GZ = {
    icon: {
      tag: "svg",
      attrs: {
        "fill-rule": "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
      },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z",
          },
        },
      ],
    },
    name: "close-circle",
    theme: "filled",
  },
  WZ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: GZ }));
  },
  XU = L.forwardRef(WZ),
  jZ = {
    icon: {
      tag: "svg",
      attrs: {
        "fill-rule": "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
      },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z",
          },
        },
      ],
    },
    name: "close",
    theme: "outlined",
  },
  $Z = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: jZ }));
  },
  XZ = L.forwardRef($Z),
  YZ = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z",
          },
        },
      ],
    },
    name: "exclamation-circle",
    theme: "filled",
  },
  qZ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: YZ }));
  },
  KZ = L.forwardRef(qZ),
  ZZ = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z",
          },
        },
      ],
    },
    name: "info-circle",
    theme: "filled",
  },
  JZ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: ZZ }));
  },
  QZ = L.forwardRef(JZ),
  eJ = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`,
  tJ = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`,
  nJ = ""
    .concat(eJ, " ")
    .concat(tJ)
    .split(/[\s\n]+/),
  rJ = "aria-",
  iJ = "data-";
function c3(t, e) {
  return t.indexOf(e) === 0;
}
function Zy(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n;
  e === !1
    ? (n = { aria: !0, data: !0, attr: !0 })
    : e === !0
    ? (n = { aria: !0 })
    : (n = Fe({}, e));
  var r = {};
  return (
    Object.keys(t).forEach(function (i) {
      ((n.aria && (i === "role" || c3(i, rJ))) ||
        (n.data && c3(i, iJ)) ||
        (n.attr && nJ.includes(i))) &&
        (r[i] = t[i]);
    }),
    r
  );
}
function oJ(t) {
  return t && We.isValidElement(t) && t.type === We.Fragment;
}
const sJ = (t, e, n) =>
  We.isValidElement(t)
    ? We.cloneElement(t, typeof n == "function" ? n(t.props || {}) : n)
    : e;
function Rf(t, e) {
  return sJ(t, t, e);
}
const jf = (t) => {
  const [, , , , e] = Vf();
  return e ? `${t}-css-var` : "";
};
var Db = { ENTER: 13 },
  YU = L.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = t.style,
      i = t.className,
      o = t.duration,
      s = o === void 0 ? 4.5 : o,
      a = t.showProgress,
      l = t.pauseOnHover,
      c = l === void 0 ? !0 : l,
      u = t.eventKey,
      d = t.content,
      p = t.closable,
      m = t.closeIcon,
      v = m === void 0 ? "x" : m,
      _ = t.props,
      y = t.onClick,
      g = t.onNoticeClose,
      x = t.times,
      S = t.hovering,
      b = L.useState(!1),
      C = ot(b, 2),
      M = C[0],
      T = C[1],
      P = L.useState(0),
      R = ot(P, 2),
      E = R[0],
      O = R[1],
      D = L.useState(0),
      N = ot(D, 2),
      z = N[0],
      V = N[1],
      G = S || M,
      Y = s > 0 && a,
      U = function () {
        g(u);
      },
      j = function (X) {
        (X.key === "Enter" || X.code === "Enter" || X.keyCode === Db.ENTER) &&
          U();
      };
    L.useEffect(
      function () {
        if (!G && s > 0) {
          var H = Date.now() - z,
            X = setTimeout(function () {
              U();
            }, s * 1e3 - z);
          return function () {
            c && clearTimeout(X), V(Date.now() - H);
          };
        }
      },
      [s, G, x]
    ),
      L.useEffect(
        function () {
          if (!G && Y && (c || z === 0)) {
            var H = performance.now(),
              X,
              ne = function oe() {
                cancelAnimationFrame(X),
                  (X = requestAnimationFrame(function (ue) {
                    var Ie = ue + z - H,
                      te = Math.min(Ie / (s * 1e3), 1);
                    O(te * 100), te < 1 && oe();
                  }));
              };
            return (
              ne(),
              function () {
                c && cancelAnimationFrame(X);
              }
            );
          }
        },
        [s, z, G, Y, x]
      );
    var W = L.useMemo(
        function () {
          return bt(p) === "object" && p !== null
            ? p
            : p
            ? { closeIcon: v }
            : {};
        },
        [p, v]
      ),
      B = Zy(W, !0),
      q = 100 - (!E || E < 0 ? 0 : E > 100 ? 100 : E),
      Z = "".concat(n, "-notice");
    return L.createElement(
      "div",
      Bt({}, _, {
        ref: e,
        className: ft(Z, i, ve({}, "".concat(Z, "-closable"), p)),
        style: r,
        onMouseEnter: function (X) {
          var ne;
          T(!0),
            _ == null ||
              (ne = _.onMouseEnter) === null ||
              ne === void 0 ||
              ne.call(_, X);
        },
        onMouseLeave: function (X) {
          var ne;
          T(!1),
            _ == null ||
              (ne = _.onMouseLeave) === null ||
              ne === void 0 ||
              ne.call(_, X);
        },
        onClick: y,
      }),
      L.createElement("div", { className: "".concat(Z, "-content") }, d),
      p &&
        L.createElement(
          "a",
          Bt(
            {
              tabIndex: 0,
              className: "".concat(Z, "-close"),
              onKeyDown: j,
              "aria-label": "Close",
            },
            B,
            {
              onClick: function (X) {
                X.preventDefault(), X.stopPropagation(), U();
              },
            }
          ),
          W.closeIcon
        ),
      Y &&
        L.createElement(
          "progress",
          { className: "".concat(Z, "-progress"), max: "100", value: q },
          q + "%"
        )
    );
  }),
  qU = We.createContext({}),
  aJ = function (e) {
    var n = e.children,
      r = e.classNames;
    return We.createElement(qU.Provider, { value: { classNames: r } }, n);
  },
  u3 = 8,
  f3 = 3,
  d3 = 16,
  lJ = function (e) {
    var n = { offset: u3, threshold: f3, gap: d3 };
    if (e && bt(e) === "object") {
      var r, i, o;
      (n.offset = (r = e.offset) !== null && r !== void 0 ? r : u3),
        (n.threshold = (i = e.threshold) !== null && i !== void 0 ? i : f3),
        (n.gap = (o = e.gap) !== null && o !== void 0 ? o : d3);
    }
    return [!!e, n];
  },
  cJ = ["className", "style", "classNames", "styles"],
  uJ = function (e) {
    var n = e.configList,
      r = e.placement,
      i = e.prefixCls,
      o = e.className,
      s = e.style,
      a = e.motion,
      l = e.onAllNoticeRemoved,
      c = e.onNoticeClose,
      u = e.stack,
      d = L.useContext(qU),
      p = d.classNames,
      m = L.useRef({}),
      v = L.useState(null),
      _ = ot(v, 2),
      y = _[0],
      g = _[1],
      x = L.useState([]),
      S = ot(x, 2),
      b = S[0],
      C = S[1],
      M = n.map(function (G) {
        return { config: G, key: String(G.key) };
      }),
      T = lJ(u),
      P = ot(T, 2),
      R = P[0],
      E = P[1],
      O = E.offset,
      D = E.threshold,
      N = E.gap,
      z = R && (b.length > 0 || M.length <= D),
      V = typeof a == "function" ? a(r) : a;
    return (
      L.useEffect(
        function () {
          R &&
            b.length > 1 &&
            C(function (G) {
              return G.filter(function (Y) {
                return M.some(function (U) {
                  var j = U.key;
                  return Y === j;
                });
              });
            });
        },
        [b, M, R]
      ),
      L.useEffect(
        function () {
          var G;
          if (
            R &&
            m.current[
              (G = M[M.length - 1]) === null || G === void 0 ? void 0 : G.key
            ]
          ) {
            var Y;
            g(
              m.current[
                (Y = M[M.length - 1]) === null || Y === void 0 ? void 0 : Y.key
              ]
            );
          }
        },
        [M, R]
      ),
      We.createElement(
        xZ,
        Bt(
          {
            key: r,
            className: ft(
              i,
              "".concat(i, "-").concat(r),
              p == null ? void 0 : p.list,
              o,
              ve(
                ve({}, "".concat(i, "-stack"), !!R),
                "".concat(i, "-stack-expanded"),
                z
              )
            ),
            style: s,
            keys: M,
            motionAppear: !0,
          },
          V,
          {
            onAllRemoved: function () {
              l(r);
            },
          }
        ),
        function (G, Y) {
          var U = G.config,
            j = G.className,
            W = G.style,
            B = G.index,
            q = U,
            Z = q.key,
            H = q.times,
            X = String(Z),
            ne = U,
            oe = ne.className,
            ue = ne.style,
            Ie = ne.classNames,
            te = ne.styles,
            ge = sr(ne, cJ),
            ie = M.findIndex(function (ce) {
              return ce.key === X;
            }),
            pe = {};
          if (R) {
            var de = M.length - 1 - (ie > -1 ? ie : B - 1),
              Ee = r === "top" || r === "bottom" ? "-50%" : "0";
            if (de > 0) {
              var he, Ce, _e;
              pe.height = z
                ? (he = m.current[X]) === null || he === void 0
                  ? void 0
                  : he.offsetHeight
                : y == null
                ? void 0
                : y.offsetHeight;
              for (var $ = 0, k = 0; k < de; k++) {
                var J;
                $ +=
                  ((J = m.current[M[M.length - 1 - k].key]) === null ||
                  J === void 0
                    ? void 0
                    : J.offsetHeight) + N;
              }
              var fe = (z ? $ : de * O) * (r.startsWith("top") ? 1 : -1),
                le =
                  !z &&
                  y !== null &&
                  y !== void 0 &&
                  y.offsetWidth &&
                  (Ce = m.current[X]) !== null &&
                  Ce !== void 0 &&
                  Ce.offsetWidth
                    ? ((y == null ? void 0 : y.offsetWidth) -
                        O * 2 * (de < 3 ? de : 3)) /
                      ((_e = m.current[X]) === null || _e === void 0
                        ? void 0
                        : _e.offsetWidth)
                    : 1;
              pe.transform = "translate3d("
                .concat(Ee, ", ")
                .concat(fe, "px, 0) scaleX(")
                .concat(le, ")");
            } else pe.transform = "translate3d(".concat(Ee, ", 0, 0)");
          }
          return We.createElement(
            "div",
            {
              ref: Y,
              className: ft(
                "".concat(i, "-notice-wrapper"),
                j,
                Ie == null ? void 0 : Ie.wrapper
              ),
              style: Fe(Fe(Fe({}, W), pe), te == null ? void 0 : te.wrapper),
              onMouseEnter: function () {
                return C(function (we) {
                  return we.includes(X) ? we : [].concat(yt(we), [X]);
                });
              },
              onMouseLeave: function () {
                return C(function (we) {
                  return we.filter(function (Be) {
                    return Be !== X;
                  });
                });
              },
            },
            We.createElement(
              YU,
              Bt({}, ge, {
                ref: function (we) {
                  ie > -1 ? (m.current[X] = we) : delete m.current[X];
                },
                prefixCls: i,
                classNames: Ie,
                styles: te,
                className: ft(oe, p == null ? void 0 : p.notice),
                style: ue,
                times: H,
                key: Z,
                eventKey: Z,
                onNoticeClose: c,
                hovering: R && b.length > 0,
              })
            )
          );
        }
      )
    );
  },
  fJ = L.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = n === void 0 ? "rc-notification" : n,
      i = t.container,
      o = t.motion,
      s = t.maxCount,
      a = t.className,
      l = t.style,
      c = t.onAllRemoved,
      u = t.stack,
      d = t.renderNotifications,
      p = L.useState([]),
      m = ot(p, 2),
      v = m[0],
      _ = m[1],
      y = function (R) {
        var E,
          O = v.find(function (D) {
            return D.key === R;
          });
        O == null || (E = O.onClose) === null || E === void 0 || E.call(O),
          _(function (D) {
            return D.filter(function (N) {
              return N.key !== R;
            });
          });
      };
    L.useImperativeHandle(e, function () {
      return {
        open: function (R) {
          _(function (E) {
            var O = yt(E),
              D = O.findIndex(function (V) {
                return V.key === R.key;
              }),
              N = Fe({}, R);
            if (D >= 0) {
              var z;
              (N.times =
                (((z = E[D]) === null || z === void 0 ? void 0 : z.times) ||
                  0) + 1),
                (O[D] = N);
            } else (N.times = 0), O.push(N);
            return s > 0 && O.length > s && (O = O.slice(-s)), O;
          });
        },
        close: function (R) {
          y(R);
        },
        destroy: function () {
          _([]);
        },
      };
    });
    var g = L.useState({}),
      x = ot(g, 2),
      S = x[0],
      b = x[1];
    L.useEffect(
      function () {
        var P = {};
        v.forEach(function (R) {
          var E = R.placement,
            O = E === void 0 ? "topRight" : E;
          O && ((P[O] = P[O] || []), P[O].push(R));
        }),
          Object.keys(S).forEach(function (R) {
            P[R] = P[R] || [];
          }),
          b(P);
      },
      [v]
    );
    var C = function (R) {
        b(function (E) {
          var O = Fe({}, E),
            D = O[R] || [];
          return D.length || delete O[R], O;
        });
      },
      M = L.useRef(!1);
    if (
      (L.useEffect(
        function () {
          Object.keys(S).length > 0
            ? (M.current = !0)
            : M.current && (c == null || c(), (M.current = !1));
        },
        [S]
      ),
      !i)
    )
      return null;
    var T = Object.keys(S);
    return Jv.createPortal(
      L.createElement(
        L.Fragment,
        null,
        T.map(function (P) {
          var R = S[P],
            E = L.createElement(uJ, {
              key: P,
              configList: R,
              placement: P,
              prefixCls: r,
              className: a == null ? void 0 : a(P),
              style: l == null ? void 0 : l(P),
              motion: o,
              onNoticeClose: y,
              onAllNoticeRemoved: C,
              stack: u,
            });
          return d ? d(E, { prefixCls: r, key: P }) : E;
        })
      ),
      i
    );
  }),
  dJ = [
    "getContainer",
    "motion",
    "prefixCls",
    "maxCount",
    "className",
    "style",
    "onAllRemoved",
    "stack",
    "renderNotifications",
  ],
  hJ = function () {
    return document.body;
  },
  h3 = 0;
function pJ() {
  for (var t = {}, e = arguments.length, n = new Array(e), r = 0; r < e; r++)
    n[r] = arguments[r];
  return (
    n.forEach(function (i) {
      i &&
        Object.keys(i).forEach(function (o) {
          var s = i[o];
          s !== void 0 && (t[o] = s);
        });
    }),
    t
  );
}
function mJ() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = t.getContainer,
    n = e === void 0 ? hJ : e,
    r = t.motion,
    i = t.prefixCls,
    o = t.maxCount,
    s = t.className,
    a = t.style,
    l = t.onAllRemoved,
    c = t.stack,
    u = t.renderNotifications,
    d = sr(t, dJ),
    p = L.useState(),
    m = ot(p, 2),
    v = m[0],
    _ = m[1],
    y = L.useRef(),
    g = L.createElement(fJ, {
      container: v,
      ref: y,
      prefixCls: i,
      motion: r,
      maxCount: o,
      className: s,
      style: a,
      onAllRemoved: l,
      stack: c,
      renderNotifications: u,
    }),
    x = L.useState([]),
    S = ot(x, 2),
    b = S[0],
    C = S[1],
    M = na(function (P) {
      var R = pJ(d, P);
      (R.key === null || R.key === void 0) &&
        ((R.key = "rc-notification-".concat(h3)), (h3 += 1)),
        C(function (E) {
          return [].concat(yt(E), [{ type: "open", config: R }]);
        });
    }),
    T = L.useMemo(function () {
      return {
        open: M,
        close: function (R) {
          C(function (E) {
            return [].concat(yt(E), [{ type: "close", key: R }]);
          });
        },
        destroy: function () {
          C(function (R) {
            return [].concat(yt(R), [{ type: "destroy" }]);
          });
        },
      };
    }, []);
  return (
    L.useEffect(function () {
      _(n());
    }),
    L.useEffect(
      function () {
        if (y.current && b.length) {
          b.forEach(function (E) {
            switch (E.type) {
              case "open":
                y.current.open(E.config);
                break;
              case "close":
                y.current.close(E.key);
                break;
              case "destroy":
                y.current.destroy();
                break;
            }
          });
          var P, R;
          C(function (E) {
            return (
              (P !== E || !R) &&
                ((P = E),
                (R = E.filter(function (O) {
                  return !b.includes(O);
                }))),
              R
            );
          });
        }
      },
      [b]
    ),
    [T, g]
  );
}
var gJ = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "0 0 1024 1024", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z",
          },
        },
      ],
    },
    name: "loading",
    theme: "outlined",
  },
  vJ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: gJ }));
  },
  KU = L.forwardRef(vJ);
const yJ = 100,
  xJ = 10,
  _J = yJ * xJ,
  SJ = (t) => {
    const {
        componentCls: e,
        iconCls: n,
        boxShadow: r,
        colorText: i,
        colorSuccess: o,
        colorError: s,
        colorWarning: a,
        colorInfo: l,
        fontSizeLG: c,
        motionEaseInOutCirc: u,
        motionDurationSlow: d,
        marginXS: p,
        paddingXS: m,
        borderRadiusLG: v,
        zIndexPopup: _,
        contentPadding: y,
        contentBg: g,
      } = t,
      x = `${e}-notice`,
      S = new zP("MessageMoveIn", {
        "0%": { padding: 0, transform: "translateY(-100%)", opacity: 0 },
        "100%": { padding: m, transform: "translateY(0)", opacity: 1 },
      }),
      b = new zP("MessageMoveOut", {
        "0%": { maxHeight: t.height, padding: m, opacity: 1 },
        "100%": { maxHeight: 0, padding: 0, opacity: 0 },
      }),
      C = {
        padding: m,
        textAlign: "center",
        [`${e}-custom-content`]: { display: "flex", alignItems: "center" },
        [`${e}-custom-content > ${n}`]: { marginInlineEnd: p, fontSize: c },
        [`${x}-content`]: {
          display: "inline-block",
          padding: y,
          background: g,
          borderRadius: v,
          boxShadow: r,
          pointerEvents: "all",
        },
        [`${e}-success > ${n}`]: { color: o },
        [`${e}-error > ${n}`]: { color: s },
        [`${e}-warning > ${n}`]: { color: a },
        [`${e}-info > ${n},
      ${e}-loading > ${n}`]: { color: l },
      };
    return [
      {
        [e]: Object.assign(Object.assign({}, Pc(t)), {
          color: i,
          position: "fixed",
          top: p,
          width: "100%",
          pointerEvents: "none",
          zIndex: _,
          [`${e}-move-up`]: { animationFillMode: "forwards" },
          [`
        ${e}-move-up-appear,
        ${e}-move-up-enter
      `]: {
            animationName: S,
            animationDuration: d,
            animationPlayState: "paused",
            animationTimingFunction: u,
          },
          [`
        ${e}-move-up-appear${e}-move-up-appear-active,
        ${e}-move-up-enter${e}-move-up-enter-active
      `]: { animationPlayState: "running" },
          [`${e}-move-up-leave`]: {
            animationName: b,
            animationDuration: d,
            animationPlayState: "paused",
            animationTimingFunction: u,
          },
          [`${e}-move-up-leave${e}-move-up-leave-active`]: {
            animationPlayState: "running",
          },
          "&-rtl": { direction: "rtl", span: { direction: "rtl" } },
        }),
      },
      { [e]: { [`${x}-wrapper`]: Object.assign({}, C) } },
      {
        [`${e}-notice-pure-panel`]: Object.assign(Object.assign({}, C), {
          padding: 0,
          textAlign: "start",
        }),
      },
    ];
  },
  AJ = (t) => ({
    zIndexPopup: t.zIndexPopupBase + _J + 10,
    contentBg: t.colorBgElevated,
    contentPadding: `${(t.controlHeightLG - t.fontSize * t.lineHeight) / 2}px ${
      t.paddingSM
    }px`,
  }),
  ZU = dl(
    "Message",
    (t) => {
      const e = di(t, { height: 150 });
      return SJ(e);
    },
    AJ
  );
var bJ = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const wJ = {
    info: L.createElement(QZ, null),
    success: L.createElement(VZ, null),
    error: L.createElement(XU, null),
    warning: L.createElement(KZ, null),
    loading: L.createElement(KU, null),
  },
  JU = ({ prefixCls: t, type: e, icon: n, children: r }) =>
    L.createElement(
      "div",
      { className: ft(`${t}-custom-content`, `${t}-${e}`) },
      n || wJ[e],
      L.createElement("span", null, r)
    ),
  EJ = (t) => {
    const { prefixCls: e, className: n, type: r, icon: i, content: o } = t,
      s = bJ(t, ["prefixCls", "className", "type", "icon", "content"]),
      { getPrefixCls: a } = L.useContext(Sn),
      l = e || a("message"),
      c = jf(l),
      [u, d, p] = ZU(l, c);
    return u(
      L.createElement(
        YU,
        Object.assign({}, s, {
          prefixCls: l,
          className: ft(n, d, `${l}-notice-pure-panel`, p, c),
          eventKey: "pure",
          duration: null,
          content: L.createElement(JU, { prefixCls: l, type: r, icon: i }, o),
        })
      )
    );
  };
function MJ(t, e) {
  return { motionName: e ?? `${t}-move-up` };
}
function lM(t) {
  let e;
  const n = new Promise((i) => {
      e = t(() => {
        i(!0);
      });
    }),
    r = () => {
      e == null || e();
    };
  return (r.then = (i, o) => n.then(i, o)), (r.promise = n), r;
}
var CJ = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const TJ = 8,
  RJ = 3,
  PJ = ({ children: t, prefixCls: e }) => {
    const n = jf(e),
      [r, i, o] = ZU(e, n);
    return r(L.createElement(aJ, { classNames: { list: ft(i, o, n) } }, t));
  },
  IJ = (t, { prefixCls: e, key: n }) =>
    L.createElement(PJ, { prefixCls: e, key: n }, t),
  LJ = L.forwardRef((t, e) => {
    const {
        top: n,
        prefixCls: r,
        getContainer: i,
        maxCount: o,
        duration: s = RJ,
        rtl: a,
        transitionName: l,
        onAllRemoved: c,
      } = t,
      {
        getPrefixCls: u,
        getPopupContainer: d,
        message: p,
        direction: m,
      } = L.useContext(Sn),
      v = r || u("message"),
      _ = () => ({ left: "50%", transform: "translateX(-50%)", top: n ?? TJ }),
      y = () => ft({ [`${v}-rtl`]: a ?? m === "rtl" }),
      g = () => MJ(v, l),
      x = L.createElement(
        "span",
        { className: `${v}-close-x` },
        L.createElement(XZ, { className: `${v}-close-icon` })
      ),
      [S, b] = mJ({
        prefixCls: v,
        style: _,
        className: y,
        motion: g,
        closable: !1,
        closeIcon: x,
        duration: s,
        getContainer: () =>
          (i == null ? void 0 : i()) ||
          (d == null ? void 0 : d()) ||
          document.body,
        maxCount: o,
        onAllRemoved: c,
        renderNotifications: IJ,
      });
    return (
      L.useImperativeHandle(e, () =>
        Object.assign(Object.assign({}, S), { prefixCls: v, message: p })
      ),
      b
    );
  });
let p3 = 0;
function QU(t) {
  const e = L.useRef(null);
  return [
    L.useMemo(() => {
      const r = (l) => {
          var c;
          (c = e.current) === null || c === void 0 || c.close(l);
        },
        i = (l) => {
          if (!e.current) {
            const M = () => {};
            return (M.then = () => {}), M;
          }
          const { open: c, prefixCls: u, message: d } = e.current,
            p = `${u}-notice`,
            {
              content: m,
              icon: v,
              type: _,
              key: y,
              className: g,
              style: x,
              onClose: S,
            } = l,
            b = CJ(l, [
              "content",
              "icon",
              "type",
              "key",
              "className",
              "style",
              "onClose",
            ]);
          let C = y;
          return (
            C == null && ((p3 += 1), (C = `antd-message-${p3}`)),
            lM(
              (M) => (
                c(
                  Object.assign(Object.assign({}, b), {
                    key: C,
                    content: L.createElement(
                      JU,
                      { prefixCls: u, type: _, icon: v },
                      m
                    ),
                    placement: "top",
                    className: ft(
                      _ && `${p}-${_}`,
                      g,
                      d == null ? void 0 : d.className
                    ),
                    style: Object.assign(
                      Object.assign({}, d == null ? void 0 : d.style),
                      x
                    ),
                    onClose: () => {
                      S == null || S(), M();
                    },
                  })
                ),
                () => {
                  r(C);
                }
              )
            )
          );
        },
        s = {
          open: i,
          destroy: (l) => {
            var c;
            l !== void 0
              ? r(l)
              : (c = e.current) === null || c === void 0 || c.destroy();
          },
        };
      return (
        ["info", "success", "warning", "error", "loading"].forEach((l) => {
          const c = (u, d, p) => {
            let m;
            u && typeof u == "object" && "content" in u
              ? (m = u)
              : (m = { content: u });
            let v, _;
            typeof d == "function" ? (_ = d) : ((v = d), (_ = p));
            const y = Object.assign(
              Object.assign({ onClose: _, duration: v }, m),
              { type: l }
            );
            return i(y);
          };
          s[l] = c;
        }),
        s
      );
    }, []),
    L.createElement(
      LJ,
      Object.assign({ key: "message-holder" }, t, { ref: e })
    ),
  ];
}
function OJ(t) {
  return QU(t);
}
function e4(t, e) {
  (this.v = t), (this.k = e);
}
function Wr(t, e, n, r) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch {
    i = 0;
  }
  (Wr = function (s, a, l, c) {
    function u(d, p) {
      Wr(s, d, function (m) {
        return this._invoke(d, p, m);
      });
    }
    a
      ? i
        ? i(s, a, { value: l, enumerable: !c, configurable: !c, writable: !c })
        : (s[a] = l)
      : (u("next", 0), u("throw", 1), u("return", 2));
  }),
    Wr(t, e, n, r);
}
function cM() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var t,
    e,
    n = typeof Symbol == "function" ? Symbol : {},
    r = n.iterator || "@@iterator",
    i = n.toStringTag || "@@toStringTag";
  function o(m, v, _, y) {
    var g = v && v.prototype instanceof a ? v : a,
      x = Object.create(g.prototype);
    return (
      Wr(
        x,
        "_invoke",
        (function (S, b, C) {
          var M,
            T,
            P,
            R = 0,
            E = C || [],
            O = !1,
            D = {
              p: 0,
              n: 0,
              v: t,
              a: N,
              f: N.bind(t, 4),
              d: function (V, G) {
                return (M = V), (T = 0), (P = t), (D.n = G), s;
              },
            };
          function N(z, V) {
            for (T = z, P = V, e = 0; !O && R && !G && e < E.length; e++) {
              var G,
                Y = E[e],
                U = D.p,
                j = Y[2];
              z > 3
                ? (G = j === V) &&
                  ((P = Y[(T = Y[4]) ? 5 : ((T = 3), 3)]), (Y[4] = Y[5] = t))
                : Y[0] <= U &&
                  ((G = z < 2 && U < Y[1])
                    ? ((T = 0), (D.v = V), (D.n = Y[1]))
                    : U < j &&
                      (G = z < 3 || Y[0] > V || V > j) &&
                      ((Y[4] = z), (Y[5] = V), (D.n = j), (T = 0)));
            }
            if (G || z > 1) return s;
            throw ((O = !0), V);
          }
          return function (z, V, G) {
            if (R > 1) throw TypeError("Generator is already running");
            for (
              O && V === 1 && N(V, G), T = V, P = G;
              (e = T < 2 ? t : P) || !O;

            ) {
              M ||
                (T
                  ? T < 3
                    ? (T > 1 && (D.n = -1), N(T, P))
                    : (D.n = P)
                  : (D.v = P));
              try {
                if (((R = 2), M)) {
                  if ((T || (z = "next"), (e = M[z]))) {
                    if (!(e = e.call(M, P)))
                      throw TypeError("iterator result is not an object");
                    if (!e.done) return e;
                    (P = e.value), T < 2 && (T = 0);
                  } else
                    T === 1 && (e = M.return) && e.call(M),
                      T < 2 &&
                        ((P = TypeError(
                          "The iterator does not provide a '" + z + "' method"
                        )),
                        (T = 1));
                  M = t;
                } else if ((e = (O = D.n < 0) ? P : S.call(b, D)) !== s) break;
              } catch (Y) {
                (M = t), (T = 1), (P = Y);
              } finally {
                R = 1;
              }
            }
            return { value: e, done: O };
          };
        })(m, _, y),
        !0
      ),
      x
    );
  }
  var s = {};
  function a() {}
  function l() {}
  function c() {}
  e = Object.getPrototypeOf;
  var u = [][r]
      ? e(e([][r]()))
      : (Wr((e = {}), r, function () {
          return this;
        }),
        e),
    d = (c.prototype = a.prototype = Object.create(u));
  function p(m) {
    return (
      Object.setPrototypeOf
        ? Object.setPrototypeOf(m, c)
        : ((m.__proto__ = c), Wr(m, i, "GeneratorFunction")),
      (m.prototype = Object.create(d)),
      m
    );
  }
  return (
    (l.prototype = c),
    Wr(d, "constructor", c),
    Wr(c, "constructor", l),
    (l.displayName = "GeneratorFunction"),
    Wr(c, i, "GeneratorFunction"),
    Wr(d),
    Wr(d, i, "Generator"),
    Wr(d, r, function () {
      return this;
    }),
    Wr(d, "toString", function () {
      return "[object Generator]";
    }),
    (cM = function () {
      return { w: o, m: p };
    })()
  );
}
function Pv(t, e) {
  function n(i, o, s, a) {
    try {
      var l = t[i](o),
        c = l.value;
      return c instanceof e4
        ? e.resolve(c.v).then(
            function (u) {
              n("next", u, s, a);
            },
            function (u) {
              n("throw", u, s, a);
            }
          )
        : e.resolve(c).then(
            function (u) {
              (l.value = u), s(l);
            },
            function (u) {
              return n("throw", u, s, a);
            }
          );
    } catch (u) {
      a(u);
    }
  }
  var r;
  this.next ||
    (Wr(Pv.prototype),
    Wr(
      Pv.prototype,
      (typeof Symbol == "function" && Symbol.asyncIterator) || "@asyncIterator",
      function () {
        return this;
      }
    )),
    Wr(
      this,
      "_invoke",
      function (i, o, s) {
        function a() {
          return new e(function (l, c) {
            n(i, s, l, c);
          });
        }
        return (r = r ? r.then(a, a) : a());
      },
      !0
    );
}
function t4(t, e, n, r, i) {
  return new Pv(cM().w(t, e, n, r), i || Promise);
}
function NJ(t, e, n, r, i) {
  var o = t4(t, e, n, r, i);
  return o.next().then(function (s) {
    return s.done ? s.value : o.next();
  });
}
function DJ(t) {
  var e = Object(t),
    n = [];
  for (var r in e) n.unshift(r);
  return function i() {
    for (; n.length; )
      if ((r = n.pop()) in e) return (i.value = r), (i.done = !1), i;
    return (i.done = !0), i;
  };
}
function m3(t) {
  if (t != null) {
    var e = t[(typeof Symbol == "function" && Symbol.iterator) || "@@iterator"],
      n = 0;
    if (e) return e.call(t);
    if (typeof t.next == "function") return t;
    if (!isNaN(t.length))
      return {
        next: function () {
          return (
            t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t }
          );
        },
      };
  }
  throw new TypeError(bt(t) + " is not iterable");
}
function Yr() {
  var t = cM(),
    e = t.m(Yr),
    n = (Object.getPrototypeOf ? Object.getPrototypeOf(e) : e.__proto__)
      .constructor;
  function r(s) {
    var a = typeof s == "function" && s.constructor;
    return (
      !!a && (a === n || (a.displayName || a.name) === "GeneratorFunction")
    );
  }
  var i = { throw: 1, return: 2, break: 3, continue: 3 };
  function o(s) {
    var a, l;
    return function (c) {
      a ||
        ((a = {
          stop: function () {
            return l(c.a, 2);
          },
          catch: function () {
            return c.v;
          },
          abrupt: function (d, p) {
            return l(c.a, i[d], p);
          },
          delegateYield: function (d, p, m) {
            return (a.resultName = p), l(c.d, m3(d), m);
          },
          finish: function (d) {
            return l(c.f, d);
          },
        }),
        (l = function (d, p, m) {
          (c.p = a.prev), (c.n = a.next);
          try {
            return d(p, m);
          } finally {
            a.next = c.n;
          }
        })),
        a.resultName && ((a[a.resultName] = c.v), (a.resultName = void 0)),
        (a.sent = c.v),
        (a.next = c.n);
      try {
        return s.call(this, a);
      } finally {
        (c.p = a.prev), (c.n = a.next);
      }
    };
  }
  return (Yr = function () {
    return {
      wrap: function (l, c, u, d) {
        return t.w(o(l), c, u, d && d.reverse());
      },
      isGeneratorFunction: r,
      mark: t.m,
      awrap: function (l, c) {
        return new e4(l, c);
      },
      AsyncIterator: Pv,
      async: function (l, c, u, d, p) {
        return (r(c) ? t4 : NJ)(o(l), c, u, d, p);
      },
      keys: DJ,
      values: m3,
    };
  })();
}
function g3(t, e, n, r, i, o, s) {
  try {
    var a = t[o](s),
      l = a.value;
  } catch (c) {
    return void n(c);
  }
  a.done ? e(l) : Promise.resolve(l).then(r, i);
}
function zc(t) {
  return function () {
    var e = this,
      n = arguments;
    return new Promise(function (r, i) {
      var o = t.apply(e, n);
      function s(l) {
        g3(o, r, i, s, a, "next", l);
      }
      function a(l) {
        g3(o, r, i, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
var Wp = Fe({}, BB),
  FJ = Wp.version,
  W_ = Wp.render,
  UJ = Wp.unmountComponentAtNode,
  Jy;
try {
  var kJ = Number((FJ || "").split(".")[0]);
  kJ >= 18 && (Jy = Wp.createRoot);
} catch {}
function v3(t) {
  var e = Wp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  e && bt(e) === "object" && (e.usingClientEntryPoint = t);
}
var Iv = "__rc_react_root__";
function zJ(t, e) {
  v3(!0);
  var n = e[Iv] || Jy(e);
  v3(!1), n.render(t), (e[Iv] = n);
}
function BJ(t, e) {
  W_ == null || W_(t, e);
}
function HJ(t, e) {
  if (Jy) {
    zJ(t, e);
    return;
  }
  BJ(t, e);
}
function VJ(t) {
  return Fb.apply(this, arguments);
}
function Fb() {
  return (
    (Fb = zc(
      Yr().mark(function t(e) {
        return Yr().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.resolve().then(function () {
                    var i;
                    (i = e[Iv]) === null || i === void 0 || i.unmount(),
                      delete e[Iv];
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    Fb.apply(this, arguments)
  );
}
function GJ(t) {
  UJ(t);
}
function WJ(t) {
  return Ub.apply(this, arguments);
}
function Ub() {
  return (
    (Ub = zc(
      Yr().mark(function t(e) {
        return Yr().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                if (Jy === void 0) {
                  r.next = 2;
                  break;
                }
                return r.abrupt("return", VJ(e));
              case 2:
                GJ(e);
              case 3:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    Ub.apply(this, arguments)
  );
}
const jJ = (t, e) => (HJ(t, e), () => WJ(e));
let $J = jJ;
function n4(t) {
  return $J;
}
const j_ = () => ({ height: 0, opacity: 0 }),
  y3 = (t) => {
    const { scrollHeight: e } = t;
    return { height: e, opacity: 1 };
  },
  XJ = (t) => ({ height: t ? t.offsetHeight : 0 }),
  $_ = (t, e) =>
    (e == null ? void 0 : e.deadline) === !0 || e.propertyName === "height",
  YJ = (t = mp) => ({
    motionName: `${t}-motion-collapse`,
    onAppearStart: j_,
    onEnterStart: j_,
    onAppearActive: y3,
    onEnterActive: y3,
    onLeaveStart: XJ,
    onLeaveActive: j_,
    onAppearEnd: $_,
    onEnterEnd: $_,
    onLeaveEnd: $_,
    motionDeadline: 500,
  });
function vp(t, e) {
  var n = Object.assign({}, t);
  return (
    Array.isArray(e) &&
      e.forEach(function (r) {
        delete n[r];
      }),
    n
  );
}
const qJ = function (t) {
    if (!t) return !1;
    if (t instanceof Element) {
      if (t.offsetParent) return !0;
      if (t.getBBox) {
        var e = t.getBBox(),
          n = e.width,
          r = e.height;
        if (n || r) return !0;
      }
      if (t.getBoundingClientRect) {
        var i = t.getBoundingClientRect(),
          o = i.width,
          s = i.height;
        if (o || s) return !0;
      }
    }
    return !1;
  },
  KJ = (t) => {
    const { componentCls: e, colorPrimary: n } = t;
    return {
      [e]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${n})`,
        boxShadow: "0 0 0 0 currentcolor",
        opacity: 0.2,
        "&.wave-motion-appear": {
          transition: [
            `box-shadow 0.4s ${t.motionEaseOutCirc}`,
            `opacity 2s ${t.motionEaseOutCirc}`,
          ].join(","),
          "&-active": { boxShadow: "0 0 0 6px currentcolor", opacity: 0 },
          "&.wave-quick": {
            transition: [
              `box-shadow ${t.motionDurationSlow} ${t.motionEaseInOut}`,
              `opacity ${t.motionDurationSlow} ${t.motionEaseInOut}`,
            ].join(","),
          },
        },
      },
    };
  },
  ZJ = jK("Wave", KJ),
  uM = `${mp}-wave-target`;
function JJ(t) {
  return (
    t &&
    t !== "#fff" &&
    t !== "#ffffff" &&
    t !== "rgb(255, 255, 255)" &&
    t !== "rgba(255, 255, 255, 1)" &&
    !/rgba\((?:\d*, ){3}0\)/.test(t) &&
    t !== "transparent" &&
    t !== "canvastext"
  );
}
function QJ(t) {
  var e;
  const {
    borderTopColor: n,
    borderColor: r,
    backgroundColor: i,
  } = getComputedStyle(t);
  return (e = [n, r, i].find(JJ)) !== null && e !== void 0 ? e : null;
}
function X_(t) {
  return Number.isNaN(t) ? 0 : t;
}
const eQ = (t) => {
    const { className: e, target: n, component: r, registerUnmount: i } = t,
      o = L.useRef(null),
      s = L.useRef(null);
    L.useEffect(() => {
      s.current = i();
    }, []);
    const [a, l] = L.useState(null),
      [c, u] = L.useState([]),
      [d, p] = L.useState(0),
      [m, v] = L.useState(0),
      [_, y] = L.useState(0),
      [g, x] = L.useState(0),
      [S, b] = L.useState(!1),
      C = {
        left: d,
        top: m,
        width: _,
        height: g,
        borderRadius: c.map((P) => `${P}px`).join(" "),
      };
    a && (C["--wave-color"] = a);
    function M() {
      const P = getComputedStyle(n);
      l(QJ(n));
      const R = P.position === "static",
        { borderLeftWidth: E, borderTopWidth: O } = P;
      p(R ? n.offsetLeft : X_(-parseFloat(E))),
        v(R ? n.offsetTop : X_(-parseFloat(O))),
        y(n.offsetWidth),
        x(n.offsetHeight);
      const {
        borderTopLeftRadius: D,
        borderTopRightRadius: N,
        borderBottomLeftRadius: z,
        borderBottomRightRadius: V,
      } = P;
      u([D, N, V, z].map((G) => X_(parseFloat(G))));
    }
    if (
      (L.useEffect(() => {
        if (n) {
          const P = Ao(() => {
            M(), b(!0);
          });
          let R;
          return (
            typeof ResizeObserver < "u" &&
              ((R = new ResizeObserver(M)), R.observe(n)),
            () => {
              Ao.cancel(P), R == null || R.disconnect();
            }
          );
        }
      }, []),
      !S)
    )
      return null;
    const T =
      (r === "Checkbox" || r === "Radio") &&
      (n == null ? void 0 : n.classList.contains(uM));
    return L.createElement(
      Ky,
      {
        visible: !0,
        motionAppear: !0,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (P, R) => {
          var E, O;
          if (R.deadline || R.propertyName === "opacity") {
            const D =
              (E = o.current) === null || E === void 0
                ? void 0
                : E.parentElement;
            (O = s.current) === null ||
              O === void 0 ||
              O.call(s).then(() => {
                D == null || D.remove();
              });
          }
          return !1;
        },
      },
      ({ className: P }, R) =>
        L.createElement("div", {
          ref: kc(o, R),
          className: ft(e, P, { "wave-quick": T }),
          style: C,
        })
    );
  },
  tQ = (t, e) => {
    var n;
    const { component: r } = e;
    if (
      r === "Checkbox" &&
      !(!((n = t.querySelector("input")) === null || n === void 0) && n.checked)
    )
      return;
    const i = document.createElement("div");
    (i.style.position = "absolute"),
      (i.style.left = "0px"),
      (i.style.top = "0px"),
      t == null || t.insertBefore(i, t == null ? void 0 : t.firstChild);
    const o = n4();
    let s = null;
    function a() {
      return s;
    }
    s = o(
      L.createElement(
        eQ,
        Object.assign({}, e, { target: t, registerUnmount: a })
      ),
      i
    );
  },
  nQ = (t, e, n) => {
    const { wave: r } = L.useContext(Sn),
      [, i, o] = Vf(),
      s = na((c) => {
        const u = t.current;
        if ((r != null && r.disabled) || !u) return;
        const d = u.querySelector(`.${uM}`) || u,
          { showEffect: p } = r || {};
        (p || tQ)(d, {
          className: e,
          token: i,
          component: n,
          event: c,
          hashId: o,
        });
      }),
      a = L.useRef(null);
    return (c) => {
      Ao.cancel(a.current),
        (a.current = Ao(() => {
          s(c);
        }));
    };
  },
  r4 = (t) => {
    const { children: e, disabled: n, component: r } = t,
      { getPrefixCls: i } = L.useContext(Sn),
      o = L.useRef(null),
      s = i("wave"),
      [, a] = ZJ(s),
      l = nQ(o, ft(s, a), r);
    if (
      (We.useEffect(() => {
        const u = o.current;
        if (!u || u.nodeType !== 1 || n) return;
        const d = (p) => {
          !qJ(p.target) ||
            !u.getAttribute ||
            u.getAttribute("disabled") ||
            u.disabled ||
            u.className.includes("disabled") ||
            u.className.includes("-leave") ||
            l(p);
        };
        return (
          u.addEventListener("click", d, !0),
          () => {
            u.removeEventListener("click", d, !0);
          }
        );
      }, [n]),
      !We.isValidElement(e))
    )
      return e ?? null;
    const c = XE(e) ? kc(YE(e), o) : o;
    return Rf(e, { ref: c });
  },
  Bc = (t) => {
    const e = We.useContext(Tf);
    return We.useMemo(
      () =>
        t
          ? typeof t == "string"
            ? t ?? e
            : typeof t == "function"
            ? t(e)
            : e
          : e,
      [t, e]
    );
  },
  i4 = L.createContext(null),
  Qy = (t, e) => {
    const n = L.useContext(i4),
      r = L.useMemo(() => {
        if (!n) return "";
        const { compactDirection: i, isFirstItem: o, isLastItem: s } = n,
          a = i === "vertical" ? "-vertical-" : "-";
        return ft(`${t}-compact${a}item`, {
          [`${t}-compact${a}first-item`]: o,
          [`${t}-compact${a}last-item`]: s,
          [`${t}-compact${a}item-rtl`]: e === "rtl",
        });
      }, [t, e, n]);
    return {
      compactSize: n == null ? void 0 : n.compactSize,
      compactDirection: n == null ? void 0 : n.compactDirection,
      compactItemClassnames: r,
    };
  },
  rQ = (t) => {
    const { children: e } = t;
    return L.createElement(i4.Provider, { value: null }, e);
  };
var iQ = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const o4 = L.createContext(void 0),
  oQ = (t) => {
    const { getPrefixCls: e, direction: n } = L.useContext(Sn),
      { prefixCls: r, size: i, className: o } = t,
      s = iQ(t, ["prefixCls", "size", "className"]),
      a = e("btn-group", r),
      [, , l] = Vf(),
      c = L.useMemo(() => {
        switch (i) {
          case "large":
            return "lg";
          case "small":
            return "sm";
          default:
            return "";
        }
      }, [i]),
      u = ft(a, { [`${a}-${c}`]: c, [`${a}-rtl`]: n === "rtl" }, o, l);
    return L.createElement(
      o4.Provider,
      { value: i },
      L.createElement("div", Object.assign({}, s, { className: u }))
    );
  },
  x3 = /^[\u4E00-\u9FA5]{2}$/,
  kb = x3.test.bind(x3);
function _3(t) {
  return typeof t == "string";
}
function Y_(t) {
  return t === "text" || t === "link";
}
function sQ(t, e) {
  if (t == null) return;
  const n = e ? " " : "";
  return typeof t != "string" &&
    typeof t != "number" &&
    _3(t.type) &&
    kb(t.props.children)
    ? Rf(t, { children: t.props.children.split("").join(n) })
    : _3(t)
    ? kb(t)
      ? We.createElement("span", null, t.split("").join(n))
      : We.createElement("span", null, t)
    : oJ(t)
    ? We.createElement("span", null, t)
    : t;
}
function aQ(t, e) {
  let n = !1;
  const r = [];
  return (
    We.Children.forEach(t, (i) => {
      const o = typeof i,
        s = o === "string" || o === "number";
      if (n && s) {
        const a = r.length - 1,
          l = r[a];
        r[a] = `${l}${i}`;
      } else r.push(i);
      n = s;
    }),
    We.Children.map(r, (i) => sQ(i, e))
  );
}
["default", "primary", "danger"].concat(yt(iM));
const zb = L.forwardRef((t, e) => {
    const { className: n, style: r, children: i, prefixCls: o } = t,
      s = ft(`${o}-icon`, n);
    return We.createElement("span", { ref: e, className: s, style: r }, i);
  }),
  S3 = L.forwardRef((t, e) => {
    const { prefixCls: n, className: r, style: i, iconClassName: o } = t,
      s = ft(`${n}-loading-icon`, r);
    return We.createElement(
      zb,
      { prefixCls: n, className: s, style: i, ref: e },
      We.createElement(KU, { className: o })
    );
  }),
  q_ = () => ({ width: 0, opacity: 0, transform: "scale(0)" }),
  K_ = (t) => ({ width: t.scrollWidth, opacity: 1, transform: "scale(1)" }),
  lQ = (t) => {
    const {
        prefixCls: e,
        loading: n,
        existIcon: r,
        className: i,
        style: o,
        mount: s,
      } = t,
      a = !!n;
    return r
      ? We.createElement(S3, { prefixCls: e, className: i, style: o })
      : We.createElement(
          Ky,
          {
            visible: a,
            motionName: `${e}-loading-icon-motion`,
            motionAppear: !s,
            motionEnter: !s,
            motionLeave: !s,
            removeOnLeave: !0,
            onAppearStart: q_,
            onAppearActive: K_,
            onEnterStart: q_,
            onEnterActive: K_,
            onLeaveStart: K_,
            onLeaveActive: q_,
          },
          ({ className: l, style: c }, u) => {
            const d = Object.assign(Object.assign({}, o), c);
            return We.createElement(S3, {
              prefixCls: e,
              className: ft(i, l),
              style: d,
              ref: u,
            });
          }
        );
  },
  A3 = (t, e) => ({
    [`> span, > ${t}`]: {
      "&:not(:last-child)": {
        [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineEndColor: e } },
      },
      "&:not(:first-child)": {
        [`&, & > ${t}`]: { "&:not(:disabled)": { borderInlineStartColor: e } },
      },
    },
  }),
  cQ = (t) => {
    const {
      componentCls: e,
      fontSize: n,
      lineWidth: r,
      groupBorderColor: i,
      colorErrorHover: o,
    } = t;
    return {
      [`${e}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          [`> span, > ${e}`]: {
            "&:not(:last-child)": {
              [`&, & > ${e}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
              },
            },
            "&:not(:first-child)": {
              marginInlineStart: t.calc(r).mul(-1).equal(),
              [`&, & > ${e}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
              },
            },
          },
          [e]: {
            position: "relative",
            zIndex: 1,
            "&:hover, &:focus, &:active": { zIndex: 2 },
            "&[disabled]": { zIndex: 0 },
          },
          [`${e}-icon-only`]: { fontSize: n },
        },
        A3(`${e}-primary`, i),
        A3(`${e}-danger`, o),
      ],
    };
  };
var uQ = ["b"],
  fQ = ["v"],
  Z_ = function (e) {
    return Math.round(Number(e || 0));
  },
  dQ = function (e) {
    if (e instanceof Tn) return e;
    if (e && bt(e) === "object" && "h" in e && "b" in e) {
      var n = e,
        r = n.b,
        i = sr(n, uQ);
      return Fe(Fe({}, i), {}, { v: r });
    }
    return typeof e == "string" && /hsb/.test(e) ? e.replace(/hsb/, "hsv") : e;
  },
  yp = (function (t) {
    ul(n, t);
    var e = fl(n);
    function n(r) {
      return Sr(this, n), e.call(this, dQ(r));
    }
    return (
      Ar(n, [
        {
          key: "toHsbString",
          value: function () {
            var i = this.toHsb(),
              o = Z_(i.s * 100),
              s = Z_(i.b * 100),
              a = Z_(i.h),
              l = i.a,
              c = "hsb(".concat(a, ", ").concat(o, "%, ").concat(s, "%)"),
              u = "hsba("
                .concat(a, ", ")
                .concat(o, "%, ")
                .concat(s, "%, ")
                .concat(l.toFixed(l === 0 ? 0 : 2), ")");
            return l === 1 ? c : u;
          },
        },
        {
          key: "toHsb",
          value: function () {
            var i = this.toHsv(),
              o = i.v,
              s = sr(i, fQ);
            return Fe(Fe({}, s), {}, { b: o, a: this.a });
          },
        },
      ]),
      n
    );
  })(Tn),
  hQ = function (e) {
    return e instanceof yp ? e : new yp(e);
  };
hQ("#1677ff");
const pQ = (t, e) =>
    (t == null ? void 0 : t.replace(/[^\w/]/g, "").slice(0, e ? 8 : 6)) || "",
  mQ = (t, e) => (t ? pQ(t, e) : "");
let gQ = (function () {
  function t(e) {
    Sr(this, t);
    var n;
    if (((this.cleared = !1), e instanceof t)) {
      (this.metaColor = e.metaColor.clone()),
        (this.colors =
          (n = e.colors) === null || n === void 0
            ? void 0
            : n.map((i) => ({ color: new t(i.color), percent: i.percent }))),
        (this.cleared = e.cleared);
      return;
    }
    const r = Array.isArray(e);
    r && e.length
      ? ((this.colors = e.map(({ color: i, percent: o }) => ({
          color: new t(i),
          percent: o,
        }))),
        (this.metaColor = new yp(this.colors[0].color.metaColor)))
      : (this.metaColor = new yp(r ? "" : e)),
      (!e || (r && !this.colors)) &&
        ((this.metaColor = this.metaColor.setA(0)), (this.cleared = !0));
  }
  return Ar(t, [
    {
      key: "toHsb",
      value: function () {
        return this.metaColor.toHsb();
      },
    },
    {
      key: "toHsbString",
      value: function () {
        return this.metaColor.toHsbString();
      },
    },
    {
      key: "toHex",
      value: function () {
        return mQ(this.toHexString(), this.metaColor.a < 1);
      },
    },
    {
      key: "toHexString",
      value: function () {
        return this.metaColor.toHexString();
      },
    },
    {
      key: "toRgb",
      value: function () {
        return this.metaColor.toRgb();
      },
    },
    {
      key: "toRgbString",
      value: function () {
        return this.metaColor.toRgbString();
      },
    },
    {
      key: "isGradient",
      value: function () {
        return !!this.colors && !this.cleared;
      },
    },
    {
      key: "getColors",
      value: function () {
        return this.colors || [{ color: this, percent: 0 }];
      },
    },
    {
      key: "toCssString",
      value: function () {
        const { colors: n } = this;
        return n
          ? `linear-gradient(90deg, ${n
              .map((i) => `${i.color.toRgbString()} ${i.percent}%`)
              .join(", ")})`
          : this.metaColor.toRgbString();
      },
    },
    {
      key: "equals",
      value: function (n) {
        return !n || this.isGradient() !== n.isGradient()
          ? !1
          : this.isGradient()
          ? this.colors.length === n.colors.length &&
            this.colors.every((r, i) => {
              const o = n.colors[i];
              return r.percent === o.percent && r.color.equals(o.color);
            })
          : this.toHexString() === n.toHexString();
      },
    },
  ]);
})();
var vQ = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z",
          },
        },
      ],
    },
    name: "right",
    theme: "outlined",
  },
  yQ = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: vQ }));
  },
  xQ = L.forwardRef(yQ),
  s4 = We.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = t.forceRender,
      i = t.className,
      o = t.style,
      s = t.children,
      a = t.isActive,
      l = t.role,
      c = t.classNames,
      u = t.styles,
      d = We.useState(a || r),
      p = ot(d, 2),
      m = p[0],
      v = p[1];
    return (
      We.useEffect(
        function () {
          (r || a) && v(!0);
        },
        [r, a]
      ),
      m
        ? We.createElement(
            "div",
            {
              ref: e,
              className: ft(
                "".concat(n, "-content"),
                ve(
                  ve({}, "".concat(n, "-content-active"), a),
                  "".concat(n, "-content-inactive"),
                  !a
                ),
                i
              ),
              style: o,
              role: l,
            },
            We.createElement(
              "div",
              {
                className: ft(
                  "".concat(n, "-content-box"),
                  c == null ? void 0 : c.body
                ),
                style: u == null ? void 0 : u.body,
              },
              s
            )
          )
        : null
    );
  });
s4.displayName = "PanelContent";
var _Q = [
    "showArrow",
    "headerClass",
    "isActive",
    "onItemClick",
    "forceRender",
    "className",
    "classNames",
    "styles",
    "prefixCls",
    "collapsible",
    "accordion",
    "panelKey",
    "extra",
    "header",
    "expandIcon",
    "openMotion",
    "destroyInactivePanel",
    "children",
  ],
  a4 = We.forwardRef(function (t, e) {
    var n = t.showArrow,
      r = n === void 0 ? !0 : n,
      i = t.headerClass,
      o = t.isActive,
      s = t.onItemClick,
      a = t.forceRender,
      l = t.className,
      c = t.classNames,
      u = c === void 0 ? {} : c,
      d = t.styles,
      p = d === void 0 ? {} : d,
      m = t.prefixCls,
      v = t.collapsible,
      _ = t.accordion,
      y = t.panelKey,
      g = t.extra,
      x = t.header,
      S = t.expandIcon,
      b = t.openMotion,
      C = t.destroyInactivePanel,
      M = t.children,
      T = sr(t, _Q),
      P = v === "disabled",
      R = g != null && typeof g != "boolean",
      E = ve(
        ve(
          ve(
            {
              onClick: function () {
                s == null || s(y);
              },
              onKeyDown: function (Y) {
                (Y.key === "Enter" ||
                  Y.keyCode === Db.ENTER ||
                  Y.which === Db.ENTER) &&
                  (s == null || s(y));
              },
              role: _ ? "tab" : "button",
            },
            "aria-expanded",
            o
          ),
          "aria-disabled",
          P
        ),
        "tabIndex",
        P ? -1 : 0
      ),
      O =
        typeof S == "function"
          ? S(t)
          : We.createElement("i", { className: "arrow" }),
      D =
        O &&
        We.createElement(
          "div",
          Bt(
            { className: "".concat(m, "-expand-icon") },
            ["header", "icon"].includes(v) ? E : {}
          ),
          O
        ),
      N = ft(
        "".concat(m, "-item"),
        ve(
          ve({}, "".concat(m, "-item-active"), o),
          "".concat(m, "-item-disabled"),
          P
        ),
        l
      ),
      z = ft(
        i,
        "".concat(m, "-header"),
        ve({}, "".concat(m, "-collapsible-").concat(v), !!v),
        u.header
      ),
      V = Fe(
        { className: z, style: p.header },
        ["header", "icon"].includes(v) ? {} : E
      );
    return We.createElement(
      "div",
      Bt({}, T, { ref: e, className: N }),
      We.createElement(
        "div",
        V,
        r && D,
        We.createElement(
          "span",
          Bt(
            { className: "".concat(m, "-header-text") },
            v === "header" ? E : {}
          ),
          x
        ),
        R && We.createElement("div", { className: "".concat(m, "-extra") }, g)
      ),
      We.createElement(
        Ky,
        Bt(
          { visible: o, leavedClassName: "".concat(m, "-content-hidden") },
          b,
          { forceRender: a, removeOnLeave: C }
        ),
        function (G, Y) {
          var U = G.className,
            j = G.style;
          return We.createElement(
            s4,
            {
              ref: Y,
              prefixCls: m,
              className: U,
              classNames: u,
              style: j,
              styles: p,
              isActive: o,
              forceRender: a,
              role: _ ? "tabpanel" : void 0,
            },
            M
          );
        }
      )
    );
  }),
  SQ = [
    "children",
    "label",
    "key",
    "collapsible",
    "onItemClick",
    "destroyInactivePanel",
  ],
  AQ = function (e, n) {
    var r = n.prefixCls,
      i = n.accordion,
      o = n.collapsible,
      s = n.destroyInactivePanel,
      a = n.onItemClick,
      l = n.activeKey,
      c = n.openMotion,
      u = n.expandIcon;
    return e.map(function (d, p) {
      var m = d.children,
        v = d.label,
        _ = d.key,
        y = d.collapsible,
        g = d.onItemClick,
        x = d.destroyInactivePanel,
        S = sr(d, SQ),
        b = String(_ ?? p),
        C = y ?? o,
        M = x ?? s,
        T = function (E) {
          C !== "disabled" && (a(E), g == null || g(E));
        },
        P = !1;
      return (
        i ? (P = l[0] === b) : (P = l.indexOf(b) > -1),
        We.createElement(
          a4,
          Bt({}, S, {
            prefixCls: r,
            key: b,
            panelKey: b,
            isActive: P,
            accordion: i,
            openMotion: c,
            expandIcon: u,
            header: v,
            collapsible: C,
            onItemClick: T,
            destroyInactivePanel: M,
          }),
          m
        )
      );
    });
  },
  bQ = function (e, n, r) {
    if (!e) return null;
    var i = r.prefixCls,
      o = r.accordion,
      s = r.collapsible,
      a = r.destroyInactivePanel,
      l = r.onItemClick,
      c = r.activeKey,
      u = r.openMotion,
      d = r.expandIcon,
      p = e.key || String(n),
      m = e.props,
      v = m.header,
      _ = m.headerClass,
      y = m.destroyInactivePanel,
      g = m.collapsible,
      x = m.onItemClick,
      S = !1;
    o ? (S = c[0] === p) : (S = c.indexOf(p) > -1);
    var b = g ?? s,
      C = function (P) {
        b !== "disabled" && (l(P), x == null || x(P));
      },
      M = {
        key: p,
        panelKey: p,
        header: v,
        headerClass: _,
        isActive: S,
        prefixCls: i,
        destroyInactivePanel: y ?? a,
        openMotion: u,
        accordion: o,
        children: e.props.children,
        onItemClick: C,
        expandIcon: d,
        collapsible: b,
      };
    return typeof e.type == "string"
      ? e
      : (Object.keys(M).forEach(function (T) {
          typeof M[T] > "u" && delete M[T];
        }),
        We.cloneElement(e, M));
  };
function wQ(t, e, n) {
  return Array.isArray(t)
    ? AQ(t, n)
    : bf(e).map(function (r, i) {
        return bQ(r, i, n);
      });
}
function EQ(t) {
  var e = t;
  if (!Array.isArray(e)) {
    var n = bt(e);
    e = n === "number" || n === "string" ? [e] : [];
  }
  return e.map(function (r) {
    return String(r);
  });
}
var MQ = We.forwardRef(function (t, e) {
  var n = t.prefixCls,
    r = n === void 0 ? "rc-collapse" : n,
    i = t.destroyInactivePanel,
    o = i === void 0 ? !1 : i,
    s = t.style,
    a = t.accordion,
    l = t.className,
    c = t.children,
    u = t.collapsible,
    d = t.openMotion,
    p = t.expandIcon,
    m = t.activeKey,
    v = t.defaultActiveKey,
    _ = t.onChange,
    y = t.items,
    g = ft(r, l),
    x = Hf([], {
      value: m,
      onChange: function (R) {
        return _ == null ? void 0 : _(R);
      },
      defaultValue: v,
      postState: EQ,
    }),
    S = ot(x, 2),
    b = S[0],
    C = S[1],
    M = function (R) {
      return C(function () {
        if (a) return b[0] === R ? [] : [R];
        var E = b.indexOf(R),
          O = E > -1;
        return O
          ? b.filter(function (D) {
              return D !== R;
            })
          : [].concat(yt(b), [R]);
      });
    };
  Ei(
    !c,
    "[rc-collapse] `children` will be removed in next major version. Please use `items` instead."
  );
  var T = wQ(y, c, {
    prefixCls: r,
    accordion: a,
    openMotion: d,
    expandIcon: p,
    collapsible: u,
    destroyInactivePanel: o,
    onItemClick: M,
    activeKey: b,
  });
  return We.createElement(
    "div",
    Bt(
      { ref: e, className: g, style: s, role: a ? "tablist" : void 0 },
      Zy(t, { aria: !0, data: !0 })
    ),
    T
  );
});
const fM = Object.assign(MQ, { Panel: a4 });
fM.Panel;
const CQ = L.forwardRef((t, e) => {
    const { getPrefixCls: n } = L.useContext(Sn),
      { prefixCls: r, className: i, showArrow: o = !0 } = t,
      s = n("collapse", r),
      a = ft({ [`${s}-no-arrow`]: !o }, i);
    return L.createElement(
      fM.Panel,
      Object.assign({ ref: e }, t, { prefixCls: s, className: a })
    );
  }),
  TQ = (t) => ({
    [t.componentCls]: {
      [`${t.antCls}-motion-collapse-legacy`]: {
        overflow: "hidden",
        "&-active": {
          transition: `height ${t.motionDurationMid} ${t.motionEaseInOut},
        opacity ${t.motionDurationMid} ${t.motionEaseInOut} !important`,
        },
      },
      [`${t.antCls}-motion-collapse`]: {
        overflow: "hidden",
        transition: `height ${t.motionDurationMid} ${t.motionEaseInOut},
        opacity ${t.motionDurationMid} ${t.motionEaseInOut} !important`,
      },
    },
  }),
  RQ = (t) => {
    const {
        componentCls: e,
        contentBg: n,
        padding: r,
        headerBg: i,
        headerPadding: o,
        collapseHeaderPaddingSM: s,
        collapseHeaderPaddingLG: a,
        collapsePanelBorderRadius: l,
        lineWidth: c,
        lineType: u,
        colorBorder: d,
        colorText: p,
        colorTextHeading: m,
        colorTextDisabled: v,
        fontSizeLG: _,
        lineHeight: y,
        lineHeightLG: g,
        marginSM: x,
        paddingSM: S,
        paddingLG: b,
        paddingXS: C,
        motionDurationSlow: M,
        fontSizeIcon: T,
        contentPadding: P,
        fontHeight: R,
        fontHeightLG: E,
      } = t,
      O = `${Tt(c)} ${u} ${d}`;
    return {
      [e]: Object.assign(Object.assign({}, Pc(t)), {
        backgroundColor: i,
        border: O,
        borderRadius: l,
        "&-rtl": { direction: "rtl" },
        [`& > ${e}-item`]: {
          borderBottom: O,
          "&:first-child": {
            [`
            &,
            & > ${e}-header`]: { borderRadius: `${Tt(l)} ${Tt(l)} 0 0` },
          },
          "&:last-child": {
            [`
            &,
            & > ${e}-header`]: { borderRadius: `0 0 ${Tt(l)} ${Tt(l)}` },
          },
          [`> ${e}-header`]: Object.assign(
            Object.assign(
              {
                position: "relative",
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "flex-start",
                padding: o,
                color: m,
                lineHeight: y,
                cursor: "pointer",
                transition: `all ${M}, visibility 0s`,
              },
              TU(t)
            ),
            {
              [`> ${e}-header-text`]: { flex: "auto" },
              [`${e}-expand-icon`]: {
                height: R,
                display: "flex",
                alignItems: "center",
                paddingInlineEnd: x,
              },
              [`${e}-arrow`]: Object.assign(Object.assign({}, oM()), {
                fontSize: T,
                transition: `transform ${M}`,
                svg: { transition: `transform ${M}` },
              }),
              [`${e}-header-text`]: { marginInlineEnd: "auto" },
            }
          ),
          [`${e}-collapsible-header`]: {
            cursor: "default",
            [`${e}-header-text`]: { flex: "none", cursor: "pointer" },
            [`${e}-expand-icon`]: { cursor: "pointer" },
          },
          [`${e}-collapsible-icon`]: {
            cursor: "unset",
            [`${e}-expand-icon`]: { cursor: "pointer" },
          },
        },
        [`${e}-content`]: {
          color: p,
          backgroundColor: n,
          borderTop: O,
          [`& > ${e}-content-box`]: { padding: P },
          "&-hidden": { display: "none" },
        },
        "&-small": {
          [`> ${e}-item`]: {
            [`> ${e}-header`]: {
              padding: s,
              paddingInlineStart: C,
              [`> ${e}-expand-icon`]: {
                marginInlineStart: t.calc(S).sub(C).equal(),
              },
            },
            [`> ${e}-content > ${e}-content-box`]: { padding: S },
          },
        },
        "&-large": {
          [`> ${e}-item`]: {
            fontSize: _,
            lineHeight: g,
            [`> ${e}-header`]: {
              padding: a,
              paddingInlineStart: r,
              [`> ${e}-expand-icon`]: {
                height: E,
                marginInlineStart: t.calc(b).sub(r).equal(),
              },
            },
            [`> ${e}-content > ${e}-content-box`]: { padding: b },
          },
        },
        [`${e}-item:last-child`]: {
          borderBottom: 0,
          [`> ${e}-content`]: { borderRadius: `0 0 ${Tt(l)} ${Tt(l)}` },
        },
        [`& ${e}-item-disabled > ${e}-header`]: {
          "\n          &,\n          & > .arrow\n        ": {
            color: v,
            cursor: "not-allowed",
          },
        },
        [`&${e}-icon-position-end`]: {
          [`& > ${e}-item`]: {
            [`> ${e}-header`]: {
              [`${e}-expand-icon`]: {
                order: 1,
                paddingInlineEnd: 0,
                paddingInlineStart: x,
              },
            },
          },
        },
      }),
    };
  },
  PQ = (t) => {
    const { componentCls: e } = t,
      n = `> ${e}-item > ${e}-header ${e}-arrow`;
    return { [`${e}-rtl`]: { [n]: { transform: "rotate(180deg)" } } };
  },
  IQ = (t) => {
    const {
      componentCls: e,
      headerBg: n,
      borderlessContentPadding: r,
      borderlessContentBg: i,
      colorBorder: o,
    } = t;
    return {
      [`${e}-borderless`]: {
        backgroundColor: n,
        border: 0,
        [`> ${e}-item`]: { borderBottom: `1px solid ${o}` },
        [`
        > ${e}-item:last-child,
        > ${e}-item:last-child ${e}-header
      `]: { borderRadius: 0 },
        [`> ${e}-item:last-child`]: { borderBottom: 0 },
        [`> ${e}-item > ${e}-content`]: { backgroundColor: i, borderTop: 0 },
        [`> ${e}-item > ${e}-content > ${e}-content-box`]: { padding: r },
      },
    };
  },
  LQ = (t) => {
    const { componentCls: e, paddingSM: n } = t;
    return {
      [`${e}-ghost`]: {
        backgroundColor: "transparent",
        border: 0,
        [`> ${e}-item`]: {
          borderBottom: 0,
          [`> ${e}-content`]: {
            backgroundColor: "transparent",
            border: 0,
            [`> ${e}-content-box`]: { paddingBlock: n },
          },
        },
      },
    };
  },
  OQ = (t) => ({
    headerPadding: `${t.paddingSM}px ${t.padding}px`,
    headerBg: t.colorFillAlter,
    contentPadding: `${t.padding}px 16px`,
    contentBg: t.colorBgContainer,
    borderlessContentPadding: `${t.paddingXXS}px 16px ${t.padding}px`,
    borderlessContentBg: "transparent",
  }),
  NQ = dl(
    "Collapse",
    (t) => {
      const e = di(t, {
        collapseHeaderPaddingSM: `${Tt(t.paddingXS)} ${Tt(t.paddingSM)}`,
        collapseHeaderPaddingLG: `${Tt(t.padding)} ${Tt(t.paddingLG)}`,
        collapsePanelBorderRadius: t.borderRadiusLG,
      });
      return [RQ(e), IQ(e), LQ(e), PQ(e), TQ(e)];
    },
    OQ
  ),
  DQ = L.forwardRef((t, e) => {
    const {
        getPrefixCls: n,
        direction: r,
        expandIcon: i,
        className: o,
        style: s,
      } = qy("collapse"),
      {
        prefixCls: a,
        className: l,
        rootClassName: c,
        style: u,
        bordered: d = !0,
        ghost: p,
        size: m,
        expandIconPosition: v = "start",
        children: _,
        destroyInactivePanel: y,
        destroyOnHidden: g,
        expandIcon: x,
      } = t,
      S = Bc((V) => {
        var G;
        return (G = m ?? V) !== null && G !== void 0 ? G : "middle";
      }),
      b = n("collapse", a),
      C = n(),
      [M, T, P] = NQ(b),
      R = L.useMemo(
        () => (v === "left" ? "start" : v === "right" ? "end" : v),
        [v]
      ),
      E = x ?? i,
      O = L.useCallback(
        (V = {}) => {
          const G =
            typeof E == "function"
              ? E(V)
              : L.createElement(xQ, {
                  rotate: V.isActive ? (r === "rtl" ? -90 : 90) : void 0,
                  "aria-label": V.isActive ? "expanded" : "collapsed",
                });
          return Rf(G, () => {
            var Y;
            return {
              className: ft(
                (Y = G.props) === null || Y === void 0 ? void 0 : Y.className,
                `${b}-arrow`
              ),
            };
          });
        },
        [E, b, r]
      ),
      D = ft(
        `${b}-icon-position-${R}`,
        {
          [`${b}-borderless`]: !d,
          [`${b}-rtl`]: r === "rtl",
          [`${b}-ghost`]: !!p,
          [`${b}-${S}`]: S !== "middle",
        },
        o,
        l,
        c,
        T,
        P
      ),
      N = L.useMemo(
        () =>
          Object.assign(Object.assign({}, YJ(C)), {
            motionAppear: !1,
            leavedClassName: `${b}-content-hidden`,
          }),
        [C, b]
      ),
      z = L.useMemo(
        () =>
          _
            ? bf(_).map((V, G) => {
                var Y, U;
                const j = V.props;
                if (j != null && j.disabled) {
                  const W =
                      (Y = V.key) !== null && Y !== void 0 ? Y : String(G),
                    B = Object.assign(
                      Object.assign({}, vp(V.props, ["disabled"])),
                      {
                        key: W,
                        collapsible:
                          (U = j.collapsible) !== null && U !== void 0
                            ? U
                            : "disabled",
                      }
                    );
                  return Rf(V, B);
                }
                return V;
              })
            : null,
        [_]
      );
    return M(
      L.createElement(
        fM,
        Object.assign({ ref: e, openMotion: N }, vp(t, ["rootClassName"]), {
          expandIcon: O,
          prefixCls: b,
          className: D,
          style: Object.assign(Object.assign({}, s), u),
          destroyInactivePanel: g ?? y,
        }),
        z
      )
    );
  }),
  l4 = Object.assign(DQ, { Panel: CQ }),
  FQ = (t, e) => {
    const { r: n, g: r, b: i, a: o } = t.toRgb(),
      s = new yp(t.toRgbString()).onBackground(e).toHsv();
    return o <= 0.5 ? s.v > 0.5 : n * 0.299 + r * 0.587 + i * 0.114 > 192;
  },
  c4 = (t) => {
    const { paddingInline: e, onlyIconSize: n } = t;
    return di(t, {
      buttonPaddingHorizontal: e,
      buttonPaddingVertical: 0,
      buttonIconOnlyFontSize: n,
    });
  },
  u4 = (t) => {
    var e, n, r, i, o, s;
    const a = (e = t.contentFontSize) !== null && e !== void 0 ? e : t.fontSize,
      l = (n = t.contentFontSizeSM) !== null && n !== void 0 ? n : t.fontSize,
      c = (r = t.contentFontSizeLG) !== null && r !== void 0 ? r : t.fontSizeLG,
      u = (i = t.contentLineHeight) !== null && i !== void 0 ? i : H0(a),
      d = (o = t.contentLineHeightSM) !== null && o !== void 0 ? o : H0(l),
      p = (s = t.contentLineHeightLG) !== null && s !== void 0 ? s : H0(c),
      m = FQ(new gQ(t.colorBgSolid), "#fff") ? "#000" : "#fff",
      v = iM.reduce(
        (_, y) =>
          Object.assign(Object.assign({}, _), {
            [`${y}ShadowColor`]: `0 ${Tt(t.controlOutlineWidth)} 0 ${Qd(
              t[`${y}1`],
              t.colorBgContainer
            )}`,
          }),
        {}
      );
    return Object.assign(Object.assign({}, v), {
      fontWeight: 400,
      iconGap: t.marginXS,
      defaultShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlTmpOutline}`,
      primaryShadow: `0 ${t.controlOutlineWidth}px 0 ${t.controlOutline}`,
      dangerShadow: `0 ${t.controlOutlineWidth}px 0 ${t.colorErrorOutline}`,
      primaryColor: t.colorTextLightSolid,
      dangerColor: t.colorTextLightSolid,
      borderColorDisabled: t.colorBorder,
      defaultGhostColor: t.colorBgContainer,
      ghostBg: "transparent",
      defaultGhostBorderColor: t.colorBgContainer,
      paddingInline: t.paddingContentHorizontal - t.lineWidth,
      paddingInlineLG: t.paddingContentHorizontal - t.lineWidth,
      paddingInlineSM: 8 - t.lineWidth,
      onlyIconSize: "inherit",
      onlyIconSizeSM: "inherit",
      onlyIconSizeLG: "inherit",
      groupBorderColor: t.colorPrimaryHover,
      linkHoverBg: "transparent",
      textTextColor: t.colorText,
      textTextHoverColor: t.colorText,
      textTextActiveColor: t.colorText,
      textHoverBg: t.colorFillTertiary,
      defaultColor: t.colorText,
      defaultBg: t.colorBgContainer,
      defaultBorderColor: t.colorBorder,
      defaultBorderColorDisabled: t.colorBorder,
      defaultHoverBg: t.colorBgContainer,
      defaultHoverColor: t.colorPrimaryHover,
      defaultHoverBorderColor: t.colorPrimaryHover,
      defaultActiveBg: t.colorBgContainer,
      defaultActiveColor: t.colorPrimaryActive,
      defaultActiveBorderColor: t.colorPrimaryActive,
      solidTextColor: m,
      contentFontSize: a,
      contentFontSizeSM: l,
      contentFontSizeLG: c,
      contentLineHeight: u,
      contentLineHeightSM: d,
      contentLineHeightLG: p,
      paddingBlock: Math.max((t.controlHeight - a * u) / 2 - t.lineWidth, 0),
      paddingBlockSM: Math.max(
        (t.controlHeightSM - l * d) / 2 - t.lineWidth,
        0
      ),
      paddingBlockLG: Math.max(
        (t.controlHeightLG - c * p) / 2 - t.lineWidth,
        0
      ),
    });
  },
  UQ = (t) => {
    const {
      componentCls: e,
      iconCls: n,
      fontWeight: r,
      opacityLoading: i,
      motionDurationSlow: o,
      motionEaseInOut: s,
      iconGap: a,
      calc: l,
    } = t;
    return {
      [e]: {
        outline: "none",
        position: "relative",
        display: "inline-flex",
        gap: a,
        alignItems: "center",
        justifyContent: "center",
        fontWeight: r,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        background: "transparent",
        border: `${Tt(t.lineWidth)} ${t.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${t.motionDurationMid} ${t.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        color: t.colorText,
        "&:disabled > *": { pointerEvents: "none" },
        [`${e}-icon > svg`]: oM(),
        "> a": { color: "currentColor" },
        "&:not(:disabled)": TU(t),
        [`&${e}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
        [`&${e}-two-chinese-chars > *:not(${n})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em",
        },
        [`&${e}-icon-only`]: {
          paddingInline: 0,
          [`&${e}-compact-item`]: { flex: "none" },
          [`&${e}-round`]: { width: "auto" },
        },
        [`&${e}-loading`]: { opacity: i, cursor: "default" },
        [`${e}-loading-icon`]: {
          transition: ["width", "opacity", "margin"]
            .map((c) => `${c} ${o} ${s}`)
            .join(","),
        },
        [`&:not(${e}-icon-end)`]: {
          [`${e}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineEnd: l(a).mul(-1).equal(),
            },
            "&-appear-active, &-enter-active": { marginInlineEnd: 0 },
            "&-leave-start": { marginInlineEnd: 0 },
            "&-leave-active": { marginInlineEnd: l(a).mul(-1).equal() },
          },
        },
        "&-icon-end": {
          flexDirection: "row-reverse",
          [`${e}-loading-icon-motion`]: {
            "&-appear-start, &-enter-start": {
              marginInlineStart: l(a).mul(-1).equal(),
            },
            "&-appear-active, &-enter-active": { marginInlineStart: 0 },
            "&-leave-start": { marginInlineStart: 0 },
            "&-leave-active": { marginInlineStart: l(a).mul(-1).equal() },
          },
        },
      },
    };
  },
  f4 = (t, e, n) => ({
    [`&:not(:disabled):not(${t}-disabled)`]: { "&:hover": e, "&:active": n },
  }),
  kQ = (t) => ({
    minWidth: t.controlHeight,
    paddingInline: 0,
    borderRadius: "50%",
  }),
  zQ = (t) => {
    var e;
    return {
      borderRadius: t.controlHeight,
      paddingInline:
        (e = t.paddingInline) !== null && e !== void 0
          ? e
          : t.calc(t.controlHeight).div(2).equal(),
    };
  },
  BQ = (t) => ({
    cursor: "not-allowed",
    borderColor: t.borderColorDisabled,
    color: t.colorTextDisabled,
    background: t.colorBgContainerDisabled,
    boxShadow: "none",
  }),
  ex = (t, e, n, r, i, o, s, a) => ({
    [`&${t}-background-ghost`]: Object.assign(
      Object.assign(
        {
          color: n || void 0,
          background: e,
          borderColor: r || void 0,
          boxShadow: "none",
        },
        f4(
          t,
          Object.assign({ background: e }, s),
          Object.assign({ background: e }, a)
        )
      ),
      {
        "&:disabled": {
          cursor: "not-allowed",
          color: i || void 0,
          borderColor: o || void 0,
        },
      }
    ),
  }),
  HQ = (t) => ({
    [`&:disabled, &${t.componentCls}-disabled`]: Object.assign({}, BQ(t)),
  }),
  VQ = (t) => ({
    [`&:disabled, &${t.componentCls}-disabled`]: {
      cursor: "not-allowed",
      color: t.colorTextDisabled,
    },
  }),
  tx = (t, e, n, r) => {
    const o = r && ["link", "text"].includes(r) ? VQ : HQ;
    return Object.assign(Object.assign({}, o(t)), f4(t.componentCls, e, n));
  },
  nx = (t, e, n, r, i) => ({
    [`&${t.componentCls}-variant-solid`]: Object.assign(
      { color: e, background: n },
      tx(t, r, i)
    ),
  }),
  rx = (t, e, n, r, i) => ({
    [`&${t.componentCls}-variant-outlined, &${t.componentCls}-variant-dashed`]:
      Object.assign({ borderColor: e, background: n }, tx(t, r, i)),
  }),
  ix = (t) => ({
    [`&${t.componentCls}-variant-dashed`]: { borderStyle: "dashed" },
  }),
  ox = (t, e, n, r) => ({
    [`&${t.componentCls}-variant-filled`]: Object.assign(
      { boxShadow: "none", background: e },
      tx(t, n, r)
    ),
  }),
  vs = (t, e, n, r, i) => ({
    [`&${t.componentCls}-variant-${n}`]: Object.assign(
      { color: e, boxShadow: "none" },
      tx(t, r, i, n)
    ),
  }),
  GQ = (t) => {
    const { componentCls: e } = t;
    return iM.reduce((n, r) => {
      const i = t[`${r}6`],
        o = t[`${r}1`],
        s = t[`${r}5`],
        a = t[`${r}2`],
        l = t[`${r}3`],
        c = t[`${r}7`];
      return Object.assign(Object.assign({}, n), {
        [`&${e}-color-${r}`]: Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    { color: i, boxShadow: t[`${r}ShadowColor`] },
                    nx(
                      t,
                      t.colorTextLightSolid,
                      i,
                      { background: s },
                      { background: c }
                    )
                  ),
                  rx(
                    t,
                    i,
                    t.colorBgContainer,
                    {
                      color: s,
                      borderColor: s,
                      background: t.colorBgContainer,
                    },
                    { color: c, borderColor: c, background: t.colorBgContainer }
                  )
                ),
                ix(t)
              ),
              ox(t, o, { color: i, background: a }, { color: i, background: l })
            ),
            vs(t, i, "link", { color: s }, { color: c })
          ),
          vs(
            t,
            i,
            "text",
            { color: s, background: o },
            { color: c, background: l }
          )
        ),
      });
    }, {});
  },
  WQ = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              { color: t.defaultColor, boxShadow: t.defaultShadow },
              nx(
                t,
                t.solidTextColor,
                t.colorBgSolid,
                { color: t.solidTextColor, background: t.colorBgSolidHover },
                { color: t.solidTextColor, background: t.colorBgSolidActive }
              )
            ),
            ix(t)
          ),
          ox(
            t,
            t.colorFillTertiary,
            { color: t.defaultColor, background: t.colorFillSecondary },
            { color: t.defaultColor, background: t.colorFill }
          )
        ),
        ex(
          t.componentCls,
          t.ghostBg,
          t.defaultGhostColor,
          t.defaultGhostBorderColor,
          t.colorTextDisabled,
          t.colorBorder
        )
      ),
      vs(
        t,
        t.textTextColor,
        "link",
        { color: t.colorLinkHover, background: t.linkHoverBg },
        { color: t.colorLinkActive }
      )
    ),
  jQ = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                { color: t.colorPrimary, boxShadow: t.primaryShadow },
                rx(
                  t,
                  t.colorPrimary,
                  t.colorBgContainer,
                  {
                    color: t.colorPrimaryTextHover,
                    borderColor: t.colorPrimaryHover,
                    background: t.colorBgContainer,
                  },
                  {
                    color: t.colorPrimaryTextActive,
                    borderColor: t.colorPrimaryActive,
                    background: t.colorBgContainer,
                  }
                )
              ),
              ix(t)
            ),
            ox(
              t,
              t.colorPrimaryBg,
              { color: t.colorPrimary, background: t.colorPrimaryBgHover },
              { color: t.colorPrimary, background: t.colorPrimaryBorder }
            )
          ),
          vs(
            t,
            t.colorPrimaryText,
            "text",
            { color: t.colorPrimaryTextHover, background: t.colorPrimaryBg },
            {
              color: t.colorPrimaryTextActive,
              background: t.colorPrimaryBorder,
            }
          )
        ),
        vs(
          t,
          t.colorPrimaryText,
          "link",
          { color: t.colorPrimaryTextHover, background: t.linkHoverBg },
          { color: t.colorPrimaryTextActive }
        )
      ),
      ex(
        t.componentCls,
        t.ghostBg,
        t.colorPrimary,
        t.colorPrimary,
        t.colorTextDisabled,
        t.colorBorder,
        { color: t.colorPrimaryHover, borderColor: t.colorPrimaryHover },
        { color: t.colorPrimaryActive, borderColor: t.colorPrimaryActive }
      )
    ),
  $Q = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  { color: t.colorError, boxShadow: t.dangerShadow },
                  nx(
                    t,
                    t.dangerColor,
                    t.colorError,
                    { background: t.colorErrorHover },
                    { background: t.colorErrorActive }
                  )
                ),
                rx(
                  t,
                  t.colorError,
                  t.colorBgContainer,
                  {
                    color: t.colorErrorHover,
                    borderColor: t.colorErrorBorderHover,
                  },
                  { color: t.colorErrorActive, borderColor: t.colorErrorActive }
                )
              ),
              ix(t)
            ),
            ox(
              t,
              t.colorErrorBg,
              { color: t.colorError, background: t.colorErrorBgFilledHover },
              { color: t.colorError, background: t.colorErrorBgActive }
            )
          ),
          vs(
            t,
            t.colorError,
            "text",
            { color: t.colorErrorHover, background: t.colorErrorBg },
            { color: t.colorErrorHover, background: t.colorErrorBgActive }
          )
        ),
        vs(
          t,
          t.colorError,
          "link",
          { color: t.colorErrorHover },
          { color: t.colorErrorActive }
        )
      ),
      ex(
        t.componentCls,
        t.ghostBg,
        t.colorError,
        t.colorError,
        t.colorTextDisabled,
        t.colorBorder,
        { color: t.colorErrorHover, borderColor: t.colorErrorHover },
        { color: t.colorErrorActive, borderColor: t.colorErrorActive }
      )
    ),
  XQ = (t) =>
    Object.assign(
      Object.assign(
        {},
        vs(
          t,
          t.colorLink,
          "link",
          { color: t.colorLinkHover },
          { color: t.colorLinkActive }
        )
      ),
      ex(
        t.componentCls,
        t.ghostBg,
        t.colorInfo,
        t.colorInfo,
        t.colorTextDisabled,
        t.colorBorder,
        { color: t.colorInfoHover, borderColor: t.colorInfoHover },
        { color: t.colorInfoActive, borderColor: t.colorInfoActive }
      )
    ),
  YQ = (t) => {
    const { componentCls: e } = t;
    return Object.assign(
      {
        [`${e}-color-default`]: WQ(t),
        [`${e}-color-primary`]: jQ(t),
        [`${e}-color-dangerous`]: $Q(t),
        [`${e}-color-link`]: XQ(t),
      },
      GQ(t)
    );
  },
  qQ = (t) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            rx(
              t,
              t.defaultBorderColor,
              t.defaultBg,
              {
                color: t.defaultHoverColor,
                borderColor: t.defaultHoverBorderColor,
                background: t.defaultHoverBg,
              },
              {
                color: t.defaultActiveColor,
                borderColor: t.defaultActiveBorderColor,
                background: t.defaultActiveBg,
              }
            )
          ),
          vs(
            t,
            t.textTextColor,
            "text",
            { color: t.textTextHoverColor, background: t.textHoverBg },
            { color: t.textTextActiveColor, background: t.colorBgTextActive }
          )
        ),
        nx(
          t,
          t.primaryColor,
          t.colorPrimary,
          { background: t.colorPrimaryHover, color: t.primaryColor },
          { background: t.colorPrimaryActive, color: t.primaryColor }
        )
      ),
      vs(
        t,
        t.colorLink,
        "link",
        { color: t.colorLinkHover, background: t.linkHoverBg },
        { color: t.colorLinkActive }
      )
    ),
  dM = (t, e = "") => {
    const {
      componentCls: n,
      controlHeight: r,
      fontSize: i,
      borderRadius: o,
      buttonPaddingHorizontal: s,
      iconCls: a,
      buttonPaddingVertical: l,
      buttonIconOnlyFontSize: c,
    } = t;
    return [
      {
        [e]: {
          fontSize: i,
          height: r,
          padding: `${Tt(l)} ${Tt(s)}`,
          borderRadius: o,
          [`&${n}-icon-only`]: { width: r, [a]: { fontSize: c } },
        },
      },
      { [`${n}${n}-circle${e}`]: kQ(t) },
      { [`${n}${n}-round${e}`]: zQ(t) },
    ];
  },
  KQ = (t) => {
    const e = di(t, { fontSize: t.contentFontSize });
    return dM(e, t.componentCls);
  },
  ZQ = (t) => {
    const e = di(t, {
      controlHeight: t.controlHeightSM,
      fontSize: t.contentFontSizeSM,
      padding: t.paddingXS,
      buttonPaddingHorizontal: t.paddingInlineSM,
      buttonPaddingVertical: 0,
      borderRadius: t.borderRadiusSM,
      buttonIconOnlyFontSize: t.onlyIconSizeSM,
    });
    return dM(e, `${t.componentCls}-sm`);
  },
  JQ = (t) => {
    const e = di(t, {
      controlHeight: t.controlHeightLG,
      fontSize: t.contentFontSizeLG,
      buttonPaddingHorizontal: t.paddingInlineLG,
      buttonPaddingVertical: 0,
      borderRadius: t.borderRadiusLG,
      buttonIconOnlyFontSize: t.onlyIconSizeLG,
    });
    return dM(e, `${t.componentCls}-lg`);
  },
  QQ = (t) => {
    const { componentCls: e } = t;
    return { [e]: { [`&${e}-block`]: { width: "100%" } } };
  },
  eee = dl(
    "Button",
    (t) => {
      const e = c4(t);
      return [UQ(e), KQ(e), ZQ(e), JQ(e), QQ(e), YQ(e), qQ(e), cQ(e)];
    },
    u4,
    {
      unitless: {
        fontWeight: !0,
        contentLineHeight: !0,
        contentLineHeightSM: !0,
        contentLineHeightLG: !0,
      },
    }
  );
function tee(t, e, n, r) {
  const { focusElCls: i, focus: o, borderElCls: s } = n,
    a = s ? "> *" : "",
    l = ["hover", o ? "focus" : null, "active"]
      .filter(Boolean)
      .map((c) => `&:${c} ${a}`)
      .join(",");
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
    },
    [`&-item:not(${r}-status-success)`]: { zIndex: 2 },
    "&-item": Object.assign(
      Object.assign(
        { [l]: { zIndex: 3 } },
        i ? { [`&${i}`]: { zIndex: 3 } } : {}
      ),
      { [`&[disabled] ${a}`]: { zIndex: 0 } }
    ),
  };
}
function nee(t, e, n) {
  const { borderElCls: r } = n,
    i = r ? `> ${r}` : "";
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item) ${i}`]: {
      borderRadius: 0,
    },
    [`&-item:not(${e}-last-item)${e}-first-item`]: {
      [`& ${i}, &${t}-sm ${i}, &${t}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
      },
    },
    [`&-item:not(${e}-first-item)${e}-last-item`]: {
      [`& ${i}, &${t}-sm ${i}, &${t}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
      },
    },
  };
}
function d4(t, e = { focus: !0 }) {
  const { componentCls: n } = t,
    r = `${n}-compact`;
  return {
    [r]: Object.assign(Object.assign({}, tee(t, r, e, n)), nee(n, r, e)),
  };
}
function ree(t, e, n) {
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginBottom: t.calc(t.lineWidth).mul(-1).equal(),
    },
    [`&-item:not(${n}-status-success)`]: { zIndex: 2 },
    "&-item": {
      "&:hover,&:focus,&:active": { zIndex: 3 },
      "&[disabled]": { zIndex: 0 },
    },
  };
}
function iee(t, e) {
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item)`]: { borderRadius: 0 },
    [`&-item${e}-first-item:not(${e}-last-item)`]: {
      [`&, &${t}-sm, &${t}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0,
      },
    },
    [`&-item${e}-last-item:not(${e}-first-item)`]: {
      [`&, &${t}-sm, &${t}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0,
      },
    },
  };
}
function oee(t) {
  const e = `${t.componentCls}-compact-vertical`;
  return {
    [e]: Object.assign(
      Object.assign({}, ree(t, e, t.componentCls)),
      iee(t.componentCls, e)
    ),
  };
}
const see = (t) => {
    const { componentCls: e, colorPrimaryHover: n, lineWidth: r, calc: i } = t,
      o = i(r).mul(-1).equal(),
      s = (a) => {
        const l = `${e}-compact${
          a ? "-vertical" : ""
        }-item${e}-primary:not([disabled])`;
        return {
          [`${l} + ${l}::before`]: {
            position: "absolute",
            top: a ? o : 0,
            insetInlineStart: a ? 0 : o,
            backgroundColor: n,
            content: '""',
            width: a ? "100%" : r,
            height: a ? r : "100%",
          },
        };
      };
    return Object.assign(Object.assign({}, s()), s(!0));
  },
  aee = $K(
    ["Button", "compact"],
    (t) => {
      const e = c4(t);
      return [d4(e), oee(e), see(e)];
    },
    u4
  );
var lee = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function cee(t) {
  if (typeof t == "object" && t) {
    let e = t == null ? void 0 : t.delay;
    return (
      (e = !Number.isNaN(e) && typeof e == "number" ? e : 0),
      { loading: e <= 0, delay: e }
    );
  }
  return { loading: !!t, delay: 0 };
}
const uee = {
    default: ["default", "outlined"],
    primary: ["primary", "solid"],
    dashed: ["default", "dashed"],
    link: ["link", "link"],
    text: ["default", "text"],
  },
  fee = We.forwardRef((t, e) => {
    var n, r;
    const {
        loading: i = !1,
        prefixCls: o,
        color: s,
        variant: a,
        type: l,
        danger: c = !1,
        shape: u,
        size: d,
        styles: p,
        disabled: m,
        className: v,
        rootClassName: _,
        children: y,
        icon: g,
        iconPosition: x = "start",
        ghost: S = !1,
        block: b = !1,
        htmlType: C = "button",
        classNames: M,
        style: T = {},
        autoInsertSpace: P,
        autoFocus: R,
      } = t,
      E = lee(t, [
        "loading",
        "prefixCls",
        "color",
        "variant",
        "type",
        "danger",
        "shape",
        "size",
        "styles",
        "disabled",
        "className",
        "rootClassName",
        "children",
        "icon",
        "iconPosition",
        "ghost",
        "block",
        "htmlType",
        "classNames",
        "style",
        "autoInsertSpace",
        "autoFocus",
      ]),
      O = l || "default",
      { button: D } = We.useContext(Sn),
      N = u || (D == null ? void 0 : D.shape) || "default",
      [z, V] = L.useMemo(() => {
        if (s && a) return [s, a];
        if (l || c) {
          const be = uee[O] || [];
          return c ? ["danger", be[1]] : be;
        }
        return D != null && D.color && D != null && D.variant
          ? [D.color, D.variant]
          : ["default", "outlined"];
      }, [
        l,
        s,
        a,
        c,
        D == null ? void 0 : D.variant,
        D == null ? void 0 : D.color,
      ]),
      Y = z === "danger" ? "dangerous" : z,
      {
        getPrefixCls: U,
        direction: j,
        autoInsertSpace: W,
        className: B,
        style: q,
        classNames: Z,
        styles: H,
      } = qy("button"),
      X = (n = P ?? W) !== null && n !== void 0 ? n : !0,
      ne = U("btn", o),
      [oe, ue, Ie] = eee(ne),
      te = L.useContext(rl),
      ge = m ?? te,
      ie = L.useContext(o4),
      pe = L.useMemo(() => cee(i), [i]),
      [de, Ee] = L.useState(pe.loading),
      [he, Ce] = L.useState(!1),
      _e = L.useRef(null),
      $ = DF(e, _e),
      k = L.Children.count(y) === 1 && !g && !Y_(V),
      J = L.useRef(!0);
    We.useEffect(
      () => (
        (J.current = !1),
        () => {
          J.current = !0;
        }
      ),
      []
    ),
      fp(() => {
        let be = null;
        pe.delay > 0
          ? (be = setTimeout(() => {
              (be = null), Ee(!0);
            }, pe.delay))
          : Ee(pe.loading);
        function se() {
          be && (clearTimeout(be), (be = null));
        }
        return se;
      }, [pe.delay, pe.loading]),
      L.useEffect(() => {
        if (!_e.current || !X) return;
        const be = _e.current.textContent || "";
        k && kb(be) ? he || Ce(!0) : he && Ce(!1);
      }),
      L.useEffect(() => {
        R && _e.current && _e.current.focus();
      }, []);
    const fe = We.useCallback(
        (be) => {
          var se;
          if (de || ge) {
            be.preventDefault();
            return;
          }
          (se = t.onClick) === null ||
            se === void 0 ||
            se.call(t, ("href" in t, be));
        },
        [t.onClick, de, ge]
      ),
      { compactSize: le, compactItemClassnames: ce } = Qy(ne, j),
      we = { large: "lg", small: "sm", middle: void 0 },
      Be = Bc((be) => {
        var se, Ae;
        return (Ae = (se = d ?? le) !== null && se !== void 0 ? se : ie) !==
          null && Ae !== void 0
          ? Ae
          : be;
      }),
      Me = Be && (r = we[Be]) !== null && r !== void 0 ? r : "",
      Ge = de ? "loading" : g,
      Le = vp(E, ["navigate"]),
      je = ft(
        ne,
        ue,
        Ie,
        {
          [`${ne}-${N}`]: N !== "default" && N,
          [`${ne}-${O}`]: O,
          [`${ne}-dangerous`]: c,
          [`${ne}-color-${Y}`]: Y,
          [`${ne}-variant-${V}`]: V,
          [`${ne}-${Me}`]: Me,
          [`${ne}-icon-only`]: !y && y !== 0 && !!Ge,
          [`${ne}-background-ghost`]: S && !Y_(V),
          [`${ne}-loading`]: de,
          [`${ne}-two-chinese-chars`]: he && X && !de,
          [`${ne}-block`]: b,
          [`${ne}-rtl`]: j === "rtl",
          [`${ne}-icon-end`]: x === "end",
        },
        ce,
        v,
        _,
        B
      ),
      Je = Object.assign(Object.assign({}, q), T),
      Ye = ft(M == null ? void 0 : M.icon, Z.icon),
      De = Object.assign(
        Object.assign({}, (p == null ? void 0 : p.icon) || {}),
        H.icon || {}
      ),
      ze =
        g && !de
          ? We.createElement(zb, { prefixCls: ne, className: Ye, style: De }, g)
          : i && typeof i == "object" && i.icon
          ? We.createElement(
              zb,
              { prefixCls: ne, className: Ye, style: De },
              i.icon
            )
          : We.createElement(lQ, {
              existIcon: !!g,
              prefixCls: ne,
              loading: de,
              mount: J.current,
            }),
      Ve = y || y === 0 ? aQ(y, k && X) : null;
    if (Le.href !== void 0)
      return oe(
        We.createElement(
          "a",
          Object.assign({}, Le, {
            className: ft(je, { [`${ne}-disabled`]: ge }),
            href: ge ? void 0 : Le.href,
            style: Je,
            onClick: fe,
            ref: $,
            tabIndex: ge ? -1 : 0,
            "aria-disabled": ge,
          }),
          ze,
          Ve
        )
      );
    let ae = We.createElement(
      "button",
      Object.assign({}, E, {
        type: C,
        className: je,
        style: Je,
        onClick: fe,
        disabled: ge,
        ref: $,
      }),
      ze,
      Ve,
      ce && We.createElement(aee, { prefixCls: ne })
    );
    return (
      Y_(V) ||
        (ae = We.createElement(r4, { component: "Button", disabled: de }, ae)),
      oe(ae)
    );
  }),
  ca = fee;
ca.Group = oQ;
ca.__ANT_BUTTON = !0;
function dee() {
  var t = Fe({}, Fv);
  return t.useId;
}
var b3 = 0,
  w3 = dee();
const hee = w3
  ? function (e) {
      var n = w3();
      return e || n;
    }
  : function (e) {
      var n = L.useState("ssr-id"),
        r = ot(n, 2),
        i = r[0],
        o = r[1];
      return (
        L.useEffect(function () {
          var s = b3;
          (b3 += 1), o("rc_unique_".concat(s));
        }, []),
        e || i
      );
    };
var sc = "RC_FORM_INTERNAL_HOOKS",
  ln = function () {
    Ei(
      !1,
      "Can not find FormContext. Please make sure you wrap Field under Form."
    );
  },
  Pf = L.createContext({
    getFieldValue: ln,
    getFieldsValue: ln,
    getFieldError: ln,
    getFieldWarning: ln,
    getFieldsError: ln,
    isFieldsTouched: ln,
    isFieldTouched: ln,
    isFieldValidating: ln,
    isFieldsValidating: ln,
    resetFields: ln,
    setFields: ln,
    setFieldValue: ln,
    setFieldsValue: ln,
    validateFields: ln,
    submit: ln,
    getInternalHooks: function () {
      return (
        ln(),
        {
          dispatch: ln,
          initEntityValue: ln,
          registerField: ln,
          useSubscribe: ln,
          setInitialValues: ln,
          destroyForm: ln,
          setCallbacks: ln,
          registerWatch: ln,
          getFields: ln,
          setValidateMessages: ln,
          setPreserve: ln,
          getInitialValue: ln,
        }
      );
    },
  }),
  Lv = L.createContext(null);
function Bb(t) {
  return t == null ? [] : Array.isArray(t) ? t : [t];
}
function pee(t) {
  return t && !!t._init;
}
function Hb() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid",
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s",
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters",
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s",
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length",
    },
    pattern: { mismatch: "%s value %s does not match pattern %s" },
    clone: function () {
      var e = JSON.parse(JSON.stringify(this));
      return (e.clone = this.clone), e;
    },
  };
}
var Vb = Hb();
function mee(t) {
  try {
    return Function.toString.call(t).indexOf("[native code]") !== -1;
  } catch {
    return typeof t == "function";
  }
}
function gee(t, e, n) {
  if (qE()) return Reflect.construct.apply(null, arguments);
  var r = [null];
  r.push.apply(r, e);
  var i = new (t.bind.apply(t, r))();
  return n && lp(i, n.prototype), i;
}
function Gb(t) {
  var e = typeof Map == "function" ? new Map() : void 0;
  return (
    (Gb = function (r) {
      if (r === null || !mee(r)) return r;
      if (typeof r != "function")
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (e !== void 0) {
        if (e.has(r)) return e.get(r);
        e.set(r, i);
      }
      function i() {
        return gee(r, arguments, cp(this).constructor);
      }
      return (
        (i.prototype = Object.create(r.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        lp(i, r)
      );
    }),
    Gb(t)
  );
}
var vee = /%[sdj%]/g,
  yee = function () {};
function Wb(t) {
  if (!t || !t.length) return null;
  var e = {};
  return (
    t.forEach(function (n) {
      var r = n.field;
      (e[r] = e[r] || []), e[r].push(n);
    }),
    e
  );
}
function ji(t) {
  for (
    var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    n[r - 1] = arguments[r];
  var i = 0,
    o = n.length;
  if (typeof t == "function") return t.apply(null, n);
  if (typeof t == "string") {
    var s = t.replace(vee, function (a) {
      if (a === "%%") return "%";
      if (i >= o) return a;
      switch (a) {
        case "%s":
          return String(n[i++]);
        case "%d":
          return Number(n[i++]);
        case "%j":
          try {
            return JSON.stringify(n[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return s;
  }
  return t;
}
function xee(t) {
  return (
    t === "string" ||
    t === "url" ||
    t === "hex" ||
    t === "email" ||
    t === "date" ||
    t === "pattern"
  );
}
function ar(t, e) {
  return !!(
    t == null ||
    (e === "array" && Array.isArray(t) && !t.length) ||
    (xee(e) && typeof t == "string" && !t)
  );
}
function _ee(t, e, n) {
  var r = [],
    i = 0,
    o = t.length;
  function s(a) {
    r.push.apply(r, yt(a || [])), i++, i === o && n(r);
  }
  t.forEach(function (a) {
    e(a, s);
  });
}
function E3(t, e, n) {
  var r = 0,
    i = t.length;
  function o(s) {
    if (s && s.length) {
      n(s);
      return;
    }
    var a = r;
    (r = r + 1), a < i ? e(t[a], o) : n([]);
  }
  o([]);
}
function See(t) {
  var e = [];
  return (
    Object.keys(t).forEach(function (n) {
      e.push.apply(e, yt(t[n] || []));
    }),
    e
  );
}
var M3 = (function (t) {
  ul(n, t);
  var e = fl(n);
  function n(r, i) {
    var o;
    return (
      Sr(this, n),
      (o = e.call(this, "Async Validation Error")),
      ve(zt(o), "errors", void 0),
      ve(zt(o), "fields", void 0),
      (o.errors = r),
      (o.fields = i),
      o
    );
  }
  return Ar(n);
})(Gb(Error));
function Aee(t, e, n, r, i) {
  if (e.first) {
    var o = new Promise(function (p, m) {
      var v = function (g) {
          return r(g), g.length ? m(new M3(g, Wb(g))) : p(i);
        },
        _ = See(t);
      E3(_, n, v);
    });
    return (
      o.catch(function (p) {
        return p;
      }),
      o
    );
  }
  var s = e.firstFields === !0 ? Object.keys(t) : e.firstFields || [],
    a = Object.keys(t),
    l = a.length,
    c = 0,
    u = [],
    d = new Promise(function (p, m) {
      var v = function (y) {
        if ((u.push.apply(u, y), c++, c === l))
          return r(u), u.length ? m(new M3(u, Wb(u))) : p(i);
      };
      a.length || (r(u), p(i)),
        a.forEach(function (_) {
          var y = t[_];
          s.indexOf(_) !== -1 ? E3(y, n, v) : _ee(y, n, v);
        });
    });
  return (
    d.catch(function (p) {
      return p;
    }),
    d
  );
}
function bee(t) {
  return !!(t && t.message !== void 0);
}
function wee(t, e) {
  for (var n = t, r = 0; r < e.length; r++) {
    if (n == null) return n;
    n = n[e[r]];
  }
  return n;
}
function C3(t, e) {
  return function (n) {
    var r;
    return (
      t.fullFields
        ? (r = wee(e, t.fullFields))
        : (r = e[n.field || t.fullField]),
      bee(n)
        ? ((n.field = n.field || t.fullField), (n.fieldValue = r), n)
        : {
            message: typeof n == "function" ? n() : n,
            fieldValue: r,
            field: n.field || t.fullField,
          }
    );
  };
}
function T3(t, e) {
  if (e) {
    for (var n in e)
      if (e.hasOwnProperty(n)) {
        var r = e[n];
        bt(r) === "object" && bt(t[n]) === "object"
          ? (t[n] = Fe(Fe({}, t[n]), r))
          : (t[n] = r);
      }
  }
  return t;
}
var Pu = "enum",
  Eee = function (e, n, r, i, o) {
    (e[Pu] = Array.isArray(e[Pu]) ? e[Pu] : []),
      e[Pu].indexOf(n) === -1 &&
        i.push(ji(o.messages[Pu], e.fullField, e[Pu].join(", ")));
  },
  Mee = function (e, n, r, i, o) {
    if (e.pattern) {
      if (e.pattern instanceof RegExp)
        (e.pattern.lastIndex = 0),
          e.pattern.test(n) ||
            i.push(ji(o.messages.pattern.mismatch, e.fullField, n, e.pattern));
      else if (typeof e.pattern == "string") {
        var s = new RegExp(e.pattern);
        s.test(n) ||
          i.push(ji(o.messages.pattern.mismatch, e.fullField, n, e.pattern));
      }
    }
  },
  Cee = function (e, n, r, i, o) {
    var s = typeof e.len == "number",
      a = typeof e.min == "number",
      l = typeof e.max == "number",
      c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      u = n,
      d = null,
      p = typeof n == "number",
      m = typeof n == "string",
      v = Array.isArray(n);
    if ((p ? (d = "number") : m ? (d = "string") : v && (d = "array"), !d))
      return !1;
    v && (u = n.length),
      m && (u = n.replace(c, "_").length),
      s
        ? u !== e.len && i.push(ji(o.messages[d].len, e.fullField, e.len))
        : a && !l && u < e.min
        ? i.push(ji(o.messages[d].min, e.fullField, e.min))
        : l && !a && u > e.max
        ? i.push(ji(o.messages[d].max, e.fullField, e.max))
        : a &&
          l &&
          (u < e.min || u > e.max) &&
          i.push(ji(o.messages[d].range, e.fullField, e.min, e.max));
  },
  h4 = function (e, n, r, i, o, s) {
    e.required &&
      (!r.hasOwnProperty(e.field) || ar(n, s || e.type)) &&
      i.push(ji(o.messages.required, e.fullField));
  },
  c0;
const Tee = function () {
  if (c0) return c0;
  var t = "[a-fA-F\\d:]",
    e = function (M) {
      return M && M.includeBoundaries
        ? "(?:(?<=\\s|^)(?=".concat(t, ")|(?<=").concat(t, ")(?=\\s|$))")
        : "";
    },
    n =
      "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
    r = "[a-fA-F\\d]{1,4}",
    i = [
      "(?:".concat(r, ":){7}(?:").concat(r, "|:)"),
      "(?:".concat(r, ":){6}(?:").concat(n, "|:").concat(r, "|:)"),
      "(?:".concat(r, ":){5}(?::").concat(n, "|(?::").concat(r, "){1,2}|:)"),
      "(?:"
        .concat(r, ":){4}(?:(?::")
        .concat(r, "){0,1}:")
        .concat(n, "|(?::")
        .concat(r, "){1,3}|:)"),
      "(?:"
        .concat(r, ":){3}(?:(?::")
        .concat(r, "){0,2}:")
        .concat(n, "|(?::")
        .concat(r, "){1,4}|:)"),
      "(?:"
        .concat(r, ":){2}(?:(?::")
        .concat(r, "){0,3}:")
        .concat(n, "|(?::")
        .concat(r, "){1,5}|:)"),
      "(?:"
        .concat(r, ":){1}(?:(?::")
        .concat(r, "){0,4}:")
        .concat(n, "|(?::")
        .concat(r, "){1,6}|:)"),
      "(?::(?:(?::"
        .concat(r, "){0,5}:")
        .concat(n, "|(?::")
        .concat(r, "){1,7}|:))"),
    ],
    o = "(?:%[0-9a-zA-Z]{1,})?",
    s = "(?:".concat(i.join("|"), ")").concat(o),
    a = new RegExp("(?:^".concat(n, "$)|(?:^").concat(s, "$)")),
    l = new RegExp("^".concat(n, "$")),
    c = new RegExp("^".concat(s, "$")),
    u = function (M) {
      return M && M.exact
        ? a
        : new RegExp(
            "(?:"
              .concat(e(M))
              .concat(n)
              .concat(e(M), ")|(?:")
              .concat(e(M))
              .concat(s)
              .concat(e(M), ")"),
            "g"
          );
    };
  (u.v4 = function (C) {
    return C && C.exact
      ? l
      : new RegExp("".concat(e(C)).concat(n).concat(e(C)), "g");
  }),
    (u.v6 = function (C) {
      return C && C.exact
        ? c
        : new RegExp("".concat(e(C)).concat(s).concat(e(C)), "g");
    });
  var d = "(?:(?:[a-z]+:)?//)",
    p = "(?:\\S+(?::\\S*)?@)?",
    m = u.v4().source,
    v = u.v6().source,
    _ = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",
    y = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",
    g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",
    x = "(?::\\d{2,5})?",
    S = '(?:[/?#][^\\s"]*)?',
    b = "(?:"
      .concat(d, "|www\\.)")
      .concat(p, "(?:localhost|")
      .concat(m, "|")
      .concat(v, "|")
      .concat(_)
      .concat(y)
      .concat(g, ")")
      .concat(x)
      .concat(S);
  return (c0 = new RegExp("(?:^".concat(b, "$)"), "i")), c0;
};
var R3 = {
    email:
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
  },
  eh = {
    integer: function (e) {
      return eh.number(e) && parseInt(e, 10) === e;
    },
    float: function (e) {
      return eh.number(e) && !eh.integer(e);
    },
    array: function (e) {
      return Array.isArray(e);
    },
    regexp: function (e) {
      if (e instanceof RegExp) return !0;
      try {
        return !!new RegExp(e);
      } catch {
        return !1;
      }
    },
    date: function (e) {
      return (
        typeof e.getTime == "function" &&
        typeof e.getMonth == "function" &&
        typeof e.getYear == "function" &&
        !isNaN(e.getTime())
      );
    },
    number: function (e) {
      return isNaN(e) ? !1 : typeof e == "number";
    },
    object: function (e) {
      return bt(e) === "object" && !eh.array(e);
    },
    method: function (e) {
      return typeof e == "function";
    },
    email: function (e) {
      return typeof e == "string" && e.length <= 320 && !!e.match(R3.email);
    },
    url: function (e) {
      return typeof e == "string" && e.length <= 2048 && !!e.match(Tee());
    },
    hex: function (e) {
      return typeof e == "string" && !!e.match(R3.hex);
    },
  },
  Ree = function (e, n, r, i, o) {
    if (e.required && n === void 0) {
      h4(e, n, r, i, o);
      return;
    }
    var s = [
        "integer",
        "float",
        "array",
        "regexp",
        "object",
        "method",
        "email",
        "number",
        "date",
        "url",
        "hex",
      ],
      a = e.type;
    s.indexOf(a) > -1
      ? eh[a](n) || i.push(ji(o.messages.types[a], e.fullField, e.type))
      : a &&
        bt(n) !== e.type &&
        i.push(ji(o.messages.types[a], e.fullField, e.type));
  },
  Pee = function (e, n, r, i, o) {
    (/^\s+$/.test(n) || n === "") &&
      i.push(ji(o.messages.whitespace, e.fullField));
  };
const jt = {
  required: h4,
  whitespace: Pee,
  type: Ree,
  range: Cee,
  enum: Eee,
  pattern: Mee,
};
var Iee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o);
    }
    r(s);
  },
  Lee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (n == null && !e.required) return r();
      jt.required(e, n, i, s, o, "array"),
        n != null && (jt.type(e, n, i, s, o), jt.range(e, n, i, s, o));
    }
    r(s);
  },
  Oee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o), n !== void 0 && jt.type(e, n, i, s, o);
    }
    r(s);
  },
  Nee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n, "date") && !e.required) return r();
      if ((jt.required(e, n, i, s, o), !ar(n, "date"))) {
        var l;
        n instanceof Date ? (l = n) : (l = new Date(n)),
          jt.type(e, l, i, s, o),
          l && jt.range(e, l.getTime(), i, s, o);
      }
    }
    r(s);
  },
  Dee = "enum",
  Fee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o), n !== void 0 && jt[Dee](e, n, i, s, o);
    }
    r(s);
  },
  Uee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o),
        n !== void 0 && (jt.type(e, n, i, s, o), jt.range(e, n, i, s, o));
    }
    r(s);
  },
  kee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o),
        n !== void 0 && (jt.type(e, n, i, s, o), jt.range(e, n, i, s, o));
    }
    r(s);
  },
  zee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o), n !== void 0 && jt.type(e, n, i, s, o);
    }
    r(s);
  },
  Bee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if ((n === "" && (n = void 0), ar(n) && !e.required)) return r();
      jt.required(e, n, i, s, o),
        n !== void 0 && (jt.type(e, n, i, s, o), jt.range(e, n, i, s, o));
    }
    r(s);
  },
  Hee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o), n !== void 0 && jt.type(e, n, i, s, o);
    }
    r(s);
  },
  Vee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n, "string") && !e.required) return r();
      jt.required(e, n, i, s, o), ar(n, "string") || jt.pattern(e, n, i, s, o);
    }
    r(s);
  },
  Gee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n) && !e.required) return r();
      jt.required(e, n, i, s, o), ar(n) || jt.type(e, n, i, s, o);
    }
    r(s);
  },
  Wee = function (e, n, r, i, o) {
    var s = [],
      a = Array.isArray(n) ? "array" : bt(n);
    jt.required(e, n, i, s, o, a), r(s);
  },
  jee = function (e, n, r, i, o) {
    var s = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (ar(n, "string") && !e.required) return r();
      jt.required(e, n, i, s, o, "string"),
        ar(n, "string") ||
          (jt.type(e, n, i, s, o),
          jt.range(e, n, i, s, o),
          jt.pattern(e, n, i, s, o),
          e.whitespace === !0 && jt.whitespace(e, n, i, s, o));
    }
    r(s);
  },
  J_ = function (e, n, r, i, o) {
    var s = e.type,
      a = [],
      l = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (l) {
      if (ar(n, s) && !e.required) return r();
      jt.required(e, n, i, a, o, s), ar(n, s) || jt.type(e, n, i, a, o);
    }
    r(a);
  };
const _h = {
  string: jee,
  method: zee,
  number: Bee,
  boolean: Oee,
  regexp: Gee,
  integer: kee,
  float: Uee,
  array: Lee,
  object: Hee,
  enum: Fee,
  pattern: Vee,
  date: Nee,
  url: J_,
  hex: J_,
  email: J_,
  required: Wee,
  any: Iee,
};
var jp = (function () {
  function t(e) {
    Sr(this, t),
      ve(this, "rules", null),
      ve(this, "_messages", Vb),
      this.define(e);
  }
  return (
    Ar(t, [
      {
        key: "define",
        value: function (n) {
          var r = this;
          if (!n) throw new Error("Cannot configure a schema with no rules");
          if (bt(n) !== "object" || Array.isArray(n))
            throw new Error("Rules must be an object");
          (this.rules = {}),
            Object.keys(n).forEach(function (i) {
              var o = n[i];
              r.rules[i] = Array.isArray(o) ? o : [o];
            });
        },
      },
      {
        key: "messages",
        value: function (n) {
          return n && (this._messages = T3(Hb(), n)), this._messages;
        },
      },
      {
        key: "validate",
        value: function (n) {
          var r = this,
            i =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {},
            o =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : function () {},
            s = n,
            a = i,
            l = o;
          if (
            (typeof a == "function" && ((l = a), (a = {})),
            !this.rules || Object.keys(this.rules).length === 0)
          )
            return l && l(null, s), Promise.resolve(s);
          function c(v) {
            var _ = [],
              y = {};
            function g(S) {
              if (Array.isArray(S)) {
                var b;
                _ = (b = _).concat.apply(b, yt(S));
              } else _.push(S);
            }
            for (var x = 0; x < v.length; x++) g(v[x]);
            _.length ? ((y = Wb(_)), l(_, y)) : l(null, s);
          }
          if (a.messages) {
            var u = this.messages();
            u === Vb && (u = Hb()), T3(u, a.messages), (a.messages = u);
          } else a.messages = this.messages();
          var d = {},
            p = a.keys || Object.keys(this.rules);
          p.forEach(function (v) {
            var _ = r.rules[v],
              y = s[v];
            _.forEach(function (g) {
              var x = g;
              typeof x.transform == "function" &&
                (s === n && (s = Fe({}, s)),
                (y = s[v] = x.transform(y)),
                y != null &&
                  (x.type = x.type || (Array.isArray(y) ? "array" : bt(y)))),
                typeof x == "function"
                  ? (x = { validator: x })
                  : (x = Fe({}, x)),
                (x.validator = r.getValidationMethod(x)),
                x.validator &&
                  ((x.field = v),
                  (x.fullField = x.fullField || v),
                  (x.type = r.getType(x)),
                  (d[v] = d[v] || []),
                  d[v].push({ rule: x, value: y, source: s, field: v }));
            });
          });
          var m = {};
          return Aee(
            d,
            a,
            function (v, _) {
              var y = v.rule,
                g =
                  (y.type === "object" || y.type === "array") &&
                  (bt(y.fields) === "object" ||
                    bt(y.defaultField) === "object");
              (g = g && (y.required || (!y.required && v.value))),
                (y.field = v.field);
              function x(T, P) {
                return Fe(
                  Fe({}, P),
                  {},
                  {
                    fullField: "".concat(y.fullField, ".").concat(T),
                    fullFields: y.fullFields
                      ? [].concat(yt(y.fullFields), [T])
                      : [T],
                  }
                );
              }
              function S() {
                var T =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : [],
                  P = Array.isArray(T) ? T : [T];
                !a.suppressWarning &&
                  P.length &&
                  t.warning("async-validator:", P),
                  P.length &&
                    y.message !== void 0 &&
                    (P = [].concat(y.message));
                var R = P.map(C3(y, s));
                if (a.first && R.length) return (m[y.field] = 1), _(R);
                if (!g) _(R);
                else {
                  if (y.required && !v.value)
                    return (
                      y.message !== void 0
                        ? (R = [].concat(y.message).map(C3(y, s)))
                        : a.error &&
                          (R = [a.error(y, ji(a.messages.required, y.field))]),
                      _(R)
                    );
                  var E = {};
                  y.defaultField &&
                    Object.keys(v.value).map(function (N) {
                      E[N] = y.defaultField;
                    }),
                    (E = Fe(Fe({}, E), v.rule.fields));
                  var O = {};
                  Object.keys(E).forEach(function (N) {
                    var z = E[N],
                      V = Array.isArray(z) ? z : [z];
                    O[N] = V.map(x.bind(null, N));
                  });
                  var D = new t(O);
                  D.messages(a.messages),
                    v.rule.options &&
                      ((v.rule.options.messages = a.messages),
                      (v.rule.options.error = a.error)),
                    D.validate(v.value, v.rule.options || a, function (N) {
                      var z = [];
                      R && R.length && z.push.apply(z, yt(R)),
                        N && N.length && z.push.apply(z, yt(N)),
                        _(z.length ? z : null);
                    });
                }
              }
              var b;
              if (y.asyncValidator)
                b = y.asyncValidator(y, v.value, S, v.source, a);
              else if (y.validator) {
                try {
                  b = y.validator(y, v.value, S, v.source, a);
                } catch (T) {
                  var C, M;
                  (C = (M = console).error) === null ||
                    C === void 0 ||
                    C.call(M, T),
                    a.suppressValidatorError ||
                      setTimeout(function () {
                        throw T;
                      }, 0),
                    S(T.message);
                }
                b === !0
                  ? S()
                  : b === !1
                  ? S(
                      typeof y.message == "function"
                        ? y.message(y.fullField || y.field)
                        : y.message ||
                            "".concat(y.fullField || y.field, " fails")
                    )
                  : b instanceof Array
                  ? S(b)
                  : b instanceof Error && S(b.message);
              }
              b &&
                b.then &&
                b.then(
                  function () {
                    return S();
                  },
                  function (T) {
                    return S(T);
                  }
                );
            },
            function (v) {
              c(v);
            },
            s
          );
        },
      },
      {
        key: "getType",
        value: function (n) {
          if (
            (n.type === void 0 &&
              n.pattern instanceof RegExp &&
              (n.type = "pattern"),
            typeof n.validator != "function" &&
              n.type &&
              !_h.hasOwnProperty(n.type))
          )
            throw new Error(ji("Unknown rule type %s", n.type));
          return n.type || "string";
        },
      },
      {
        key: "getValidationMethod",
        value: function (n) {
          if (typeof n.validator == "function") return n.validator;
          var r = Object.keys(n),
            i = r.indexOf("message");
          return (
            i !== -1 && r.splice(i, 1),
            r.length === 1 && r[0] === "required"
              ? _h.required
              : _h[this.getType(n)] || void 0
          );
        },
      },
    ]),
    t
  );
})();
ve(jp, "register", function (e, n) {
  if (typeof n != "function")
    throw new Error(
      "Cannot register a validator by type, validator is not a function"
    );
  _h[e] = n;
});
ve(jp, "warning", yee);
ve(jp, "messages", Vb);
ve(jp, "validators", _h);
var Bi = "'${name}' is not a valid ${type}",
  p4 = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date",
    },
    types: {
      string: Bi,
      method: Bi,
      array: Bi,
      object: Bi,
      number: Bi,
      date: Bi,
      boolean: Bi,
      integer: Bi,
      float: Bi,
      regexp: Bi,
      email: Bi,
      url: Bi,
      hex: Bi,
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters",
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}",
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length",
    },
    pattern: { mismatch: "'${name}' does not match pattern ${pattern}" },
  },
  P3 = jp;
function $ee(t, e) {
  return t.replace(/\\?\$\{\w+\}/g, function (n) {
    if (n.startsWith("\\")) return n.slice(1);
    var r = n.slice(2, -1);
    return e[r];
  });
}
var I3 = "CODE_LOGIC_ERROR";
function jb(t, e, n, r, i) {
  return $b.apply(this, arguments);
}
function $b() {
  return (
    ($b = zc(
      Yr().mark(function t(e, n, r, i, o) {
        var s, a, l, c, u, d, p, m, v;
        return Yr().wrap(
          function (y) {
            for (;;)
              switch ((y.prev = y.next)) {
                case 0:
                  return (
                    (s = Fe({}, r)),
                    delete s.ruleIndex,
                    (P3.warning = function () {}),
                    s.validator &&
                      ((a = s.validator),
                      (s.validator = function () {
                        try {
                          return a.apply(void 0, arguments);
                        } catch (g) {
                          return console.error(g), Promise.reject(I3);
                        }
                      })),
                    (l = null),
                    s &&
                      s.type === "array" &&
                      s.defaultField &&
                      ((l = s.defaultField), delete s.defaultField),
                    (c = new P3(ve({}, e, [s]))),
                    (u = Ju(p4, i.validateMessages)),
                    c.messages(u),
                    (d = []),
                    (y.prev = 10),
                    (y.next = 13),
                    Promise.resolve(c.validate(ve({}, e, n), Fe({}, i)))
                  );
                case 13:
                  y.next = 18;
                  break;
                case 15:
                  (y.prev = 15),
                    (y.t0 = y.catch(10)),
                    y.t0.errors &&
                      (d = y.t0.errors.map(function (g, x) {
                        var S = g.message,
                          b = S === I3 ? u.default : S;
                        return L.isValidElement(b)
                          ? L.cloneElement(b, { key: "error_".concat(x) })
                          : b;
                      }));
                case 18:
                  if (!(!d.length && l)) {
                    y.next = 23;
                    break;
                  }
                  return (
                    (y.next = 21),
                    Promise.all(
                      n.map(function (g, x) {
                        return jb("".concat(e, ".").concat(x), g, l, i, o);
                      })
                    )
                  );
                case 21:
                  return (
                    (p = y.sent),
                    y.abrupt(
                      "return",
                      p.reduce(function (g, x) {
                        return [].concat(yt(g), yt(x));
                      }, [])
                    )
                  );
                case 23:
                  return (
                    (m = Fe(
                      Fe({}, r),
                      {},
                      { name: e, enum: (r.enum || []).join(", ") },
                      o
                    )),
                    (v = d.map(function (g) {
                      return typeof g == "string" ? $ee(g, m) : g;
                    })),
                    y.abrupt("return", v)
                  );
                case 26:
                case "end":
                  return y.stop();
              }
          },
          t,
          null,
          [[10, 15]]
        );
      })
    )),
    $b.apply(this, arguments)
  );
}
function Xee(t, e, n, r, i, o) {
  var s = t.join("."),
    a = n
      .map(function (u, d) {
        var p = u.validator,
          m = Fe(Fe({}, u), {}, { ruleIndex: d });
        return (
          p &&
            (m.validator = function (v, _, y) {
              var g = !1,
                x = function () {
                  for (
                    var C = arguments.length, M = new Array(C), T = 0;
                    T < C;
                    T++
                  )
                    M[T] = arguments[T];
                  Promise.resolve().then(function () {
                    Ei(
                      !g,
                      "Your validator function has already return a promise. `callback` will be ignored."
                    ),
                      g || y.apply(void 0, M);
                  });
                },
                S = p(v, _, x);
              (g =
                S &&
                typeof S.then == "function" &&
                typeof S.catch == "function"),
                Ei(
                  g,
                  "`callback` is deprecated. Please return a promise instead."
                ),
                g &&
                  S.then(function () {
                    y();
                  }).catch(function (b) {
                    y(b || " ");
                  });
            }),
          m
        );
      })
      .sort(function (u, d) {
        var p = u.warningOnly,
          m = u.ruleIndex,
          v = d.warningOnly,
          _ = d.ruleIndex;
        return !!p == !!v ? m - _ : p ? 1 : -1;
      }),
    l;
  if (i === !0)
    l = new Promise(
      (function () {
        var u = zc(
          Yr().mark(function d(p, m) {
            var v, _, y;
            return Yr().wrap(function (x) {
              for (;;)
                switch ((x.prev = x.next)) {
                  case 0:
                    v = 0;
                  case 1:
                    if (!(v < a.length)) {
                      x.next = 12;
                      break;
                    }
                    return (_ = a[v]), (x.next = 5), jb(s, e, _, r, o);
                  case 5:
                    if (((y = x.sent), !y.length)) {
                      x.next = 9;
                      break;
                    }
                    return m([{ errors: y, rule: _ }]), x.abrupt("return");
                  case 9:
                    (v += 1), (x.next = 1);
                    break;
                  case 12:
                    p([]);
                  case 13:
                  case "end":
                    return x.stop();
                }
            }, d);
          })
        );
        return function (d, p) {
          return u.apply(this, arguments);
        };
      })()
    );
  else {
    var c = a.map(function (u) {
      return jb(s, e, u, r, o).then(function (d) {
        return { errors: d, rule: u };
      });
    });
    l = (i ? qee(c) : Yee(c)).then(function (u) {
      return Promise.reject(u);
    });
  }
  return (
    l.catch(function (u) {
      return u;
    }),
    l
  );
}
function Yee(t) {
  return Xb.apply(this, arguments);
}
function Xb() {
  return (
    (Xb = zc(
      Yr().mark(function t(e) {
        return Yr().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.all(e).then(function (i) {
                    var o,
                      s = (o = []).concat.apply(o, yt(i));
                    return s;
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, t);
      })
    )),
    Xb.apply(this, arguments)
  );
}
function qee(t) {
  return Yb.apply(this, arguments);
}
function Yb() {
  return (
    (Yb = zc(
      Yr().mark(function t(e) {
        var n;
        return Yr().wrap(function (i) {
          for (;;)
            switch ((i.prev = i.next)) {
              case 0:
                return (
                  (n = 0),
                  i.abrupt(
                    "return",
                    new Promise(function (o) {
                      e.forEach(function (s) {
                        s.then(function (a) {
                          a.errors.length && o([a]),
                            (n += 1),
                            n === e.length && o([]);
                        });
                      });
                    })
                  )
                );
              case 2:
              case "end":
                return i.stop();
            }
        }, t);
      })
    )),
    Yb.apply(this, arguments)
  );
}
function jn(t) {
  return Bb(t);
}
function L3(t, e) {
  var n = {};
  return (
    e.forEach(function (r) {
      var i = us(t, r);
      n = No(n, r, i);
    }),
    n
  );
}
function uf(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return (
    t &&
    t.some(function (r) {
      return m4(e, r, n);
    })
  );
}
function m4(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !t || !e || (!n && t.length !== e.length)
    ? !1
    : e.every(function (r, i) {
        return t[i] === r;
      });
}
function Kee(t, e) {
  if (t === e) return !0;
  if (
    (!t && e) ||
    (t && !e) ||
    !t ||
    !e ||
    bt(t) !== "object" ||
    bt(e) !== "object"
  )
    return !1;
  var n = Object.keys(t),
    r = Object.keys(e),
    i = new Set([].concat(n, r));
  return yt(i).every(function (o) {
    var s = t[o],
      a = e[o];
    return typeof s == "function" && typeof a == "function" ? !0 : s === a;
  });
}
function Zee(t) {
  var e = arguments.length <= 1 ? void 0 : arguments[1];
  return e && e.target && bt(e.target) === "object" && t in e.target
    ? e.target[t]
    : e;
}
function O3(t, e, n) {
  var r = t.length;
  if (e < 0 || e >= r || n < 0 || n >= r) return t;
  var i = t[e],
    o = e - n;
  return o > 0
    ? [].concat(
        yt(t.slice(0, n)),
        [i],
        yt(t.slice(n, e)),
        yt(t.slice(e + 1, r))
      )
    : o < 0
    ? [].concat(
        yt(t.slice(0, e)),
        yt(t.slice(e + 1, n + 1)),
        [i],
        yt(t.slice(n + 1, r))
      )
    : t;
}
var Jee = ["name"],
  co = [];
function Q_(t, e, n, r, i, o) {
  return typeof t == "function"
    ? t(e, n, "source" in o ? { source: o.source } : {})
    : r !== i;
}
var hM = (function (t) {
  ul(n, t);
  var e = fl(n);
  function n(r) {
    var i;
    if (
      (Sr(this, n),
      (i = e.call(this, r)),
      ve(zt(i), "state", { resetCount: 0 }),
      ve(zt(i), "cancelRegisterFunc", null),
      ve(zt(i), "mounted", !1),
      ve(zt(i), "touched", !1),
      ve(zt(i), "dirty", !1),
      ve(zt(i), "validatePromise", void 0),
      ve(zt(i), "prevValidating", void 0),
      ve(zt(i), "errors", co),
      ve(zt(i), "warnings", co),
      ve(zt(i), "cancelRegister", function () {
        var l = i.props,
          c = l.preserve,
          u = l.isListField,
          d = l.name;
        i.cancelRegisterFunc && i.cancelRegisterFunc(u, c, jn(d)),
          (i.cancelRegisterFunc = null);
      }),
      ve(zt(i), "getNamePath", function () {
        var l = i.props,
          c = l.name,
          u = l.fieldContext,
          d = u.prefixName,
          p = d === void 0 ? [] : d;
        return c !== void 0 ? [].concat(yt(p), yt(c)) : [];
      }),
      ve(zt(i), "getRules", function () {
        var l = i.props,
          c = l.rules,
          u = c === void 0 ? [] : c,
          d = l.fieldContext;
        return u.map(function (p) {
          return typeof p == "function" ? p(d) : p;
        });
      }),
      ve(zt(i), "refresh", function () {
        i.mounted &&
          i.setState(function (l) {
            var c = l.resetCount;
            return { resetCount: c + 1 };
          });
      }),
      ve(zt(i), "metaCache", null),
      ve(zt(i), "triggerMetaEvent", function (l) {
        var c = i.props.onMetaChange;
        if (c) {
          var u = Fe(Fe({}, i.getMeta()), {}, { destroy: l });
          cb(i.metaCache, u) || c(u), (i.metaCache = u);
        } else i.metaCache = null;
      }),
      ve(zt(i), "onStoreChange", function (l, c, u) {
        var d = i.props,
          p = d.shouldUpdate,
          m = d.dependencies,
          v = m === void 0 ? [] : m,
          _ = d.onReset,
          y = u.store,
          g = i.getNamePath(),
          x = i.getValue(l),
          S = i.getValue(y),
          b = c && uf(c, g);
        switch (
          (u.type === "valueUpdate" &&
            u.source === "external" &&
            !cb(x, S) &&
            ((i.touched = !0),
            (i.dirty = !0),
            (i.validatePromise = null),
            (i.errors = co),
            (i.warnings = co),
            i.triggerMetaEvent()),
          u.type)
        ) {
          case "reset":
            if (!c || b) {
              (i.touched = !1),
                (i.dirty = !1),
                (i.validatePromise = void 0),
                (i.errors = co),
                (i.warnings = co),
                i.triggerMetaEvent(),
                _ == null || _(),
                i.refresh();
              return;
            }
            break;
          case "remove": {
            if (p && Q_(p, l, y, x, S, u)) {
              i.reRender();
              return;
            }
            break;
          }
          case "setField": {
            var C = u.data;
            if (b) {
              "touched" in C && (i.touched = C.touched),
                "validating" in C &&
                  !("originRCField" in C) &&
                  (i.validatePromise = C.validating
                    ? Promise.resolve([])
                    : null),
                "errors" in C && (i.errors = C.errors || co),
                "warnings" in C && (i.warnings = C.warnings || co),
                (i.dirty = !0),
                i.triggerMetaEvent(),
                i.reRender();
              return;
            } else if ("value" in C && uf(c, g, !0)) {
              i.reRender();
              return;
            }
            if (p && !g.length && Q_(p, l, y, x, S, u)) {
              i.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var M = v.map(jn);
            if (
              M.some(function (T) {
                return uf(u.relatedFields, T);
              })
            ) {
              i.reRender();
              return;
            }
            break;
          }
          default:
            if (b || ((!v.length || g.length || p) && Q_(p, l, y, x, S, u))) {
              i.reRender();
              return;
            }
            break;
        }
        p === !0 && i.reRender();
      }),
      ve(zt(i), "validateRules", function (l) {
        var c = i.getNamePath(),
          u = i.getValue(),
          d = l || {},
          p = d.triggerName,
          m = d.validateOnly,
          v = m === void 0 ? !1 : m,
          _ = Promise.resolve().then(
            zc(
              Yr().mark(function y() {
                var g, x, S, b, C, M, T;
                return Yr().wrap(function (R) {
                  for (;;)
                    switch ((R.prev = R.next)) {
                      case 0:
                        if (i.mounted) {
                          R.next = 2;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 2:
                        if (
                          ((g = i.props),
                          (x = g.validateFirst),
                          (S = x === void 0 ? !1 : x),
                          (b = g.messageVariables),
                          (C = g.validateDebounce),
                          (M = i.getRules()),
                          p &&
                            (M = M.filter(function (E) {
                              return E;
                            }).filter(function (E) {
                              var O = E.validateTrigger;
                              if (!O) return !0;
                              var D = Bb(O);
                              return D.includes(p);
                            })),
                          !(C && p))
                        ) {
                          R.next = 10;
                          break;
                        }
                        return (
                          (R.next = 8),
                          new Promise(function (E) {
                            setTimeout(E, C);
                          })
                        );
                      case 8:
                        if (i.validatePromise === _) {
                          R.next = 10;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 10:
                        return (
                          (T = Xee(c, u, M, l, S, b)),
                          T.catch(function (E) {
                            return E;
                          }).then(function () {
                            var E =
                              arguments.length > 0 && arguments[0] !== void 0
                                ? arguments[0]
                                : co;
                            if (i.validatePromise === _) {
                              var O;
                              i.validatePromise = null;
                              var D = [],
                                N = [];
                              (O = E.forEach) === null ||
                                O === void 0 ||
                                O.call(E, function (z) {
                                  var V = z.rule.warningOnly,
                                    G = z.errors,
                                    Y = G === void 0 ? co : G;
                                  V
                                    ? N.push.apply(N, yt(Y))
                                    : D.push.apply(D, yt(Y));
                                }),
                                (i.errors = D),
                                (i.warnings = N),
                                i.triggerMetaEvent(),
                                i.reRender();
                            }
                          }),
                          R.abrupt("return", T)
                        );
                      case 13:
                      case "end":
                        return R.stop();
                    }
                }, y);
              })
            )
          );
        return (
          v ||
            ((i.validatePromise = _),
            (i.dirty = !0),
            (i.errors = co),
            (i.warnings = co),
            i.triggerMetaEvent(),
            i.reRender()),
          _
        );
      }),
      ve(zt(i), "isFieldValidating", function () {
        return !!i.validatePromise;
      }),
      ve(zt(i), "isFieldTouched", function () {
        return i.touched;
      }),
      ve(zt(i), "isFieldDirty", function () {
        if (i.dirty || i.props.initialValue !== void 0) return !0;
        var l = i.props.fieldContext,
          c = l.getInternalHooks(sc),
          u = c.getInitialValue;
        return u(i.getNamePath()) !== void 0;
      }),
      ve(zt(i), "getErrors", function () {
        return i.errors;
      }),
      ve(zt(i), "getWarnings", function () {
        return i.warnings;
      }),
      ve(zt(i), "isListField", function () {
        return i.props.isListField;
      }),
      ve(zt(i), "isList", function () {
        return i.props.isList;
      }),
      ve(zt(i), "isPreserve", function () {
        return i.props.preserve;
      }),
      ve(zt(i), "getMeta", function () {
        i.prevValidating = i.isFieldValidating();
        var l = {
          touched: i.isFieldTouched(),
          validating: i.prevValidating,
          errors: i.errors,
          warnings: i.warnings,
          name: i.getNamePath(),
          validated: i.validatePromise === null,
        };
        return l;
      }),
      ve(zt(i), "getOnlyChild", function (l) {
        if (typeof l == "function") {
          var c = i.getMeta();
          return Fe(
            Fe(
              {},
              i.getOnlyChild(l(i.getControlled(), c, i.props.fieldContext))
            ),
            {},
            { isFunction: !0 }
          );
        }
        var u = bf(l);
        return u.length !== 1 || !L.isValidElement(u[0])
          ? { child: u, isFunction: !1 }
          : { child: u[0], isFunction: !1 };
      }),
      ve(zt(i), "getValue", function (l) {
        var c = i.props.fieldContext.getFieldsValue,
          u = i.getNamePath();
        return us(l || c(!0), u);
      }),
      ve(zt(i), "getControlled", function () {
        var l =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          c = i.props,
          u = c.name,
          d = c.trigger,
          p = c.validateTrigger,
          m = c.getValueFromEvent,
          v = c.normalize,
          _ = c.valuePropName,
          y = c.getValueProps,
          g = c.fieldContext,
          x = p !== void 0 ? p : g.validateTrigger,
          S = i.getNamePath(),
          b = g.getInternalHooks,
          C = g.getFieldsValue,
          M = b(sc),
          T = M.dispatch,
          P = i.getValue(),
          R =
            y ||
            function (z) {
              return ve({}, _, z);
            },
          E = l[d],
          O = u !== void 0 ? R(P) : {},
          D = Fe(Fe({}, l), O);
        D[d] = function () {
          (i.touched = !0), (i.dirty = !0), i.triggerMetaEvent();
          for (var z, V = arguments.length, G = new Array(V), Y = 0; Y < V; Y++)
            G[Y] = arguments[Y];
          m ? (z = m.apply(void 0, G)) : (z = Zee.apply(void 0, [_].concat(G))),
            v && (z = v(z, P, C(!0))),
            z !== P && T({ type: "updateValue", namePath: S, value: z }),
            E && E.apply(void 0, G);
        };
        var N = Bb(x || []);
        return (
          N.forEach(function (z) {
            var V = D[z];
            D[z] = function () {
              V && V.apply(void 0, arguments);
              var G = i.props.rules;
              G &&
                G.length &&
                T({ type: "validateField", namePath: S, triggerName: z });
            };
          }),
          D
        );
      }),
      r.fieldContext)
    ) {
      var o = r.fieldContext.getInternalHooks,
        s = o(sc),
        a = s.initEntityValue;
      a(zt(i));
    }
    return i;
  }
  return (
    Ar(n, [
      {
        key: "componentDidMount",
        value: function () {
          var i = this.props,
            o = i.shouldUpdate,
            s = i.fieldContext;
          if (((this.mounted = !0), s)) {
            var a = s.getInternalHooks,
              l = a(sc),
              c = l.registerField;
            this.cancelRegisterFunc = c(this);
          }
          o === !0 && this.reRender();
        },
      },
      {
        key: "componentWillUnmount",
        value: function () {
          this.cancelRegister(), this.triggerMetaEvent(!0), (this.mounted = !1);
        },
      },
      {
        key: "reRender",
        value: function () {
          this.mounted && this.forceUpdate();
        },
      },
      {
        key: "render",
        value: function () {
          var i = this.state.resetCount,
            o = this.props.children,
            s = this.getOnlyChild(o),
            a = s.child,
            l = s.isFunction,
            c;
          return (
            l
              ? (c = a)
              : L.isValidElement(a)
              ? (c = L.cloneElement(a, this.getControlled(a.props)))
              : (Ei(!a, "`children` of Field is not validate ReactElement."),
                (c = a)),
            L.createElement(L.Fragment, { key: i }, c)
          );
        },
      },
    ]),
    n
  );
})(L.Component);
ve(hM, "contextType", Pf);
ve(hM, "defaultProps", { trigger: "onChange", valuePropName: "value" });
function g4(t) {
  var e,
    n = t.name,
    r = sr(t, Jee),
    i = L.useContext(Pf),
    o = L.useContext(Lv),
    s = n !== void 0 ? jn(n) : void 0,
    a = (e = r.isListField) !== null && e !== void 0 ? e : !!o,
    l = "keep";
  return (
    a || (l = "_".concat((s || []).join("_"))),
    L.createElement(
      hM,
      Bt({ key: l, name: s, isListField: a }, r, { fieldContext: i })
    )
  );
}
function Qee(t) {
  var e = t.name,
    n = t.initialValue,
    r = t.children,
    i = t.rules,
    o = t.validateTrigger,
    s = t.isListField,
    a = L.useContext(Pf),
    l = L.useContext(Lv),
    c = L.useRef({ keys: [], id: 0 }),
    u = c.current,
    d = L.useMemo(
      function () {
        var _ = jn(a.prefixName) || [];
        return [].concat(yt(_), yt(jn(e)));
      },
      [a.prefixName, e]
    ),
    p = L.useMemo(
      function () {
        return Fe(Fe({}, a), {}, { prefixName: d });
      },
      [a, d]
    ),
    m = L.useMemo(
      function () {
        return {
          getKey: function (y) {
            var g = d.length,
              x = y[g];
            return [u.keys[x], y.slice(g + 1)];
          },
        };
      },
      [d]
    );
  if (typeof r != "function")
    return Ei(!1, "Form.List only accepts function as children."), null;
  var v = function (y, g, x) {
    var S = x.source;
    return S === "internal" ? !1 : y !== g;
  };
  return L.createElement(
    Lv.Provider,
    { value: m },
    L.createElement(
      Pf.Provider,
      { value: p },
      L.createElement(
        g4,
        {
          name: [],
          shouldUpdate: v,
          rules: i,
          validateTrigger: o,
          initialValue: n,
          isList: !0,
          isListField: s ?? !!l,
        },
        function (_, y) {
          var g = _.value,
            x = g === void 0 ? [] : g,
            S = _.onChange,
            b = a.getFieldValue,
            C = function () {
              var R = b(d || []);
              return R || [];
            },
            M = {
              add: function (R, E) {
                var O = C();
                E >= 0 && E <= O.length
                  ? ((u.keys = [].concat(
                      yt(u.keys.slice(0, E)),
                      [u.id],
                      yt(u.keys.slice(E))
                    )),
                    S([].concat(yt(O.slice(0, E)), [R], yt(O.slice(E)))))
                  : ((u.keys = [].concat(yt(u.keys), [u.id])),
                    S([].concat(yt(O), [R]))),
                  (u.id += 1);
              },
              remove: function (R) {
                var E = C(),
                  O = new Set(Array.isArray(R) ? R : [R]);
                O.size <= 0 ||
                  ((u.keys = u.keys.filter(function (D, N) {
                    return !O.has(N);
                  })),
                  S(
                    E.filter(function (D, N) {
                      return !O.has(N);
                    })
                  ));
              },
              move: function (R, E) {
                if (R !== E) {
                  var O = C();
                  R < 0 ||
                    R >= O.length ||
                    E < 0 ||
                    E >= O.length ||
                    ((u.keys = O3(u.keys, R, E)), S(O3(O, R, E)));
                }
              },
            },
            T = x || [];
          return (
            Array.isArray(T) || (T = []),
            r(
              T.map(function (P, R) {
                var E = u.keys[R];
                return (
                  E === void 0 &&
                    ((u.keys[R] = u.id), (E = u.keys[R]), (u.id += 1)),
                  { name: R, key: E, isListField: !0 }
                );
              }),
              M,
              y
            )
          );
        }
      )
    )
  );
}
function ete(t) {
  var e = !1,
    n = t.length,
    r = [];
  return t.length
    ? new Promise(function (i, o) {
        t.forEach(function (s, a) {
          s.catch(function (l) {
            return (e = !0), l;
          }).then(function (l) {
            (n -= 1), (r[a] = l), !(n > 0) && (e && o(r), i(r));
          });
        });
      })
    : Promise.resolve([]);
}
var v4 = "__@field_split__";
function eS(t) {
  return t
    .map(function (e) {
      return "".concat(bt(e), ":").concat(e);
    })
    .join(v4);
}
var Iu = (function () {
    function t() {
      Sr(this, t), ve(this, "kvs", new Map());
    }
    return (
      Ar(t, [
        {
          key: "set",
          value: function (n, r) {
            this.kvs.set(eS(n), r);
          },
        },
        {
          key: "get",
          value: function (n) {
            return this.kvs.get(eS(n));
          },
        },
        {
          key: "update",
          value: function (n, r) {
            var i = this.get(n),
              o = r(i);
            o ? this.set(n, o) : this.delete(n);
          },
        },
        {
          key: "delete",
          value: function (n) {
            this.kvs.delete(eS(n));
          },
        },
        {
          key: "map",
          value: function (n) {
            return yt(this.kvs.entries()).map(function (r) {
              var i = ot(r, 2),
                o = i[0],
                s = i[1],
                a = o.split(v4);
              return n({
                key: a.map(function (l) {
                  var c = l.match(/^([^:]*):(.*)$/),
                    u = ot(c, 3),
                    d = u[1],
                    p = u[2];
                  return d === "number" ? Number(p) : p;
                }),
                value: s,
              });
            });
          },
        },
        {
          key: "toJSON",
          value: function () {
            var n = {};
            return (
              this.map(function (r) {
                var i = r.key,
                  o = r.value;
                return (n[i.join(".")] = o), null;
              }),
              n
            );
          },
        },
      ]),
      t
    );
  })(),
  tte = ["name"],
  nte = Ar(function t(e) {
    var n = this;
    Sr(this, t),
      ve(this, "formHooked", !1),
      ve(this, "forceRootUpdate", void 0),
      ve(this, "subscribable", !0),
      ve(this, "store", {}),
      ve(this, "fieldEntities", []),
      ve(this, "initialValues", {}),
      ve(this, "callbacks", {}),
      ve(this, "validateMessages", null),
      ve(this, "preserve", null),
      ve(this, "lastValidatePromise", null),
      ve(this, "getForm", function () {
        return {
          getFieldValue: n.getFieldValue,
          getFieldsValue: n.getFieldsValue,
          getFieldError: n.getFieldError,
          getFieldWarning: n.getFieldWarning,
          getFieldsError: n.getFieldsError,
          isFieldsTouched: n.isFieldsTouched,
          isFieldTouched: n.isFieldTouched,
          isFieldValidating: n.isFieldValidating,
          isFieldsValidating: n.isFieldsValidating,
          resetFields: n.resetFields,
          setFields: n.setFields,
          setFieldValue: n.setFieldValue,
          setFieldsValue: n.setFieldsValue,
          validateFields: n.validateFields,
          submit: n.submit,
          _init: !0,
          getInternalHooks: n.getInternalHooks,
        };
      }),
      ve(this, "getInternalHooks", function (r) {
        return r === sc
          ? ((n.formHooked = !0),
            {
              dispatch: n.dispatch,
              initEntityValue: n.initEntityValue,
              registerField: n.registerField,
              useSubscribe: n.useSubscribe,
              setInitialValues: n.setInitialValues,
              destroyForm: n.destroyForm,
              setCallbacks: n.setCallbacks,
              setValidateMessages: n.setValidateMessages,
              getFields: n.getFields,
              setPreserve: n.setPreserve,
              getInitialValue: n.getInitialValue,
              registerWatch: n.registerWatch,
            })
          : (Ei(
              !1,
              "`getInternalHooks` is internal usage. Should not call directly."
            ),
            null);
      }),
      ve(this, "useSubscribe", function (r) {
        n.subscribable = r;
      }),
      ve(this, "prevWithoutPreserves", null),
      ve(this, "setInitialValues", function (r, i) {
        if (((n.initialValues = r || {}), i)) {
          var o,
            s = Ju(r, n.store);
          (o = n.prevWithoutPreserves) === null ||
            o === void 0 ||
            o.map(function (a) {
              var l = a.key;
              s = No(s, l, us(r, l));
            }),
            (n.prevWithoutPreserves = null),
            n.updateStore(s);
        }
      }),
      ve(this, "destroyForm", function (r) {
        if (r) n.updateStore({});
        else {
          var i = new Iu();
          n.getFieldEntities(!0).forEach(function (o) {
            n.isMergedPreserve(o.isPreserve()) || i.set(o.getNamePath(), !0);
          }),
            (n.prevWithoutPreserves = i);
        }
      }),
      ve(this, "getInitialValue", function (r) {
        var i = us(n.initialValues, r);
        return r.length ? Ju(i) : i;
      }),
      ve(this, "setCallbacks", function (r) {
        n.callbacks = r;
      }),
      ve(this, "setValidateMessages", function (r) {
        n.validateMessages = r;
      }),
      ve(this, "setPreserve", function (r) {
        n.preserve = r;
      }),
      ve(this, "watchList", []),
      ve(this, "registerWatch", function (r) {
        return (
          n.watchList.push(r),
          function () {
            n.watchList = n.watchList.filter(function (i) {
              return i !== r;
            });
          }
        );
      }),
      ve(this, "notifyWatch", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (n.watchList.length) {
          var i = n.getFieldsValue(),
            o = n.getFieldsValue(!0);
          n.watchList.forEach(function (s) {
            s(i, o, r);
          });
        }
      }),
      ve(this, "timeoutId", null),
      ve(this, "warningUnhooked", function () {}),
      ve(this, "updateStore", function (r) {
        n.store = r;
      }),
      ve(this, "getFieldEntities", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        return r
          ? n.fieldEntities.filter(function (i) {
              return i.getNamePath().length;
            })
          : n.fieldEntities;
      }),
      ve(this, "getFieldsMap", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
          i = new Iu();
        return (
          n.getFieldEntities(r).forEach(function (o) {
            var s = o.getNamePath();
            i.set(s, o);
          }),
          i
        );
      }),
      ve(this, "getFieldEntitiesForNamePathList", function (r) {
        if (!r) return n.getFieldEntities(!0);
        var i = n.getFieldsMap(!0);
        return r.map(function (o) {
          var s = jn(o);
          return i.get(s) || { INVALIDATE_NAME_PATH: jn(o) };
        });
      }),
      ve(this, "getFieldsValue", function (r, i) {
        n.warningUnhooked();
        var o, s, a;
        if (
          (r === !0 || Array.isArray(r)
            ? ((o = r), (s = i))
            : r && bt(r) === "object" && ((a = r.strict), (s = r.filter)),
          o === !0 && !s)
        )
          return n.store;
        var l = n.getFieldEntitiesForNamePathList(Array.isArray(o) ? o : null),
          c = [];
        return (
          l.forEach(function (u) {
            var d,
              p,
              m =
                "INVALIDATE_NAME_PATH" in u
                  ? u.INVALIDATE_NAME_PATH
                  : u.getNamePath();
            if (a) {
              var v, _;
              if ((v = (_ = u).isList) !== null && v !== void 0 && v.call(_))
                return;
            } else if (!o && (d = (p = u).isListField) !== null && d !== void 0 && d.call(p)) return;
            if (!s) c.push(m);
            else {
              var y = "getMeta" in u ? u.getMeta() : null;
              s(y) && c.push(m);
            }
          }),
          L3(n.store, c.map(jn))
        );
      }),
      ve(this, "getFieldValue", function (r) {
        n.warningUnhooked();
        var i = jn(r);
        return us(n.store, i);
      }),
      ve(this, "getFieldsError", function (r) {
        n.warningUnhooked();
        var i = n.getFieldEntitiesForNamePathList(r);
        return i.map(function (o, s) {
          return o && !("INVALIDATE_NAME_PATH" in o)
            ? {
                name: o.getNamePath(),
                errors: o.getErrors(),
                warnings: o.getWarnings(),
              }
            : { name: jn(r[s]), errors: [], warnings: [] };
        });
      }),
      ve(this, "getFieldError", function (r) {
        n.warningUnhooked();
        var i = jn(r),
          o = n.getFieldsError([i])[0];
        return o.errors;
      }),
      ve(this, "getFieldWarning", function (r) {
        n.warningUnhooked();
        var i = jn(r),
          o = n.getFieldsError([i])[0];
        return o.warnings;
      }),
      ve(this, "isFieldsTouched", function () {
        n.warningUnhooked();
        for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
          i[o] = arguments[o];
        var s = i[0],
          a = i[1],
          l,
          c = !1;
        i.length === 0
          ? (l = null)
          : i.length === 1
          ? Array.isArray(s)
            ? ((l = s.map(jn)), (c = !1))
            : ((l = null), (c = s))
          : ((l = s.map(jn)), (c = a));
        var u = n.getFieldEntities(!0),
          d = function (y) {
            return y.isFieldTouched();
          };
        if (!l)
          return c
            ? u.every(function (_) {
                return d(_) || _.isList();
              })
            : u.some(d);
        var p = new Iu();
        l.forEach(function (_) {
          p.set(_, []);
        }),
          u.forEach(function (_) {
            var y = _.getNamePath();
            l.forEach(function (g) {
              g.every(function (x, S) {
                return y[S] === x;
              }) &&
                p.update(g, function (x) {
                  return [].concat(yt(x), [_]);
                });
            });
          });
        var m = function (y) {
            return y.some(d);
          },
          v = p.map(function (_) {
            var y = _.value;
            return y;
          });
        return c ? v.every(m) : v.some(m);
      }),
      ve(this, "isFieldTouched", function (r) {
        return n.warningUnhooked(), n.isFieldsTouched([r]);
      }),
      ve(this, "isFieldsValidating", function (r) {
        n.warningUnhooked();
        var i = n.getFieldEntities();
        if (!r)
          return i.some(function (s) {
            return s.isFieldValidating();
          });
        var o = r.map(jn);
        return i.some(function (s) {
          var a = s.getNamePath();
          return uf(o, a) && s.isFieldValidating();
        });
      }),
      ve(this, "isFieldValidating", function (r) {
        return n.warningUnhooked(), n.isFieldsValidating([r]);
      }),
      ve(this, "resetWithFieldInitialValue", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          i = new Iu(),
          o = n.getFieldEntities(!0);
        o.forEach(function (l) {
          var c = l.props.initialValue,
            u = l.getNamePath();
          if (c !== void 0) {
            var d = i.get(u) || new Set();
            d.add({ entity: l, value: c }), i.set(u, d);
          }
        });
        var s = function (c) {
            c.forEach(function (u) {
              var d = u.props.initialValue;
              if (d !== void 0) {
                var p = u.getNamePath(),
                  m = n.getInitialValue(p);
                if (m !== void 0)
                  Ei(
                    !1,
                    "Form already set 'initialValues' with path '".concat(
                      p.join("."),
                      "'. Field can not overwrite it."
                    )
                  );
                else {
                  var v = i.get(p);
                  if (v && v.size > 1)
                    Ei(
                      !1,
                      "Multiple Field with path '".concat(
                        p.join("."),
                        "' set 'initialValue'. Can not decide which one to pick."
                      )
                    );
                  else if (v) {
                    var _ = n.getFieldValue(p),
                      y = u.isListField();
                    !y &&
                      (!r.skipExist || _ === void 0) &&
                      n.updateStore(No(n.store, p, yt(v)[0].value));
                  }
                }
              }
            });
          },
          a;
        r.entities
          ? (a = r.entities)
          : r.namePathList
          ? ((a = []),
            r.namePathList.forEach(function (l) {
              var c = i.get(l);
              if (c) {
                var u;
                (u = a).push.apply(
                  u,
                  yt(
                    yt(c).map(function (d) {
                      return d.entity;
                    })
                  )
                );
              }
            }))
          : (a = o),
          s(a);
      }),
      ve(this, "resetFields", function (r) {
        n.warningUnhooked();
        var i = n.store;
        if (!r) {
          n.updateStore(Ju(n.initialValues)),
            n.resetWithFieldInitialValue(),
            n.notifyObservers(i, null, { type: "reset" }),
            n.notifyWatch();
          return;
        }
        var o = r.map(jn);
        o.forEach(function (s) {
          var a = n.getInitialValue(s);
          n.updateStore(No(n.store, s, a));
        }),
          n.resetWithFieldInitialValue({ namePathList: o }),
          n.notifyObservers(i, o, { type: "reset" }),
          n.notifyWatch(o);
      }),
      ve(this, "setFields", function (r) {
        n.warningUnhooked();
        var i = n.store,
          o = [];
        r.forEach(function (s) {
          var a = s.name,
            l = sr(s, tte),
            c = jn(a);
          o.push(c),
            "value" in l && n.updateStore(No(n.store, c, l.value)),
            n.notifyObservers(i, [c], { type: "setField", data: s });
        }),
          n.notifyWatch(o);
      }),
      ve(this, "getFields", function () {
        var r = n.getFieldEntities(!0),
          i = r.map(function (o) {
            var s = o.getNamePath(),
              a = o.getMeta(),
              l = Fe(Fe({}, a), {}, { name: s, value: n.getFieldValue(s) });
            return Object.defineProperty(l, "originRCField", { value: !0 }), l;
          });
        return i;
      }),
      ve(this, "initEntityValue", function (r) {
        var i = r.props.initialValue;
        if (i !== void 0) {
          var o = r.getNamePath(),
            s = us(n.store, o);
          s === void 0 && n.updateStore(No(n.store, o, i));
        }
      }),
      ve(this, "isMergedPreserve", function (r) {
        var i = r !== void 0 ? r : n.preserve;
        return i ?? !0;
      }),
      ve(this, "registerField", function (r) {
        n.fieldEntities.push(r);
        var i = r.getNamePath();
        if ((n.notifyWatch([i]), r.props.initialValue !== void 0)) {
          var o = n.store;
          n.resetWithFieldInitialValue({ entities: [r], skipExist: !0 }),
            n.notifyObservers(o, [r.getNamePath()], {
              type: "valueUpdate",
              source: "internal",
            });
        }
        return function (s, a) {
          var l =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          if (
            ((n.fieldEntities = n.fieldEntities.filter(function (d) {
              return d !== r;
            })),
            !n.isMergedPreserve(a) && (!s || l.length > 1))
          ) {
            var c = s ? void 0 : n.getInitialValue(i);
            if (
              i.length &&
              n.getFieldValue(i) !== c &&
              n.fieldEntities.every(function (d) {
                return !m4(d.getNamePath(), i);
              })
            ) {
              var u = n.store;
              n.updateStore(No(u, i, c, !0)),
                n.notifyObservers(u, [i], { type: "remove" }),
                n.triggerDependenciesUpdate(u, i);
            }
          }
          n.notifyWatch([i]);
        };
      }),
      ve(this, "dispatch", function (r) {
        switch (r.type) {
          case "updateValue": {
            var i = r.namePath,
              o = r.value;
            n.updateValue(i, o);
            break;
          }
          case "validateField": {
            var s = r.namePath,
              a = r.triggerName;
            n.validateFields([s], { triggerName: a });
            break;
          }
        }
      }),
      ve(this, "notifyObservers", function (r, i, o) {
        if (n.subscribable) {
          var s = Fe(Fe({}, o), {}, { store: n.getFieldsValue(!0) });
          n.getFieldEntities().forEach(function (a) {
            var l = a.onStoreChange;
            l(r, i, s);
          });
        } else n.forceRootUpdate();
      }),
      ve(this, "triggerDependenciesUpdate", function (r, i) {
        var o = n.getDependencyChildrenFields(i);
        return (
          o.length && n.validateFields(o),
          n.notifyObservers(r, o, {
            type: "dependenciesUpdate",
            relatedFields: [i].concat(yt(o)),
          }),
          o
        );
      }),
      ve(this, "updateValue", function (r, i) {
        var o = jn(r),
          s = n.store;
        n.updateStore(No(n.store, o, i)),
          n.notifyObservers(s, [o], {
            type: "valueUpdate",
            source: "internal",
          }),
          n.notifyWatch([o]);
        var a = n.triggerDependenciesUpdate(s, o),
          l = n.callbacks.onValuesChange;
        if (l) {
          var c = L3(n.store, [o]);
          l(c, n.getFieldsValue());
        }
        n.triggerOnFieldsChange([o].concat(yt(a)));
      }),
      ve(this, "setFieldsValue", function (r) {
        n.warningUnhooked();
        var i = n.store;
        if (r) {
          var o = Ju(n.store, r);
          n.updateStore(o);
        }
        n.notifyObservers(i, null, { type: "valueUpdate", source: "external" }),
          n.notifyWatch();
      }),
      ve(this, "setFieldValue", function (r, i) {
        n.setFields([{ name: r, value: i, errors: [], warnings: [] }]);
      }),
      ve(this, "getDependencyChildrenFields", function (r) {
        var i = new Set(),
          o = [],
          s = new Iu();
        n.getFieldEntities().forEach(function (l) {
          var c = l.props.dependencies;
          (c || []).forEach(function (u) {
            var d = jn(u);
            s.update(d, function () {
              var p =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : new Set();
              return p.add(l), p;
            });
          });
        });
        var a = function l(c) {
          var u = s.get(c) || new Set();
          u.forEach(function (d) {
            if (!i.has(d)) {
              i.add(d);
              var p = d.getNamePath();
              d.isFieldDirty() && p.length && (o.push(p), l(p));
            }
          });
        };
        return a(r), o;
      }),
      ve(this, "triggerOnFieldsChange", function (r, i) {
        var o = n.callbacks.onFieldsChange;
        if (o) {
          var s = n.getFields();
          if (i) {
            var a = new Iu();
            i.forEach(function (c) {
              var u = c.name,
                d = c.errors;
              a.set(u, d);
            }),
              s.forEach(function (c) {
                c.errors = a.get(c.name) || c.errors;
              });
          }
          var l = s.filter(function (c) {
            var u = c.name;
            return uf(r, u);
          });
          l.length && o(l, s);
        }
      }),
      ve(this, "validateFields", function (r, i) {
        n.warningUnhooked();
        var o, s;
        Array.isArray(r) || typeof r == "string" || typeof i == "string"
          ? ((o = r), (s = i))
          : (s = r);
        var a = !!o,
          l = a ? o.map(jn) : [],
          c = [],
          u = String(Date.now()),
          d = new Set(),
          p = s || {},
          m = p.recursive,
          v = p.dirty;
        n.getFieldEntities(!0).forEach(function (x) {
          if (
            (a || l.push(x.getNamePath()),
            !(!x.props.rules || !x.props.rules.length) &&
              !(v && !x.isFieldDirty()))
          ) {
            var S = x.getNamePath();
            if ((d.add(S.join(u)), !a || uf(l, S, m))) {
              var b = x.validateRules(
                Fe({ validateMessages: Fe(Fe({}, p4), n.validateMessages) }, s)
              );
              c.push(
                b
                  .then(function () {
                    return { name: S, errors: [], warnings: [] };
                  })
                  .catch(function (C) {
                    var M,
                      T = [],
                      P = [];
                    return (
                      (M = C.forEach) === null ||
                        M === void 0 ||
                        M.call(C, function (R) {
                          var E = R.rule.warningOnly,
                            O = R.errors;
                          E ? P.push.apply(P, yt(O)) : T.push.apply(T, yt(O));
                        }),
                      T.length
                        ? Promise.reject({ name: S, errors: T, warnings: P })
                        : { name: S, errors: T, warnings: P }
                    );
                  })
              );
            }
          }
        });
        var _ = ete(c);
        (n.lastValidatePromise = _),
          _.catch(function (x) {
            return x;
          }).then(function (x) {
            var S = x.map(function (b) {
              var C = b.name;
              return C;
            });
            n.notifyObservers(n.store, S, { type: "validateFinish" }),
              n.triggerOnFieldsChange(S, x);
          });
        var y = _.then(function () {
          return n.lastValidatePromise === _
            ? Promise.resolve(n.getFieldsValue(l))
            : Promise.reject([]);
        }).catch(function (x) {
          var S = x.filter(function (b) {
            return b && b.errors.length;
          });
          return Promise.reject({
            values: n.getFieldsValue(l),
            errorFields: S,
            outOfDate: n.lastValidatePromise !== _,
          });
        });
        y.catch(function (x) {
          return x;
        });
        var g = l.filter(function (x) {
          return d.has(x.join(u));
        });
        return n.triggerOnFieldsChange(g), y;
      }),
      ve(this, "submit", function () {
        n.warningUnhooked(),
          n
            .validateFields()
            .then(function (r) {
              var i = n.callbacks.onFinish;
              if (i)
                try {
                  i(r);
                } catch (o) {
                  console.error(o);
                }
            })
            .catch(function (r) {
              var i = n.callbacks.onFinishFailed;
              i && i(r);
            });
      }),
      (this.forceRootUpdate = e);
  });
function y4(t) {
  var e = L.useRef(),
    n = L.useState({}),
    r = ot(n, 2),
    i = r[1];
  if (!e.current)
    if (t) e.current = t;
    else {
      var o = function () {
          i({});
        },
        s = new nte(o);
      e.current = s.getForm();
    }
  return [e.current];
}
var qb = L.createContext({
    triggerFormChange: function () {},
    triggerFormFinish: function () {},
    registerForm: function () {},
    unregisterForm: function () {},
  }),
  rte = function (e) {
    var n = e.validateMessages,
      r = e.onFormChange,
      i = e.onFormFinish,
      o = e.children,
      s = L.useContext(qb),
      a = L.useRef({});
    return L.createElement(
      qb.Provider,
      {
        value: Fe(
          Fe({}, s),
          {},
          {
            validateMessages: Fe(Fe({}, s.validateMessages), n),
            triggerFormChange: function (c, u) {
              r && r(c, { changedFields: u, forms: a.current }),
                s.triggerFormChange(c, u);
            },
            triggerFormFinish: function (c, u) {
              i && i(c, { values: u, forms: a.current }),
                s.triggerFormFinish(c, u);
            },
            registerForm: function (c, u) {
              c && (a.current = Fe(Fe({}, a.current), {}, ve({}, c, u))),
                s.registerForm(c, u);
            },
            unregisterForm: function (c) {
              var u = Fe({}, a.current);
              delete u[c], (a.current = u), s.unregisterForm(c);
            },
          }
        ),
      },
      o
    );
  },
  ite = [
    "name",
    "initialValues",
    "fields",
    "form",
    "preserve",
    "children",
    "component",
    "validateMessages",
    "validateTrigger",
    "onValuesChange",
    "onFieldsChange",
    "onFinish",
    "onFinishFailed",
    "clearOnDestroy",
  ],
  ote = function (e, n) {
    var r = e.name,
      i = e.initialValues,
      o = e.fields,
      s = e.form,
      a = e.preserve,
      l = e.children,
      c = e.component,
      u = c === void 0 ? "form" : c,
      d = e.validateMessages,
      p = e.validateTrigger,
      m = p === void 0 ? "onChange" : p,
      v = e.onValuesChange,
      _ = e.onFieldsChange,
      y = e.onFinish,
      g = e.onFinishFailed,
      x = e.clearOnDestroy,
      S = sr(e, ite),
      b = L.useRef(null),
      C = L.useContext(qb),
      M = y4(s),
      T = ot(M, 1),
      P = T[0],
      R = P.getInternalHooks(sc),
      E = R.useSubscribe,
      O = R.setInitialValues,
      D = R.setCallbacks,
      N = R.setValidateMessages,
      z = R.setPreserve,
      V = R.destroyForm;
    L.useImperativeHandle(n, function () {
      return Fe(Fe({}, P), {}, { nativeElement: b.current });
    }),
      L.useEffect(
        function () {
          return (
            C.registerForm(r, P),
            function () {
              C.unregisterForm(r);
            }
          );
        },
        [C, P, r]
      ),
      N(Fe(Fe({}, C.validateMessages), d)),
      D({
        onValuesChange: v,
        onFieldsChange: function (H) {
          if ((C.triggerFormChange(r, H), _)) {
            for (
              var X = arguments.length,
                ne = new Array(X > 1 ? X - 1 : 0),
                oe = 1;
              oe < X;
              oe++
            )
              ne[oe - 1] = arguments[oe];
            _.apply(void 0, [H].concat(ne));
          }
        },
        onFinish: function (H) {
          C.triggerFormFinish(r, H), y && y(H);
        },
        onFinishFailed: g,
      }),
      z(a);
    var G = L.useRef(null);
    O(i, !G.current),
      G.current || (G.current = !0),
      L.useEffect(function () {
        return function () {
          return V(x);
        };
      }, []);
    var Y,
      U = typeof l == "function";
    if (U) {
      var j = P.getFieldsValue(!0);
      Y = l(j, P);
    } else Y = l;
    E(!U);
    var W = L.useRef();
    L.useEffect(
      function () {
        Kee(W.current || [], o || []) || P.setFields(o || []), (W.current = o);
      },
      [o, P]
    );
    var B = L.useMemo(
        function () {
          return Fe(Fe({}, P), {}, { validateTrigger: m });
        },
        [P, m]
      ),
      q = L.createElement(
        Lv.Provider,
        { value: null },
        L.createElement(Pf.Provider, { value: B }, Y)
      );
    return u === !1
      ? q
      : L.createElement(
          u,
          Bt({}, S, {
            ref: b,
            onSubmit: function (H) {
              H.preventDefault(), H.stopPropagation(), P.submit();
            },
            onReset: function (H) {
              var X;
              H.preventDefault(),
                P.resetFields(),
                (X = S.onReset) === null || X === void 0 || X.call(S, H);
            },
          }),
          q
        );
  };
function N3(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return Math.random();
  }
}
function ste() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  var r = e[0],
    i = e[1],
    o = i === void 0 ? {} : i,
    s = pee(o) ? { form: o } : o,
    a = s.form,
    l = L.useState(),
    c = ot(l, 2),
    u = c[0],
    d = c[1],
    p = L.useMemo(
      function () {
        return N3(u);
      },
      [u]
    ),
    m = L.useRef(p);
  m.current = p;
  var v = L.useContext(Pf),
    _ = a || v,
    y = _ && _._init,
    g = jn(r),
    x = L.useRef(g);
  return (
    (x.current = g),
    L.useEffect(
      function () {
        if (y) {
          var S = _.getFieldsValue,
            b = _.getInternalHooks,
            C = b(sc),
            M = C.registerWatch,
            T = function (O, D) {
              var N = s.preserve ? D : O;
              return typeof r == "function" ? r(N) : us(N, x.current);
            },
            P = M(function (E, O) {
              var D = T(E, O),
                N = N3(D);
              m.current !== N && ((m.current = N), d(D));
            }),
            R = T(S(), S(!0));
          return u !== R && d(R), P;
        }
      },
      [y]
    ),
    u
  );
}
var ate = L.forwardRef(ote),
  $p = ate;
$p.FormProvider = rte;
$p.Field = g4;
$p.List = Qee;
$p.useForm = y4;
$p.useWatch = ste;
const ys = L.createContext({}),
  lte = ({ children: t, status: e, override: n }) => {
    const r = L.useContext(ys),
      i = L.useMemo(() => {
        const o = Object.assign({}, r);
        return (
          n && delete o.isFormItemInput,
          e && (delete o.status, delete o.hasFeedback, delete o.feedbackIcon),
          o
        );
      }, [e, n, r]);
    return L.createElement(ys.Provider, { value: i }, t);
  },
  cte = L.createContext(void 0),
  D3 = (t) => {
    const { space: e, form: n, children: r } = t;
    if (r == null) return null;
    let i = r;
    return (
      n && (i = We.createElement(lte, { override: !0, status: !0 }, i)),
      e && (i = We.createElement(rQ, null, i)),
      i
    );
  },
  ute = We.createContext({});
function Kb(t, e, n) {
  return ft({
    [`${t}-status-success`]: e === "success",
    [`${t}-status-warning`]: e === "warning",
    [`${t}-status-error`]: e === "error",
    [`${t}-status-validating`]: e === "validating",
    [`${t}-has-feedback`]: n,
  });
}
const pM = (t, e) => e || t,
  x4 = (t, e, n = void 0) => {
    var r, i;
    const { variant: o, [t]: s } = L.useContext(Sn),
      a = L.useContext(cte),
      l = s == null ? void 0 : s.variant;
    let c;
    typeof e < "u"
      ? (c = e)
      : n === !1
      ? (c = "borderless")
      : (c =
          (i = (r = a ?? l) !== null && r !== void 0 ? r : o) !== null &&
          i !== void 0
            ? i
            : "outlined");
    const u = yK.includes(c);
    return [c, u];
  };
var fte = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z",
          },
        },
      ],
    },
    name: "search",
    theme: "outlined",
  },
  dte = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: fte }));
  },
  hte = L.forwardRef(dte);
const _4 = L.createContext(null),
  pte = _4.Provider,
  S4 = L.createContext(null),
  mte = S4.Provider;
var gte = [
    "prefixCls",
    "className",
    "style",
    "checked",
    "disabled",
    "defaultChecked",
    "type",
    "title",
    "onChange",
  ],
  vte = L.forwardRef(function (t, e) {
    var n = t.prefixCls,
      r = n === void 0 ? "rc-checkbox" : n,
      i = t.className,
      o = t.style,
      s = t.checked,
      a = t.disabled,
      l = t.defaultChecked,
      c = l === void 0 ? !1 : l,
      u = t.type,
      d = u === void 0 ? "checkbox" : u,
      p = t.title,
      m = t.onChange,
      v = sr(t, gte),
      _ = L.useRef(null),
      y = L.useRef(null),
      g = Hf(c, { value: s }),
      x = ot(g, 2),
      S = x[0],
      b = x[1];
    L.useImperativeHandle(e, function () {
      return {
        focus: function (P) {
          var R;
          (R = _.current) === null || R === void 0 || R.focus(P);
        },
        blur: function () {
          var P;
          (P = _.current) === null || P === void 0 || P.blur();
        },
        input: _.current,
        nativeElement: y.current,
      };
    });
    var C = ft(
        r,
        i,
        ve(ve({}, "".concat(r, "-checked"), S), "".concat(r, "-disabled"), a)
      ),
      M = function (P) {
        a ||
          ("checked" in t || b(P.target.checked),
          m == null ||
            m({
              target: Fe(Fe({}, t), {}, { type: d, checked: P.target.checked }),
              stopPropagation: function () {
                P.stopPropagation();
              },
              preventDefault: function () {
                P.preventDefault();
              },
              nativeEvent: P.nativeEvent,
            }));
      };
    return L.createElement(
      "span",
      { className: C, title: p, style: o, ref: y },
      L.createElement(
        "input",
        Bt({}, v, {
          className: "".concat(r, "-input"),
          ref: _,
          onChange: M,
          disabled: a,
          checked: !!S,
          type: d,
        })
      ),
      L.createElement("span", { className: "".concat(r, "-inner") })
    );
  });
function yte(t) {
  const e = We.useRef(null),
    n = () => {
      Ao.cancel(e.current), (e.current = null);
    };
  return [
    () => {
      n(),
        (e.current = Ao(() => {
          e.current = null;
        }));
    },
    (o) => {
      e.current && (o.stopPropagation(), n()), t == null || t(o);
    },
  ];
}
const xte = (t) => {
    const { componentCls: e, antCls: n } = t,
      r = `${e}-group`;
    return {
      [r]: Object.assign(Object.assign({}, Pc(t)), {
        display: "inline-block",
        fontSize: 0,
        [`&${r}-rtl`]: { direction: "rtl" },
        [`&${r}-block`]: { display: "flex" },
        [`${n}-badge ${n}-badge-count`]: { zIndex: 1 },
        [`> ${n}-badge:not(:first-child) > ${n}-button-wrapper`]: {
          borderInlineStart: "none",
        },
      }),
    };
  },
  _te = (t) => {
    const {
        componentCls: e,
        wrapperMarginInlineEnd: n,
        colorPrimary: r,
        radioSize: i,
        motionDurationSlow: o,
        motionDurationMid: s,
        motionEaseInOutCirc: a,
        colorBgContainer: l,
        colorBorder: c,
        lineWidth: u,
        colorBgContainerDisabled: d,
        colorTextDisabled: p,
        paddingXS: m,
        dotColorDisabled: v,
        lineType: _,
        radioColor: y,
        radioBgColor: g,
        calc: x,
      } = t,
      S = `${e}-inner`,
      C = x(i).sub(x(4).mul(2)),
      M = x(1).mul(i).equal({ unit: !0 });
    return {
      [`${e}-wrapper`]: Object.assign(Object.assign({}, Pc(t)), {
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: n,
        cursor: "pointer",
        "&:last-child": { marginInlineEnd: 0 },
        [`&${e}-wrapper-rtl`]: { direction: "rtl" },
        "&-disabled": { cursor: "not-allowed", color: t.colorTextDisabled },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"',
        },
        "&-block": { flex: 1, justifyContent: "center" },
        [`${e}-checked::after`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          border: `${Tt(u)} ${_} ${r}`,
          borderRadius: "50%",
          visibility: "hidden",
          opacity: 0,
          content: '""',
        },
        [e]: Object.assign(Object.assign({}, Pc(t)), {
          position: "relative",
          display: "inline-block",
          outline: "none",
          cursor: "pointer",
          alignSelf: "center",
          borderRadius: "50%",
        }),
        [`${e}-wrapper:hover &,
        &:hover ${S}`]: { borderColor: r },
        [`${e}-input:focus-visible + ${S}`]: sM(t),
        [`${e}:hover::after, ${e}-wrapper:hover &::after`]: {
          visibility: "visible",
        },
        [`${e}-inner`]: {
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: "50%",
            display: "block",
            width: M,
            height: M,
            marginBlockStart: x(1).mul(i).div(-2).equal({ unit: !0 }),
            marginInlineStart: x(1).mul(i).div(-2).equal({ unit: !0 }),
            backgroundColor: y,
            borderBlockStart: 0,
            borderInlineStart: 0,
            borderRadius: M,
            transform: "scale(0)",
            opacity: 0,
            transition: `all ${o} ${a}`,
            content: '""',
          },
          boxSizing: "border-box",
          position: "relative",
          insetBlockStart: 0,
          insetInlineStart: 0,
          display: "block",
          width: M,
          height: M,
          backgroundColor: l,
          borderColor: c,
          borderStyle: "solid",
          borderWidth: u,
          borderRadius: "50%",
          transition: `all ${s}`,
        },
        [`${e}-input`]: {
          position: "absolute",
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
        },
        [`${e}-checked`]: {
          [S]: {
            borderColor: r,
            backgroundColor: g,
            "&::after": {
              transform: `scale(${t.calc(t.dotSize).div(i).equal()})`,
              opacity: 1,
              transition: `all ${o} ${a}`,
            },
          },
        },
        [`${e}-disabled`]: {
          cursor: "not-allowed",
          [S]: {
            backgroundColor: d,
            borderColor: c,
            cursor: "not-allowed",
            "&::after": { backgroundColor: v },
          },
          [`${e}-input`]: { cursor: "not-allowed" },
          [`${e}-disabled + span`]: { color: p, cursor: "not-allowed" },
          [`&${e}-checked`]: {
            [S]: { "&::after": { transform: `scale(${x(C).div(i).equal()})` } },
          },
        },
        [`span${e} + *`]: { paddingInlineStart: m, paddingInlineEnd: m },
      }),
    };
  },
  Ste = (t) => {
    const {
      buttonColor: e,
      controlHeight: n,
      componentCls: r,
      lineWidth: i,
      lineType: o,
      colorBorder: s,
      motionDurationMid: a,
      buttonPaddingInline: l,
      fontSize: c,
      buttonBg: u,
      fontSizeLG: d,
      controlHeightLG: p,
      controlHeightSM: m,
      paddingXS: v,
      borderRadius: _,
      borderRadiusSM: y,
      borderRadiusLG: g,
      buttonCheckedBg: x,
      buttonSolidCheckedColor: S,
      colorTextDisabled: b,
      colorBgContainerDisabled: C,
      buttonCheckedBgDisabled: M,
      buttonCheckedColorDisabled: T,
      colorPrimary: P,
      colorPrimaryHover: R,
      colorPrimaryActive: E,
      buttonSolidCheckedBg: O,
      buttonSolidCheckedHoverBg: D,
      buttonSolidCheckedActiveBg: N,
      calc: z,
    } = t;
    return {
      [`${r}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: n,
        margin: 0,
        paddingInline: l,
        paddingBlock: 0,
        color: e,
        fontSize: c,
        lineHeight: Tt(z(n).sub(z(i).mul(2)).equal()),
        background: u,
        border: `${Tt(i)} ${o} ${s}`,
        borderBlockStartWidth: z(i).add(0.02).equal(),
        borderInlineEndWidth: i,
        cursor: "pointer",
        transition: [`color ${a}`, `background ${a}`, `box-shadow ${a}`].join(
          ","
        ),
        a: { color: e },
        [`> ${r}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%",
        },
        "&:not(:last-child)": { marginInlineEnd: z(i).mul(-1).equal() },
        "&:first-child": {
          borderInlineStart: `${Tt(i)} ${o} ${s}`,
          borderStartStartRadius: _,
          borderEndStartRadius: _,
        },
        "&:last-child": { borderStartEndRadius: _, borderEndEndRadius: _ },
        "&:first-child:last-child": { borderRadius: _ },
        [`${r}-group-large &`]: {
          height: p,
          fontSize: d,
          lineHeight: Tt(z(p).sub(z(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: g,
            borderEndStartRadius: g,
          },
          "&:last-child": { borderStartEndRadius: g, borderEndEndRadius: g },
        },
        [`${r}-group-small &`]: {
          height: m,
          paddingInline: z(v).sub(i).equal(),
          paddingBlock: 0,
          lineHeight: Tt(z(m).sub(z(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: y,
            borderEndStartRadius: y,
          },
          "&:last-child": { borderStartEndRadius: y, borderEndEndRadius: y },
        },
        "&:hover": { position: "relative", color: P },
        "&:has(:focus-visible)": sM(t),
        [`${r}-inner, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none",
        },
        [`&-checked:not(${r}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: P,
          background: x,
          borderColor: P,
          "&::before": { backgroundColor: P },
          "&:first-child": { borderColor: P },
          "&:hover": {
            color: R,
            borderColor: R,
            "&::before": { backgroundColor: R },
          },
          "&:active": {
            color: E,
            borderColor: E,
            "&::before": { backgroundColor: E },
          },
        },
        [`${r}-group-solid &-checked:not(${r}-button-wrapper-disabled)`]: {
          color: S,
          background: O,
          borderColor: O,
          "&:hover": { color: S, background: D, borderColor: D },
          "&:active": { color: S, background: N, borderColor: N },
        },
        "&-disabled": {
          color: b,
          backgroundColor: C,
          borderColor: s,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: b,
            backgroundColor: C,
            borderColor: s,
          },
        },
        [`&-disabled${r}-button-wrapper-checked`]: {
          color: T,
          backgroundColor: M,
          borderColor: s,
          boxShadow: "none",
        },
        "&-block": { flex: 1, textAlign: "center" },
      },
    };
  },
  Ate = (t) => {
    const {
        wireframe: e,
        padding: n,
        marginXS: r,
        lineWidth: i,
        fontSizeLG: o,
        colorText: s,
        colorBgContainer: a,
        colorTextDisabled: l,
        controlItemBgActiveDisabled: c,
        colorTextLightSolid: u,
        colorPrimary: d,
        colorPrimaryHover: p,
        colorPrimaryActive: m,
        colorWhite: v,
      } = t,
      _ = 4,
      y = o,
      g = e ? y - _ * 2 : y - (_ + i) * 2;
    return {
      radioSize: y,
      dotSize: g,
      dotColorDisabled: l,
      buttonSolidCheckedColor: u,
      buttonSolidCheckedBg: d,
      buttonSolidCheckedHoverBg: p,
      buttonSolidCheckedActiveBg: m,
      buttonBg: a,
      buttonCheckedBg: a,
      buttonColor: s,
      buttonCheckedBgDisabled: c,
      buttonCheckedColorDisabled: l,
      buttonPaddingInline: n - i,
      wrapperMarginInlineEnd: r,
      radioColor: e ? d : v,
      radioBgColor: e ? a : d,
    };
  },
  A4 = dl(
    "Radio",
    (t) => {
      const { controlOutline: e, controlOutlineWidth: n } = t,
        r = `0 0 0 ${Tt(n)} ${e}`,
        o = di(t, { radioFocusShadow: r, radioButtonFocusShadow: r });
      return [xte(o), _te(o), Ste(o)];
    },
    Ate,
    { unitless: { radioSize: !0, dotSize: !0 } }
  );
var bte = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const wte = (t, e) => {
    var n, r;
    const i = L.useContext(_4),
      o = L.useContext(S4),
      { getPrefixCls: s, direction: a, radio: l } = L.useContext(Sn),
      c = L.useRef(null),
      u = kc(e, c),
      { isFormItemInput: d } = L.useContext(ys),
      p = (G) => {
        var Y, U;
        (Y = t.onChange) === null || Y === void 0 || Y.call(t, G),
          (U = i == null ? void 0 : i.onChange) === null ||
            U === void 0 ||
            U.call(i, G);
      },
      {
        prefixCls: m,
        className: v,
        rootClassName: _,
        children: y,
        style: g,
        title: x,
      } = t,
      S = bte(t, [
        "prefixCls",
        "className",
        "rootClassName",
        "children",
        "style",
        "title",
      ]),
      b = s("radio", m),
      C = ((i == null ? void 0 : i.optionType) || o) === "button",
      M = C ? `${b}-button` : b,
      T = jf(b),
      [P, R, E] = A4(b, T),
      O = Object.assign({}, S),
      D = L.useContext(rl);
    i &&
      ((O.name = i.name),
      (O.onChange = p),
      (O.checked = t.value === i.value),
      (O.disabled =
        (n = O.disabled) !== null && n !== void 0 ? n : i.disabled)),
      (O.disabled = (r = O.disabled) !== null && r !== void 0 ? r : D);
    const N = ft(
        `${M}-wrapper`,
        {
          [`${M}-wrapper-checked`]: O.checked,
          [`${M}-wrapper-disabled`]: O.disabled,
          [`${M}-wrapper-rtl`]: a === "rtl",
          [`${M}-wrapper-in-form-item`]: d,
          [`${M}-wrapper-block`]: !!(i != null && i.block),
        },
        l == null ? void 0 : l.className,
        v,
        _,
        R,
        E,
        T
      ),
      [z, V] = yte(O.onClick);
    return P(
      L.createElement(
        r4,
        { component: "Radio", disabled: O.disabled },
        L.createElement(
          "label",
          {
            className: N,
            style: Object.assign(
              Object.assign({}, l == null ? void 0 : l.style),
              g
            ),
            onMouseEnter: t.onMouseEnter,
            onMouseLeave: t.onMouseLeave,
            title: x,
            onClick: z,
          },
          L.createElement(
            vte,
            Object.assign({}, O, {
              className: ft(O.className, { [uM]: !C }),
              type: "radio",
              prefixCls: M,
              ref: u,
              onClick: V,
            })
          ),
          y !== void 0
            ? L.createElement("span", { className: `${M}-label` }, y)
            : null
        )
      )
    );
  },
  Ov = L.forwardRef(wte);
function Ete(t) {
  return t === void 0 || t === !1 ? [] : Array.isArray(t) ? t : [t];
}
function Mte(t) {
  return Ete(t).join("_");
}
const Cte = L.forwardRef((t, e) => {
    const { getPrefixCls: n, direction: r } = L.useContext(Sn),
      { name: i } = L.useContext(ys),
      o = hee(Mte(i)),
      {
        prefixCls: s,
        className: a,
        rootClassName: l,
        options: c,
        buttonStyle: u = "outline",
        disabled: d,
        children: p,
        size: m,
        style: v,
        id: _,
        optionType: y,
        name: g = o,
        defaultValue: x,
        value: S,
        block: b = !1,
        onChange: C,
        onMouseEnter: M,
        onMouseLeave: T,
        onFocus: P,
        onBlur: R,
      } = t,
      [E, O] = Hf(x, { value: S }),
      D = L.useCallback(
        (Z) => {
          const H = E,
            X = Z.target.value;
          "value" in t || O(X), X !== H && (C == null || C(Z));
        },
        [E, O, C]
      ),
      N = n("radio", s),
      z = `${N}-group`,
      V = jf(N),
      [G, Y, U] = A4(N, V);
    let j = p;
    c &&
      c.length > 0 &&
      (j = c.map((Z) =>
        typeof Z == "string" || typeof Z == "number"
          ? L.createElement(
              Ov,
              {
                key: Z.toString(),
                prefixCls: N,
                disabled: d,
                value: Z,
                checked: E === Z,
              },
              Z
            )
          : L.createElement(
              Ov,
              {
                key: `radio-group-value-options-${Z.value}`,
                prefixCls: N,
                disabled: Z.disabled || d,
                value: Z.value,
                checked: E === Z.value,
                title: Z.title,
                style: Z.style,
                className: Z.className,
                id: Z.id,
                required: Z.required,
              },
              Z.label
            )
      ));
    const W = Bc(m),
      B = ft(
        z,
        `${z}-${u}`,
        { [`${z}-${W}`]: W, [`${z}-rtl`]: r === "rtl", [`${z}-block`]: b },
        a,
        l,
        Y,
        U,
        V
      ),
      q = L.useMemo(
        () => ({
          onChange: D,
          value: E,
          disabled: d,
          name: g,
          optionType: y,
          block: b,
        }),
        [D, E, d, g, y, b]
      );
    return G(
      L.createElement(
        "div",
        Object.assign({}, Zy(t, { aria: !0, data: !0 }), {
          className: B,
          style: v,
          onMouseEnter: M,
          onMouseLeave: T,
          onFocus: P,
          onBlur: R,
          id: _,
          ref: e,
        }),
        L.createElement(pte, { value: q }, j)
      )
    );
  }),
  Tte = L.memo(Cte);
var Rte = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Pte = (t, e) => {
    const { getPrefixCls: n } = L.useContext(Sn),
      { prefixCls: r } = t,
      i = Rte(t, ["prefixCls"]),
      o = n("radio", r);
    return L.createElement(
      mte,
      { value: "button" },
      L.createElement(
        Ov,
        Object.assign({ prefixCls: o }, i, { type: "radio", ref: e })
      )
    );
  },
  Ite = L.forwardRef(Pte),
  xp = Ov;
xp.Button = Ite;
xp.Group = Tte;
xp.__ANT_RADIO = !0;
function sx(t) {
  return di(t, { inputAffixPadding: t.paddingXXS });
}
const ax = (t) => {
    const {
        controlHeight: e,
        fontSize: n,
        lineHeight: r,
        lineWidth: i,
        controlHeightSM: o,
        controlHeightLG: s,
        fontSizeLG: a,
        lineHeightLG: l,
        paddingSM: c,
        controlPaddingHorizontalSM: u,
        controlPaddingHorizontal: d,
        colorFillAlter: p,
        colorPrimaryHover: m,
        colorPrimary: v,
        controlOutlineWidth: _,
        controlOutline: y,
        colorErrorOutline: g,
        colorWarningOutline: x,
        colorBgContainer: S,
        inputFontSize: b,
        inputFontSizeLG: C,
        inputFontSizeSM: M,
      } = t,
      T = b || n,
      P = M || T,
      R = C || a,
      E = Math.round(((e - T * r) / 2) * 10) / 10 - i,
      O = Math.round(((o - P * r) / 2) * 10) / 10 - i,
      D = Math.ceil(((s - R * l) / 2) * 10) / 10 - i;
    return {
      paddingBlock: Math.max(E, 0),
      paddingBlockSM: Math.max(O, 0),
      paddingBlockLG: Math.max(D, 0),
      paddingInline: c - i,
      paddingInlineSM: u - i,
      paddingInlineLG: d - i,
      addonBg: p,
      activeBorderColor: v,
      hoverBorderColor: m,
      activeShadow: `0 0 0 ${_}px ${y}`,
      errorActiveShadow: `0 0 0 ${_}px ${g}`,
      warningActiveShadow: `0 0 0 ${_}px ${x}`,
      hoverBg: S,
      activeBg: S,
      inputFontSize: T,
      inputFontSizeLG: R,
      inputFontSizeSM: P,
    };
  },
  Lte = (t) => ({
    borderColor: t.hoverBorderColor,
    backgroundColor: t.hoverBg,
  }),
  mM = (t) => ({
    color: t.colorTextDisabled,
    backgroundColor: t.colorBgContainerDisabled,
    borderColor: t.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "input[disabled], textarea[disabled]": { cursor: "not-allowed" },
    "&:hover:not([disabled])": Object.assign(
      {},
      Lte(
        di(t, {
          hoverBorderColor: t.colorBorder,
          hoverBg: t.colorBgContainerDisabled,
        })
      )
    ),
  }),
  b4 = (t, e) => ({
    background: t.colorBgContainer,
    borderWidth: t.lineWidth,
    borderStyle: t.lineType,
    borderColor: e.borderColor,
    "&:hover": { borderColor: e.hoverBorderColor, backgroundColor: t.hoverBg },
    "&:focus, &:focus-within": {
      borderColor: e.activeBorderColor,
      boxShadow: e.activeShadow,
      outline: 0,
      backgroundColor: t.activeBg,
    },
  }),
  F3 = (t, e) => ({
    [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, b4(t, e)), {
        [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
    [`&${t.componentCls}-status-${e.status}${t.componentCls}-disabled`]: {
      borderColor: e.borderColor,
    },
  }),
  Ote = (t, e) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              b4(t, {
                borderColor: t.colorBorder,
                hoverBorderColor: t.hoverBorderColor,
                activeBorderColor: t.activeBorderColor,
                activeShadow: t.activeShadow,
              })
            ),
            {
              [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                mM(t)
              ),
            }
          ),
          F3(t, {
            status: "error",
            borderColor: t.colorError,
            hoverBorderColor: t.colorErrorBorderHover,
            activeBorderColor: t.colorError,
            activeShadow: t.errorActiveShadow,
            affixColor: t.colorError,
          })
        ),
        F3(t, {
          status: "warning",
          borderColor: t.colorWarning,
          hoverBorderColor: t.colorWarningBorderHover,
          activeBorderColor: t.colorWarning,
          activeShadow: t.warningActiveShadow,
          affixColor: t.colorWarning,
        })
      ),
      e
    ),
  }),
  U3 = (t, e) => ({
    [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${t.componentCls}-group-addon`]: {
        borderColor: e.addonBorderColor,
        color: e.addonColor,
      },
    },
  }),
  Nte = (t) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${t.componentCls}-group`]: {
              "&-addon": {
                background: t.addonBg,
                border: `${Tt(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              },
              "&-addon:first-child": { borderInlineEnd: 0 },
              "&-addon:last-child": { borderInlineStart: 0 },
            },
          },
          U3(t, {
            status: "error",
            addonBorderColor: t.colorError,
            addonColor: t.colorErrorText,
          })
        ),
        U3(t, {
          status: "warning",
          addonBorderColor: t.colorWarning,
          addonColor: t.colorWarningText,
        })
      ),
      {
        [`&${t.componentCls}-group-wrapper-disabled`]: {
          [`${t.componentCls}-group-addon`]: Object.assign({}, mM(t)),
        },
      }
    ),
  }),
  Dte = (t, e) => {
    const { componentCls: n } = t;
    return {
      "&-borderless": Object.assign(
        {
          background: "transparent",
          border: "none",
          "&:focus, &:focus-within": { outline: "none" },
          [`&${n}-disabled, &[disabled]`]: {
            color: t.colorTextDisabled,
            cursor: "not-allowed",
          },
          [`&${n}-status-error`]: {
            "&, & input, & textarea": { color: t.colorError },
          },
          [`&${n}-status-warning`]: {
            "&, & input, & textarea": { color: t.colorWarning },
          },
        },
        e
      ),
    };
  },
  w4 = (t, e) => {
    var n;
    return {
      background: e.bg,
      borderWidth: t.lineWidth,
      borderStyle: t.lineType,
      borderColor: "transparent",
      "input&, & input, textarea&, & textarea": {
        color:
          (n = e == null ? void 0 : e.inputColor) !== null && n !== void 0
            ? n
            : "unset",
      },
      "&:hover": { background: e.hoverBg },
      "&:focus, &:focus-within": {
        outline: 0,
        borderColor: e.activeBorderColor,
        backgroundColor: t.activeBg,
      },
    };
  },
  k3 = (t, e) => ({
    [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, w4(t, e)), {
        [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
  }),
  Fte = (t, e) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              w4(t, {
                bg: t.colorFillTertiary,
                hoverBg: t.colorFillSecondary,
                activeBorderColor: t.activeBorderColor,
              })
            ),
            {
              [`&${t.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                mM(t)
              ),
            }
          ),
          k3(t, {
            status: "error",
            bg: t.colorErrorBg,
            hoverBg: t.colorErrorBgHover,
            activeBorderColor: t.colorError,
            inputColor: t.colorErrorText,
            affixColor: t.colorError,
          })
        ),
        k3(t, {
          status: "warning",
          bg: t.colorWarningBg,
          hoverBg: t.colorWarningBgHover,
          activeBorderColor: t.colorWarning,
          inputColor: t.colorWarningText,
          affixColor: t.colorWarning,
        })
      ),
      e
    ),
  }),
  z3 = (t, e) => ({
    [`&${t.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${t.componentCls}-group-addon`]: {
        background: e.addonBg,
        color: e.addonColor,
      },
    },
  }),
  Ute = (t) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${t.componentCls}-group-addon`]: {
              background: t.colorFillTertiary,
              "&:last-child": { position: "static" },
            },
          },
          z3(t, {
            status: "error",
            addonBg: t.colorErrorBg,
            addonColor: t.colorErrorText,
          })
        ),
        z3(t, {
          status: "warning",
          addonBg: t.colorWarningBg,
          addonColor: t.colorWarningText,
        })
      ),
      {
        [`&${t.componentCls}-group-wrapper-disabled`]: {
          [`${t.componentCls}-group`]: {
            "&-addon": {
              background: t.colorFillTertiary,
              color: t.colorTextDisabled,
            },
            "&-addon:first-child": {
              borderInlineStart: `${Tt(t.lineWidth)} ${t.lineType} ${
                t.colorBorder
              }`,
              borderTop: `${Tt(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              borderBottom: `${Tt(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
            },
            "&-addon:last-child": {
              borderInlineEnd: `${Tt(t.lineWidth)} ${t.lineType} ${
                t.colorBorder
              }`,
              borderTop: `${Tt(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
              borderBottom: `${Tt(t.lineWidth)} ${t.lineType} ${t.colorBorder}`,
            },
          },
        },
      }
    ),
  }),
  E4 = (t, e) => ({
    background: t.colorBgContainer,
    borderWidth: `${Tt(t.lineWidth)} 0`,
    borderStyle: `${t.lineType} none`,
    borderColor: `transparent transparent ${e.borderColor} transparent`,
    borderRadius: 0,
    "&:hover": {
      borderColor: `transparent transparent ${e.borderColor} transparent`,
      backgroundColor: t.hoverBg,
    },
    "&:focus, &:focus-within": {
      borderColor: `transparent transparent ${e.activeBorderColor} transparent`,
      outline: 0,
      backgroundColor: t.activeBg,
    },
  }),
  B3 = (t, e) => ({
    [`&${t.componentCls}-status-${e.status}:not(${t.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, E4(t, e)), {
        [`${t.componentCls}-prefix, ${t.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
    [`&${t.componentCls}-status-${e.status}${t.componentCls}-disabled`]: {
      borderColor: `transparent transparent ${e.borderColor} transparent`,
    },
  }),
  kte = (t, e) => ({
    "&-underlined": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              E4(t, {
                borderColor: t.colorBorder,
                hoverBorderColor: t.hoverBorderColor,
                activeBorderColor: t.activeBorderColor,
                activeShadow: t.activeShadow,
              })
            ),
            {
              [`&${t.componentCls}-disabled, &[disabled]`]: {
                color: t.colorTextDisabled,
                boxShadow: "none",
                cursor: "not-allowed",
                "&:hover": {
                  borderColor: `transparent transparent ${t.colorBorder} transparent`,
                },
              },
              "input[disabled], textarea[disabled]": { cursor: "not-allowed" },
            }
          ),
          B3(t, {
            status: "error",
            borderColor: t.colorError,
            hoverBorderColor: t.colorErrorBorderHover,
            activeBorderColor: t.colorError,
            activeShadow: t.errorActiveShadow,
            affixColor: t.colorError,
          })
        ),
        B3(t, {
          status: "warning",
          borderColor: t.colorWarning,
          hoverBorderColor: t.colorWarningBorderHover,
          activeBorderColor: t.colorWarning,
          activeShadow: t.warningActiveShadow,
          affixColor: t.colorWarning,
        })
      ),
      e
    ),
  }),
  zte = (t) => ({
    "&::-moz-placeholder": { opacity: 1 },
    "&::placeholder": { color: t, userSelect: "none" },
    "&:placeholder-shown": { textOverflow: "ellipsis" },
  }),
  M4 = (t) => {
    const {
      paddingBlockLG: e,
      lineHeightLG: n,
      borderRadiusLG: r,
      paddingInlineLG: i,
    } = t;
    return {
      padding: `${Tt(e)} ${Tt(i)}`,
      fontSize: t.inputFontSizeLG,
      lineHeight: n,
      borderRadius: r,
    };
  },
  C4 = (t) => ({
    padding: `${Tt(t.paddingBlockSM)} ${Tt(t.paddingInlineSM)}`,
    fontSize: t.inputFontSizeSM,
    borderRadius: t.borderRadiusSM,
  }),
  T4 = (t) =>
    Object.assign(
      Object.assign(
        {
          position: "relative",
          display: "inline-block",
          width: "100%",
          minWidth: 0,
          padding: `${Tt(t.paddingBlock)} ${Tt(t.paddingInline)}`,
          color: t.colorText,
          fontSize: t.inputFontSize,
          lineHeight: t.lineHeight,
          borderRadius: t.borderRadius,
          transition: `all ${t.motionDurationMid}`,
        },
        zte(t.colorTextPlaceholder)
      ),
      {
        "&-lg": Object.assign({}, M4(t)),
        "&-sm": Object.assign({}, C4(t)),
        "&-rtl, &-textarea-rtl": { direction: "rtl" },
      }
    ),
  Bte = (t) => {
    const { componentCls: e, antCls: n } = t;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      "&[class*='col-']": {
        paddingInlineEnd: t.paddingXS,
        "&:last-child": { paddingInlineEnd: 0 },
      },
      [`&-lg ${e}, &-lg > ${e}-group-addon`]: Object.assign({}, M4(t)),
      [`&-sm ${e}, &-sm > ${e}-group-addon`]: Object.assign({}, C4(t)),
      [`&-lg ${n}-select-single ${n}-select-selector`]: {
        height: t.controlHeightLG,
      },
      [`&-sm ${n}-select-single ${n}-select-selector`]: {
        height: t.controlHeightSM,
      },
      [`> ${e}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
      },
      [`${e}-group`]: {
        "&-addon, &-wrap": {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
        },
        "&-wrap > *": { display: "block !important" },
        "&-addon": {
          position: "relative",
          padding: `0 ${Tt(t.paddingInline)}`,
          color: t.colorText,
          fontWeight: "normal",
          fontSize: t.inputFontSize,
          textAlign: "center",
          borderRadius: t.borderRadius,
          transition: `all ${t.motionDurationSlow}`,
          lineHeight: 1,
          [`${n}-select`]: {
            margin: `${Tt(t.calc(t.paddingBlock).add(1).mul(-1).equal())} ${Tt(
              t.calc(t.paddingInline).mul(-1).equal()
            )}`,
            [`&${n}-select-single:not(${n}-select-customize-input):not(${n}-pagination-size-changer)`]:
              {
                [`${n}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${Tt(t.lineWidth)} ${t.lineType} transparent`,
                  boxShadow: "none",
                },
              },
          },
          [`${n}-cascader-picker`]: {
            margin: `-9px ${Tt(t.calc(t.paddingInline).mul(-1).equal())}`,
            backgroundColor: "transparent",
            [`${n}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none",
            },
          },
        },
      },
      [e]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": { zIndex: 1, borderInlineEndWidth: 1 },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${e}-search-with-button &`]: { zIndex: 0 },
        },
      },
      [`> ${e}:first-child, ${e}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${n}-select ${n}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}-affix-wrapper`]: {
        [`&:not(:first-child) ${e}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
        [`&:not(:last-child) ${e}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}:last-child, ${e}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        [`${n}-select ${n}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`${e}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${e}-search &`]: {
            borderStartStartRadius: t.borderRadius,
            borderEndStartRadius: t.borderRadius,
          },
        },
        [`&:not(:first-child), ${e}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`&${e}-group-compact`]: Object.assign(
        Object.assign({ display: "block" }, VK()),
        {
          [`${e}-group-addon, ${e}-group-wrap, > ${e}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: t.lineWidth,
              "&:hover, &:focus": { zIndex: 1 },
            },
          },
          "& > *": {
            display: "inline-flex",
            float: "none",
            verticalAlign: "top",
            borderRadius: 0,
          },
          [`
        & > ${e}-affix-wrapper,
        & > ${e}-number-affix-wrapper,
        & > ${n}-picker-range
      `]: { display: "inline-flex" },
          "& > *:not(:last-child)": {
            marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: t.lineWidth,
          },
          [e]: { float: "none" },
          [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${e},
      & > ${n}-cascader-picker ${e},
      & > ${e}-group-wrapper ${e}`]: {
            borderInlineEndWidth: t.lineWidth,
            borderRadius: 0,
            "&:hover, &:focus": { zIndex: 1 },
          },
          [`& > ${n}-select-focused`]: { zIndex: 1 },
          [`& > ${n}-select > ${n}-select-arrow`]: { zIndex: 1 },
          [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${e},
      & > ${n}-cascader-picker:first-child ${e}`]: {
            borderStartStartRadius: t.borderRadius,
            borderEndStartRadius: t.borderRadius,
          },
          [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${e},
      & > ${n}-cascader-picker-focused:last-child ${e}`]: {
            borderInlineEndWidth: t.lineWidth,
            borderStartEndRadius: t.borderRadius,
            borderEndEndRadius: t.borderRadius,
          },
          [`& > ${n}-select-auto-complete ${e}`]: { verticalAlign: "top" },
          [`${e}-group-wrapper + ${e}-group-wrapper`]: {
            marginInlineStart: t.calc(t.lineWidth).mul(-1).equal(),
            [`${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`${e}-group-wrapper:not(:last-child)`]: {
            [`&${e}-search > ${e}-group`]: {
              [`& > ${e}-group-addon > ${e}-search-button`]: {
                borderRadius: 0,
              },
              [`& > ${e}`]: {
                borderStartStartRadius: t.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: t.borderRadius,
              },
            },
          },
        }
      ),
    };
  },
  Hte = (t) => {
    const { componentCls: e, controlHeightSM: n, lineWidth: r, calc: i } = t,
      s = i(n).sub(i(r).mul(2)).sub(16).div(2).equal();
    return {
      [e]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(Object.assign({}, Pc(t)), T4(t)),
                Ote(t)
              ),
              Fte(t)
            ),
            Dte(t)
          ),
          kte(t)
        ),
        {
          '&[type="color"]': {
            height: t.controlHeight,
            [`&${e}-lg`]: { height: t.controlHeightLG },
            [`&${e}-sm`]: { height: n, paddingTop: s, paddingBottom: s },
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration':
            { appearance: "none" },
        }
      ),
    };
  },
  Vte = (t) => {
    const { componentCls: e } = t;
    return {
      [`${e}-clear-icon`]: {
        margin: 0,
        padding: 0,
        lineHeight: 0,
        color: t.colorTextQuaternary,
        fontSize: t.fontSizeIcon,
        verticalAlign: -1,
        cursor: "pointer",
        transition: `color ${t.motionDurationSlow}`,
        border: "none",
        outline: "none",
        backgroundColor: "transparent",
        "&:hover": { color: t.colorIcon },
        "&:active": { color: t.colorText },
        "&-hidden": { visibility: "hidden" },
        "&-has-suffix": { margin: `0 ${Tt(t.inputAffixPadding)}` },
      },
    };
  },
  Gte = (t) => {
    const {
        componentCls: e,
        inputAffixPadding: n,
        colorTextDescription: r,
        motionDurationSlow: i,
        colorIcon: o,
        colorIconHover: s,
        iconCls: a,
      } = t,
      l = `${e}-affix-wrapper`,
      c = `${e}-affix-wrapper-disabled`;
    return {
      [l]: Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, T4(t)), {
            display: "inline-flex",
            [`&:not(${e}-disabled):hover`]: {
              zIndex: 1,
              [`${e}-search-with-button &`]: { zIndex: 0 },
            },
            "&-focused, &:focus": { zIndex: 1 },
            [`> input${e}`]: { padding: 0 },
            [`> input${e}, > textarea${e}`]: {
              fontSize: "inherit",
              border: "none",
              borderRadius: 0,
              outline: "none",
              background: "transparent",
              color: "inherit",
              "&::-ms-reveal": { display: "none" },
              "&:focus": { boxShadow: "none !important" },
            },
            "&::before": {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"',
            },
            [e]: {
              "&-prefix, &-suffix": {
                display: "flex",
                flex: "none",
                alignItems: "center",
                "> *:not(:last-child)": { marginInlineEnd: t.paddingXS },
              },
              "&-show-count-suffix": { color: r, direction: "ltr" },
              "&-show-count-has-suffix": { marginInlineEnd: t.paddingXXS },
              "&-prefix": { marginInlineEnd: n },
              "&-suffix": { marginInlineStart: n },
            },
          }),
          Vte(t)
        ),
        {
          [`${a}${e}-password-icon`]: {
            color: o,
            cursor: "pointer",
            transition: `all ${i}`,
            "&:hover": { color: s },
          },
        }
      ),
      [`${e}-underlined`]: { borderRadius: 0 },
      [c]: {
        [`${a}${e}-password-icon`]: {
          color: o,
          cursor: "not-allowed",
          "&:hover": { color: o },
        },
      },
    };
  },
  Wte = (t) => {
    const { componentCls: e, borderRadiusLG: n, borderRadiusSM: r } = t;
    return {
      [`${e}-group`]: Object.assign(
        Object.assign(Object.assign({}, Pc(t)), Bte(t)),
        {
          "&-rtl": { direction: "rtl" },
          "&-wrapper": Object.assign(
            Object.assign(
              Object.assign(
                {
                  display: "inline-block",
                  width: "100%",
                  textAlign: "start",
                  verticalAlign: "top",
                  "&-rtl": { direction: "rtl" },
                  "&-lg": {
                    [`${e}-group-addon`]: {
                      borderRadius: n,
                      fontSize: t.inputFontSizeLG,
                    },
                  },
                  "&-sm": { [`${e}-group-addon`]: { borderRadius: r } },
                },
                Nte(t)
              ),
              Ute(t)
            ),
            {
              [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]:
                { [`${e}, ${e}-group-addon`]: { borderRadius: 0 } },
              [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
              [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                },
              },
              [`&:not(${e}-compact-last-item)${e}-compact-item`]: {
                [`${e}-affix-wrapper`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
              [`&:not(${e}-compact-first-item)${e}-compact-item`]: {
                [`${e}-affix-wrapper`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                },
              },
            }
          ),
        }
      ),
    };
  },
  jte = (t) => {
    const { componentCls: e, antCls: n } = t,
      r = `${e}-search`;
    return {
      [r]: {
        [e]: {
          "&:hover, &:focus": {
            [`+ ${e}-group-addon ${r}-button:not(${n}-btn-color-primary):not(${n}-btn-variant-text)`]:
              { borderInlineStartColor: t.colorPrimaryHover },
          },
        },
        [`${e}-affix-wrapper`]: { height: t.controlHeight, borderRadius: 0 },
        [`${e}-lg`]: { lineHeight: t.calc(t.lineHeightLG).sub(2e-4).equal() },
        [`> ${e}-group`]: {
          [`> ${e}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${r}-button`]: {
              marginInlineEnd: -1,
              borderStartStartRadius: 0,
              borderEndStartRadius: 0,
              boxShadow: "none",
            },
            [`${r}-button:not(${n}-btn-color-primary)`]: {
              color: t.colorTextDescription,
              "&:hover": { color: t.colorPrimaryHover },
              "&:active": { color: t.colorPrimaryActive },
              [`&${n}-btn-loading::before`]: { inset: 0 },
            },
          },
        },
        [`${r}-button`]: {
          height: t.controlHeight,
          "&:hover, &:focus": { zIndex: 1 },
        },
        "&-large": {
          [`${e}-affix-wrapper, ${r}-button`]: { height: t.controlHeightLG },
        },
        "&-small": {
          [`${e}-affix-wrapper, ${r}-button`]: { height: t.controlHeightSM },
        },
        "&-rtl": { direction: "rtl" },
        [`&${e}-compact-item`]: {
          [`&:not(${e}-compact-last-item)`]: {
            [`${e}-group-addon`]: {
              [`${e}-search-button`]: {
                marginInlineEnd: t.calc(t.lineWidth).mul(-1).equal(),
                borderRadius: 0,
              },
            },
          },
          [`&:not(${e}-compact-first-item)`]: {
            [`${e},${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`> ${e}-group-addon ${e}-search-button,
        > ${e},
        ${e}-affix-wrapper`]: { "&:hover, &:focus, &:active": { zIndex: 2 } },
          [`> ${e}-affix-wrapper-focused`]: { zIndex: 2 },
        },
      },
    };
  },
  $te = (t) => {
    const { componentCls: e } = t;
    return {
      [`${e}-out-of-range`]: {
        [`&, & input, & textarea, ${e}-show-count-suffix, ${e}-data-count`]: {
          color: t.colorError,
        },
      },
    };
  },
  R4 = dl(
    ["Input", "Shared"],
    (t) => {
      const e = di(t, sx(t));
      return [Hte(e), Gte(e)];
    },
    ax,
    { resetFont: !1 }
  ),
  P4 = dl(
    ["Input", "Component"],
    (t) => {
      const e = di(t, sx(t));
      return [Wte(e), jte(e), $te(e), d4(e)];
    },
    ax,
    { resetFont: !1 }
  );
function Xte(t) {
  return !!(t.addonBefore || t.addonAfter);
}
function Yte(t) {
  return !!(t.prefix || t.suffix || t.allowClear);
}
function H3(t, e, n) {
  var r = e.cloneNode(!0),
    i = Object.create(t, { target: { value: r }, currentTarget: { value: r } });
  return (
    (r.value = n),
    typeof e.selectionStart == "number" &&
      typeof e.selectionEnd == "number" &&
      ((r.selectionStart = e.selectionStart),
      (r.selectionEnd = e.selectionEnd)),
    (r.setSelectionRange = function () {
      e.setSelectionRange.apply(e, arguments);
    }),
    i
  );
}
function Nv(t, e, n, r) {
  if (n) {
    var i = e;
    if (e.type === "click") {
      (i = H3(e, t, "")), n(i);
      return;
    }
    if (t.type !== "file" && r !== void 0) {
      (i = H3(e, t, r)), n(i);
      return;
    }
    n(i);
  }
}
function I4(t, e) {
  if (t) {
    t.focus(e);
    var n = e || {},
      r = n.cursor;
    if (r) {
      var i = t.value.length;
      switch (r) {
        case "start":
          t.setSelectionRange(0, 0);
          break;
        case "end":
          t.setSelectionRange(i, i);
          break;
        default:
          t.setSelectionRange(0, i);
      }
    }
  }
}
var L4 = We.forwardRef(function (t, e) {
    var n,
      r,
      i,
      o = t.inputElement,
      s = t.children,
      a = t.prefixCls,
      l = t.prefix,
      c = t.suffix,
      u = t.addonBefore,
      d = t.addonAfter,
      p = t.className,
      m = t.style,
      v = t.disabled,
      _ = t.readOnly,
      y = t.focused,
      g = t.triggerFocus,
      x = t.allowClear,
      S = t.value,
      b = t.handleReset,
      C = t.hidden,
      M = t.classes,
      T = t.classNames,
      P = t.dataAttrs,
      R = t.styles,
      E = t.components,
      O = t.onClear,
      D = s ?? o,
      N = (E == null ? void 0 : E.affixWrapper) || "span",
      z = (E == null ? void 0 : E.groupWrapper) || "span",
      V = (E == null ? void 0 : E.wrapper) || "span",
      G = (E == null ? void 0 : E.groupAddon) || "span",
      Y = L.useRef(null),
      U = function (Ee) {
        var he;
        (he = Y.current) !== null &&
          he !== void 0 &&
          he.contains(Ee.target) &&
          (g == null || g());
      },
      j = Yte(t),
      W = L.cloneElement(D, {
        value: S,
        className:
          ft(
            (n = D.props) === null || n === void 0 ? void 0 : n.className,
            !j && (T == null ? void 0 : T.variant)
          ) || null,
      }),
      B = L.useRef(null);
    if (
      (We.useImperativeHandle(e, function () {
        return { nativeElement: B.current || Y.current };
      }),
      j)
    ) {
      var q = null;
      if (x) {
        var Z = !v && !_ && S,
          H = "".concat(a, "-clear-icon"),
          X =
            bt(x) === "object" && x !== null && x !== void 0 && x.clearIcon
              ? x.clearIcon
              : "✖";
        q = We.createElement(
          "button",
          {
            type: "button",
            tabIndex: -1,
            onClick: function (Ee) {
              b == null || b(Ee), O == null || O();
            },
            onMouseDown: function (Ee) {
              return Ee.preventDefault();
            },
            className: ft(
              H,
              ve(
                ve({}, "".concat(H, "-hidden"), !Z),
                "".concat(H, "-has-suffix"),
                !!c
              )
            ),
          },
          X
        );
      }
      var ne = "".concat(a, "-affix-wrapper"),
        oe = ft(
          ne,
          ve(
            ve(
              ve(
                ve(
                  ve({}, "".concat(a, "-disabled"), v),
                  "".concat(ne, "-disabled"),
                  v
                ),
                "".concat(ne, "-focused"),
                y
              ),
              "".concat(ne, "-readonly"),
              _
            ),
            "".concat(ne, "-input-with-clear-btn"),
            c && x && S
          ),
          M == null ? void 0 : M.affixWrapper,
          T == null ? void 0 : T.affixWrapper,
          T == null ? void 0 : T.variant
        ),
        ue =
          (c || x) &&
          We.createElement(
            "span",
            {
              className: ft(
                "".concat(a, "-suffix"),
                T == null ? void 0 : T.suffix
              ),
              style: R == null ? void 0 : R.suffix,
            },
            q,
            c
          );
      W = We.createElement(
        N,
        Bt(
          {
            className: oe,
            style: R == null ? void 0 : R.affixWrapper,
            onClick: U,
          },
          P == null ? void 0 : P.affixWrapper,
          { ref: Y }
        ),
        l &&
          We.createElement(
            "span",
            {
              className: ft(
                "".concat(a, "-prefix"),
                T == null ? void 0 : T.prefix
              ),
              style: R == null ? void 0 : R.prefix,
            },
            l
          ),
        W,
        ue
      );
    }
    if (Xte(t)) {
      var Ie = "".concat(a, "-group"),
        te = "".concat(Ie, "-addon"),
        ge = "".concat(Ie, "-wrapper"),
        ie = ft(
          "".concat(a, "-wrapper"),
          Ie,
          M == null ? void 0 : M.wrapper,
          T == null ? void 0 : T.wrapper
        ),
        pe = ft(
          ge,
          ve({}, "".concat(ge, "-disabled"), v),
          M == null ? void 0 : M.group,
          T == null ? void 0 : T.groupWrapper
        );
      W = We.createElement(
        z,
        { className: pe, ref: B },
        We.createElement(
          V,
          { className: ie },
          u && We.createElement(G, { className: te }, u),
          W,
          d && We.createElement(G, { className: te }, d)
        )
      );
    }
    return We.cloneElement(W, {
      className:
        ft((r = W.props) === null || r === void 0 ? void 0 : r.className, p) ||
        null,
      style: Fe(
        Fe({}, (i = W.props) === null || i === void 0 ? void 0 : i.style),
        m
      ),
      hidden: C,
    });
  }),
  qte = ["show"];
function O4(t, e) {
  return L.useMemo(
    function () {
      var n = {};
      e && (n.show = bt(e) === "object" && e.formatter ? e.formatter : !!e),
        (n = Fe(Fe({}, n), t));
      var r = n,
        i = r.show,
        o = sr(r, qte);
      return Fe(
        Fe({}, o),
        {},
        {
          show: !!i,
          showFormatter: typeof i == "function" ? i : void 0,
          strategy:
            o.strategy ||
            function (s) {
              return s.length;
            },
        }
      );
    },
    [t, e]
  );
}
var Kte = [
    "autoComplete",
    "onChange",
    "onFocus",
    "onBlur",
    "onPressEnter",
    "onKeyDown",
    "onKeyUp",
    "prefixCls",
    "disabled",
    "htmlSize",
    "className",
    "maxLength",
    "suffix",
    "showCount",
    "count",
    "type",
    "classes",
    "classNames",
    "styles",
    "onCompositionStart",
    "onCompositionEnd",
  ],
  Zte = L.forwardRef(function (t, e) {
    var n = t.autoComplete,
      r = t.onChange,
      i = t.onFocus,
      o = t.onBlur,
      s = t.onPressEnter,
      a = t.onKeyDown,
      l = t.onKeyUp,
      c = t.prefixCls,
      u = c === void 0 ? "rc-input" : c,
      d = t.disabled,
      p = t.htmlSize,
      m = t.className,
      v = t.maxLength,
      _ = t.suffix,
      y = t.showCount,
      g = t.count,
      x = t.type,
      S = x === void 0 ? "text" : x,
      b = t.classes,
      C = t.classNames,
      M = t.styles,
      T = t.onCompositionStart,
      P = t.onCompositionEnd,
      R = sr(t, Kte),
      E = L.useState(!1),
      O = ot(E, 2),
      D = O[0],
      N = O[1],
      z = L.useRef(!1),
      V = L.useRef(!1),
      G = L.useRef(null),
      Y = L.useRef(null),
      U = function (ce) {
        G.current && I4(G.current, ce);
      },
      j = Hf(t.defaultValue, { value: t.value }),
      W = ot(j, 2),
      B = W[0],
      q = W[1],
      Z = B == null ? "" : String(B),
      H = L.useState(null),
      X = ot(H, 2),
      ne = X[0],
      oe = X[1],
      ue = O4(g, y),
      Ie = ue.max || v,
      te = ue.strategy(Z),
      ge = !!Ie && te > Ie;
    L.useImperativeHandle(e, function () {
      var le;
      return {
        focus: U,
        blur: function () {
          var we;
          (we = G.current) === null || we === void 0 || we.blur();
        },
        setSelectionRange: function (we, Be, Me) {
          var Ge;
          (Ge = G.current) === null ||
            Ge === void 0 ||
            Ge.setSelectionRange(we, Be, Me);
        },
        select: function () {
          var we;
          (we = G.current) === null || we === void 0 || we.select();
        },
        input: G.current,
        nativeElement:
          ((le = Y.current) === null || le === void 0
            ? void 0
            : le.nativeElement) || G.current,
      };
    }),
      L.useEffect(
        function () {
          V.current && (V.current = !1),
            N(function (le) {
              return le && d ? !1 : le;
            });
        },
        [d]
      );
    var ie = function (ce, we, Be) {
      var Me = we;
      if (
        !z.current &&
        ue.exceedFormatter &&
        ue.max &&
        ue.strategy(we) > ue.max
      ) {
        if (((Me = ue.exceedFormatter(we, { max: ue.max })), we !== Me)) {
          var Ge, Le;
          oe([
            ((Ge = G.current) === null || Ge === void 0
              ? void 0
              : Ge.selectionStart) || 0,
            ((Le = G.current) === null || Le === void 0
              ? void 0
              : Le.selectionEnd) || 0,
          ]);
        }
      } else if (Be.source === "compositionEnd") return;
      q(Me), G.current && Nv(G.current, ce, r, Me);
    };
    L.useEffect(
      function () {
        if (ne) {
          var le;
          (le = G.current) === null ||
            le === void 0 ||
            le.setSelectionRange.apply(le, yt(ne));
        }
      },
      [ne]
    );
    var pe = function (ce) {
        ie(ce, ce.target.value, { source: "change" });
      },
      de = function (ce) {
        (z.current = !1),
          ie(ce, ce.currentTarget.value, { source: "compositionEnd" }),
          P == null || P(ce);
      },
      Ee = function (ce) {
        s && ce.key === "Enter" && !V.current && ((V.current = !0), s(ce)),
          a == null || a(ce);
      },
      he = function (ce) {
        ce.key === "Enter" && (V.current = !1), l == null || l(ce);
      },
      Ce = function (ce) {
        N(!0), i == null || i(ce);
      },
      _e = function (ce) {
        V.current && (V.current = !1), N(!1), o == null || o(ce);
      },
      $ = function (ce) {
        q(""), U(), G.current && Nv(G.current, ce, r);
      },
      k = ge && "".concat(u, "-out-of-range"),
      J = function () {
        var ce = vp(t, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          "defaultValue",
          "showCount",
          "count",
          "classes",
          "htmlSize",
          "styles",
          "classNames",
          "onClear",
        ]);
        return We.createElement(
          "input",
          Bt({ autoComplete: n }, ce, {
            onChange: pe,
            onFocus: Ce,
            onBlur: _e,
            onKeyDown: Ee,
            onKeyUp: he,
            className: ft(
              u,
              ve({}, "".concat(u, "-disabled"), d),
              C == null ? void 0 : C.input
            ),
            style: M == null ? void 0 : M.input,
            ref: G,
            size: p,
            type: S,
            onCompositionStart: function (Be) {
              (z.current = !0), T == null || T(Be);
            },
            onCompositionEnd: de,
          })
        );
      },
      fe = function () {
        var ce = Number(Ie) > 0;
        if (_ || ue.show) {
          var we = ue.showFormatter
            ? ue.showFormatter({ value: Z, count: te, maxLength: Ie })
            : "".concat(te).concat(ce ? " / ".concat(Ie) : "");
          return We.createElement(
            We.Fragment,
            null,
            ue.show &&
              We.createElement(
                "span",
                {
                  className: ft(
                    "".concat(u, "-show-count-suffix"),
                    ve({}, "".concat(u, "-show-count-has-suffix"), !!_),
                    C == null ? void 0 : C.count
                  ),
                  style: Fe({}, M == null ? void 0 : M.count),
                },
                we
              ),
            _
          );
        }
        return null;
      };
    return We.createElement(
      L4,
      Bt({}, R, {
        prefixCls: u,
        className: ft(m, k),
        handleReset: $,
        value: Z,
        focused: D,
        triggerFocus: U,
        suffix: fe(),
        disabled: d,
        classes: b,
        classNames: C,
        styles: M,
        ref: Y,
      }),
      J()
    );
  });
const N4 = (t) => {
  let e;
  return (
    typeof t == "object" && t != null && t.clearIcon
      ? (e = t)
      : t && (e = { clearIcon: We.createElement(XU, null) }),
    e
  );
};
function D4(t, e) {
  const n = L.useRef([]),
    r = () => {
      n.current.push(
        setTimeout(() => {
          var i, o, s, a;
          !((i = t.current) === null || i === void 0) &&
            i.input &&
            ((o = t.current) === null || o === void 0
              ? void 0
              : o.input.getAttribute("type")) === "password" &&
            !((s = t.current) === null || s === void 0) &&
            s.input.hasAttribute("value") &&
            ((a = t.current) === null ||
              a === void 0 ||
              a.input.removeAttribute("value"));
        })
      );
    };
  return (
    L.useEffect(
      () => (
        e && r(),
        () =>
          n.current.forEach((i) => {
            i && clearTimeout(i);
          })
      ),
      []
    ),
    r
  );
}
function Jte(t) {
  return !!(t.prefix || t.suffix || t.allowClear || t.showCount);
}
var Qte = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const lx = L.forwardRef((t, e) => {
  const {
      prefixCls: n,
      bordered: r = !0,
      status: i,
      size: o,
      disabled: s,
      onBlur: a,
      onFocus: l,
      suffix: c,
      allowClear: u,
      addonAfter: d,
      addonBefore: p,
      className: m,
      style: v,
      styles: _,
      rootClassName: y,
      onChange: g,
      classNames: x,
      variant: S,
    } = t,
    b = Qte(t, [
      "prefixCls",
      "bordered",
      "status",
      "size",
      "disabled",
      "onBlur",
      "onFocus",
      "suffix",
      "allowClear",
      "addonAfter",
      "addonBefore",
      "className",
      "style",
      "styles",
      "rootClassName",
      "onChange",
      "classNames",
      "variant",
    ]),
    {
      getPrefixCls: C,
      direction: M,
      allowClear: T,
      autoComplete: P,
      className: R,
      style: E,
      classNames: O,
      styles: D,
    } = qy("input"),
    N = C("input", n),
    z = L.useRef(null),
    V = jf(N),
    [G, Y, U] = R4(N, y),
    [j] = P4(N, V),
    { compactSize: W, compactItemClassnames: B } = Qy(N, M),
    q = Bc((_e) => {
      var $;
      return ($ = o ?? W) !== null && $ !== void 0 ? $ : _e;
    }),
    Z = We.useContext(rl),
    H = s ?? Z,
    { status: X, hasFeedback: ne, feedbackIcon: oe } = L.useContext(ys),
    ue = pM(X, i),
    Ie = Jte(t) || !!ne;
  L.useRef(Ie);
  const te = D4(z, !0),
    ge = (_e) => {
      te(), a == null || a(_e);
    },
    ie = (_e) => {
      te(), l == null || l(_e);
    },
    pe = (_e) => {
      te(), g == null || g(_e);
    },
    de = (ne || c) && We.createElement(We.Fragment, null, c, ne && oe),
    Ee = N4(u ?? T),
    [he, Ce] = x4("input", S, r);
  return G(
    j(
      We.createElement(
        Zte,
        Object.assign({ ref: kc(e, z), prefixCls: N, autoComplete: P }, b, {
          disabled: H,
          onBlur: ge,
          onFocus: ie,
          style: Object.assign(Object.assign({}, E), v),
          styles: Object.assign(Object.assign({}, D), _),
          suffix: de,
          allowClear: Ee,
          className: ft(m, y, U, V, B, R),
          onChange: pe,
          addonBefore: p && We.createElement(D3, { form: !0, space: !0 }, p),
          addonAfter: d && We.createElement(D3, { form: !0, space: !0 }, d),
          classNames: Object.assign(Object.assign(Object.assign({}, x), O), {
            input: ft(
              {
                [`${N}-sm`]: q === "small",
                [`${N}-lg`]: q === "large",
                [`${N}-rtl`]: M === "rtl",
              },
              x == null ? void 0 : x.input,
              O.input,
              Y
            ),
            variant: ft({ [`${N}-${he}`]: Ce }, Kb(N, ue)),
            affixWrapper: ft(
              {
                [`${N}-affix-wrapper-sm`]: q === "small",
                [`${N}-affix-wrapper-lg`]: q === "large",
                [`${N}-affix-wrapper-rtl`]: M === "rtl",
              },
              Y
            ),
            wrapper: ft({ [`${N}-group-rtl`]: M === "rtl" }, Y),
            groupWrapper: ft(
              {
                [`${N}-group-wrapper-sm`]: q === "small",
                [`${N}-group-wrapper-lg`]: q === "large",
                [`${N}-group-wrapper-rtl`]: M === "rtl",
                [`${N}-group-wrapper-${he}`]: Ce,
              },
              Kb(`${N}-group-wrapper`, ue, ne),
              Y
            ),
          }),
        })
      )
    )
  );
});
var ene = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z",
          },
        },
      ],
    },
    name: "eye",
    theme: "outlined",
  },
  tne = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: ene }));
  },
  nne = L.forwardRef(tne);
const rne = (t) => {
    const { getPrefixCls: e, direction: n } = L.useContext(Sn),
      { prefixCls: r, className: i } = t,
      o = e("input-group", r),
      s = e("input"),
      [a, l, c] = P4(s),
      u = ft(
        o,
        c,
        {
          [`${o}-lg`]: t.size === "large",
          [`${o}-sm`]: t.size === "small",
          [`${o}-compact`]: t.compact,
          [`${o}-rtl`]: n === "rtl",
        },
        l,
        i
      ),
      d = L.useContext(ys),
      p = L.useMemo(
        () => Object.assign(Object.assign({}, d), { isFormItemInput: !1 }),
        [d]
      );
    return a(
      L.createElement(
        "span",
        {
          className: u,
          style: t.style,
          onMouseEnter: t.onMouseEnter,
          onMouseLeave: t.onMouseLeave,
          onFocus: t.onFocus,
          onBlur: t.onBlur,
        },
        L.createElement(ys.Provider, { value: p }, t.children)
      )
    );
  },
  ine = (t) => {
    const { componentCls: e, paddingXS: n } = t;
    return {
      [e]: {
        display: "inline-flex",
        alignItems: "center",
        flexWrap: "nowrap",
        columnGap: n,
        [`${e}-input-wrapper`]: {
          position: "relative",
          [`${e}-mask-icon`]: {
            position: "absolute",
            zIndex: "1",
            top: "50%",
            right: "50%",
            transform: "translate(50%, -50%)",
            pointerEvents: "none",
          },
          [`${e}-mask-input`]: {
            color: "transparent",
            caretColor: t.colorText,
          },
          [`${e}-mask-input[type=number]::-webkit-inner-spin-button`]: {
            "-webkit-appearance": "none",
            margin: 0,
          },
          [`${e}-mask-input[type=number]`]: { "-moz-appearance": "textfield" },
        },
        "&-rtl": { direction: "rtl" },
        [`${e}-input`]: { textAlign: "center", paddingInline: t.paddingXXS },
        [`&${e}-sm ${e}-input`]: {
          paddingInline: t.calc(t.paddingXXS).div(2).equal(),
        },
        [`&${e}-lg ${e}-input`]: { paddingInline: t.paddingXS },
      },
    };
  },
  one = dl(
    ["Input", "OTP"],
    (t) => {
      const e = di(t, sx(t));
      return ine(e);
    },
    ax
  );
var sne = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const ane = L.forwardRef((t, e) => {
  const {
      className: n,
      value: r,
      onChange: i,
      onActiveChange: o,
      index: s,
      mask: a,
    } = t,
    l = sne(t, [
      "className",
      "value",
      "onChange",
      "onActiveChange",
      "index",
      "mask",
    ]),
    { getPrefixCls: c } = L.useContext(Sn),
    u = c("otp"),
    d = typeof a == "string" ? a : r,
    p = L.useRef(null);
  L.useImperativeHandle(e, () => p.current);
  const m = (g) => {
      i(s, g.target.value);
    },
    v = () => {
      Ao(() => {
        var g;
        const x = (g = p.current) === null || g === void 0 ? void 0 : g.input;
        document.activeElement === x && x && x.select();
      });
    },
    _ = (g) => {
      const { key: x, ctrlKey: S, metaKey: b } = g;
      x === "ArrowLeft"
        ? o(s - 1)
        : x === "ArrowRight"
        ? o(s + 1)
        : x === "z" && (S || b) && g.preventDefault(),
        v();
    },
    y = (g) => {
      g.key === "Backspace" && !r && o(s - 1), v();
    };
  return L.createElement(
    "span",
    { className: `${u}-input-wrapper`, role: "presentation" },
    a &&
      r !== "" &&
      r !== void 0 &&
      L.createElement(
        "span",
        { className: `${u}-mask-icon`, "aria-hidden": "true" },
        d
      ),
    L.createElement(
      lx,
      Object.assign(
        {
          "aria-label": `OTP Input ${s + 1}`,
          type: a === !0 ? "password" : "text",
        },
        l,
        {
          ref: p,
          value: r,
          onInput: m,
          onFocus: v,
          onKeyDown: _,
          onKeyUp: y,
          onMouseDown: v,
          onMouseUp: v,
          className: ft(n, { [`${u}-mask-input`]: a }),
        }
      )
    )
  );
});
var lne = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
function u0(t) {
  return (t || "").split("");
}
const cne = (t) => {
    const { index: e, prefixCls: n, separator: r } = t,
      i = typeof r == "function" ? r(e) : r;
    return i
      ? L.createElement("span", { className: `${n}-separator` }, i)
      : null;
  },
  une = L.forwardRef((t, e) => {
    const {
        prefixCls: n,
        length: r = 6,
        size: i,
        defaultValue: o,
        value: s,
        onChange: a,
        formatter: l,
        separator: c,
        variant: u,
        disabled: d,
        status: p,
        autoFocus: m,
        mask: v,
        type: _,
        onInput: y,
        inputMode: g,
      } = t,
      x = lne(t, [
        "prefixCls",
        "length",
        "size",
        "defaultValue",
        "value",
        "onChange",
        "formatter",
        "separator",
        "variant",
        "disabled",
        "status",
        "autoFocus",
        "mask",
        "type",
        "onInput",
        "inputMode",
      ]),
      { getPrefixCls: S, direction: b } = L.useContext(Sn),
      C = S("otp", n),
      M = Zy(x, { aria: !0, data: !0, attr: !0 }),
      [T, P, R] = one(C),
      E = Bc((H) => i ?? H),
      O = L.useContext(ys),
      D = pM(O.status, p),
      N = L.useMemo(
        () =>
          Object.assign(Object.assign({}, O), {
            status: D,
            hasFeedback: !1,
            feedbackIcon: null,
          }),
        [O, D]
      ),
      z = L.useRef(null),
      V = L.useRef({});
    L.useImperativeHandle(e, () => ({
      focus: () => {
        var H;
        (H = V.current[0]) === null || H === void 0 || H.focus();
      },
      blur: () => {
        var H;
        for (let X = 0; X < r; X += 1)
          (H = V.current[X]) === null || H === void 0 || H.blur();
      },
      nativeElement: z.current,
    }));
    const G = (H) => (l ? l(H) : H),
      [Y, U] = L.useState(() => u0(G(o || "")));
    L.useEffect(() => {
      s !== void 0 && U(u0(s));
    }, [s]);
    const j = na((H) => {
        U(H),
          y && y(H),
          a &&
            H.length === r &&
            H.every((X) => X) &&
            H.some((X, ne) => Y[ne] !== X) &&
            a(H.join(""));
      }),
      W = na((H, X) => {
        let ne = yt(Y);
        for (let ue = 0; ue < H; ue += 1) ne[ue] || (ne[ue] = "");
        X.length <= 1 ? (ne[H] = X) : (ne = ne.slice(0, H).concat(u0(X))),
          (ne = ne.slice(0, r));
        for (let ue = ne.length - 1; ue >= 0 && !ne[ue]; ue -= 1) ne.pop();
        const oe = G(ne.map((ue) => ue || " ").join(""));
        return (
          (ne = u0(oe).map((ue, Ie) => (ue === " " && !ne[Ie] ? ne[Ie] : ue))),
          ne
        );
      }),
      B = (H, X) => {
        var ne;
        const oe = W(H, X),
          ue = Math.min(H + X.length, r - 1);
        ue !== H &&
          oe[H] !== void 0 &&
          ((ne = V.current[ue]) === null || ne === void 0 || ne.focus()),
          j(oe);
      },
      q = (H) => {
        var X;
        (X = V.current[H]) === null || X === void 0 || X.focus();
      },
      Z = {
        variant: u,
        disabled: d,
        status: D,
        mask: v,
        type: _,
        inputMode: g,
      };
    return T(
      L.createElement(
        "div",
        Object.assign({}, M, {
          ref: z,
          className: ft(
            C,
            {
              [`${C}-sm`]: E === "small",
              [`${C}-lg`]: E === "large",
              [`${C}-rtl`]: b === "rtl",
            },
            R,
            P
          ),
          role: "group",
        }),
        L.createElement(
          ys.Provider,
          { value: N },
          Array.from({ length: r }).map((H, X) => {
            const ne = `otp-${X}`,
              oe = Y[X] || "";
            return L.createElement(
              L.Fragment,
              { key: ne },
              L.createElement(
                ane,
                Object.assign(
                  {
                    ref: (ue) => {
                      V.current[X] = ue;
                    },
                    index: X,
                    size: E,
                    htmlSize: 1,
                    className: `${C}-input`,
                    onChange: B,
                    value: oe,
                    onActiveChange: q,
                    autoFocus: X === 0 && m,
                  },
                  Z
                )
              ),
              X < r - 1 &&
                L.createElement(cne, { separator: c, index: X, prefixCls: C })
            );
          })
        )
      )
    );
  });
var fne = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z",
          },
        },
        {
          tag: "path",
          attrs: {
            d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z",
          },
        },
      ],
    },
    name: "eye-invisible",
    theme: "outlined",
  },
  dne = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: fne }));
  },
  hne = L.forwardRef(dne),
  pne = function (t, e) {
    var n = {};
    for (var r in t)
      Object.prototype.hasOwnProperty.call(t, r) &&
        e.indexOf(r) < 0 &&
        (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
          (n[r[i]] = t[r[i]]);
    return n;
  };
const mne = (t) =>
    t ? L.createElement(nne, null) : L.createElement(hne, null),
  gne = { click: "onClick", hover: "onMouseOver" },
  vne = L.forwardRef((t, e) => {
    const {
        disabled: n,
        action: r = "click",
        visibilityToggle: i = !0,
        iconRender: o = mne,
        suffix: s,
      } = t,
      a = L.useContext(rl),
      l = n ?? a,
      c = typeof i == "object" && i.visible !== void 0,
      [u, d] = L.useState(() => (c ? i.visible : !1)),
      p = L.useRef(null);
    L.useEffect(() => {
      c && d(i.visible);
    }, [c, i]);
    const m = D4(p),
      v = () => {
        var O;
        if (l) return;
        u && m();
        const D = !u;
        d(D),
          typeof i == "object" &&
            ((O = i.onVisibleChange) === null || O === void 0 || O.call(i, D));
      },
      _ = (O) => {
        const D = gne[r] || "",
          N = o(u),
          z = {
            [D]: v,
            className: `${O}-icon`,
            key: "passwordIcon",
            onMouseDown: (V) => {
              V.preventDefault();
            },
            onMouseUp: (V) => {
              V.preventDefault();
            },
          };
        return L.cloneElement(
          L.isValidElement(N) ? N : L.createElement("span", null, N),
          z
        );
      },
      { className: y, prefixCls: g, inputPrefixCls: x, size: S } = t,
      b = pne(t, ["className", "prefixCls", "inputPrefixCls", "size"]),
      { getPrefixCls: C } = L.useContext(Sn),
      M = C("input", x),
      T = C("input-password", g),
      P = i && _(T),
      R = ft(T, y, { [`${T}-${S}`]: !!S }),
      E = Object.assign(
        Object.assign({}, vp(b, ["suffix", "iconRender", "visibilityToggle"])),
        {
          type: u ? "text" : "password",
          className: R,
          prefixCls: M,
          suffix: L.createElement(L.Fragment, null, P, s),
        }
      );
    return (
      S && (E.size = S),
      L.createElement(lx, Object.assign({ ref: kc(e, p) }, E))
    );
  });
var yne = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const xne = L.forwardRef((t, e) => {
  const {
      prefixCls: n,
      inputPrefixCls: r,
      className: i,
      size: o,
      suffix: s,
      enterButton: a = !1,
      addonAfter: l,
      loading: c,
      disabled: u,
      onSearch: d,
      onChange: p,
      onCompositionStart: m,
      onCompositionEnd: v,
      variant: _,
      onPressEnter: y,
    } = t,
    g = yne(t, [
      "prefixCls",
      "inputPrefixCls",
      "className",
      "size",
      "suffix",
      "enterButton",
      "addonAfter",
      "loading",
      "disabled",
      "onSearch",
      "onChange",
      "onCompositionStart",
      "onCompositionEnd",
      "variant",
      "onPressEnter",
    ]),
    { getPrefixCls: x, direction: S } = L.useContext(Sn),
    b = L.useRef(!1),
    C = x("input-search", n),
    M = x("input", r),
    { compactSize: T } = Qy(C, S),
    P = Bc((Z) => {
      var H;
      return (H = o ?? T) !== null && H !== void 0 ? H : Z;
    }),
    R = L.useRef(null),
    E = (Z) => {
      Z != null &&
        Z.target &&
        Z.type === "click" &&
        d &&
        d(Z.target.value, Z, { source: "clear" }),
        p == null || p(Z);
    },
    O = (Z) => {
      var H;
      document.activeElement ===
        ((H = R.current) === null || H === void 0 ? void 0 : H.input) &&
        Z.preventDefault();
    },
    D = (Z) => {
      var H, X;
      d &&
        d(
          (X = (H = R.current) === null || H === void 0 ? void 0 : H.input) ===
            null || X === void 0
            ? void 0
            : X.value,
          Z,
          { source: "input" }
        );
    },
    N = (Z) => {
      b.current || c || (y == null || y(Z), D(Z));
    },
    z = typeof a == "boolean" ? L.createElement(hte, null) : null,
    V = `${C}-button`;
  let G;
  const Y = a || {},
    U = Y.type && Y.type.__ANT_BUTTON === !0;
  U || Y.type === "button"
    ? (G = Rf(
        Y,
        Object.assign(
          {
            onMouseDown: O,
            onClick: (Z) => {
              var H, X;
              (X =
                (H = Y == null ? void 0 : Y.props) === null || H === void 0
                  ? void 0
                  : H.onClick) === null ||
                X === void 0 ||
                X.call(H, Z),
                D(Z);
            },
            key: "enterButton",
          },
          U ? { className: V, size: P } : {}
        )
      ))
    : (G = L.createElement(
        ca,
        {
          className: V,
          color: a ? "primary" : "default",
          size: P,
          disabled: u,
          key: "enterButton",
          onMouseDown: O,
          onClick: D,
          loading: c,
          icon: z,
          variant:
            _ === "borderless" || _ === "filled" || _ === "underlined"
              ? "text"
              : a
              ? "solid"
              : void 0,
        },
        a
      )),
    l && (G = [G, Rf(l, { key: "addonAfter" })]);
  const j = ft(
      C,
      {
        [`${C}-rtl`]: S === "rtl",
        [`${C}-${P}`]: !!P,
        [`${C}-with-button`]: !!a,
      },
      i
    ),
    W = (Z) => {
      (b.current = !0), m == null || m(Z);
    },
    B = (Z) => {
      (b.current = !1), v == null || v(Z);
    },
    q = Object.assign(Object.assign({}, g), {
      className: j,
      prefixCls: M,
      type: "search",
      size: P,
      variant: _,
      onPressEnter: N,
      onCompositionStart: W,
      onCompositionEnd: B,
      addonAfter: G,
      suffix: s,
      onChange: E,
      disabled: u,
    });
  return L.createElement(lx, Object.assign({ ref: kc(R, e) }, q));
});
var _ne = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`,
  Sne = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "font-variant",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
    "word-break",
    "white-space",
  ],
  tS = {},
  Hi;
function Ane(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n =
      t.getAttribute("id") ||
      t.getAttribute("data-reactid") ||
      t.getAttribute("name");
  if (e && tS[n]) return tS[n];
  var r = window.getComputedStyle(t),
    i =
      r.getPropertyValue("box-sizing") ||
      r.getPropertyValue("-moz-box-sizing") ||
      r.getPropertyValue("-webkit-box-sizing"),
    o =
      parseFloat(r.getPropertyValue("padding-bottom")) +
      parseFloat(r.getPropertyValue("padding-top")),
    s =
      parseFloat(r.getPropertyValue("border-bottom-width")) +
      parseFloat(r.getPropertyValue("border-top-width")),
    a = Sne.map(function (c) {
      return "".concat(c, ":").concat(r.getPropertyValue(c));
    }).join(";"),
    l = { sizingStyle: a, paddingSize: o, borderSize: s, boxSizing: i };
  return e && n && (tS[n] = l), l;
}
function bne(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
    r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Hi ||
    ((Hi = document.createElement("textarea")),
    Hi.setAttribute("tab-index", "-1"),
    Hi.setAttribute("aria-hidden", "true"),
    Hi.setAttribute("name", "hiddenTextarea"),
    document.body.appendChild(Hi)),
    t.getAttribute("wrap")
      ? Hi.setAttribute("wrap", t.getAttribute("wrap"))
      : Hi.removeAttribute("wrap");
  var i = Ane(t, e),
    o = i.paddingSize,
    s = i.borderSize,
    a = i.boxSizing,
    l = i.sizingStyle;
  Hi.setAttribute("style", "".concat(l, ";").concat(_ne)),
    (Hi.value = t.value || t.placeholder || "");
  var c = void 0,
    u = void 0,
    d,
    p = Hi.scrollHeight;
  if (
    (a === "border-box" ? (p += s) : a === "content-box" && (p -= o),
    n !== null || r !== null)
  ) {
    Hi.value = " ";
    var m = Hi.scrollHeight - o;
    n !== null &&
      ((c = m * n),
      a === "border-box" && (c = c + o + s),
      (p = Math.max(c, p))),
      r !== null &&
        ((u = m * r),
        a === "border-box" && (u = u + o + s),
        (d = p > u ? "" : "hidden"),
        (p = Math.min(u, p)));
  }
  var v = { height: p, overflowY: d, resize: "none" };
  return c && (v.minHeight = c), u && (v.maxHeight = u), v;
}
var wne = [
    "prefixCls",
    "defaultValue",
    "value",
    "autoSize",
    "onResize",
    "className",
    "style",
    "disabled",
    "onChange",
    "onInternalAutoSize",
  ],
  nS = 0,
  rS = 1,
  iS = 2,
  Ene = L.forwardRef(function (t, e) {
    var n = t,
      r = n.prefixCls,
      i = n.defaultValue,
      o = n.value,
      s = n.autoSize,
      a = n.onResize,
      l = n.className,
      c = n.style,
      u = n.disabled,
      d = n.onChange;
    n.onInternalAutoSize;
    var p = sr(n, wne),
      m = Hf(i, {
        value: o,
        postState: function (Z) {
          return Z ?? "";
        },
      }),
      v = ot(m, 2),
      _ = v[0],
      y = v[1],
      g = function (Z) {
        y(Z.target.value), d == null || d(Z);
      },
      x = L.useRef();
    L.useImperativeHandle(e, function () {
      return { textArea: x.current };
    });
    var S = L.useMemo(
        function () {
          return s && bt(s) === "object" ? [s.minRows, s.maxRows] : [];
        },
        [s]
      ),
      b = ot(S, 2),
      C = b[0],
      M = b[1],
      T = !!s,
      P = L.useState(iS),
      R = ot(P, 2),
      E = R[0],
      O = R[1],
      D = L.useState(),
      N = ot(D, 2),
      z = N[0],
      V = N[1],
      G = function () {
        O(nS);
      };
    fp(
      function () {
        T && G();
      },
      [o, C, M, T]
    ),
      fp(
        function () {
          if (E === nS) O(rS);
          else if (E === rS) {
            var q = bne(x.current, !1, C, M);
            O(iS), V(q);
          }
        },
        [E]
      );
    var Y = L.useRef(),
      U = function () {
        Ao.cancel(Y.current);
      },
      j = function (Z) {
        E === iS &&
          (a == null || a(Z),
          s &&
            (U(),
            (Y.current = Ao(function () {
              G();
            }))));
      };
    L.useEffect(function () {
      return U;
    }, []);
    var W = T ? z : null,
      B = Fe(Fe({}, c), W);
    return (
      (E === nS || E === rS) &&
        ((B.overflowY = "hidden"), (B.overflowX = "hidden")),
      L.createElement(
        GF,
        { onResize: j, disabled: !(s || a) },
        L.createElement(
          "textarea",
          Bt({}, p, {
            ref: x,
            style: B,
            className: ft(r, l, ve({}, "".concat(r, "-disabled"), u)),
            disabled: u,
            value: _,
            onChange: g,
          })
        )
      )
    );
  }),
  Mne = [
    "defaultValue",
    "value",
    "onFocus",
    "onBlur",
    "onChange",
    "allowClear",
    "maxLength",
    "onCompositionStart",
    "onCompositionEnd",
    "suffix",
    "prefixCls",
    "showCount",
    "count",
    "className",
    "style",
    "disabled",
    "hidden",
    "classNames",
    "styles",
    "onResize",
    "onClear",
    "onPressEnter",
    "readOnly",
    "autoSize",
    "onKeyDown",
  ],
  Cne = We.forwardRef(function (t, e) {
    var n,
      r = t.defaultValue,
      i = t.value,
      o = t.onFocus,
      s = t.onBlur,
      a = t.onChange,
      l = t.allowClear,
      c = t.maxLength,
      u = t.onCompositionStart,
      d = t.onCompositionEnd,
      p = t.suffix,
      m = t.prefixCls,
      v = m === void 0 ? "rc-textarea" : m,
      _ = t.showCount,
      y = t.count,
      g = t.className,
      x = t.style,
      S = t.disabled,
      b = t.hidden,
      C = t.classNames,
      M = t.styles,
      T = t.onResize,
      P = t.onClear,
      R = t.onPressEnter,
      E = t.readOnly,
      O = t.autoSize,
      D = t.onKeyDown,
      N = sr(t, Mne),
      z = Hf(r, { value: i, defaultValue: r }),
      V = ot(z, 2),
      G = V[0],
      Y = V[1],
      U = G == null ? "" : String(G),
      j = We.useState(!1),
      W = ot(j, 2),
      B = W[0],
      q = W[1],
      Z = We.useRef(!1),
      H = We.useState(null),
      X = ot(H, 2),
      ne = X[0],
      oe = X[1],
      ue = L.useRef(null),
      Ie = L.useRef(null),
      te = function () {
        var ze;
        return (ze = Ie.current) === null || ze === void 0
          ? void 0
          : ze.textArea;
      },
      ge = function () {
        te().focus();
      };
    L.useImperativeHandle(e, function () {
      var De;
      return {
        resizableTextArea: Ie.current,
        focus: ge,
        blur: function () {
          te().blur();
        },
        nativeElement:
          ((De = ue.current) === null || De === void 0
            ? void 0
            : De.nativeElement) || te(),
      };
    }),
      L.useEffect(
        function () {
          q(function (De) {
            return !S && De;
          });
        },
        [S]
      );
    var ie = We.useState(null),
      pe = ot(ie, 2),
      de = pe[0],
      Ee = pe[1];
    We.useEffect(
      function () {
        if (de) {
          var De;
          (De = te()).setSelectionRange.apply(De, yt(de));
        }
      },
      [de]
    );
    var he = O4(y, _),
      Ce = (n = he.max) !== null && n !== void 0 ? n : c,
      _e = Number(Ce) > 0,
      $ = he.strategy(U),
      k = !!Ce && $ > Ce,
      J = function (ze, Ve) {
        var ae = Ve;
        !Z.current &&
          he.exceedFormatter &&
          he.max &&
          he.strategy(Ve) > he.max &&
          ((ae = he.exceedFormatter(Ve, { max: he.max })),
          Ve !== ae && Ee([te().selectionStart || 0, te().selectionEnd || 0])),
          Y(ae),
          Nv(ze.currentTarget, ze, a, ae);
      },
      fe = function (ze) {
        (Z.current = !0), u == null || u(ze);
      },
      le = function (ze) {
        (Z.current = !1), J(ze, ze.currentTarget.value), d == null || d(ze);
      },
      ce = function (ze) {
        J(ze, ze.target.value);
      },
      we = function (ze) {
        ze.key === "Enter" && R && R(ze), D == null || D(ze);
      },
      Be = function (ze) {
        q(!0), o == null || o(ze);
      },
      Me = function (ze) {
        q(!1), s == null || s(ze);
      },
      Ge = function (ze) {
        Y(""), ge(), Nv(te(), ze, a);
      },
      Le = p,
      je;
    he.show &&
      (he.showFormatter
        ? (je = he.showFormatter({ value: U, count: $, maxLength: Ce }))
        : (je = "".concat($).concat(_e ? " / ".concat(Ce) : "")),
      (Le = We.createElement(
        We.Fragment,
        null,
        Le,
        We.createElement(
          "span",
          {
            className: ft(
              "".concat(v, "-data-count"),
              C == null ? void 0 : C.count
            ),
            style: M == null ? void 0 : M.count,
          },
          je
        )
      )));
    var Je = function (ze) {
        var Ve;
        T == null || T(ze),
          (Ve = te()) !== null && Ve !== void 0 && Ve.style.height && oe(!0);
      },
      Ye = !O && !_ && !l;
    return We.createElement(
      L4,
      {
        ref: ue,
        value: U,
        allowClear: l,
        handleReset: Ge,
        suffix: Le,
        prefixCls: v,
        classNames: Fe(
          Fe({}, C),
          {},
          {
            affixWrapper: ft(
              C == null ? void 0 : C.affixWrapper,
              ve(
                ve({}, "".concat(v, "-show-count"), _),
                "".concat(v, "-textarea-allow-clear"),
                l
              )
            ),
          }
        ),
        disabled: S,
        focused: B,
        className: ft(g, k && "".concat(v, "-out-of-range")),
        style: Fe(Fe({}, x), ne && !Ye ? { height: "auto" } : {}),
        dataAttrs: {
          affixWrapper: { "data-count": typeof je == "string" ? je : void 0 },
        },
        hidden: b,
        readOnly: E,
        onClear: P,
      },
      We.createElement(
        Ene,
        Bt({}, N, {
          autoSize: O,
          maxLength: c,
          onKeyDown: we,
          onChange: ce,
          onFocus: Be,
          onBlur: Me,
          onCompositionStart: fe,
          onCompositionEnd: le,
          className: ft(C == null ? void 0 : C.textarea),
          style: Fe(
            Fe({}, M == null ? void 0 : M.textarea),
            {},
            { resize: x == null ? void 0 : x.resize }
          ),
          disabled: S,
          prefixCls: v,
          onResize: Je,
          ref: Ie,
          readOnly: E,
        })
      )
    );
  });
const Tne = (t) => {
    const { componentCls: e, paddingLG: n } = t,
      r = `${e}-textarea`;
    return {
      [`textarea${e}`]: {
        maxWidth: "100%",
        height: "auto",
        minHeight: t.controlHeight,
        lineHeight: t.lineHeight,
        verticalAlign: "bottom",
        transition: `all ${t.motionDurationSlow}`,
        resize: "vertical",
        [`&${e}-mouse-active`]: {
          transition: `all ${t.motionDurationSlow}, height 0s, width 0s`,
        },
      },
      [`${e}-textarea-affix-wrapper-resize-dirty`]: { width: "auto" },
      [r]: {
        position: "relative",
        "&-show-count": {
          [`${e}-data-count`]: {
            position: "absolute",
            bottom: t.calc(t.fontSize).mul(t.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: t.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none",
          },
        },
        [`
        &-allow-clear > ${e},
        &-affix-wrapper${r}-has-feedback ${e}
      `]: { paddingInlineEnd: n },
        [`&-affix-wrapper${e}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${e}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            background: "transparent",
            minHeight: t
              .calc(t.controlHeight)
              .sub(t.calc(t.lineWidth).mul(2))
              .equal(),
            "&:focus": { boxShadow: "none !important" },
          },
          [`${e}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": { marginInline: 0 },
            [`${e}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: t.paddingInline,
              insetBlockStart: t.paddingXS,
            },
            [`${r}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: t.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none",
            },
          },
        },
        [`&-affix-wrapper${e}-affix-wrapper-rtl`]: {
          [`${e}-suffix`]: {
            [`${e}-data-count`]: { direction: "ltr", insetInlineStart: 0 },
          },
        },
        [`&-affix-wrapper${e}-affix-wrapper-sm`]: {
          [`${e}-suffix`]: {
            [`${e}-clear-icon`]: { insetInlineEnd: t.paddingInlineSM },
          },
        },
      },
    };
  },
  Rne = dl(
    ["Input", "TextArea"],
    (t) => {
      const e = di(t, sx(t));
      return Tne(e);
    },
    ax,
    { resetFont: !1 }
  );
var Pne = function (t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) &&
      e.indexOf(r) < 0 &&
      (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, r[i]) &&
        (n[r[i]] = t[r[i]]);
  return n;
};
const Ine = L.forwardRef((t, e) => {
    var n;
    const {
        prefixCls: r,
        bordered: i = !0,
        size: o,
        disabled: s,
        status: a,
        allowClear: l,
        classNames: c,
        rootClassName: u,
        className: d,
        style: p,
        styles: m,
        variant: v,
        showCount: _,
        onMouseDown: y,
        onResize: g,
      } = t,
      x = Pne(t, [
        "prefixCls",
        "bordered",
        "size",
        "disabled",
        "status",
        "allowClear",
        "classNames",
        "rootClassName",
        "className",
        "style",
        "styles",
        "variant",
        "showCount",
        "onMouseDown",
        "onResize",
      ]),
      {
        getPrefixCls: S,
        direction: b,
        allowClear: C,
        autoComplete: M,
        className: T,
        style: P,
        classNames: R,
        styles: E,
      } = qy("textArea"),
      O = L.useContext(rl),
      D = s ?? O,
      { status: N, hasFeedback: z, feedbackIcon: V } = L.useContext(ys),
      G = pM(N, a),
      Y = L.useRef(null);
    L.useImperativeHandle(e, () => {
      var he;
      return {
        resizableTextArea:
          (he = Y.current) === null || he === void 0
            ? void 0
            : he.resizableTextArea,
        focus: (Ce) => {
          var _e, $;
          I4(
            ($ =
              (_e = Y.current) === null || _e === void 0
                ? void 0
                : _e.resizableTextArea) === null || $ === void 0
              ? void 0
              : $.textArea,
            Ce
          );
        },
        blur: () => {
          var Ce;
          return (Ce = Y.current) === null || Ce === void 0
            ? void 0
            : Ce.blur();
        },
      };
    });
    const U = S("input", r),
      j = jf(U),
      [W, B, q] = R4(U, u),
      [Z] = Rne(U, j),
      { compactSize: H, compactItemClassnames: X } = Qy(U, b),
      ne = Bc((he) => {
        var Ce;
        return (Ce = o ?? H) !== null && Ce !== void 0 ? Ce : he;
      }),
      [oe, ue] = x4("textArea", v, i),
      Ie = N4(l ?? C),
      [te, ge] = L.useState(!1),
      [ie, pe] = L.useState(!1),
      de = (he) => {
        ge(!0), y == null || y(he);
        const Ce = () => {
          ge(!1), document.removeEventListener("mouseup", Ce);
        };
        document.addEventListener("mouseup", Ce);
      },
      Ee = (he) => {
        var Ce, _e;
        if ((g == null || g(he), te && typeof getComputedStyle == "function")) {
          const $ =
            (_e =
              (Ce = Y.current) === null || Ce === void 0
                ? void 0
                : Ce.nativeElement) === null || _e === void 0
              ? void 0
              : _e.querySelector("textarea");
          $ && getComputedStyle($).resize === "both" && pe(!0);
        }
      };
    return W(
      Z(
        L.createElement(
          Cne,
          Object.assign({ autoComplete: M }, x, {
            style: Object.assign(Object.assign({}, P), p),
            styles: Object.assign(Object.assign({}, E), m),
            disabled: D,
            allowClear: Ie,
            className: ft(
              q,
              j,
              d,
              u,
              X,
              T,
              ie && `${U}-textarea-affix-wrapper-resize-dirty`
            ),
            classNames: Object.assign(Object.assign(Object.assign({}, c), R), {
              textarea: ft(
                { [`${U}-sm`]: ne === "small", [`${U}-lg`]: ne === "large" },
                B,
                c == null ? void 0 : c.textarea,
                R.textarea,
                te && `${U}-mouse-active`
              ),
              variant: ft({ [`${U}-${oe}`]: ue }, Kb(U, G)),
              affixWrapper: ft(
                `${U}-textarea-affix-wrapper`,
                {
                  [`${U}-affix-wrapper-rtl`]: b === "rtl",
                  [`${U}-affix-wrapper-sm`]: ne === "small",
                  [`${U}-affix-wrapper-lg`]: ne === "large",
                  [`${U}-textarea-show-count`]:
                    _ ||
                    ((n = t.count) === null || n === void 0 ? void 0 : n.show),
                },
                B
              ),
            }),
            prefixCls: U,
            suffix:
              z &&
              L.createElement("span", { className: `${U}-textarea-suffix` }, V),
            showCount: _,
            ref: Y,
            onResize: Ee,
            onMouseDown: de,
          })
        )
      )
    );
  }),
  $f = lx;
$f.Group = rne;
$f.Search = xne;
$f.TextArea = Ine;
$f.Password = vne;
$f.OTP = une;
let uo = null,
  ac = (t) => t(),
  _p = [],
  Sp = {};
function V3() {
  const { getContainer: t, duration: e, rtl: n, maxCount: r, top: i } = Sp,
    o = (t == null ? void 0 : t()) || document.body;
  return { getContainer: () => o, duration: e, rtl: n, maxCount: r, top: i };
}
const Lne = We.forwardRef((t, e) => {
    const { messageConfig: n, sync: r } = t,
      { getPrefixCls: i } = L.useContext(Sn),
      o = Sp.prefixCls || i("message"),
      s = L.useContext(ute),
      [a, l] = QU(
        Object.assign(
          Object.assign(Object.assign({}, n), { prefixCls: o }),
          s.message
        )
      );
    return (
      We.useImperativeHandle(e, () => {
        const c = Object.assign({}, a);
        return (
          Object.keys(c).forEach((u) => {
            c[u] = (...d) => (r(), a[u].apply(a, d));
          }),
          { instance: c, sync: r }
        );
      }),
      l
    );
  }),
  One = We.forwardRef((t, e) => {
    const [n, r] = We.useState(V3),
      i = () => {
        r(V3);
      };
    We.useEffect(i, []);
    const o = CZ(),
      s = o.getRootPrefixCls(),
      a = o.getIconPrefixCls(),
      l = o.getTheme(),
      c = We.createElement(Lne, { ref: e, sync: i, messageConfig: n });
    return We.createElement(
      Gf,
      { prefixCls: s, iconPrefixCls: a, theme: l },
      o.holderRender ? o.holderRender(c) : c
    );
  }),
  cx = () => {
    if (!uo) {
      const t = document.createDocumentFragment(),
        e = { fragment: t };
      (uo = e),
        ac(() => {
          n4()(
            We.createElement(One, {
              ref: (r) => {
                const { instance: i, sync: o } = r || {};
                Promise.resolve().then(() => {
                  !e.instance && i && ((e.instance = i), (e.sync = o), cx());
                });
              },
            }),
            t
          );
        });
      return;
    }
    uo.instance &&
      (_p.forEach((t) => {
        const { type: e, skipped: n } = t;
        if (!n)
          switch (e) {
            case "open": {
              ac(() => {
                const r = uo.instance.open(
                  Object.assign(Object.assign({}, Sp), t.config)
                );
                r == null || r.then(t.resolve), t.setCloseFn(r);
              });
              break;
            }
            case "destroy":
              ac(() => {
                uo == null || uo.instance.destroy(t.key);
              });
              break;
            default:
              ac(() => {
                var r;
                const i = (r = uo.instance)[e].apply(r, yt(t.args));
                i == null || i.then(t.resolve), t.setCloseFn(i);
              });
          }
      }),
      (_p = []));
  };
function Nne(t) {
  (Sp = Object.assign(Object.assign({}, Sp), t)),
    ac(() => {
      var e;
      (e = uo == null ? void 0 : uo.sync) === null ||
        e === void 0 ||
        e.call(uo);
    });
}
function Dne(t) {
  const e = lM((n) => {
    let r;
    const i = {
      type: "open",
      config: t,
      resolve: n,
      setCloseFn: (o) => {
        r = o;
      },
    };
    return (
      _p.push(i),
      () => {
        r
          ? ac(() => {
              r();
            })
          : (i.skipped = !0);
      }
    );
  });
  return cx(), e;
}
function Fne(t, e) {
  const n = lM((r) => {
    let i;
    const o = {
      type: t,
      args: e,
      resolve: r,
      setCloseFn: (s) => {
        i = s;
      },
    };
    return (
      _p.push(o),
      () => {
        i
          ? ac(() => {
              i();
            })
          : (o.skipped = !0);
      }
    );
  });
  return cx(), n;
}
const Une = (t) => {
    _p.push({ type: "destroy", key: t }), cx();
  },
  kne = ["success", "info", "warning", "error", "loading"],
  zne = {
    open: Dne,
    destroy: Une,
    config: Nne,
    useMessage: OJ,
    _InternalPanelDoNotUseOrYouWillBeFired: EJ,
  },
  Xs = zne;
kne.forEach((t) => {
  Xs[t] = (...e) => Fne(t, e);
});
const F4 = ({ radioValue: t }) => {
  const { checkedValue: e } = Mi((o) => o.exp),
    n = $o(),
    r = L.useRef(null),
    i = (o) => {
      var s;
      n(AX()),
        n(vX((s = o == null ? void 0 : o.target) == null ? void 0 : s.value));
    };
  return Q.jsx(xp.Group, {
    defaultValue: e,
    ref: r,
    buttonStyle: "solid",
    onChange: i,
    style: { display: "flex", flexDirection: "column", alignItems: "center" },
    children: t.map((o) =>
      Q.jsx(
        xp.Button,
        {
          style: {
            backgroundColor: e === o.value ? "#0e2134" : "transparent",
            borderColor: "#0e2134",
            marginBottom: 8,
            width: "100%",
            maxWidth: "250px",
            textAlign: "center",
          },
          value: o.value,
          children: o.title,
        },
        o.id
      )
    ),
  });
};
F4.propTypes = { radioValue: La.arrayOf(La.object).isRequired };
const U4 = () => {
    const t = $o(),
      {
        openTaskManger: e,
        DumbFile: n,
        showDumb: r,
        checkedValue: i,
        instructionIncludes: o,
      } = Mi((a) => a.exp);
    L.useEffect(() => {}, [r]);
    const s = (a) => {
      switch (a) {
        case "create":
          t(wF(!0));
          break;
      }
    };
    return (
      L.useEffect(() => {
        r &&
          (t(
            Oa([
              "To preserve integrity of the files on the victim's PC we transfer the memorydump file to an Analyst machine.",
            ])
          ),
          t(wv(o[o.length - 1] + 1)),
          t(Vp(["2"])));
      }, [r, t]),
      Q.jsx("div", {
        children: Q.jsxs("div", {
          children: [
            i === "1"
              ? Q.jsx("h4", { children: "Create a Memory Dump File " })
              : Q.jsx("h4", { children: "Create a Memory Dump File" }),
            Q.jsx(ca, {
              onClick: () => s("create"),
              style: {
                background: n || r ? "grey" : "#0c2133",
                color: "white",
              },
              disabled: n || r,
              children: "MemoryDump tool",
            }),
            r &&
              Q.jsxs("h4", {
                style: { color: "green" },
                children: [
                  Q.jsx("mark", { children: "memory.dump " }),
                  " file created successfully.",
                ],
              }),
          ],
        }),
      })
    );
  },
  k4 = () => {
    const t = $o(),
      e = () => {
        t(EF(!0));
      },
      {
        isFileTransfered: n,
        step: r,
        instructionIncludes: i,
      } = Mi((o) => o.exp);
    return (
      L.useEffect(() => {
        r.includes("3") &&
          i.length < 4 &&
          (t(wv(i[i.length - 1] + 1)),
          t(
            Oa([
              "We use the imageinfo plugin from the Volatility framework to look out for various Operating system related  information. Copy the OS Profile string highlighted in Yellow.",
            ])
          ),
          t(wv(i[i.length - 1] + 1)),
          t(Vp(["3"])));
      }, [r, i]),
      Q.jsx("div", {
        children: Q.jsx("div", {
          children: Q.jsx(ca, {
            onClick: e,
            style: {
              background: n | r.includes("3") ? "grey" : "#04101bff",
              color: "white",
            },
            disabled: n,
            children: "Transfer File",
          }),
        }),
      })
    );
  },
  Bne = () => {
    const t = $o(),
      {
        dumbFileDetails: e,
        volitilitySteps: n,
        checkedValue: r,
        analyseStep: i,
        steps: o,
      } = Mi((p) => p.exp),
      { fileName: s, profileName: a, systemOffset: l, samOffset: c } = e;
    console.log(o);
    const u = (p) => {
        const { name: m, value: v } = p.target;
        t(MF({ ...e, [m]: v }));
      },
      d = () => {
        if ((console.log(n), n.includes("1"))) {
          if (s.toLowerCase() !== "memory.dump") {
            Xs.error("File name is incorrect");
            return;
          }
          t(gc("1"));
        }
        if (n.includes("2")) {
          if ((console.log("hi"), a.trim() !== "Win7SP1x64")) {
            Xs.error("Profile Name is incorrect");
            return;
          }
          t(gc("2"));
        }
        if (n.includes("3")) {
          if (
            l.trim() !== "0xfffff8a000022010" ||
            c.trim() !== "0xfffff8a0016a7420"
          ) {
            Xs.error("SAM or SYSTEM offset is incorrect");
            return;
          }
          t(gc("3"));
        }
      };
    return Q.jsxs("div", {
      children: [
        n.includes("1") &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", {
                  children: "1.Identify the memory profile using Volatility",
                }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 50,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  display: "flex",
                  flexWrap: "wrap",
                  minHeight: 80,
                },
                children: [
                  "Volatility -f imageinfo",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: s,
                    onChange: u,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "Enter the file name",
                    disabled: n.includes("2"),
                  }),
                  " ",
                ],
              }),
            ],
          }),
        n.includes("2") &&
          r === "1" &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", {
                  children: "2.List the Registery hive",
                }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "volatility -f",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: s,
                    onChange: u,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "hivelist ",
                  Q.jsx("br", {}),
                  " --profile=",
                  Q.jsx("input", {
                    name: "profileName",
                    value: a,
                    onChange: u,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "Enter the profile name t",
                    disabled: n.includes("3"),
                  }),
                ],
              }),
            ],
          }),
        n.includes("2") &&
          r === "2" &&
          Q.jsxs("div", {
            children: [
              Q.jsx("h4", {
                children:
                  "2.Check all file entries in the memory using filescan",
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "volatility -f",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: s,
                    onChange: u,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "hivelist ",
                  Q.jsx("br", {}),
                  " --profile=",
                  Q.jsx("input", {
                    name: "profileName",
                    value: a,
                    onChange: u,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: n.includes("3"),
                  }),
                ],
              }),
            ],
          }),
        n.includes("3") &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", { children: "3.Extract the hashes" }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  minHeight: 130,
                },
                children: [
                  "volatility -f",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: s,
                    onChange: u,
                    style: { width: 100 },
                    disabled: !0,
                    placeholder: "Enter the file name",
                  }),
                  " ",
                  Q.jsx("br", {}),
                  " --profile=",
                  Q.jsx("input", {
                    name: "profileName",
                    value: a,
                    onChange: u,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: !0,
                  }),
                  " ",
                  "hashdump ",
                  Q.jsx("br", {}),
                  " -y",
                  " ",
                  Q.jsx("input", {
                    name: "systemOffset",
                    value: l,
                    onChange: u,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "SYSTEM offset",
                    disabled: n.includes("4"),
                  }),
                  "-s",
                  " ",
                  Q.jsx("input", {
                    name: "samOffset",
                    value: c,
                    onChange: u,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    disabled: n.includes("4"),
                    placeholder: "SAM offset",
                  }),
                  " ",
                  Q.jsx("br", {}),
                ],
              }),
              i === "4" &&
                Q.jsxs("div", {
                  children: [
                    Q.jsx("h4", {
                      style: { textDecoration: "underline" },
                      children: "Hash Password:",
                    }),
                    Q.jsx("h4", {
                      style: { color: "green", fontSize: 12 },
                      children:
                        "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
                    }),
                  ],
                }),
            ],
          }),
        i !== "4" &&
          Q.jsx("div", {
            style: { display: "flex", justifyContent: "flex-end" },
            children: Q.jsx(ca, {
              onClick: d,
              style: { background: "#0c2133", color: "white" },
              children: "Run",
            }),
          }),
      ],
    });
  };
var Hne = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M168 504.2c1-43.7 10-86.1 26.9-126 17.3-41 42.1-77.7 73.7-109.4S337 212.3 378 195c42.4-17.9 87.4-27 133.9-27s91.5 9.1 133.8 27A341.5 341.5 0 01755 268.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.7 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c0-6.7-7.7-10.5-12.9-6.3l-56.4 44.1C765.8 155.1 646.2 92 511.8 92 282.7 92 96.3 275.6 92 503.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8zm756 7.8h-60c-4.4 0-7.9 3.5-8 7.8-1 43.7-10 86.1-26.9 126-17.3 41-42.1 77.8-73.7 109.4A342.45 342.45 0 01512.1 856a342.24 342.24 0 01-243.2-100.8c-9.9-9.9-19.2-20.4-27.8-31.4l60.2-47a8 8 0 00-3-14.1l-175.7-43c-5-1.2-9.9 2.6-9.9 7.7l-.7 181c0 6.7 7.7 10.5 12.9 6.3l56.4-44.1C258.2 868.9 377.8 932 512.2 932c229.2 0 415.5-183.7 419.8-411.8a8 8 0 00-8-8.2z",
          },
        },
      ],
    },
    name: "sync",
    theme: "outlined",
  },
  Vne = function (e, n) {
    return L.createElement(Ti, Bt({}, e, { ref: n, icon: Hne }));
  },
  Zb = L.forwardRef(Vne);
const Gne = () => {
    const { isCracked: t, carckedData: e } = Mi((a) => a.exp),
      [n, r] = L.useState(""),
      i = $o(),
      o = (a) => {
        const { value: l } = a.target;
        r(l.trim());
      },
      s = () => {
        if ((console.log(n), n !== "")) {
          const a =
            n === "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::"
              ? "HELLOWORLD"
              : n === "5f4dcc3b5aa765d61d8327deb882cf99"
              ? "HOWAREYOU"
              : n === "5f4dcc3b5aa765d61d8327deb882cf99"
              ? "GOODDAY"
              : Xs.error("Please enter the correct password.");
          i(bX(a));
        } else Xs.error("Please enter the correct password.");
      };
    return Q.jsx("div", {
      children: Q.jsxs("div", {
        children: [
          Q.jsx("h4", { children: "Enter Hashed password" }),
          Q.jsx($f, {
            name: "hashFile",
            style: { width: 250, margin: 5 },
            value: n,
            onChange: o,
            placeholder: "Enter hash file name",
          }),
          Q.jsx(ca, {
            onClick: s,
            style: { background: "#0c2133", color: "white" },
            children: "Crack",
          }),
          Q.jsxs("div", {
            style: { display: "flex", alignItems: "center" },
            children: [
              Q.jsx("h5", { children: "Cracked password = " }),
              Q.jsx("b", { style: { color: "green" }, children: e }),
            ],
          }),
        ],
      }),
    });
  },
  Wne = () => {
    const { step: t, activeAccordien: e } = Mi((s) => s.exp),
      n = $o(),
      r = () => {
        n(CF());
      },
      i = [
        {
          key: "1",
          label: Q.jsx("p", {
            style: { margin: 0, wordBreak: "break-word" },
            children: Q.jsx("b", {
              children: " STEP-1 : Create a memory dump file",
            }),
          }),
          children: Q.jsx(U4, {}),
        },
        {
          key: "2",
          label: Q.jsx("p", {
            style: { margin: 0, wordBreak: "break-word" },
            children: Q.jsx("b", {
              children: " STEP-2 : Transfer dump file to analyst machine",
            }),
          }),
          children: Q.jsx(k4, {}),
          collapsible: t.includes("2") ? "header" : "disabled",
        },
        {
          key: "3",
          label: Q.jsxs("div", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              flexWrap: "wrap",
              gap: "0.5rem",
            },
            children: [
              Q.jsx("b", { children: " STEP-3 : Analyse memory dump file" }),
              Q.jsx(Zb, {
                style: { color: "#0c2133", fontWeight: 800, cursor: "pointer" },
                onClick: r,
              }),
            ],
          }),
          children: Q.jsx(Bne, {}),
          collapsible: t.includes("3") ? "header" : "disabled",
        },
        {
          key: "4",
          label: Q.jsx("p", {
            style: { margin: 0, wordBreak: "break-word" },
            children: Q.jsx("b", { children: " STEP-4 : Crack the Hash" }),
          }),
          children: Q.jsx(Gne, {}),
          collapsible: t.includes("4") ? "header" : "disabled",
        },
      ],
      o = (s) => {
        n(Vp(s));
      };
    return Q.jsx("div", {
      className: "first-usecase-container",
      style: {
        flex: 1,
        overflowY: "auto",
        maxHeight: "100%",
        padding: "0.5rem",
        minWidth: 0,
      },
      children: Q.jsx(l4, {
        onChange: o,
        items: i,
        activeKey: e,
        accordion: !0,
        style: { width: "100%", wordWrap: "break-word" },
      }),
    });
  },
  jne = () => {
    const t = $o(),
      {
        dumbFileDetails: e,
        volitilitySteps: n,
        instructionIncludes: r,
        analyseStep: i,
      } = Mi((v) => v.exp),
      [o, s] = L.useState(!1),
      [a, l] = L.useState(0),
      { fileName: c, profileName: u, systemOffset: d } = e,
      p = (v) => {
        const { name: _, value: y } = v.target;
        t(MF({ ...e, [_]: y }));
      },
      m = () => {
        if (n.includes("1")) {
          if (c.toLowerCase() !== "memory.dump") {
            Xs.error("File name is incorrect");
            return;
          }
          t(gc("1")), s(!1);
        }
        if (n.includes("2")) {
          if (u.trim() !== "Win7SP1x64") {
            Xs.error("Profile Name is incorrect");
            return;
          }
          t(gc("2")), s(!1);
        }
        if (n.includes("3")) {
          if (d.trim() !== "0x0000000004a41433") {
            Xs.error("JPG offset is incorrect");
            return;
          }
          t(gc("3")), s(!1), t(wv(r[r.length - 1] + 1));
        }
      };
    return Q.jsxs("div", {
      children: [
        n.includes("1") &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", {
                  children: "1.Analysis the image info of the given file",
                }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 50,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  display: "flex",
                  flexWrap: "wrap",
                  minHeight: 80,
                },
                children: [
                  "volatility -f",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: p,
                    style: { width: 100, height: 20 },
                    placeholder: "Enter the file name",
                    disabled: n.includes("2"),
                  }),
                  "    ",
                  "imageinfo",
                ],
              }),
            ],
          }),
        n.includes("2") &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", { children: "2.Locate the image file." }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "volatility -f",
                  " ",
                  Q.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: p,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "--profile",
                  Q.jsx("br", {}),
                  Q.jsx("input", {
                    name: "profileName",
                    value: u,
                    onChange: p,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: n.includes("3"),
                  }),
                  " ",
                  Q.jsx("br", {}),
                  "filescan",
                ],
              }),
            ],
          }),
        n.includes("3") &&
          Q.jsxs("div", {
            children: [
              Q.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: Q.jsx("h4", { children: "3.Dump the image file." }),
              }),
              Q.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 120,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "volatility -f",
                  Q.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: p,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  Q.jsx("br", {}),
                  " --profile=",
                  Q.jsx("input", {
                    name: "profileName",
                    value: u,
                    onChange: p,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: !0,
                  }),
                  "dumpfiles -Q",
                  Q.jsx("br", {}),
                  Q.jsx("input", {
                    name: "systemOffset",
                    value: d,
                    onChange: p,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter offset",
                    disabled: n.includes("4"),
                  }),
                  Q.jsx("br", {}),
                  " --name file -D /opt/",
                ],
              }),
            ],
          }),
        i !== "4" &&
          Q.jsx("div", {
            style: { display: "flex", justifyContent: "flex-end" },
            children: Q.jsx(ca, {
              onClick: m,
              style: { background: "#0c2133", color: "white" },
              children: "Run",
            }),
          }),
      ],
    });
  },
  $ne = () => {
    const t = $o(),
      { openComputer: e, openFolder: n, openImage: r } = Mi((o) => o.exp);
    console.log(e);
    const i = (o) => {
      switch (o) {
        case "open":
          t(_X(!0));
          break;
        case "openFolder":
          t(SX(!0));
          break;
        case "openImage":
          t(rb(!0));
          break;
      }
    };
    return Q.jsx("div", {
      children: Q.jsx("div", {
        children: Q.jsx(ca, {
          onClick: () => i("openImage"),
          style: { background: "#0c2133", color: "white" },
          disabled: r,
          children: "open image",
        }),
      }),
    });
  },
  Xne = () => {
    const {
        step: t,
        showDumb: e,
        analyseStep: n,
        activeAccordien: r,
      } = Mi((l) => l.exp),
      i = $o(),
      o = () => {
        i(rb(!1)), i(CF());
      },
      s = [
        {
          key: "1",
          label: Q.jsx("p", {
            style: { margin: 0, wordBreak: "break-word" },
            children: Q.jsx("b", {
              children: " STEP-1 : Create a memory dump file",
            }),
          }),
          children: Q.jsx(U4, {}),
        },
        {
          key: "2",
          label: Q.jsx("p", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              flexWrap: "wrap",
              gap: "0.5rem",
            },
            children: Q.jsx("b", {
              children: "STEP-2 :Transfer dump file to forensic system",
            }),
          }),
          children: Q.jsx(k4, {}),
          collapsible: t.includes("2") ? "header" : "disabled",
        },
        {
          key: "3",
          label: Q.jsxs("div", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              flexWrap: "wrap",
              gap: "0.5rem",
            },
            children: [
              Q.jsx("b", { children: " STEP-3 : Analyse memory dump file" }),
              Q.jsx(Zb, {
                style: { color: "#0c2133", fontWeight: 800, cursor: "pointer" },
                onClick: o,
              }),
            ],
          }),
          children: Q.jsx(jne, {}),
          collapsible: t.includes("3") ? "header" : "disabled",
        },
        {
          key: "4",
          label: Q.jsxs("div", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              flexWrap: "wrap",
              gap: "0.5rem",
            },
            children: [
              Q.jsx("b", { children: " STEP-4 : View the image file" }),
              Q.jsx(Zb, {
                style: { color: "#0c2133", fontWeight: 800, cursor: "pointer" },
                onClick: o,
              }),
            ],
          }),
          children: Q.jsx($ne, {}),
          collapsible: n.includes("4") ? "header" : "disabled",
        },
      ],
      a = (l) => {
        i(Vp(l)),
          i(rb(!1)),
          l.includes("2") && e
            ? i(t0("step-2"))
            : l.includes("3") && t.includes("3")
            ? i(t0("step-3"))
            : l.includes("1") && t.includes("1")
            ? i(t0("step-1"))
            : l.includes("4") && t.includes("4") && i(t0("step-4"));
      };
    return Q.jsx("div", {
      style: {
        overflowY: "auto",
        height: "auto",
        maxHeight: "100%",
        padding: "0.5rem",
      },
      children: Q.jsx(l4, {
        onChange: a,
        items: s,
        activeKey: r,
        accordion: !0,
      }),
    });
  },
  Yne = () => {
    const { checkedValue: t } = Mi((e) => e.exp);
    return Q.jsxs("div", {
      style: { marginTop: 20, paddingInline: 5 },
      children: [t === "1" && Q.jsx(Wne, {}), t === "2" && Q.jsx(Xne, {})],
    });
  },
  qne = () =>
    Q.jsxs("div", {
      className: "control-panel",
      children: [
        Q.jsx("div", {
          style: {
            background: "#0c2136",
            height: 50,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          },
          children: Q.jsx("h4", {
            style: { textAlign: "center", margin: 0, color: "white" },
            children: "Memory forensic",
          }),
        }),
        Q.jsx("div", {
          style: {
            padding: 5,
            paddingBlock: 10,
            display: "flex",
            justifyContent: "center",
            width: "100%",
          },
          children: Q.jsx(F4, { radioValue: JX }),
        }),
        Q.jsx("div", {
          style: { height: "auto", padding: 4, width: "100%" },
          children: Q.jsx(Yne, {}),
        }),
      ],
    }),
  Kne = () => {
    const { steps: t, checkedValue: e } = Mi((r) => r.exp),
      n = L.useRef(null);
    return (
      L.useEffect(() => {
        n.current && (n.current.scrollTop = n.current.scrollHeight);
      }, [t]),
      Q.jsx("div", {
        style: {
          marginBlock: 10,
          marginLeft: "auto",
          marginRight: "auto",
          height: "90%",
          overflowY: "auto",
          width: "100%",
          maxWidth: "100%",
        },
        id: "scroll",
        ref: n,
        children: t.map((r, i) => {
          const o =
            i === 0
              ? "Create a memory dump file"
              : i === 1
              ? "Transfer memorydump file to an Analyst machine"
              : i === 2
              ? e === 1
                ? "Find the Operating system details"
                : "Locate the image file"
              : i === 3
              ? e === 1
                ? "Find the offsets of SAM and SYSTEM"
                : "Dump the image file"
              : i === 4
              ? e === 1
                ? "Dump the hashed credentials"
                : "View the image file"
              : i === 5 && e === 1
              ? "Crack the hashes"
              : "";
          return Q.jsx(
            "div",
            {
              style: {
                width: "95%",
                maxWidth: "600px",
                marginInline: "auto",
                background: "#eff7ff",
                borderRadius: 20,
                paddingInline: 15,
                paddingBlock: 12,
                marginBlock: 12,
                wordWrap: "break-word",
              },
              children: Q.jsxs("div", {
                style: { display: "flex", flexDirection: "column" },
                children: [
                  Q.jsxs("h5", {
                    style: {
                      color: "#0c2136",
                      fontSize: "0.9rem",
                      margin: "4px 0",
                      lineHeight: 1.4,
                    },
                    children: ["Step-", i + 1, ": ", o],
                  }),
                  r == null
                    ? void 0
                    : r.map((s, a) =>
                        Q.jsxs(
                          "div",
                          {
                            style: {
                              marginBlock: 6,
                              display: "flex",
                              width: "95%",
                              fontWeight: 500,
                              flexWrap: "wrap",
                            },
                            children: [
                              Q.jsxs("h5", {
                                style: {
                                  margin: 0,
                                  fontSize: "0.8rem",
                                  fontWeight: 500,
                                  color: "black",
                                  flexShrink: 0,
                                },
                                children: [a + 1, "."],
                              }),
                              Q.jsx("h5", {
                                style: {
                                  margin: 0,
                                  fontSize: "0.85rem",
                                  marginLeft: 5,
                                  fontWeight: 500,
                                  color: "black",
                                  wordBreak: "break-word",
                                },
                                children: s,
                              }),
                            ],
                          },
                          a
                        )
                      ),
                ],
              }),
            },
            i
          );
        }),
      })
    );
  },
  Zne = () =>
    Q.jsxs("div", {
      className: "main-container",
      children: [
        Q.jsx(qne, {}),
        Q.jsx(tY, {}),
        Q.jsxs("div", {
          className: "instructions-container",
          style: { overflowY: "auto", maxHeight: "100vh" },
          children: [
            Q.jsx("div", {
              className: "instructions-header",
              children: Q.jsx("h5", {
                style: { color: "white", margin: 0 },
                children: "Steps",
              }),
            }),
            Q.jsx(Kne, {}),
          ],
        }),
      ],
    }),
  Jne = rX({ reducer: { exp: wX } });
function Qne() {
  return (
    ((e) => {
      let n = "";
      for (let r = e.length - 1; r >= 0; r--) n += n[r];
      return n;
    })("hello"),
    Q.jsx(s5, { store: Jne, children: Q.jsx(Zne, {}) })
  );
}
oS.createRoot(document.getElementById("root")).render(
  Q.jsx(We.StrictMode, { children: Q.jsx(Qne, {}) })
);
