function WD(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              n,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
function Qh(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var jD = { exports: {} },
  X1 = {},
  $D = { exports: {} },
  ln = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var i0 = Symbol.for("react.element"),
  nG = Symbol.for("react.portal"),
  rG = Symbol.for("react.fragment"),
  iG = Symbol.for("react.strict_mode"),
  sG = Symbol.for("react.profiler"),
  oG = Symbol.for("react.provider"),
  aG = Symbol.for("react.context"),
  lG = Symbol.for("react.forward_ref"),
  cG = Symbol.for("react.suspense"),
  uG = Symbol.for("react.memo"),
  dG = Symbol.for("react.lazy"),
  mP = Symbol.iterator;
function fG(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (mP && n[mP]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var XD = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  YD = Object.assign,
  qD = {};
function Jh(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = qD),
    (this.updater = t || XD);
}
Jh.prototype.isReactComponent = {};
Jh.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Jh.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function KD() {}
KD.prototype = Jh.prototype;
function $T(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = qD),
    (this.updater = t || XD);
}
var XT = ($T.prototype = new KD());
XT.constructor = $T;
YD(XT, Jh.prototype);
XT.isPureReactComponent = !0;
var gP = Array.isArray,
  ZD = Object.prototype.hasOwnProperty,
  YT = { current: null },
  QD = { key: !0, ref: !0, __self: !0, __source: !0 };
function JD(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      ZD.call(e, r) && !QD.hasOwnProperty(r) && (i[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = t;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    i.children = l;
  }
  if (n && n.defaultProps)
    for (r in ((a = n.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: i0,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: YT.current,
  };
}
function hG(n, e) {
  return {
    $$typeof: i0,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function qT(n) {
  return typeof n == "object" && n !== null && n.$$typeof === i0;
}
function pG(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var vP = /\/+/g;
function bA(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? pG("" + n.key)
    : e.toString(36);
}
function rx(n, e, t, r, i) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case i0:
          case nG:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (i = i(o)),
      (n = r === "" ? "." + bA(o, 0) : r),
      gP(i)
        ? ((t = ""),
          n != null && (t = n.replace(vP, "$&/") + "/"),
          rx(i, e, t, "", function (c) {
            return c;
          }))
        : i != null &&
          (qT(i) &&
            (i = hG(
              i,
              t +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(vP, "$&/") + "/") +
                n
            )),
          e.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), gP(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = r + bA(s, a);
      o += rx(s, e, t, l, i);
    }
  else if (((l = fG(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = r + bA(s, a++)), (o += rx(s, e, t, l, i));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function wv(n, e, t) {
  if (n == null) return n;
  var r = [],
    i = 0;
  return (
    rx(n, r, "", "", function (s) {
      return e.call(t, s, i++);
    }),
    r
  );
}
function mG(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var rs = { current: null },
  ix = { transition: null },
  gG = {
    ReactCurrentDispatcher: rs,
    ReactCurrentBatchConfig: ix,
    ReactCurrentOwner: YT,
  };
function eF() {
  throw Error("act(...) is not supported in production builds of React.");
}
ln.Children = {
  map: wv,
  forEach: function (n, e, t) {
    wv(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      wv(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      wv(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!qT(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
ln.Component = Jh;
ln.Fragment = rG;
ln.Profiler = sG;
ln.PureComponent = $T;
ln.StrictMode = iG;
ln.Suspense = cG;
ln.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gG;
ln.act = eF;
ln.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var r = YD({}, n.props),
    i = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = YT.current)),
      e.key !== void 0 && (i = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      ZD.call(e, l) &&
        !QD.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    r.children = a;
  }
  return { $$typeof: i0, type: n.type, key: i, ref: s, props: r, _owner: o };
};
ln.createContext = function (n) {
  return (
    (n = {
      $$typeof: aG,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: oG, _context: n }),
    (n.Consumer = n)
  );
};
ln.createElement = JD;
ln.createFactory = function (n) {
  var e = JD.bind(null, n);
  return (e.type = n), e;
};
ln.createRef = function () {
  return { current: null };
};
ln.forwardRef = function (n) {
  return { $$typeof: lG, render: n };
};
ln.isValidElement = qT;
ln.lazy = function (n) {
  return { $$typeof: dG, _payload: { _status: -1, _result: n }, _init: mG };
};
ln.memo = function (n, e) {
  return { $$typeof: uG, type: n, compare: e === void 0 ? null : e };
};
ln.startTransition = function (n) {
  var e = ix.transition;
  ix.transition = {};
  try {
    n();
  } finally {
    ix.transition = e;
  }
};
ln.unstable_act = eF;
ln.useCallback = function (n, e) {
  return rs.current.useCallback(n, e);
};
ln.useContext = function (n) {
  return rs.current.useContext(n);
};
ln.useDebugValue = function () {};
ln.useDeferredValue = function (n) {
  return rs.current.useDeferredValue(n);
};
ln.useEffect = function (n, e) {
  return rs.current.useEffect(n, e);
};
ln.useId = function () {
  return rs.current.useId();
};
ln.useImperativeHandle = function (n, e, t) {
  return rs.current.useImperativeHandle(n, e, t);
};
ln.useInsertionEffect = function (n, e) {
  return rs.current.useInsertionEffect(n, e);
};
ln.useLayoutEffect = function (n, e) {
  return rs.current.useLayoutEffect(n, e);
};
ln.useMemo = function (n, e) {
  return rs.current.useMemo(n, e);
};
ln.useReducer = function (n, e, t) {
  return rs.current.useReducer(n, e, t);
};
ln.useRef = function (n) {
  return rs.current.useRef(n);
};
ln.useState = function (n) {
  return rs.current.useState(n);
};
ln.useSyncExternalStore = function (n, e, t) {
  return rs.current.useSyncExternalStore(n, e, t);
};
ln.useTransition = function () {
  return rs.current.useTransition();
};
ln.version = "18.3.1";
$D.exports = ln;
var I = $D.exports;
const Je = Qh(I),
  ng = WD({ __proto__: null, default: Je }, [I]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var vG = I,
  yG = Symbol.for("react.element"),
  xG = Symbol.for("react.fragment"),
  _G = Object.prototype.hasOwnProperty,
  SG = vG.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  AG = { key: !0, ref: !0, __self: !0, __source: !0 };
function tF(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (r in e) _G.call(e, r) && !AG.hasOwnProperty(r) && (i[r] = e[r]);
  if (n && n.defaultProps)
    for (r in ((e = n.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: yG,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: SG.current,
  };
}
X1.Fragment = xG;
X1.jsx = tF;
X1.jsxs = tF;
jD.exports = X1;
var J = jD.exports,
  Hb = {},
  nF = { exports: {} },
  ho = {},
  rF = { exports: {} },
  iF = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(U, H) {
    var V = U.length;
    U.push(H);
    e: for (; 0 < V; ) {
      var k = (V - 1) >>> 1,
        W = U[k];
      if (0 < i(W, H)) (U[k] = H), (U[V] = W), (V = k);
      else break e;
    }
  }
  function t(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var H = U[0],
      V = U.pop();
    if (V !== H) {
      U[0] = V;
      e: for (var k = 0, W = U.length, ee = W >>> 1; k < ee; ) {
        var Y = 2 * (k + 1) - 1,
          K = U[Y],
          ae = Y + 1,
          se = U[ae];
        if (0 > i(K, V))
          ae < W && 0 > i(se, K)
            ? ((U[k] = se), (U[ae] = V), (k = ae))
            : ((U[k] = K), (U[Y] = V), (k = Y));
        else if (ae < W && 0 > i(se, V)) (U[k] = se), (U[ae] = V), (k = ae);
        else break e;
      }
    }
    return H;
  }
  function i(U, H) {
    var V = U.sortIndex - H.sortIndex;
    return V !== 0 ? V : U.id - H.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    h = 3,
    m = !1,
    g = !1,
    x = !1,
    y = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var H = t(c); H !== null; ) {
      if (H.callback === null) r(c);
      else if (H.startTime <= U)
        r(c), (H.sortIndex = H.expirationTime), e(l, H);
      else break;
      H = t(c);
    }
  }
  function w(U) {
    if (((x = !1), S(U), !g))
      if (t(l) !== null) (g = !0), G(T);
      else {
        var H = t(c);
        H !== null && j(w, H.startTime - U);
      }
  }
  function T(U, H) {
    (g = !1), x && ((x = !1), v(N), (N = -1)), (m = !0);
    var V = h;
    try {
      for (
        S(H), d = t(l);
        d !== null && (!(d.expirationTime > H) || (U && !L()));

      ) {
        var k = d.callback;
        if (typeof k == "function") {
          (d.callback = null), (h = d.priorityLevel);
          var W = k(d.expirationTime <= H);
          (H = n.unstable_now()),
            typeof W == "function" ? (d.callback = W) : d === t(l) && r(l),
            S(H);
        } else r(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var Y = t(c);
        Y !== null && j(w, Y.startTime - H), (ee = !1);
      }
      return ee;
    } finally {
      (d = null), (h = V), (m = !1);
    }
  }
  var E = !1,
    M = null,
    N = -1,
    R = 5,
    C = -1;
  function L() {
    return !(n.unstable_now() - C < R);
  }
  function O() {
    if (M !== null) {
      var U = n.unstable_now();
      C = U;
      var H = !0;
      try {
        H = M(!0, U);
      } finally {
        H ? D() : ((E = !1), (M = null));
      }
    } else E = !1;
  }
  var D;
  if (typeof _ == "function")
    D = function () {
      _(O);
    };
  else if (typeof MessageChannel < "u") {
    var B = new MessageChannel(),
      $ = B.port2;
    (B.port1.onmessage = O),
      (D = function () {
        $.postMessage(null);
      });
  } else
    D = function () {
      y(O, 0);
    };
  function G(U) {
    (M = U), E || ((E = !0), D());
  }
  function j(U, H) {
    N = y(function () {
      U(n.unstable_now());
    }, H);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      g || m || ((g = !0), G(T));
    }),
    (n.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return h;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (U) {
      switch (h) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = h;
      }
      var V = h;
      h = H;
      try {
        return U();
      } finally {
        h = V;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (U, H) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var V = h;
      h = U;
      try {
        return H();
      } finally {
        h = V;
      }
    }),
    (n.unstable_scheduleCallback = function (U, H, V) {
      var k = n.unstable_now();
      switch (
        (typeof V == "object" && V !== null
          ? ((V = V.delay), (V = typeof V == "number" && 0 < V ? k + V : k))
          : (V = k),
        U)
      ) {
        case 1:
          var W = -1;
          break;
        case 2:
          W = 250;
          break;
        case 5:
          W = 1073741823;
          break;
        case 4:
          W = 1e4;
          break;
        default:
          W = 5e3;
      }
      return (
        (W = V + W),
        (U = {
          id: u++,
          callback: H,
          priorityLevel: U,
          startTime: V,
          expirationTime: W,
          sortIndex: -1,
        }),
        V > k
          ? ((U.sortIndex = V),
            e(c, U),
            t(l) === null &&
              U === t(c) &&
              (x ? (v(N), (N = -1)) : (x = !0), j(w, V - k)))
          : ((U.sortIndex = W), e(l, U), g || m || ((g = !0), G(T))),
        U
      );
    }),
    (n.unstable_shouldYield = L),
    (n.unstable_wrapCallback = function (U) {
      var H = h;
      return function () {
        var V = h;
        h = H;
        try {
          return U.apply(this, arguments);
        } finally {
          h = V;
        }
      };
    });
})(iF);
rF.exports = iF;
var wG = rF.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bG = I,
  oo = wG;
function rt(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var sF = new Set(),
  rg = {};
function Nd(n, e) {
  Th(n, e), Th(n + "Capture", e);
}
function Th(n, e) {
  for (rg[n] = e, n = 0; n < e.length; n++) sF.add(e[n]);
}
var Pl = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Gb = Object.prototype.hasOwnProperty,
  EG =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  yP = {},
  xP = {};
function MG(n) {
  return Gb.call(xP, n)
    ? !0
    : Gb.call(yP, n)
    ? !1
    : EG.test(n)
    ? (xP[n] = !0)
    : ((yP[n] = !0), !1);
}
function TG(n, e, t, r) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function CG(n, e, t, r) {
  if (e === null || typeof e > "u" || TG(n, e, t, r)) return !0;
  if (r) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function is(n, e, t, r, i, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var yi = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    yi[n] = new is(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  yi[e] = new is(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  yi[n] = new is(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  yi[n] = new is(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    yi[n] = new is(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  yi[n] = new is(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  yi[n] = new is(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  yi[n] = new is(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  yi[n] = new is(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var KT = /[\-:]([a-z])/g;
function ZT(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(KT, ZT);
    yi[e] = new is(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(KT, ZT);
    yi[e] = new is(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(KT, ZT);
  yi[e] = new is(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  yi[n] = new is(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
yi.xlinkHref = new is(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  yi[n] = new is(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function QT(n, e, t, r) {
  var i = yi.hasOwnProperty(e) ? yi[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (CG(e, t, i, r) && (t = null),
    r || i === null
      ? MG(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : i.mustUseProperty
      ? (n[i.propertyName] = t === null ? (i.type === 3 ? !1 : "") : t)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((i = i.type),
            (t = i === 3 || (i === 4 && t === !0) ? "" : "" + t),
            r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))));
}
var Hl = bG.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  bv = Symbol.for("react.element"),
  Vf = Symbol.for("react.portal"),
  Hf = Symbol.for("react.fragment"),
  JT = Symbol.for("react.strict_mode"),
  Wb = Symbol.for("react.profiler"),
  oF = Symbol.for("react.provider"),
  aF = Symbol.for("react.context"),
  eC = Symbol.for("react.forward_ref"),
  jb = Symbol.for("react.suspense"),
  $b = Symbol.for("react.suspense_list"),
  tC = Symbol.for("react.memo"),
  hc = Symbol.for("react.lazy"),
  lF = Symbol.for("react.offscreen"),
  _P = Symbol.iterator;
function qp(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (_P && n[_P]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var ir = Object.assign,
  EA;
function bm(n) {
  if (EA === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      EA = (e && e[1]) || "";
    }
  return (
    `
` +
    EA +
    n
  );
}
var MA = !1;
function TA(n, e) {
  if (!n || MA) return "";
  MA = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var r = c;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          r = c;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        r = c;
      }
      n();
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var i = c.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (MA = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? bm(n) : "";
}
function RG(n) {
  switch (n.tag) {
    case 5:
      return bm(n.type);
    case 16:
      return bm("Lazy");
    case 13:
      return bm("Suspense");
    case 19:
      return bm("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = TA(n.type, !1)), n;
    case 11:
      return (n = TA(n.type.render, !1)), n;
    case 1:
      return (n = TA(n.type, !0)), n;
    default:
      return "";
  }
}
function Xb(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Hf:
      return "Fragment";
    case Vf:
      return "Portal";
    case Wb:
      return "Profiler";
    case JT:
      return "StrictMode";
    case jb:
      return "Suspense";
    case $b:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case aF:
        return (n.displayName || "Context") + ".Consumer";
      case oF:
        return (n._context.displayName || "Context") + ".Provider";
      case eC:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case tC:
        return (
          (e = n.displayName || null), e !== null ? e : Xb(n.type) || "Memo"
        );
      case hc:
        (e = n._payload), (n = n._init);
        try {
          return Xb(n(e));
        } catch {}
    }
  return null;
}
function NG(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Xb(e);
    case 8:
      return e === JT ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Uc(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function cF(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function PG(n) {
  var e = cF(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    r = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var i = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Ev(n) {
  n._valueTracker || (n._valueTracker = PG(n));
}
function uF(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    r = "";
  return (
    n && (r = cF(n) ? (n.checked ? "true" : "false") : n.value),
    (n = r),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function zx(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function Yb(n, e) {
  var t = e.checked;
  return ir({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function SP(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (t = Uc(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: r,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function dF(n, e) {
  (e = e.checked), e != null && QT(n, "checked", e, !1);
}
function qb(n, e) {
  dF(n, e);
  var t = Uc(e.value),
    r = e.type;
  if (t != null)
    r === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (r === "submit" || r === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Kb(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && Kb(n, e.type, Uc(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function AP(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function Kb(n, e, t) {
  (e !== "number" || zx(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Em = Array.isArray;
function fh(n, e, t, r) {
  if (((n = n.options), e)) {
    e = {};
    for (var i = 0; i < t.length; i++) e["$" + t[i]] = !0;
    for (t = 0; t < n.length; t++)
      (i = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== i && (n[t].selected = i),
        i && r && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + Uc(t), e = null, i = 0; i < n.length; i++) {
      if (n[i].value === t) {
        (n[i].selected = !0), r && (n[i].defaultSelected = !0);
        return;
      }
      e !== null || n[i].disabled || (e = n[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function Zb(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(rt(91));
  return ir({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function wP(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(rt(92));
      if (Em(t)) {
        if (1 < t.length) throw Error(rt(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: Uc(t) };
}
function fF(n, e) {
  var t = Uc(e.value),
    r = Uc(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    r != null && (n.defaultValue = "" + r);
}
function bP(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function hF(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function Qb(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? hF(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Mv,
  pF = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, r, i);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Mv = Mv || document.createElement("div"),
          Mv.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Mv.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function ig(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Om = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  IG = ["Webkit", "ms", "Moz", "O"];
Object.keys(Om).forEach(function (n) {
  IG.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Om[e] = Om[n]);
  });
});
function mF(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (Om.hasOwnProperty(n) && Om[n])
    ? ("" + e).trim()
    : e + "px";
}
function gF(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var r = t.indexOf("--") === 0,
        i = mF(t, e[t], r);
      t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : (n[t] = i);
    }
}
var LG = ir(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function Jb(n, e) {
  if (e) {
    if (LG[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(rt(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(rt(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(rt(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(rt(62));
  }
}
function eE(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var tE = null;
function nC(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var nE = null,
  hh = null,
  ph = null;
function EP(n) {
  if ((n = a0(n))) {
    if (typeof nE != "function") throw Error(rt(280));
    var e = n.stateNode;
    e && ((e = Q1(e)), nE(n.stateNode, n.type, e));
  }
}
function vF(n) {
  hh ? (ph ? ph.push(n) : (ph = [n])) : (hh = n);
}
function yF() {
  if (hh) {
    var n = hh,
      e = ph;
    if (((ph = hh = null), EP(n), e)) for (n = 0; n < e.length; n++) EP(e[n]);
  }
}
function xF(n, e) {
  return n(e);
}
function _F() {}
var CA = !1;
function SF(n, e, t) {
  if (CA) return n(e, t);
  CA = !0;
  try {
    return xF(n, e, t);
  } finally {
    (CA = !1), (hh !== null || ph !== null) && (_F(), yF());
  }
}
function sg(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var r = Q1(t);
  if (r === null) return null;
  t = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((n = n.type),
        (r = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !r);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(rt(231, e, typeof t));
  return t;
}
var rE = !1;
if (Pl)
  try {
    var Kp = {};
    Object.defineProperty(Kp, "passive", {
      get: function () {
        rE = !0;
      },
    }),
      window.addEventListener("test", Kp, Kp),
      window.removeEventListener("test", Kp, Kp);
  } catch {
    rE = !1;
  }
function OG(n, e, t, r, i, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, c);
  } catch (u) {
    this.onError(u);
  }
}
var Dm = !1,
  Bx = null,
  Vx = !1,
  iE = null,
  DG = {
    onError: function (n) {
      (Dm = !0), (Bx = n);
    },
  };
function FG(n, e, t, r, i, s, o, a, l) {
  (Dm = !1), (Bx = null), OG.apply(DG, arguments);
}
function UG(n, e, t, r, i, s, o, a, l) {
  if ((FG.apply(this, arguments), Dm)) {
    if (Dm) {
      var c = Bx;
      (Dm = !1), (Bx = null);
    } else throw Error(rt(198));
    Vx || ((Vx = !0), (iE = c));
  }
}
function Pd(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function AF(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function MP(n) {
  if (Pd(n) !== n) throw Error(rt(188));
}
function kG(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = Pd(n)), e === null)) throw Error(rt(188));
    return e !== n ? null : n;
  }
  for (var t = n, r = e; ; ) {
    var i = t.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        t = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === t) return MP(i), n;
        if (s === r) return MP(i), e;
        s = s.sibling;
      }
      throw Error(rt(188));
    }
    if (t.return !== r.return) (t = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === t) {
          (o = !0), (t = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (t = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(rt(189));
      }
    }
    if (t.alternate !== r) throw Error(rt(190));
  }
  if (t.tag !== 3) throw Error(rt(188));
  return t.stateNode.current === t ? n : e;
}
function wF(n) {
  return (n = kG(n)), n !== null ? bF(n) : null;
}
function bF(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = bF(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var EF = oo.unstable_scheduleCallback,
  TP = oo.unstable_cancelCallback,
  zG = oo.unstable_shouldYield,
  BG = oo.unstable_requestPaint,
  Er = oo.unstable_now,
  VG = oo.unstable_getCurrentPriorityLevel,
  rC = oo.unstable_ImmediatePriority,
  MF = oo.unstable_UserBlockingPriority,
  Hx = oo.unstable_NormalPriority,
  HG = oo.unstable_LowPriority,
  TF = oo.unstable_IdlePriority,
  Y1 = null,
  Ha = null;
function GG(n) {
  if (Ha && typeof Ha.onCommitFiberRoot == "function")
    try {
      Ha.onCommitFiberRoot(Y1, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var ua = Math.clz32 ? Math.clz32 : $G,
  WG = Math.log,
  jG = Math.LN2;
function $G(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((WG(n) / jG) | 0)) | 0;
}
var Tv = 64,
  Cv = 4194304;
function Mm(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function Gx(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var r = 0,
    i = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = Mm(a)) : ((s &= o), s !== 0 && (r = Mm(s)));
  } else (o = t & ~i), o !== 0 ? (r = Mm(o)) : s !== 0 && (r = Mm(s));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= r; 0 < e; )
      (t = 31 - ua(e)), (i = 1 << t), (r |= n[t]), (e &= ~i);
  return r;
}
function XG(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function YG(n, e) {
  for (
    var t = n.suspendedLanes,
      r = n.pingedLanes,
      i = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - ua(s),
      a = 1 << o,
      l = i[o];
    l === -1
      ? (!(a & t) || a & r) && (i[o] = XG(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function sE(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function CF() {
  var n = Tv;
  return (Tv <<= 1), !(Tv & 4194240) && (Tv = 64), n;
}
function RA(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function s0(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - ua(e)),
    (n[e] = t);
}
function qG(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var r = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var i = 31 - ua(t),
      s = 1 << i;
    (e[i] = 0), (r[i] = -1), (n[i] = -1), (t &= ~s);
  }
}
function iC(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var r = 31 - ua(t),
      i = 1 << r;
    (i & e) | (n[r] & e) && (n[r] |= e), (t &= ~i);
  }
}
var En = 0;
function RF(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var NF,
  sC,
  PF,
  IF,
  LF,
  oE = !1,
  Rv = [],
  Tc = null,
  Cc = null,
  Rc = null,
  og = new Map(),
  ag = new Map(),
  vc = [],
  KG =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function CP(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Tc = null;
      break;
    case "dragenter":
    case "dragleave":
      Cc = null;
      break;
    case "mouseover":
    case "mouseout":
      Rc = null;
      break;
    case "pointerover":
    case "pointerout":
      og.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      ag.delete(e.pointerId);
  }
}
function Zp(n, e, t, r, i, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = a0(e)), e !== null && sC(e)),
      n)
    : ((n.eventSystemFlags |= r),
      (e = n.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      n);
}
function ZG(n, e, t, r, i) {
  switch (e) {
    case "focusin":
      return (Tc = Zp(Tc, n, e, t, r, i)), !0;
    case "dragenter":
      return (Cc = Zp(Cc, n, e, t, r, i)), !0;
    case "mouseover":
      return (Rc = Zp(Rc, n, e, t, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return og.set(s, Zp(og.get(s) || null, n, e, t, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), ag.set(s, Zp(ag.get(s) || null, n, e, t, r, i)), !0
      );
  }
  return !1;
}
function OF(n) {
  var e = Gu(n.target);
  if (e !== null) {
    var t = Pd(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = AF(t)), e !== null)) {
          (n.blockedOn = e),
            LF(n.priority, function () {
              PF(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function sx(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = aE(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var r = new t.constructor(t.type, t);
      (tE = r), t.target.dispatchEvent(r), (tE = null);
    } else return (e = a0(t)), e !== null && sC(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function RP(n, e, t) {
  sx(n) && t.delete(e);
}
function QG() {
  (oE = !1),
    Tc !== null && sx(Tc) && (Tc = null),
    Cc !== null && sx(Cc) && (Cc = null),
    Rc !== null && sx(Rc) && (Rc = null),
    og.forEach(RP),
    ag.forEach(RP);
}
function Qp(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    oE ||
      ((oE = !0),
      oo.unstable_scheduleCallback(oo.unstable_NormalPriority, QG)));
}
function lg(n) {
  function e(i) {
    return Qp(i, n);
  }
  if (0 < Rv.length) {
    Qp(Rv[0], n);
    for (var t = 1; t < Rv.length; t++) {
      var r = Rv[t];
      r.blockedOn === n && (r.blockedOn = null);
    }
  }
  for (
    Tc !== null && Qp(Tc, n),
      Cc !== null && Qp(Cc, n),
      Rc !== null && Qp(Rc, n),
      og.forEach(e),
      ag.forEach(e),
      t = 0;
    t < vc.length;
    t++
  )
    (r = vc[t]), r.blockedOn === n && (r.blockedOn = null);
  for (; 0 < vc.length && ((t = vc[0]), t.blockedOn === null); )
    OF(t), t.blockedOn === null && vc.shift();
}
var mh = Hl.ReactCurrentBatchConfig,
  Wx = !0;
function JG(n, e, t, r) {
  var i = En,
    s = mh.transition;
  mh.transition = null;
  try {
    (En = 1), oC(n, e, t, r);
  } finally {
    (En = i), (mh.transition = s);
  }
}
function eW(n, e, t, r) {
  var i = En,
    s = mh.transition;
  mh.transition = null;
  try {
    (En = 4), oC(n, e, t, r);
  } finally {
    (En = i), (mh.transition = s);
  }
}
function oC(n, e, t, r) {
  if (Wx) {
    var i = aE(n, e, t, r);
    if (i === null) zA(n, e, r, jx, t), CP(n, r);
    else if (ZG(i, n, e, t, r)) r.stopPropagation();
    else if ((CP(n, r), e & 4 && -1 < KG.indexOf(n))) {
      for (; i !== null; ) {
        var s = a0(i);
        if (
          (s !== null && NF(s),
          (s = aE(n, e, t, r)),
          s === null && zA(n, e, r, jx, t),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else zA(n, e, r, null, t);
  }
}
var jx = null;
function aE(n, e, t, r) {
  if (((jx = null), (n = nC(r)), (n = Gu(n)), n !== null))
    if (((e = Pd(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = AF(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (jx = n), null;
}
function DF(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (VG()) {
        case rC:
          return 1;
        case MF:
          return 4;
        case Hx:
        case HG:
          return 16;
        case TF:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var _c = null,
  aC = null,
  ox = null;
function FF() {
  if (ox) return ox;
  var n,
    e = aC,
    t = e.length,
    r,
    i = "value" in _c ? _c.value : _c.textContent,
    s = i.length;
  for (n = 0; n < t && e[n] === i[n]; n++);
  var o = t - n;
  for (r = 1; r <= o && e[t - r] === i[s - r]; r++);
  return (ox = i.slice(n, 1 < r ? 1 - r : void 0));
}
function ax(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Nv() {
  return !0;
}
function NP() {
  return !1;
}
function po(n) {
  function e(t, r, i, s, o) {
    (this._reactName = t),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Nv
        : NP),
      (this.isPropagationStopped = NP),
      this
    );
  }
  return (
    ir(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Nv));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Nv));
      },
      persist: function () {},
      isPersistent: Nv,
    }),
    e
  );
}
var ep = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  lC = po(ep),
  o0 = ir({}, ep, { view: 0, detail: 0 }),
  tW = po(o0),
  NA,
  PA,
  Jp,
  q1 = ir({}, o0, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: cC,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== Jp &&
            (Jp && n.type === "mousemove"
              ? ((NA = n.screenX - Jp.screenX), (PA = n.screenY - Jp.screenY))
              : (PA = NA = 0),
            (Jp = n)),
          NA);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : PA;
    },
  }),
  PP = po(q1),
  nW = ir({}, q1, { dataTransfer: 0 }),
  rW = po(nW),
  iW = ir({}, o0, { relatedTarget: 0 }),
  IA = po(iW),
  sW = ir({}, ep, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  oW = po(sW),
  aW = ir({}, ep, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  lW = po(aW),
  cW = ir({}, ep, { data: 0 }),
  IP = po(cW),
  uW = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  dW = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  fW = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function hW(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = fW[n]) ? !!e[n] : !1;
}
function cC() {
  return hW;
}
var pW = ir({}, o0, {
    key: function (n) {
      if (n.key) {
        var e = uW[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = ax(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? dW[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: cC,
    charCode: function (n) {
      return n.type === "keypress" ? ax(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? ax(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  mW = po(pW),
  gW = ir({}, q1, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  LP = po(gW),
  vW = ir({}, o0, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: cC,
  }),
  yW = po(vW),
  xW = ir({}, ep, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  _W = po(xW),
  SW = ir({}, q1, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  AW = po(SW),
  wW = [9, 13, 27, 32],
  uC = Pl && "CompositionEvent" in window,
  Fm = null;
Pl && "documentMode" in document && (Fm = document.documentMode);
var bW = Pl && "TextEvent" in window && !Fm,
  UF = Pl && (!uC || (Fm && 8 < Fm && 11 >= Fm)),
  OP = " ",
  DP = !1;
function kF(n, e) {
  switch (n) {
    case "keyup":
      return wW.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function zF(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Gf = !1;
function EW(n, e) {
  switch (n) {
    case "compositionend":
      return zF(e);
    case "keypress":
      return e.which !== 32 ? null : ((DP = !0), OP);
    case "textInput":
      return (n = e.data), n === OP && DP ? null : n;
    default:
      return null;
  }
}
function MW(n, e) {
  if (Gf)
    return n === "compositionend" || (!uC && kF(n, e))
      ? ((n = FF()), (ox = aC = _c = null), (Gf = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return UF && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var TW = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function FP(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!TW[n.type] : e === "textarea";
}
function BF(n, e, t, r) {
  vF(r),
    (e = $x(e, "onChange")),
    0 < e.length &&
      ((t = new lC("onChange", "change", null, t, r)),
      n.push({ event: t, listeners: e }));
}
var Um = null,
  cg = null;
function CW(n) {
  ZF(n, 0);
}
function K1(n) {
  var e = $f(n);
  if (uF(e)) return n;
}
function RW(n, e) {
  if (n === "change") return e;
}
var VF = !1;
if (Pl) {
  var LA;
  if (Pl) {
    var OA = "oninput" in document;
    if (!OA) {
      var UP = document.createElement("div");
      UP.setAttribute("oninput", "return;"),
        (OA = typeof UP.oninput == "function");
    }
    LA = OA;
  } else LA = !1;
  VF = LA && (!document.documentMode || 9 < document.documentMode);
}
function kP() {
  Um && (Um.detachEvent("onpropertychange", HF), (cg = Um = null));
}
function HF(n) {
  if (n.propertyName === "value" && K1(cg)) {
    var e = [];
    BF(e, cg, n, nC(n)), SF(CW, e);
  }
}
function NW(n, e, t) {
  n === "focusin"
    ? (kP(), (Um = e), (cg = t), Um.attachEvent("onpropertychange", HF))
    : n === "focusout" && kP();
}
function PW(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return K1(cg);
}
function IW(n, e) {
  if (n === "click") return K1(e);
}
function LW(n, e) {
  if (n === "input" || n === "change") return K1(e);
}
function OW(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var ga = typeof Object.is == "function" ? Object.is : OW;
function ug(n, e) {
  if (ga(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    r = Object.keys(e);
  if (t.length !== r.length) return !1;
  for (r = 0; r < t.length; r++) {
    var i = t[r];
    if (!Gb.call(e, i) || !ga(n[i], e[i])) return !1;
  }
  return !0;
}
function zP(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function BP(n, e) {
  var t = zP(n);
  n = 0;
  for (var r; t; ) {
    if (t.nodeType === 3) {
      if (((r = n + t.textContent.length), n <= e && r >= e))
        return { node: t, offset: e - n };
      n = r;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = zP(t);
  }
}
function GF(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? GF(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function WF() {
  for (var n = window, e = zx(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = zx(n.document);
  }
  return e;
}
function dC(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function DW(n) {
  var e = WF(),
    t = n.focusedElem,
    r = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    GF(t.ownerDocument.documentElement, t)
  ) {
    if (r !== null && dC(t)) {
      if (
        ((e = r.start),
        (n = r.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var i = t.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !n.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = BP(t, s));
        var o = BP(t, r);
        i &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== i.node ||
            n.anchorOffset !== i.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          n.removeAllRanges(),
          s > r
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var FW = Pl && "documentMode" in document && 11 >= document.documentMode,
  Wf = null,
  lE = null,
  km = null,
  cE = !1;
function VP(n, e, t) {
  var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  cE ||
    Wf == null ||
    Wf !== zx(r) ||
    ((r = Wf),
    "selectionStart" in r && dC(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (km && ug(km, r)) ||
      ((km = r),
      (r = $x(lE, "onSelect")),
      0 < r.length &&
        ((e = new lC("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: r }),
        (e.target = Wf))));
}
function Pv(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var jf = {
    animationend: Pv("Animation", "AnimationEnd"),
    animationiteration: Pv("Animation", "AnimationIteration"),
    animationstart: Pv("Animation", "AnimationStart"),
    transitionend: Pv("Transition", "TransitionEnd"),
  },
  DA = {},
  jF = {};
Pl &&
  ((jF = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete jf.animationend.animation,
    delete jf.animationiteration.animation,
    delete jf.animationstart.animation),
  "TransitionEvent" in window || delete jf.transitionend.transition);
function Z1(n) {
  if (DA[n]) return DA[n];
  if (!jf[n]) return n;
  var e = jf[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in jF) return (DA[n] = e[t]);
  return n;
}
var $F = Z1("animationend"),
  XF = Z1("animationiteration"),
  YF = Z1("animationstart"),
  qF = Z1("transitionend"),
  KF = new Map(),
  HP =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function qc(n, e) {
  KF.set(n, e), Nd(e, [n]);
}
for (var FA = 0; FA < HP.length; FA++) {
  var UA = HP[FA],
    UW = UA.toLowerCase(),
    kW = UA[0].toUpperCase() + UA.slice(1);
  qc(UW, "on" + kW);
}
qc($F, "onAnimationEnd");
qc(XF, "onAnimationIteration");
qc(YF, "onAnimationStart");
qc("dblclick", "onDoubleClick");
qc("focusin", "onFocus");
qc("focusout", "onBlur");
qc(qF, "onTransitionEnd");
Th("onMouseEnter", ["mouseout", "mouseover"]);
Th("onMouseLeave", ["mouseout", "mouseover"]);
Th("onPointerEnter", ["pointerout", "pointerover"]);
Th("onPointerLeave", ["pointerout", "pointerover"]);
Nd(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
Nd(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
Nd("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Nd(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
Nd(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
Nd(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Tm =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  zW = new Set("cancel close invalid load scroll toggle".split(" ").concat(Tm));
function GP(n, e, t) {
  var r = n.type || "unknown-event";
  (n.currentTarget = t), UG(r, e, void 0, n), (n.currentTarget = null);
}
function ZF(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var r = n[t],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e;
          GP(i, a, c), (s = l);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          GP(i, a, c), (s = l);
        }
    }
  }
  if (Vx) throw ((n = iE), (Vx = !1), (iE = null), n);
}
function Vn(n, e) {
  var t = e[pE];
  t === void 0 && (t = e[pE] = new Set());
  var r = n + "__bubble";
  t.has(r) || (QF(e, n, 2, !1), t.add(r));
}
function kA(n, e, t) {
  var r = 0;
  e && (r |= 4), QF(t, n, r, e);
}
var Iv = "_reactListening" + Math.random().toString(36).slice(2);
function dg(n) {
  if (!n[Iv]) {
    (n[Iv] = !0),
      sF.forEach(function (t) {
        t !== "selectionchange" && (zW.has(t) || kA(t, !1, n), kA(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Iv] || ((e[Iv] = !0), kA("selectionchange", !1, e));
  }
}
function QF(n, e, t, r) {
  switch (DF(e)) {
    case 1:
      var i = JG;
      break;
    case 4:
      i = eW;
      break;
    default:
      i = oC;
  }
  (t = i.bind(null, e, t, n)),
    (i = void 0),
    !rE ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: i })
        : n.addEventListener(e, t, !0)
      : i !== void 0
      ? n.addEventListener(e, t, { passive: i })
      : n.addEventListener(e, t, !1);
}
function zA(n, e, t, r, i) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Gu(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  SF(function () {
    var c = s,
      u = nC(t),
      d = [];
    e: {
      var h = KF.get(n);
      if (h !== void 0) {
        var m = lC,
          g = n;
        switch (n) {
          case "keypress":
            if (ax(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = mW;
            break;
          case "focusin":
            (g = "focus"), (m = IA);
            break;
          case "focusout":
            (g = "blur"), (m = IA);
            break;
          case "beforeblur":
          case "afterblur":
            m = IA;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = PP;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = rW;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = yW;
            break;
          case $F:
          case XF:
          case YF:
            m = oW;
            break;
          case qF:
            m = _W;
            break;
          case "scroll":
            m = tW;
            break;
          case "wheel":
            m = AW;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = lW;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = LP;
        }
        var x = (e & 4) !== 0,
          y = !x && n === "scroll",
          v = x ? (h !== null ? h + "Capture" : null) : h;
        x = [];
        for (var _ = c, S; _ !== null; ) {
          S = _;
          var w = S.stateNode;
          if (
            (S.tag === 5 &&
              w !== null &&
              ((S = w),
              v !== null && ((w = sg(_, v)), w != null && x.push(fg(_, w, S)))),
            y)
          )
            break;
          _ = _.return;
        }
        0 < x.length &&
          ((h = new m(h, g, null, t, u)), d.push({ event: h, listeners: x }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((h = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          h &&
            t !== tE &&
            (g = t.relatedTarget || t.fromElement) &&
            (Gu(g) || g[Il]))
        )
          break e;
        if (
          (m || h) &&
          ((h =
            u.window === u
              ? u
              : (h = u.ownerDocument)
              ? h.defaultView || h.parentWindow
              : window),
          m
            ? ((g = t.relatedTarget || t.toElement),
              (m = c),
              (g = g ? Gu(g) : null),
              g !== null &&
                ((y = Pd(g)), g !== y || (g.tag !== 5 && g.tag !== 6)) &&
                (g = null))
            : ((m = null), (g = c)),
          m !== g)
        ) {
          if (
            ((x = PP),
            (w = "onMouseLeave"),
            (v = "onMouseEnter"),
            (_ = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((x = LP),
              (w = "onPointerLeave"),
              (v = "onPointerEnter"),
              (_ = "pointer")),
            (y = m == null ? h : $f(m)),
            (S = g == null ? h : $f(g)),
            (h = new x(w, _ + "leave", m, t, u)),
            (h.target = y),
            (h.relatedTarget = S),
            (w = null),
            Gu(u) === c &&
              ((x = new x(v, _ + "enter", g, t, u)),
              (x.target = S),
              (x.relatedTarget = y),
              (w = x)),
            (y = w),
            m && g)
          )
            t: {
              for (x = m, v = g, _ = 0, S = x; S; S = of(S)) _++;
              for (S = 0, w = v; w; w = of(w)) S++;
              for (; 0 < _ - S; ) (x = of(x)), _--;
              for (; 0 < S - _; ) (v = of(v)), S--;
              for (; _--; ) {
                if (x === v || (v !== null && x === v.alternate)) break t;
                (x = of(x)), (v = of(v));
              }
              x = null;
            }
          else x = null;
          m !== null && WP(d, h, m, x, !1),
            g !== null && y !== null && WP(d, y, g, x, !0);
        }
      }
      e: {
        if (
          ((h = c ? $f(c) : window),
          (m = h.nodeName && h.nodeName.toLowerCase()),
          m === "select" || (m === "input" && h.type === "file"))
        )
          var T = RW;
        else if (FP(h))
          if (VF) T = LW;
          else {
            T = PW;
            var E = NW;
          }
        else
          (m = h.nodeName) &&
            m.toLowerCase() === "input" &&
            (h.type === "checkbox" || h.type === "radio") &&
            (T = IW);
        if (T && (T = T(n, c))) {
          BF(d, T, t, u);
          break e;
        }
        E && E(n, h, c),
          n === "focusout" &&
            (E = h._wrapperState) &&
            E.controlled &&
            h.type === "number" &&
            Kb(h, "number", h.value);
      }
      switch (((E = c ? $f(c) : window), n)) {
        case "focusin":
          (FP(E) || E.contentEditable === "true") &&
            ((Wf = E), (lE = c), (km = null));
          break;
        case "focusout":
          km = lE = Wf = null;
          break;
        case "mousedown":
          cE = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (cE = !1), VP(d, t, u);
          break;
        case "selectionchange":
          if (FW) break;
        case "keydown":
        case "keyup":
          VP(d, t, u);
      }
      var M;
      if (uC)
        e: {
          switch (n) {
            case "compositionstart":
              var N = "onCompositionStart";
              break e;
            case "compositionend":
              N = "onCompositionEnd";
              break e;
            case "compositionupdate":
              N = "onCompositionUpdate";
              break e;
          }
          N = void 0;
        }
      else
        Gf
          ? kF(n, t) && (N = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (N = "onCompositionStart");
      N &&
        (UF &&
          t.locale !== "ko" &&
          (Gf || N !== "onCompositionStart"
            ? N === "onCompositionEnd" && Gf && (M = FF())
            : ((_c = u),
              (aC = "value" in _c ? _c.value : _c.textContent),
              (Gf = !0))),
        (E = $x(c, N)),
        0 < E.length &&
          ((N = new IP(N, n, null, t, u)),
          d.push({ event: N, listeners: E }),
          M ? (N.data = M) : ((M = zF(t)), M !== null && (N.data = M)))),
        (M = bW ? EW(n, t) : MW(n, t)) &&
          ((c = $x(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new IP("onBeforeInput", "beforeinput", null, t, u)),
            d.push({ event: u, listeners: c }),
            (u.data = M)));
    }
    ZF(d, e);
  });
}
function fg(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function $x(n, e) {
  for (var t = e + "Capture", r = []; n !== null; ) {
    var i = n,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = sg(n, t)),
      s != null && r.unshift(fg(n, s, i)),
      (s = sg(n, e)),
      s != null && r.push(fg(n, s, i))),
      (n = n.return);
  }
  return r;
}
function of(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function WP(n, e, t, r, i) {
  for (var s = e._reactName, o = []; t !== null && t !== r; ) {
    var a = t,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      i
        ? ((l = sg(t, s)), l != null && o.unshift(fg(t, l, a)))
        : i || ((l = sg(t, s)), l != null && o.push(fg(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var BW = /\r\n?/g,
  VW = /\u0000|\uFFFD/g;
function jP(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      BW,
      `
`
    )
    .replace(VW, "");
}
function Lv(n, e, t) {
  if (((e = jP(e)), jP(n) !== e && t)) throw Error(rt(425));
}
function Xx() {}
var uE = null,
  dE = null;
function fE(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var hE = typeof setTimeout == "function" ? setTimeout : void 0,
  HW = typeof clearTimeout == "function" ? clearTimeout : void 0,
  $P = typeof Promise == "function" ? Promise : void 0,
  GW =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof $P < "u"
      ? function (n) {
          return $P.resolve(null).then(n).catch(WW);
        }
      : hE;
function WW(n) {
  setTimeout(function () {
    throw n;
  });
}
function BA(n, e) {
  var t = e,
    r = 0;
  do {
    var i = t.nextSibling;
    if ((n.removeChild(t), i && i.nodeType === 8))
      if (((t = i.data), t === "/$")) {
        if (r === 0) {
          n.removeChild(i), lg(e);
          return;
        }
        r--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || r++;
    t = i;
  } while (t);
  lg(e);
}
function Nc(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function XP(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var tp = Math.random().toString(36).slice(2),
  za = "__reactFiber$" + tp,
  hg = "__reactProps$" + tp,
  Il = "__reactContainer$" + tp,
  pE = "__reactEvents$" + tp,
  jW = "__reactListeners$" + tp,
  $W = "__reactHandles$" + tp;
function Gu(n) {
  var e = n[za];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Il] || t[za])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = XP(n); n !== null; ) {
          if ((t = n[za])) return t;
          n = XP(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function a0(n) {
  return (
    (n = n[za] || n[Il]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function $f(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(rt(33));
}
function Q1(n) {
  return n[hg] || null;
}
var mE = [],
  Xf = -1;
function Kc(n) {
  return { current: n };
}
function Gn(n) {
  0 > Xf || ((n.current = mE[Xf]), (mE[Xf] = null), Xf--);
}
function zn(n, e) {
  Xf++, (mE[Xf] = n.current), (n.current = e);
}
var kc = {},
  Vi = Kc(kc),
  _s = Kc(!1),
  pd = kc;
function Ch(n, e) {
  var t = n.type.contextTypes;
  if (!t) return kc;
  var r = n.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in t) i[s] = e[s];
  return (
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function Ss(n) {
  return (n = n.childContextTypes), n != null;
}
function Yx() {
  Gn(_s), Gn(Vi);
}
function YP(n, e, t) {
  if (Vi.current !== kc) throw Error(rt(168));
  zn(Vi, e), zn(_s, t);
}
function JF(n, e, t) {
  var r = n.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return t;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(rt(108, NG(n) || "Unknown", i));
  return ir({}, t, r);
}
function qx(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || kc),
    (pd = Vi.current),
    zn(Vi, n),
    zn(_s, _s.current),
    !0
  );
}
function qP(n, e, t) {
  var r = n.stateNode;
  if (!r) throw Error(rt(169));
  t
    ? ((n = JF(n, e, pd)),
      (r.__reactInternalMemoizedMergedChildContext = n),
      Gn(_s),
      Gn(Vi),
      zn(Vi, n))
    : Gn(_s),
    zn(_s, t);
}
var xl = null,
  J1 = !1,
  VA = !1;
function eU(n) {
  xl === null ? (xl = [n]) : xl.push(n);
}
function XW(n) {
  (J1 = !0), eU(n);
}
function Zc() {
  if (!VA && xl !== null) {
    VA = !0;
    var n = 0,
      e = En;
    try {
      var t = xl;
      for (En = 1; n < t.length; n++) {
        var r = t[n];
        do r = r(!0);
        while (r !== null);
      }
      (xl = null), (J1 = !1);
    } catch (i) {
      throw (xl !== null && (xl = xl.slice(n + 1)), EF(rC, Zc), i);
    } finally {
      (En = e), (VA = !1);
    }
  }
  return null;
}
var Yf = [],
  qf = 0,
  Kx = null,
  Zx = 0,
  Po = [],
  Io = 0,
  md = null,
  bl = 1,
  El = "";
function Iu(n, e) {
  (Yf[qf++] = Zx), (Yf[qf++] = Kx), (Kx = n), (Zx = e);
}
function tU(n, e, t) {
  (Po[Io++] = bl), (Po[Io++] = El), (Po[Io++] = md), (md = n);
  var r = bl;
  n = El;
  var i = 32 - ua(r) - 1;
  (r &= ~(1 << i)), (t += 1);
  var s = 32 - ua(e) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (bl = (1 << (32 - ua(e) + i)) | (t << i) | r),
      (El = s + n);
  } else (bl = (1 << s) | (t << i) | r), (El = n);
}
function fC(n) {
  n.return !== null && (Iu(n, 1), tU(n, 1, 0));
}
function hC(n) {
  for (; n === Kx; )
    (Kx = Yf[--qf]), (Yf[qf] = null), (Zx = Yf[--qf]), (Yf[qf] = null);
  for (; n === md; )
    (md = Po[--Io]),
      (Po[Io] = null),
      (El = Po[--Io]),
      (Po[Io] = null),
      (bl = Po[--Io]),
      (Po[Io] = null);
}
var ro = null,
  Ks = null,
  Xn = !1,
  oa = null;
function nU(n, e) {
  var t = Lo(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function KP(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (ro = n), (Ks = Nc(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (ro = n), (Ks = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = md !== null ? { id: bl, overflow: El } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Lo(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (ro = n),
            (Ks = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function gE(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function vE(n) {
  if (Xn) {
    var e = Ks;
    if (e) {
      var t = e;
      if (!KP(n, e)) {
        if (gE(n)) throw Error(rt(418));
        e = Nc(t.nextSibling);
        var r = ro;
        e && KP(n, e)
          ? nU(r, t)
          : ((n.flags = (n.flags & -4097) | 2), (Xn = !1), (ro = n));
      }
    } else {
      if (gE(n)) throw Error(rt(418));
      (n.flags = (n.flags & -4097) | 2), (Xn = !1), (ro = n);
    }
  }
}
function ZP(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  ro = n;
}
function Ov(n) {
  if (n !== ro) return !1;
  if (!Xn) return ZP(n), (Xn = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !fE(n.type, n.memoizedProps))),
    e && (e = Ks))
  ) {
    if (gE(n)) throw (rU(), Error(rt(418)));
    for (; e; ) nU(n, e), (e = Nc(e.nextSibling));
  }
  if ((ZP(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(rt(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Ks = Nc(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      Ks = null;
    }
  } else Ks = ro ? Nc(n.stateNode.nextSibling) : null;
  return !0;
}
function rU() {
  for (var n = Ks; n; ) n = Nc(n.nextSibling);
}
function Rh() {
  (Ks = ro = null), (Xn = !1);
}
function pC(n) {
  oa === null ? (oa = [n]) : oa.push(n);
}
var YW = Hl.ReactCurrentBatchConfig;
function em(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(rt(309));
        var r = t.stateNode;
      }
      if (!r) throw Error(rt(147, n));
      var i = r,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = i.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(rt(284));
    if (!t._owner) throw Error(rt(290, n));
  }
  return n;
}
function Dv(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      rt(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function QP(n) {
  var e = n._init;
  return e(n._payload);
}
function iU(n) {
  function e(v, _) {
    if (n) {
      var S = v.deletions;
      S === null ? ((v.deletions = [_]), (v.flags |= 16)) : S.push(_);
    }
  }
  function t(v, _) {
    if (!n) return null;
    for (; _ !== null; ) e(v, _), (_ = _.sibling);
    return null;
  }
  function r(v, _) {
    for (v = new Map(); _ !== null; )
      _.key !== null ? v.set(_.key, _) : v.set(_.index, _), (_ = _.sibling);
    return v;
  }
  function i(v, _) {
    return (v = Oc(v, _)), (v.index = 0), (v.sibling = null), v;
  }
  function s(v, _, S) {
    return (
      (v.index = S),
      n
        ? ((S = v.alternate),
          S !== null
            ? ((S = S.index), S < _ ? ((v.flags |= 2), _) : S)
            : ((v.flags |= 2), _))
        : ((v.flags |= 1048576), _)
    );
  }
  function o(v) {
    return n && v.alternate === null && (v.flags |= 2), v;
  }
  function a(v, _, S, w) {
    return _ === null || _.tag !== 6
      ? ((_ = YA(S, v.mode, w)), (_.return = v), _)
      : ((_ = i(_, S)), (_.return = v), _);
  }
  function l(v, _, S, w) {
    var T = S.type;
    return T === Hf
      ? u(v, _, S.props.children, w, S.key)
      : _ !== null &&
        (_.elementType === T ||
          (typeof T == "object" &&
            T !== null &&
            T.$$typeof === hc &&
            QP(T) === _.type))
      ? ((w = i(_, S.props)), (w.ref = em(v, _, S)), (w.return = v), w)
      : ((w = px(S.type, S.key, S.props, null, v.mode, w)),
        (w.ref = em(v, _, S)),
        (w.return = v),
        w);
  }
  function c(v, _, S, w) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== S.containerInfo ||
      _.stateNode.implementation !== S.implementation
      ? ((_ = qA(S, v.mode, w)), (_.return = v), _)
      : ((_ = i(_, S.children || [])), (_.return = v), _);
  }
  function u(v, _, S, w, T) {
    return _ === null || _.tag !== 7
      ? ((_ = rd(S, v.mode, w, T)), (_.return = v), _)
      : ((_ = i(_, S)), (_.return = v), _);
  }
  function d(v, _, S) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = YA("" + _, v.mode, S)), (_.return = v), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case bv:
          return (
            (S = px(_.type, _.key, _.props, null, v.mode, S)),
            (S.ref = em(v, null, _)),
            (S.return = v),
            S
          );
        case Vf:
          return (_ = qA(_, v.mode, S)), (_.return = v), _;
        case hc:
          var w = _._init;
          return d(v, w(_._payload), S);
      }
      if (Em(_) || qp(_))
        return (_ = rd(_, v.mode, S, null)), (_.return = v), _;
      Dv(v, _);
    }
    return null;
  }
  function h(v, _, S, w) {
    var T = _ !== null ? _.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return T !== null ? null : a(v, _, "" + S, w);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case bv:
          return S.key === T ? l(v, _, S, w) : null;
        case Vf:
          return S.key === T ? c(v, _, S, w) : null;
        case hc:
          return (T = S._init), h(v, _, T(S._payload), w);
      }
      if (Em(S) || qp(S)) return T !== null ? null : u(v, _, S, w, null);
      Dv(v, S);
    }
    return null;
  }
  function m(v, _, S, w, T) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (v = v.get(S) || null), a(_, v, "" + w, T);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case bv:
          return (v = v.get(w.key === null ? S : w.key) || null), l(_, v, w, T);
        case Vf:
          return (v = v.get(w.key === null ? S : w.key) || null), c(_, v, w, T);
        case hc:
          var E = w._init;
          return m(v, _, S, E(w._payload), T);
      }
      if (Em(w) || qp(w)) return (v = v.get(S) || null), u(_, v, w, T, null);
      Dv(_, w);
    }
    return null;
  }
  function g(v, _, S, w) {
    for (
      var T = null, E = null, M = _, N = (_ = 0), R = null;
      M !== null && N < S.length;
      N++
    ) {
      M.index > N ? ((R = M), (M = null)) : (R = M.sibling);
      var C = h(v, M, S[N], w);
      if (C === null) {
        M === null && (M = R);
        break;
      }
      n && M && C.alternate === null && e(v, M),
        (_ = s(C, _, N)),
        E === null ? (T = C) : (E.sibling = C),
        (E = C),
        (M = R);
    }
    if (N === S.length) return t(v, M), Xn && Iu(v, N), T;
    if (M === null) {
      for (; N < S.length; N++)
        (M = d(v, S[N], w)),
          M !== null &&
            ((_ = s(M, _, N)), E === null ? (T = M) : (E.sibling = M), (E = M));
      return Xn && Iu(v, N), T;
    }
    for (M = r(v, M); N < S.length; N++)
      (R = m(M, v, N, S[N], w)),
        R !== null &&
          (n && R.alternate !== null && M.delete(R.key === null ? N : R.key),
          (_ = s(R, _, N)),
          E === null ? (T = R) : (E.sibling = R),
          (E = R));
    return (
      n &&
        M.forEach(function (L) {
          return e(v, L);
        }),
      Xn && Iu(v, N),
      T
    );
  }
  function x(v, _, S, w) {
    var T = qp(S);
    if (typeof T != "function") throw Error(rt(150));
    if (((S = T.call(S)), S == null)) throw Error(rt(151));
    for (
      var E = (T = null), M = _, N = (_ = 0), R = null, C = S.next();
      M !== null && !C.done;
      N++, C = S.next()
    ) {
      M.index > N ? ((R = M), (M = null)) : (R = M.sibling);
      var L = h(v, M, C.value, w);
      if (L === null) {
        M === null && (M = R);
        break;
      }
      n && M && L.alternate === null && e(v, M),
        (_ = s(L, _, N)),
        E === null ? (T = L) : (E.sibling = L),
        (E = L),
        (M = R);
    }
    if (C.done) return t(v, M), Xn && Iu(v, N), T;
    if (M === null) {
      for (; !C.done; N++, C = S.next())
        (C = d(v, C.value, w)),
          C !== null &&
            ((_ = s(C, _, N)), E === null ? (T = C) : (E.sibling = C), (E = C));
      return Xn && Iu(v, N), T;
    }
    for (M = r(v, M); !C.done; N++, C = S.next())
      (C = m(M, v, N, C.value, w)),
        C !== null &&
          (n && C.alternate !== null && M.delete(C.key === null ? N : C.key),
          (_ = s(C, _, N)),
          E === null ? (T = C) : (E.sibling = C),
          (E = C));
    return (
      n &&
        M.forEach(function (O) {
          return e(v, O);
        }),
      Xn && Iu(v, N),
      T
    );
  }
  function y(v, _, S, w) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === Hf &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case bv:
          e: {
            for (var T = S.key, E = _; E !== null; ) {
              if (E.key === T) {
                if (((T = S.type), T === Hf)) {
                  if (E.tag === 7) {
                    t(v, E.sibling),
                      (_ = i(E, S.props.children)),
                      (_.return = v),
                      (v = _);
                    break e;
                  }
                } else if (
                  E.elementType === T ||
                  (typeof T == "object" &&
                    T !== null &&
                    T.$$typeof === hc &&
                    QP(T) === E.type)
                ) {
                  t(v, E.sibling),
                    (_ = i(E, S.props)),
                    (_.ref = em(v, E, S)),
                    (_.return = v),
                    (v = _);
                  break e;
                }
                t(v, E);
                break;
              } else e(v, E);
              E = E.sibling;
            }
            S.type === Hf
              ? ((_ = rd(S.props.children, v.mode, w, S.key)),
                (_.return = v),
                (v = _))
              : ((w = px(S.type, S.key, S.props, null, v.mode, w)),
                (w.ref = em(v, _, S)),
                (w.return = v),
                (v = w));
          }
          return o(v);
        case Vf:
          e: {
            for (E = S.key; _ !== null; ) {
              if (_.key === E)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === S.containerInfo &&
                  _.stateNode.implementation === S.implementation
                ) {
                  t(v, _.sibling),
                    (_ = i(_, S.children || [])),
                    (_.return = v),
                    (v = _);
                  break e;
                } else {
                  t(v, _);
                  break;
                }
              else e(v, _);
              _ = _.sibling;
            }
            (_ = qA(S, v.mode, w)), (_.return = v), (v = _);
          }
          return o(v);
        case hc:
          return (E = S._init), y(v, _, E(S._payload), w);
      }
      if (Em(S)) return g(v, _, S, w);
      if (qp(S)) return x(v, _, S, w);
      Dv(v, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        _ !== null && _.tag === 6
          ? (t(v, _.sibling), (_ = i(_, S)), (_.return = v), (v = _))
          : (t(v, _), (_ = YA(S, v.mode, w)), (_.return = v), (v = _)),
        o(v))
      : t(v, _);
  }
  return y;
}
var Nh = iU(!0),
  sU = iU(!1),
  Qx = Kc(null),
  Jx = null,
  Kf = null,
  mC = null;
function gC() {
  mC = Kf = Jx = null;
}
function vC(n) {
  var e = Qx.current;
  Gn(Qx), (n._currentValue = e);
}
function yE(n, e, t) {
  for (; n !== null; ) {
    var r = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function gh(n, e) {
  (Jx = n),
    (mC = Kf = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (vs = !0), (n.firstContext = null));
}
function ko(n) {
  var e = n._currentValue;
  if (mC !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Kf === null)) {
      if (Jx === null) throw Error(rt(308));
      (Kf = n), (Jx.dependencies = { lanes: 0, firstContext: n });
    } else Kf = Kf.next = n;
  return e;
}
var Wu = null;
function yC(n) {
  Wu === null ? (Wu = [n]) : Wu.push(n);
}
function oU(n, e, t, r) {
  var i = e.interleaved;
  return (
    i === null ? ((t.next = t), yC(e)) : ((t.next = i.next), (i.next = t)),
    (e.interleaved = t),
    Ll(n, r)
  );
}
function Ll(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var pc = !1;
function xC(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function aU(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function Tl(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Pc(n, e, t) {
  var r = n.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), mn & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Ll(n, t)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), yC(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Ll(n, t)
  );
}
function lx(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), iC(n, t);
  }
}
function JP(n, e) {
  var t = n.updateQueue,
    r = n.alternate;
  if (r !== null && ((r = r.updateQueue), t === r)) {
    var i = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (i = s = e) : (s = s.next = e);
    } else i = s = e;
    (t = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function e1(n, e, t, r) {
  var i = n.updateQueue;
  pc = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var u = n.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = i.baseState;
    (o = 0), (u = c = l = null), (a = s);
    do {
      var h = a.lane,
        m = a.eventTime;
      if ((r & h) === h) {
        u !== null &&
          (u = u.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var g = n,
            x = a;
          switch (((h = e), (m = t), x.tag)) {
            case 1:
              if (((g = x.payload), typeof g == "function")) {
                d = g.call(m, d, h);
                break e;
              }
              d = g;
              break e;
            case 3:
              g.flags = (g.flags & -65537) | 128;
            case 0:
              if (
                ((g = x.payload),
                (h = typeof g == "function" ? g.call(m, d, h) : g),
                h == null)
              )
                break e;
              d = ir({}, d, h);
              break e;
            case 2:
              pc = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (h = i.effects),
          h === null ? (i.effects = [a]) : h.push(a));
      } else
        (m = {
          eventTime: m,
          lane: h,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = m), (l = d)) : (u = u.next = m),
          (o |= h);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (h = a),
          (a = h.next),
          (h.next = null),
          (i.lastBaseUpdate = h),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = d),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (o |= i.lane), (i = i.next);
      while (i !== e);
    } else s === null && (i.shared.lanes = 0);
    (vd |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function e3(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var r = n[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = t), typeof i != "function"))
          throw Error(rt(191, i));
        i.call(r);
      }
    }
}
var l0 = {},
  Ga = Kc(l0),
  pg = Kc(l0),
  mg = Kc(l0);
function ju(n) {
  if (n === l0) throw Error(rt(174));
  return n;
}
function _C(n, e) {
  switch ((zn(mg, e), zn(pg, n), zn(Ga, l0), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : Qb(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = Qb(e, n));
  }
  Gn(Ga), zn(Ga, e);
}
function Ph() {
  Gn(Ga), Gn(pg), Gn(mg);
}
function lU(n) {
  ju(mg.current);
  var e = ju(Ga.current),
    t = Qb(e, n.type);
  e !== t && (zn(pg, n), zn(Ga, t));
}
function SC(n) {
  pg.current === n && (Gn(Ga), Gn(pg));
}
var Jn = Kc(0);
function t1(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var HA = [];
function AC() {
  for (var n = 0; n < HA.length; n++)
    HA[n]._workInProgressVersionPrimary = null;
  HA.length = 0;
}
var cx = Hl.ReactCurrentDispatcher,
  GA = Hl.ReactCurrentBatchConfig,
  gd = 0,
  rr = null,
  Hr = null,
  ni = null,
  n1 = !1,
  zm = !1,
  gg = 0,
  qW = 0;
function Ni() {
  throw Error(rt(321));
}
function wC(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!ga(n[t], e[t])) return !1;
  return !0;
}
function bC(n, e, t, r, i, s) {
  if (
    ((gd = s),
    (rr = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (cx.current = n === null || n.memoizedState === null ? JW : e9),
    (n = t(r, i)),
    zm)
  ) {
    s = 0;
    do {
      if (((zm = !1), (gg = 0), 25 <= s)) throw Error(rt(301));
      (s += 1),
        (ni = Hr = null),
        (e.updateQueue = null),
        (cx.current = t9),
        (n = t(r, i));
    } while (zm);
  }
  if (
    ((cx.current = r1),
    (e = Hr !== null && Hr.next !== null),
    (gd = 0),
    (ni = Hr = rr = null),
    (n1 = !1),
    e)
  )
    throw Error(rt(300));
  return n;
}
function EC() {
  var n = gg !== 0;
  return (gg = 0), n;
}
function La() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return ni === null ? (rr.memoizedState = ni = n) : (ni = ni.next = n), ni;
}
function zo() {
  if (Hr === null) {
    var n = rr.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Hr.next;
  var e = ni === null ? rr.memoizedState : ni.next;
  if (e !== null) (ni = e), (Hr = n);
  else {
    if (n === null) throw Error(rt(310));
    (Hr = n),
      (n = {
        memoizedState: Hr.memoizedState,
        baseState: Hr.baseState,
        baseQueue: Hr.baseQueue,
        queue: Hr.queue,
        next: null,
      }),
      ni === null ? (rr.memoizedState = ni = n) : (ni = ni.next = n);
  }
  return ni;
}
function vg(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function WA(n) {
  var e = zo(),
    t = e.queue;
  if (t === null) throw Error(rt(311));
  t.lastRenderedReducer = n;
  var r = Hr,
    i = r.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (t.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((gd & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : n(r, c.action));
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = r)) : (l = l.next = d),
          (rr.lanes |= u),
          (vd |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = r) : (l.next = a),
      ga(r, e.memoizedState) || (vs = !0),
      (e.memoizedState = r),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = r);
  }
  if (((n = t.interleaved), n !== null)) {
    i = n;
    do (s = i.lane), (rr.lanes |= s), (vd |= s), (i = i.next);
    while (i !== n);
  } else i === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function jA(n) {
  var e = zo(),
    t = e.queue;
  if (t === null) throw Error(rt(311));
  t.lastRenderedReducer = n;
  var r = t.dispatch,
    i = t.pending,
    s = e.memoizedState;
  if (i !== null) {
    t.pending = null;
    var o = (i = i.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== i);
    ga(s, e.memoizedState) || (vs = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, r];
}
function cU() {}
function uU(n, e) {
  var t = rr,
    r = zo(),
    i = e(),
    s = !ga(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (vs = !0)),
    (r = r.queue),
    MC(hU.bind(null, t, r, n), [n]),
    r.getSnapshot !== e || s || (ni !== null && ni.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      yg(9, fU.bind(null, t, r, i, e), void 0, null),
      si === null)
    )
      throw Error(rt(349));
    gd & 30 || dU(t, e, i);
  }
  return i;
}
function dU(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = rr.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (rr.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function fU(n, e, t, r) {
  (e.value = t), (e.getSnapshot = r), pU(e) && mU(n);
}
function hU(n, e, t) {
  return t(function () {
    pU(e) && mU(n);
  });
}
function pU(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !ga(n, t);
  } catch {
    return !0;
  }
}
function mU(n) {
  var e = Ll(n, 1);
  e !== null && da(e, n, 1, -1);
}
function t3(n) {
  var e = La();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: vg,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = QW.bind(null, rr, n)),
    [e.memoizedState, n]
  );
}
function yg(n, e, t, r) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: r, next: null }),
    (e = rr.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (rr.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((r = t.next), (t.next = n), (n.next = r), (e.lastEffect = n))),
    n
  );
}
function gU() {
  return zo().memoizedState;
}
function ux(n, e, t, r) {
  var i = La();
  (rr.flags |= n),
    (i.memoizedState = yg(1 | e, t, void 0, r === void 0 ? null : r));
}
function e_(n, e, t, r) {
  var i = zo();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (Hr !== null) {
    var o = Hr.memoizedState;
    if (((s = o.destroy), r !== null && wC(r, o.deps))) {
      i.memoizedState = yg(e, t, s, r);
      return;
    }
  }
  (rr.flags |= n), (i.memoizedState = yg(1 | e, t, s, r));
}
function n3(n, e) {
  return ux(8390656, 8, n, e);
}
function MC(n, e) {
  return e_(2048, 8, n, e);
}
function vU(n, e) {
  return e_(4, 2, n, e);
}
function yU(n, e) {
  return e_(4, 4, n, e);
}
function xU(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function _U(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), e_(4, 4, xU.bind(null, e, n), t)
  );
}
function TC() {}
function SU(n, e) {
  var t = zo();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && wC(e, r[1])
    ? r[0]
    : ((t.memoizedState = [n, e]), n);
}
function AU(n, e) {
  var t = zo();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && wC(e, r[1])
    ? r[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function wU(n, e, t) {
  return gd & 21
    ? (ga(t, e) || ((t = CF()), (rr.lanes |= t), (vd |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (vs = !0)), (n.memoizedState = t));
}
function KW(n, e) {
  var t = En;
  (En = t !== 0 && 4 > t ? t : 4), n(!0);
  var r = GA.transition;
  GA.transition = {};
  try {
    n(!1), e();
  } finally {
    (En = t), (GA.transition = r);
  }
}
function bU() {
  return zo().memoizedState;
}
function ZW(n, e, t) {
  var r = Lc(n);
  if (
    ((t = {
      lane: r,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    EU(n))
  )
    MU(e, t);
  else if (((t = oU(n, e, t, r)), t !== null)) {
    var i = es();
    da(t, n, r, i), TU(t, e, r);
  }
}
function QW(n, e, t) {
  var r = Lc(n),
    i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (EU(n)) MU(e, i);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((i.hasEagerState = !0), (i.eagerState = a), ga(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), yC(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (t = oU(n, e, i, r)),
      t !== null && ((i = es()), da(t, n, r, i), TU(t, e, r));
  }
}
function EU(n) {
  var e = n.alternate;
  return n === rr || (e !== null && e === rr);
}
function MU(n, e) {
  zm = n1 = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function TU(n, e, t) {
  if (t & 4194240) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), iC(n, t);
  }
}
var r1 = {
    readContext: ko,
    useCallback: Ni,
    useContext: Ni,
    useEffect: Ni,
    useImperativeHandle: Ni,
    useInsertionEffect: Ni,
    useLayoutEffect: Ni,
    useMemo: Ni,
    useReducer: Ni,
    useRef: Ni,
    useState: Ni,
    useDebugValue: Ni,
    useDeferredValue: Ni,
    useTransition: Ni,
    useMutableSource: Ni,
    useSyncExternalStore: Ni,
    useId: Ni,
    unstable_isNewReconciler: !1,
  },
  JW = {
    readContext: ko,
    useCallback: function (n, e) {
      return (La().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: ko,
    useEffect: n3,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        ux(4194308, 4, xU.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return ux(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return ux(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = La();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var r = La();
      return (
        (e = t !== void 0 ? t(e) : e),
        (r.memoizedState = r.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (r.queue = n),
        (n = n.dispatch = ZW.bind(null, rr, n)),
        [r.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = La();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: t3,
    useDebugValue: TC,
    useDeferredValue: function (n) {
      return (La().memoizedState = n);
    },
    useTransition: function () {
      var n = t3(!1),
        e = n[0];
      return (n = KW.bind(null, n[1])), (La().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var r = rr,
        i = La();
      if (Xn) {
        if (t === void 0) throw Error(rt(407));
        t = t();
      } else {
        if (((t = e()), si === null)) throw Error(rt(349));
        gd & 30 || dU(r, e, t);
      }
      i.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (i.queue = s),
        n3(hU.bind(null, r, s, n), [n]),
        (r.flags |= 2048),
        yg(9, fU.bind(null, r, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = La(),
        e = si.identifierPrefix;
      if (Xn) {
        var t = El,
          r = bl;
        (t = (r & ~(1 << (32 - ua(r) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = gg++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = qW++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  e9 = {
    readContext: ko,
    useCallback: SU,
    useContext: ko,
    useEffect: MC,
    useImperativeHandle: _U,
    useInsertionEffect: vU,
    useLayoutEffect: yU,
    useMemo: AU,
    useReducer: WA,
    useRef: gU,
    useState: function () {
      return WA(vg);
    },
    useDebugValue: TC,
    useDeferredValue: function (n) {
      var e = zo();
      return wU(e, Hr.memoizedState, n);
    },
    useTransition: function () {
      var n = WA(vg)[0],
        e = zo().memoizedState;
      return [n, e];
    },
    useMutableSource: cU,
    useSyncExternalStore: uU,
    useId: bU,
    unstable_isNewReconciler: !1,
  },
  t9 = {
    readContext: ko,
    useCallback: SU,
    useContext: ko,
    useEffect: MC,
    useImperativeHandle: _U,
    useInsertionEffect: vU,
    useLayoutEffect: yU,
    useMemo: AU,
    useReducer: jA,
    useRef: gU,
    useState: function () {
      return jA(vg);
    },
    useDebugValue: TC,
    useDeferredValue: function (n) {
      var e = zo();
      return Hr === null ? (e.memoizedState = n) : wU(e, Hr.memoizedState, n);
    },
    useTransition: function () {
      var n = jA(vg)[0],
        e = zo().memoizedState;
      return [n, e];
    },
    useMutableSource: cU,
    useSyncExternalStore: uU,
    useId: bU,
    unstable_isNewReconciler: !1,
  };
function ea(n, e) {
  if (n && n.defaultProps) {
    (e = ir({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
function xE(n, e, t, r) {
  (e = n.memoizedState),
    (t = t(r, e)),
    (t = t == null ? e : ir({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var t_ = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? Pd(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var r = es(),
      i = Lc(n),
      s = Tl(r, i);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = Pc(n, s, i)),
      e !== null && (da(e, n, i, r), lx(e, n, i));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var r = es(),
      i = Lc(n),
      s = Tl(r, i);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = Pc(n, s, i)),
      e !== null && (da(e, n, i, r), lx(e, n, i));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = es(),
      r = Lc(n),
      i = Tl(t, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = Pc(n, i, r)),
      e !== null && (da(e, n, r, t), lx(e, n, r));
  },
};
function r3(n, e, t, r, i, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(r, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !ug(t, r) || !ug(i, s)
      : !0
  );
}
function CU(n, e, t) {
  var r = !1,
    i = kc,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = ko(s))
      : ((i = Ss(e) ? pd : Vi.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? Ch(n, i) : kc)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = t_),
    (n.stateNode = e),
    (e._reactInternals = n),
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = i),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function i3(n, e, t, r) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, r),
    e.state !== n && t_.enqueueReplaceState(e, e.state, null);
}
function _E(n, e, t, r) {
  var i = n.stateNode;
  (i.props = t), (i.state = n.memoizedState), (i.refs = {}), xC(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (i.context = ko(s))
    : ((s = Ss(e) ? pd : Vi.current), (i.context = Ch(n, s))),
    (i.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (xE(n, e, s, t), (i.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && t_.enqueueReplaceState(i, i.state, null),
      e1(n, t, i, r),
      (i.state = n.memoizedState)),
    typeof i.componentDidMount == "function" && (n.flags |= 4194308);
}
function Ih(n, e) {
  try {
    var t = "",
      r = e;
    do (t += RG(r)), (r = r.return);
    while (r);
    var i = t;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: i, digest: null };
}
function $A(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function SE(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var n9 = typeof WeakMap == "function" ? WeakMap : Map;
function RU(n, e, t) {
  (t = Tl(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var r = e.value;
  return (
    (t.callback = function () {
      s1 || ((s1 = !0), (PE = r)), SE(n, e);
    }),
    t
  );
}
function NU(n, e, t) {
  (t = Tl(-1, t)), (t.tag = 3);
  var r = n.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (t.payload = function () {
      return r(i);
    }),
      (t.callback = function () {
        SE(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        SE(n, e),
          typeof r != "function" &&
            (Ic === null ? (Ic = new Set([this])) : Ic.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function s3(n, e, t) {
  var r = n.pingCache;
  if (r === null) {
    r = n.pingCache = new n9();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(t) || (i.add(t), (n = g9.bind(null, n, e, t)), e.then(n, n));
}
function o3(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function a3(n, e, t, r, i) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = i), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Tl(-1, 1)), (e.tag = 2), Pc(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var r9 = Hl.ReactCurrentOwner,
  vs = !1;
function Qi(n, e, t, r) {
  e.child = n === null ? sU(e, null, t, r) : Nh(e, n.child, t, r);
}
function l3(n, e, t, r, i) {
  t = t.render;
  var s = e.ref;
  return (
    gh(e, i),
    (r = bC(n, e, t, r, s, i)),
    (t = EC()),
    n !== null && !vs
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        Ol(n, e, i))
      : (Xn && t && fC(e), (e.flags |= 1), Qi(n, e, r, i), e.child)
  );
}
function c3(n, e, t, r, i) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !DC(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), PU(n, e, s, r, i))
      : ((n = px(t.type, null, r, e, e.mode, i)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : ug), t(o, r) && n.ref === e.ref)
    )
      return Ol(n, e, i);
  }
  return (
    (e.flags |= 1),
    (n = Oc(s, r)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function PU(n, e, t, r, i) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (ug(s, r) && n.ref === e.ref)
      if (((vs = !1), (e.pendingProps = r = s), (n.lanes & i) !== 0))
        n.flags & 131072 && (vs = !0);
      else return (e.lanes = n.lanes), Ol(n, e, i);
  }
  return AE(n, e, t, r, i);
}
function IU(n, e, t) {
  var r = e.pendingProps,
    i = r.children,
    s = n !== null ? n.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        zn(Qf, $s),
        ($s |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          zn(Qf, $s),
          ($s |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : t),
        zn(Qf, $s),
        ($s |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | t), (e.memoizedState = null)) : (r = t),
      zn(Qf, $s),
      ($s |= r);
  return Qi(n, e, i, t), e.child;
}
function LU(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function AE(n, e, t, r, i) {
  var s = Ss(t) ? pd : Vi.current;
  return (
    (s = Ch(e, s)),
    gh(e, i),
    (t = bC(n, e, t, r, s, i)),
    (r = EC()),
    n !== null && !vs
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        Ol(n, e, i))
      : (Xn && r && fC(e), (e.flags |= 1), Qi(n, e, t, i), e.child)
  );
}
function u3(n, e, t, r, i) {
  if (Ss(t)) {
    var s = !0;
    qx(e);
  } else s = !1;
  if ((gh(e, i), e.stateNode === null))
    dx(n, e), CU(e, t, r), _E(e, t, r, i), (r = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      c = t.contextType;
    typeof c == "object" && c !== null
      ? (c = ko(c))
      : ((c = Ss(t) ? pd : Vi.current), (c = Ch(e, c)));
    var u = t.getDerivedStateFromProps,
      d =
        typeof u == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || l !== c) && i3(e, o, r, c)),
      (pc = !1);
    var h = e.memoizedState;
    (o.state = h),
      e1(e, r, o, i),
      (l = e.memoizedState),
      a !== r || h !== l || _s.current || pc
        ? (typeof u == "function" && (xE(e, t, u, r), (l = e.memoizedState)),
          (a = pc || r3(e, t, a, r, h, l, c))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = c),
          (r = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (o = e.stateNode),
      aU(n, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : ea(e.type, a)),
      (o.props = c),
      (d = e.pendingProps),
      (h = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = ko(l))
        : ((l = Ss(t) ? pd : Vi.current), (l = Ch(e, l)));
    var m = t.getDerivedStateFromProps;
    (u =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || h !== l) && i3(e, o, r, l)),
      (pc = !1),
      (h = e.memoizedState),
      (o.state = h),
      e1(e, r, o, i);
    var g = e.memoizedState;
    a !== d || h !== g || _s.current || pc
      ? (typeof m == "function" && (xE(e, t, m, r), (g = e.memoizedState)),
        (c = pc || r3(e, t, c, r, h, g, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, g, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, g, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && h === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && h === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = g)),
        (o.props = r),
        (o.state = g),
        (o.context = l),
        (r = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && h === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && h === n.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return wE(n, e, t, r, s, i);
}
function wE(n, e, t, r, i, s) {
  LU(n, e);
  var o = (e.flags & 128) !== 0;
  if (!r && !o) return i && qP(e, t, !1), Ol(n, e, s);
  (r = e.stateNode), (r9.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = Nh(e, n.child, null, s)), (e.child = Nh(e, null, a, s)))
      : Qi(n, e, a, s),
    (e.memoizedState = r.state),
    i && qP(e, t, !0),
    e.child
  );
}
function OU(n) {
  var e = n.stateNode;
  e.pendingContext
    ? YP(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && YP(n, e.context, !1),
    _C(n, e.containerInfo);
}
function d3(n, e, t, r, i) {
  return Rh(), pC(i), (e.flags |= 256), Qi(n, e, t, r), e.child;
}
var bE = { dehydrated: null, treeContext: null, retryLane: 0 };
function EE(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function DU(n, e, t) {
  var r = e.pendingProps,
    i = Jn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (i |= 1),
    zn(Jn, i & 1),
    n === null)
  )
    return (
      vE(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = r.children),
          (n = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = i_(o, r, 0, null)),
              (n = rd(n, r, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = EE(t)),
              (e.memoizedState = bE),
              n)
            : CC(e, o))
    );
  if (((i = n.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return i9(n, e, o, r, a, i, t);
  if (s) {
    (s = r.fallback), (o = e.mode), (i = n.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = Oc(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = Oc(a, s)) : ((s = rd(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? EE(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = bE),
      r
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (r = Oc(s, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = t),
    (r.return = e),
    (r.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function CC(n, e) {
  return (
    (e = i_({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Fv(n, e, t, r) {
  return (
    r !== null && pC(r),
    Nh(e, n.child, null, t),
    (n = CC(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function i9(n, e, t, r, i, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (r = $A(Error(rt(422)))), Fv(n, e, o, r))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = r.fallback),
        (i = e.mode),
        (r = i_({ mode: "visible", children: r.children }, i, 0, null)),
        (s = rd(s, i, o, null)),
        (s.flags |= 2),
        (r.return = e),
        (s.return = e),
        (r.sibling = s),
        (e.child = r),
        e.mode & 1 && Nh(e, n.child, null, o),
        (e.child.memoizedState = EE(o)),
        (e.memoizedState = bE),
        s);
  if (!(e.mode & 1)) return Fv(n, e, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (s = Error(rt(419))), (r = $A(s, r, void 0)), Fv(n, e, o, r)
    );
  }
  if (((a = (o & n.childLanes) !== 0), vs || a)) {
    if (((r = si), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), Ll(n, i), da(r, n, i, -1));
    }
    return OC(), (r = $A(Error(rt(421)))), Fv(n, e, o, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = v9.bind(null, n)),
      (i._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (Ks = Nc(i.nextSibling)),
      (ro = e),
      (Xn = !0),
      (oa = null),
      n !== null &&
        ((Po[Io++] = bl),
        (Po[Io++] = El),
        (Po[Io++] = md),
        (bl = n.id),
        (El = n.overflow),
        (md = e)),
      (e = CC(e, r.children)),
      (e.flags |= 4096),
      e);
}
function f3(n, e, t) {
  n.lanes |= e;
  var r = n.alternate;
  r !== null && (r.lanes |= e), yE(n.return, e, t);
}
function XA(n, e, t, r, i) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = t),
      (s.tailMode = i));
}
function FU(n, e, t) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((Qi(n, e, r.children, t), (r = Jn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && f3(n, t, e);
        else if (n.tag === 19) f3(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    r &= 1;
  }
  if ((zn(Jn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (t = e.child, i = null; t !== null; )
          (n = t.alternate),
            n !== null && t1(n) === null && (i = t),
            (t = t.sibling);
        (t = i),
          t === null
            ? ((i = e.child), (e.child = null))
            : ((i = t.sibling), (t.sibling = null)),
          XA(e, !1, i, t, s);
        break;
      case "backwards":
        for (t = null, i = e.child, e.child = null; i !== null; ) {
          if (((n = i.alternate), n !== null && t1(n) === null)) {
            e.child = i;
            break;
          }
          (n = i.sibling), (i.sibling = t), (t = i), (i = n);
        }
        XA(e, !0, t, null, s);
        break;
      case "together":
        XA(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function dx(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Ol(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (vd |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(rt(153));
  if (e.child !== null) {
    for (
      n = e.child, t = Oc(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = Oc(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function s9(n, e, t) {
  switch (e.tag) {
    case 3:
      OU(e), Rh();
      break;
    case 5:
      lU(e);
      break;
    case 1:
      Ss(e.type) && qx(e);
      break;
    case 4:
      _C(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      zn(Qx, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (zn(Jn, Jn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? DU(n, e, t)
          : (zn(Jn, Jn.current & 1),
            (n = Ol(n, e, t)),
            n !== null ? n.sibling : null);
      zn(Jn, Jn.current & 1);
      break;
    case 19:
      if (((r = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (r) return FU(n, e, t);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        zn(Jn, Jn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), IU(n, e, t);
  }
  return Ol(n, e, t);
}
var UU, ME, kU, zU;
UU = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
ME = function () {};
kU = function (n, e, t, r) {
  var i = n.memoizedProps;
  if (i !== r) {
    (n = e.stateNode), ju(Ga.current);
    var s = null;
    switch (t) {
      case "input":
        (i = Yb(n, i)), (r = Yb(n, r)), (s = []);
        break;
      case "select":
        (i = ir({}, i, { value: void 0 })),
          (r = ir({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = Zb(n, i)), (r = Zb(n, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (n.onclick = Xx);
    }
    Jb(t, r);
    var o;
    t = null;
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === "style") {
          var a = i[c];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (rg.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in r) {
      var l = r[c];
      if (
        ((a = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(c, t)), (t = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (rg.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && Vn("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    t && (s = s || []).push("style", t);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
zU = function (n, e, t, r) {
  t !== r && (e.flags |= 4);
};
function tm(n, e) {
  if (!Xn)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var r = null; t !== null; )
          t.alternate !== null && (r = t), (t = t.sibling);
        r === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (r.sibling = null);
    }
}
function Pi(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    r = 0;
  if (e)
    for (var i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = n),
        (i = i.sibling);
  else
    for (i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = n),
        (i = i.sibling);
  return (n.subtreeFlags |= r), (n.childLanes = t), e;
}
function o9(n, e, t) {
  var r = e.pendingProps;
  switch ((hC(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Pi(e), null;
    case 1:
      return Ss(e.type) && Yx(), Pi(e), null;
    case 3:
      return (
        (r = e.stateNode),
        Ph(),
        Gn(_s),
        Gn(Vi),
        AC(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (n === null || n.child === null) &&
          (Ov(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), oa !== null && (OE(oa), (oa = null)))),
        ME(n, e),
        Pi(e),
        null
      );
    case 5:
      SC(e);
      var i = ju(mg.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        kU(n, e, t, r, i),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(rt(166));
          return Pi(e), null;
        }
        if (((n = ju(Ga.current)), Ov(e))) {
          (r = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((r[za] = e), (r[hg] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              Vn("cancel", r), Vn("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Vn("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < Tm.length; i++) Vn(Tm[i], r);
              break;
            case "source":
              Vn("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Vn("error", r), Vn("load", r);
              break;
            case "details":
              Vn("toggle", r);
              break;
            case "input":
              SP(r, s), Vn("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                Vn("invalid", r);
              break;
            case "textarea":
              wP(r, s), Vn("invalid", r);
          }
          Jb(t, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Lv(r.textContent, a, n),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Lv(r.textContent, a, n),
                    (i = ["children", "" + a]))
                : rg.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Vn("scroll", r);
            }
          switch (t) {
            case "input":
              Ev(r), AP(r, s, !0);
              break;
            case "textarea":
              Ev(r), bP(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = Xx);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = hF(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof r.is == "string"
                ? (n = o.createElement(t, { is: r.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (n = o.createElementNS(n, t)),
            (n[za] = e),
            (n[hg] = r),
            UU(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = eE(t, r)), t)) {
              case "dialog":
                Vn("cancel", n), Vn("close", n), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Vn("load", n), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < Tm.length; i++) Vn(Tm[i], n);
                i = r;
                break;
              case "source":
                Vn("error", n), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Vn("error", n), Vn("load", n), (i = r);
                break;
              case "details":
                Vn("toggle", n), (i = r);
                break;
              case "input":
                SP(n, r), (i = Yb(n, r)), Vn("invalid", n);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = ir({}, r, { value: void 0 })),
                  Vn("invalid", n);
                break;
              case "textarea":
                wP(n, r), (i = Zb(n, r)), Vn("invalid", n);
                break;
              default:
                i = r;
            }
            Jb(t, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? gF(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && pF(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && ig(n, l)
                    : typeof l == "number" && ig(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (rg.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Vn("scroll", n)
                      : l != null && QT(n, s, l, o));
              }
            switch (t) {
              case "input":
                Ev(n), AP(n, r, !1);
                break;
              case "textarea":
                Ev(n), bP(n);
                break;
              case "option":
                r.value != null && n.setAttribute("value", "" + Uc(r.value));
                break;
              case "select":
                (n.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? fh(n, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      fh(n, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (n.onclick = Xx);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return Pi(e), null;
    case 6:
      if (n && e.stateNode != null) zU(n, e, n.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(rt(166));
        if (((t = ju(mg.current)), ju(Ga.current), Ov(e))) {
          if (
            ((r = e.stateNode),
            (t = e.memoizedProps),
            (r[za] = e),
            (s = r.nodeValue !== t) && ((n = ro), n !== null))
          )
            switch (n.tag) {
              case 3:
                Lv(r.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Lv(r.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r)),
            (r[za] = e),
            (e.stateNode = r);
      }
      return Pi(e), null;
    case 13:
      if (
        (Gn(Jn),
        (r = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (Xn && Ks !== null && e.mode & 1 && !(e.flags & 128))
          rU(), Rh(), (e.flags |= 98560), (s = !1);
        else if (((s = Ov(e)), r !== null && r.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(rt(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(rt(317));
            s[za] = e;
          } else
            Rh(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          Pi(e), (s = !1);
        } else oa !== null && (OE(oa), (oa = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((r = r !== null),
          r !== (n !== null && n.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || Jn.current & 1 ? $r === 0 && ($r = 3) : OC())),
          e.updateQueue !== null && (e.flags |= 4),
          Pi(e),
          null);
    case 4:
      return (
        Ph(), ME(n, e), n === null && dg(e.stateNode.containerInfo), Pi(e), null
      );
    case 10:
      return vC(e.type._context), Pi(e), null;
    case 17:
      return Ss(e.type) && Yx(), Pi(e), null;
    case 19:
      if ((Gn(Jn), (s = e.memoizedState), s === null)) return Pi(e), null;
      if (((r = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) tm(s, !1);
        else {
          if ($r !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = t1(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    tm(s, !1),
                    r = o.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return zn(Jn, (Jn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            Er() > Lh &&
            ((e.flags |= 128), (r = !0), tm(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((n = t1(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              tm(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !Xn)
            )
              return Pi(e), null;
          } else
            2 * Er() - s.renderingStartTime > Lh &&
              t !== 1073741824 &&
              ((e.flags |= 128), (r = !0), tm(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Er()),
          (e.sibling = null),
          (t = Jn.current),
          zn(Jn, r ? (t & 1) | 2 : t & 1),
          e)
        : (Pi(e), null);
    case 22:
    case 23:
      return (
        LC(),
        (r = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? $s & 1073741824 && (Pi(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Pi(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(rt(156, e.tag));
}
function a9(n, e) {
  switch ((hC(e), e.tag)) {
    case 1:
      return (
        Ss(e.type) && Yx(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Ph(),
        Gn(_s),
        Gn(Vi),
        AC(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return SC(e), null;
    case 13:
      if (
        (Gn(Jn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(rt(340));
        Rh();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return Gn(Jn), null;
    case 4:
      return Ph(), null;
    case 10:
      return vC(e.type._context), null;
    case 22:
    case 23:
      return LC(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Uv = !1,
  Fi = !1,
  l9 = typeof WeakSet == "function" ? WeakSet : Set,
  xt = null;
function Zf(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (r) {
        cr(n, e, r);
      }
    else t.current = null;
}
function TE(n, e, t) {
  try {
    t();
  } catch (r) {
    cr(n, e, r);
  }
}
var h3 = !1;
function c9(n, e) {
  if (((uE = Wx), (n = WF()), dC(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var r = t.getSelection && t.getSelection();
        if (r && r.rangeCount !== 0) {
          t = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            d = n,
            h = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (i !== 0 && d.nodeType !== 3) || (a = o + i),
                d !== s || (r !== 0 && d.nodeType !== 3) || (l = o + r),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (h = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (h === t && ++c === i && (a = o),
                h === s && ++u === r && (l = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = h), (h = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    dE = { focusedElem: n, selectionRange: t }, Wx = !1, xt = e;
    xt !== null;

  )
    if (((e = xt), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (xt = n);
    else
      for (; xt !== null; ) {
        e = xt;
        try {
          var g = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (g !== null) {
                  var x = g.memoizedProps,
                    y = g.memoizedState,
                    v = e.stateNode,
                    _ = v.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? x : ea(e.type, x),
                      y
                    );
                  v.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(rt(163));
            }
        } catch (w) {
          cr(e, e.return, w);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (xt = n);
          break;
        }
        xt = e.return;
      }
  return (g = h3), (h3 = !1), g;
}
function Bm(n, e, t) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & n) === n) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && TE(e, t, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function n_(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var r = t.create;
        t.destroy = r();
      }
      t = t.next;
    } while (t !== e);
  }
}
function CE(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function BU(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), BU(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[za], delete e[hg], delete e[pE], delete e[jW], delete e[$W])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function VU(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function p3(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || VU(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function RE(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = Xx));
  else if (r !== 4 && ((n = n.child), n !== null))
    for (RE(n, e, t), n = n.sibling; n !== null; ) RE(n, e, t), (n = n.sibling);
}
function NE(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (r !== 4 && ((n = n.child), n !== null))
    for (NE(n, e, t), n = n.sibling; n !== null; ) NE(n, e, t), (n = n.sibling);
}
var ui = null,
  na = !1;
function rc(n, e, t) {
  for (t = t.child; t !== null; ) HU(n, e, t), (t = t.sibling);
}
function HU(n, e, t) {
  if (Ha && typeof Ha.onCommitFiberUnmount == "function")
    try {
      Ha.onCommitFiberUnmount(Y1, t);
    } catch {}
  switch (t.tag) {
    case 5:
      Fi || Zf(t, e);
    case 6:
      var r = ui,
        i = na;
      (ui = null),
        rc(n, e, t),
        (ui = r),
        (na = i),
        ui !== null &&
          (na
            ? ((n = ui),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : ui.removeChild(t.stateNode));
      break;
    case 18:
      ui !== null &&
        (na
          ? ((n = ui),
            (t = t.stateNode),
            n.nodeType === 8
              ? BA(n.parentNode, t)
              : n.nodeType === 1 && BA(n, t),
            lg(n))
          : BA(ui, t.stateNode));
      break;
    case 4:
      (r = ui),
        (i = na),
        (ui = t.stateNode.containerInfo),
        (na = !0),
        rc(n, e, t),
        (ui = r),
        (na = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Fi &&
        ((r = t.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && TE(t, e, o),
            (i = i.next);
        } while (i !== r);
      }
      rc(n, e, t);
      break;
    case 1:
      if (
        !Fi &&
        (Zf(t, e),
        (r = t.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = t.memoizedProps),
            (r.state = t.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          cr(t, e, a);
        }
      rc(n, e, t);
      break;
    case 21:
      rc(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((Fi = (r = Fi) || t.memoizedState !== null), rc(n, e, t), (Fi = r))
        : rc(n, e, t);
      break;
    default:
      rc(n, e, t);
  }
}
function m3(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new l9()),
      e.forEach(function (r) {
        var i = y9.bind(null, n, r);
        t.has(r) || (t.add(r), r.then(i, i));
      });
  }
}
function qo(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (ui = a.stateNode), (na = !1);
              break e;
            case 3:
              (ui = a.stateNode.containerInfo), (na = !0);
              break e;
            case 4:
              (ui = a.stateNode.containerInfo), (na = !0);
              break e;
          }
          a = a.return;
        }
        if (ui === null) throw Error(rt(160));
        HU(s, o, i), (ui = null), (na = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (c) {
        cr(i, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) GU(e, n), (e = e.sibling);
}
function GU(n, e) {
  var t = n.alternate,
    r = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((qo(e, n), Ia(n), r & 4)) {
        try {
          Bm(3, n, n.return), n_(3, n);
        } catch (x) {
          cr(n, n.return, x);
        }
        try {
          Bm(5, n, n.return);
        } catch (x) {
          cr(n, n.return, x);
        }
      }
      break;
    case 1:
      qo(e, n), Ia(n), r & 512 && t !== null && Zf(t, t.return);
      break;
    case 5:
      if (
        (qo(e, n),
        Ia(n),
        r & 512 && t !== null && Zf(t, t.return),
        n.flags & 32)
      ) {
        var i = n.stateNode;
        try {
          ig(i, "");
        } catch (x) {
          cr(n, n.return, x);
        }
      }
      if (r & 4 && ((i = n.stateNode), i != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && dF(i, s),
              eE(a, o);
            var c = eE(a, s);
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                d = l[o + 1];
              u === "style"
                ? gF(i, d)
                : u === "dangerouslySetInnerHTML"
                ? pF(i, d)
                : u === "children"
                ? ig(i, d)
                : QT(i, u, d, c);
            }
            switch (a) {
              case "input":
                qb(i, s);
                break;
              case "textarea":
                fF(i, s);
                break;
              case "select":
                var h = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? fh(i, !!s.multiple, m, !1)
                  : h !== !!s.multiple &&
                    (s.defaultValue != null
                      ? fh(i, !!s.multiple, s.defaultValue, !0)
                      : fh(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[hg] = s;
          } catch (x) {
            cr(n, n.return, x);
          }
      }
      break;
    case 6:
      if ((qo(e, n), Ia(n), r & 4)) {
        if (n.stateNode === null) throw Error(rt(162));
        (i = n.stateNode), (s = n.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (x) {
          cr(n, n.return, x);
        }
      }
      break;
    case 3:
      if (
        (qo(e, n), Ia(n), r & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          lg(e.containerInfo);
        } catch (x) {
          cr(n, n.return, x);
        }
      break;
    case 4:
      qo(e, n), Ia(n);
      break;
    case 13:
      qo(e, n),
        Ia(n),
        (i = n.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (PC = Er())),
        r & 4 && m3(n);
      break;
    case 22:
      if (
        ((u = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((Fi = (c = Fi) || u), qo(e, n), (Fi = c)) : qo(e, n),
        Ia(n),
        r & 8192)
      ) {
        if (
          ((c = n.memoizedState !== null),
          (n.stateNode.isHidden = c) && !u && n.mode & 1)
        )
          for (xt = n, u = n.child; u !== null; ) {
            for (d = xt = u; xt !== null; ) {
              switch (((h = xt), (m = h.child), h.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Bm(4, h, h.return);
                  break;
                case 1:
                  Zf(h, h.return);
                  var g = h.stateNode;
                  if (typeof g.componentWillUnmount == "function") {
                    (r = h), (t = h.return);
                    try {
                      (e = r),
                        (g.props = e.memoizedProps),
                        (g.state = e.memoizedState),
                        g.componentWillUnmount();
                    } catch (x) {
                      cr(r, t, x);
                    }
                  }
                  break;
                case 5:
                  Zf(h, h.return);
                  break;
                case 22:
                  if (h.memoizedState !== null) {
                    v3(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = h), (xt = m)) : v3(d);
            }
            u = u.sibling;
          }
        e: for (u = null, d = n; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                (i = d.stateNode),
                  c
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = mF("display", o)));
              } catch (x) {
                cr(n, n.return, x);
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (x) {
                cr(n, n.return, x);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            u === d && (u = null), (d = d.return);
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      qo(e, n), Ia(n), r & 4 && m3(n);
      break;
    case 21:
      break;
    default:
      qo(e, n), Ia(n);
  }
}
function Ia(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (VU(t)) {
            var r = t;
            break e;
          }
          t = t.return;
        }
        throw Error(rt(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (ig(i, ""), (r.flags &= -33));
          var s = p3(n);
          NE(n, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = p3(n);
          RE(n, a, o);
          break;
        default:
          throw Error(rt(161));
      }
    } catch (l) {
      cr(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function u9(n, e, t) {
  (xt = n), WU(n);
}
function WU(n, e, t) {
  for (var r = (n.mode & 1) !== 0; xt !== null; ) {
    var i = xt,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || Uv;
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || Fi;
        a = Uv;
        var c = Fi;
        if (((Uv = o), (Fi = l) && !c))
          for (xt = i; xt !== null; )
            (o = xt),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? y3(i)
                : l !== null
                ? ((l.return = o), (xt = l))
                : y3(i);
        for (; s !== null; ) (xt = s), WU(s), (s = s.sibling);
        (xt = i), (Uv = a), (Fi = c);
      }
      g3(n);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (xt = s)) : g3(n);
  }
}
function g3(n) {
  for (; xt !== null; ) {
    var e = xt;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Fi || n_(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !Fi)
                if (t === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : ea(e.type, t.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    t.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && e3(e, s, r);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                e3(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var d = u.dehydrated;
                    d !== null && lg(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(rt(163));
          }
        Fi || (e.flags & 512 && CE(e));
      } catch (h) {
        cr(e, e.return, h);
      }
    }
    if (e === n) {
      xt = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (xt = t);
      break;
    }
    xt = e.return;
  }
}
function v3(n) {
  for (; xt !== null; ) {
    var e = xt;
    if (e === n) {
      xt = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (xt = t);
      break;
    }
    xt = e.return;
  }
}
function y3(n) {
  for (; xt !== null; ) {
    var e = xt;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            n_(4, e);
          } catch (l) {
            cr(e, t, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              cr(e, i, l);
            }
          }
          var s = e.return;
          try {
            CE(e);
          } catch (l) {
            cr(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            CE(e);
          } catch (l) {
            cr(e, o, l);
          }
      }
    } catch (l) {
      cr(e, e.return, l);
    }
    if (e === n) {
      xt = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (xt = a);
      break;
    }
    xt = e.return;
  }
}
var d9 = Math.ceil,
  i1 = Hl.ReactCurrentDispatcher,
  RC = Hl.ReactCurrentOwner,
  Uo = Hl.ReactCurrentBatchConfig,
  mn = 0,
  si = null,
  Or = null,
  hi = 0,
  $s = 0,
  Qf = Kc(0),
  $r = 0,
  xg = null,
  vd = 0,
  r_ = 0,
  NC = 0,
  Vm = null,
  gs = null,
  PC = 0,
  Lh = 1 / 0,
  yl = null,
  s1 = !1,
  PE = null,
  Ic = null,
  kv = !1,
  Sc = null,
  o1 = 0,
  Hm = 0,
  IE = null,
  fx = -1,
  hx = 0;
function es() {
  return mn & 6 ? Er() : fx !== -1 ? fx : (fx = Er());
}
function Lc(n) {
  return n.mode & 1
    ? mn & 2 && hi !== 0
      ? hi & -hi
      : YW.transition !== null
      ? (hx === 0 && (hx = CF()), hx)
      : ((n = En),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : DF(n.type))),
        n)
    : 1;
}
function da(n, e, t, r) {
  if (50 < Hm) throw ((Hm = 0), (IE = null), Error(rt(185)));
  s0(n, t, r),
    (!(mn & 2) || n !== si) &&
      (n === si && (!(mn & 2) && (r_ |= t), $r === 4 && yc(n, hi)),
      As(n, r),
      t === 1 && mn === 0 && !(e.mode & 1) && ((Lh = Er() + 500), J1 && Zc()));
}
function As(n, e) {
  var t = n.callbackNode;
  YG(n, e);
  var r = Gx(n, n === si ? hi : 0);
  if (r === 0)
    t !== null && TP(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = r & -r), n.callbackPriority !== e)) {
    if ((t != null && TP(t), e === 1))
      n.tag === 0 ? XW(x3.bind(null, n)) : eU(x3.bind(null, n)),
        GW(function () {
          !(mn & 6) && Zc();
        }),
        (t = null);
    else {
      switch (RF(r)) {
        case 1:
          t = rC;
          break;
        case 4:
          t = MF;
          break;
        case 16:
          t = Hx;
          break;
        case 536870912:
          t = TF;
          break;
        default:
          t = Hx;
      }
      t = QU(t, jU.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function jU(n, e) {
  if (((fx = -1), (hx = 0), mn & 6)) throw Error(rt(327));
  var t = n.callbackNode;
  if (vh() && n.callbackNode !== t) return null;
  var r = Gx(n, n === si ? hi : 0);
  if (r === 0) return null;
  if (r & 30 || r & n.expiredLanes || e) e = a1(n, r);
  else {
    e = r;
    var i = mn;
    mn |= 2;
    var s = XU();
    (si !== n || hi !== e) && ((yl = null), (Lh = Er() + 500), nd(n, e));
    do
      try {
        p9();
        break;
      } catch (a) {
        $U(n, a);
      }
    while (!0);
    gC(),
      (i1.current = s),
      (mn = i),
      Or !== null ? (e = 0) : ((si = null), (hi = 0), (e = $r));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = sE(n)), i !== 0 && ((r = i), (e = LE(n, i)))), e === 1)
    )
      throw ((t = xg), nd(n, 0), yc(n, r), As(n, Er()), t);
    if (e === 6) yc(n, r);
    else {
      if (
        ((i = n.current.alternate),
        !(r & 30) &&
          !f9(i) &&
          ((e = a1(n, r)),
          e === 2 && ((s = sE(n)), s !== 0 && ((r = s), (e = LE(n, s)))),
          e === 1))
      )
        throw ((t = xg), nd(n, 0), yc(n, r), As(n, Er()), t);
      switch (((n.finishedWork = i), (n.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(rt(345));
        case 2:
          Lu(n, gs, yl);
          break;
        case 3:
          if (
            (yc(n, r), (r & 130023424) === r && ((e = PC + 500 - Er()), 10 < e))
          ) {
            if (Gx(n, 0) !== 0) break;
            if (((i = n.suspendedLanes), (i & r) !== r)) {
              es(), (n.pingedLanes |= n.suspendedLanes & i);
              break;
            }
            n.timeoutHandle = hE(Lu.bind(null, n, gs, yl), e);
            break;
          }
          Lu(n, gs, yl);
          break;
        case 4:
          if ((yc(n, r), (r & 4194240) === r)) break;
          for (e = n.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - ua(r);
            (s = 1 << o), (o = e[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = Er() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * d9(r / 1960)) - r),
            10 < r)
          ) {
            n.timeoutHandle = hE(Lu.bind(null, n, gs, yl), r);
            break;
          }
          Lu(n, gs, yl);
          break;
        case 5:
          Lu(n, gs, yl);
          break;
        default:
          throw Error(rt(329));
      }
    }
  }
  return As(n, Er()), n.callbackNode === t ? jU.bind(null, n) : null;
}
function LE(n, e) {
  var t = Vm;
  return (
    n.current.memoizedState.isDehydrated && (nd(n, e).flags |= 256),
    (n = a1(n, e)),
    n !== 2 && ((e = gs), (gs = t), e !== null && OE(e)),
    n
  );
}
function OE(n) {
  gs === null ? (gs = n) : gs.push.apply(gs, n);
}
function f9(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var r = 0; r < t.length; r++) {
          var i = t[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!ga(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function yc(n, e) {
  for (
    e &= ~NC,
      e &= ~r_,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - ua(e),
      r = 1 << t;
    (n[t] = -1), (e &= ~r);
  }
}
function x3(n) {
  if (mn & 6) throw Error(rt(327));
  vh();
  var e = Gx(n, 0);
  if (!(e & 1)) return As(n, Er()), null;
  var t = a1(n, e);
  if (n.tag !== 0 && t === 2) {
    var r = sE(n);
    r !== 0 && ((e = r), (t = LE(n, r)));
  }
  if (t === 1) throw ((t = xg), nd(n, 0), yc(n, e), As(n, Er()), t);
  if (t === 6) throw Error(rt(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Lu(n, gs, yl),
    As(n, Er()),
    null
  );
}
function IC(n, e) {
  var t = mn;
  mn |= 1;
  try {
    return n(e);
  } finally {
    (mn = t), mn === 0 && ((Lh = Er() + 500), J1 && Zc());
  }
}
function yd(n) {
  Sc !== null && Sc.tag === 0 && !(mn & 6) && vh();
  var e = mn;
  mn |= 1;
  var t = Uo.transition,
    r = En;
  try {
    if (((Uo.transition = null), (En = 1), n)) return n();
  } finally {
    (En = r), (Uo.transition = t), (mn = e), !(mn & 6) && Zc();
  }
}
function LC() {
  ($s = Qf.current), Gn(Qf);
}
function nd(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), HW(t)), Or !== null))
    for (t = Or.return; t !== null; ) {
      var r = t;
      switch ((hC(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && Yx();
          break;
        case 3:
          Ph(), Gn(_s), Gn(Vi), AC();
          break;
        case 5:
          SC(r);
          break;
        case 4:
          Ph();
          break;
        case 13:
          Gn(Jn);
          break;
        case 19:
          Gn(Jn);
          break;
        case 10:
          vC(r.type._context);
          break;
        case 22:
        case 23:
          LC();
      }
      t = t.return;
    }
  if (
    ((si = n),
    (Or = n = Oc(n.current, null)),
    (hi = $s = e),
    ($r = 0),
    (xg = null),
    (NC = r_ = vd = 0),
    (gs = Vm = null),
    Wu !== null)
  ) {
    for (e = 0; e < Wu.length; e++)
      if (((t = Wu[e]), (r = t.interleaved), r !== null)) {
        t.interleaved = null;
        var i = r.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        t.pending = r;
      }
    Wu = null;
  }
  return n;
}
function $U(n, e) {
  do {
    var t = Or;
    try {
      if ((gC(), (cx.current = r1), n1)) {
        for (var r = rr.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        n1 = !1;
      }
      if (
        ((gd = 0),
        (ni = Hr = rr = null),
        (zm = !1),
        (gg = 0),
        (RC.current = null),
        t === null || t.return === null)
      ) {
        ($r = 1), (xg = e), (Or = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = hi),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var h = u.alternate;
            h
              ? ((u.updateQueue = h.updateQueue),
                (u.memoizedState = h.memoizedState),
                (u.lanes = h.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var m = o3(o);
          if (m !== null) {
            (m.flags &= -257),
              a3(m, o, a, s, e),
              m.mode & 1 && s3(s, c, e),
              (e = m),
              (l = c);
            var g = e.updateQueue;
            if (g === null) {
              var x = new Set();
              x.add(l), (e.updateQueue = x);
            } else g.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              s3(s, c, e), OC();
              break e;
            }
            l = Error(rt(426));
          }
        } else if (Xn && a.mode & 1) {
          var y = o3(o);
          if (y !== null) {
            !(y.flags & 65536) && (y.flags |= 256),
              a3(y, o, a, s, e),
              pC(Ih(l, a));
            break e;
          }
        }
        (s = l = Ih(l, a)),
          $r !== 4 && ($r = 2),
          Vm === null ? (Vm = [s]) : Vm.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var v = RU(s, l, e);
              JP(s, v);
              break e;
            case 1:
              a = l;
              var _ = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (Ic === null || !Ic.has(S))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var w = NU(s, a, e);
                JP(s, w);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      qU(t);
    } catch (T) {
      (e = T), Or === t && t !== null && (Or = t = t.return);
      continue;
    }
    break;
  } while (!0);
}
function XU() {
  var n = i1.current;
  return (i1.current = r1), n === null ? r1 : n;
}
function OC() {
  ($r === 0 || $r === 3 || $r === 2) && ($r = 4),
    si === null || (!(vd & 268435455) && !(r_ & 268435455)) || yc(si, hi);
}
function a1(n, e) {
  var t = mn;
  mn |= 2;
  var r = XU();
  (si !== n || hi !== e) && ((yl = null), nd(n, e));
  do
    try {
      h9();
      break;
    } catch (i) {
      $U(n, i);
    }
  while (!0);
  if ((gC(), (mn = t), (i1.current = r), Or !== null)) throw Error(rt(261));
  return (si = null), (hi = 0), $r;
}
function h9() {
  for (; Or !== null; ) YU(Or);
}
function p9() {
  for (; Or !== null && !zG(); ) YU(Or);
}
function YU(n) {
  var e = ZU(n.alternate, n, $s);
  (n.memoizedProps = n.pendingProps),
    e === null ? qU(n) : (Or = e),
    (RC.current = null);
}
function qU(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = a9(t, e)), t !== null)) {
        (t.flags &= 32767), (Or = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        ($r = 6), (Or = null);
        return;
      }
    } else if (((t = o9(t, e, $s)), t !== null)) {
      Or = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Or = e;
      return;
    }
    Or = e = n;
  } while (e !== null);
  $r === 0 && ($r = 5);
}
function Lu(n, e, t) {
  var r = En,
    i = Uo.transition;
  try {
    (Uo.transition = null), (En = 1), m9(n, e, t, r);
  } finally {
    (Uo.transition = i), (En = r);
  }
  return null;
}
function m9(n, e, t, r) {
  do vh();
  while (Sc !== null);
  if (mn & 6) throw Error(rt(327));
  t = n.finishedWork;
  var i = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(rt(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (qG(n, s),
    n === si && ((Or = si = null), (hi = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      kv ||
      ((kv = !0),
      QU(Hx, function () {
        return vh(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Uo.transition), (Uo.transition = null);
    var o = En;
    En = 1;
    var a = mn;
    (mn |= 4),
      (RC.current = null),
      c9(n, t),
      GU(t, n),
      DW(dE),
      (Wx = !!uE),
      (dE = uE = null),
      (n.current = t),
      u9(t),
      BG(),
      (mn = a),
      (En = o),
      (Uo.transition = s);
  } else n.current = t;
  if (
    (kv && ((kv = !1), (Sc = n), (o1 = i)),
    (s = n.pendingLanes),
    s === 0 && (Ic = null),
    GG(t.stateNode),
    As(n, Er()),
    e !== null)
  )
    for (r = n.onRecoverableError, t = 0; t < e.length; t++)
      (i = e[t]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (s1) throw ((s1 = !1), (n = PE), (PE = null), n);
  return (
    o1 & 1 && n.tag !== 0 && vh(),
    (s = n.pendingLanes),
    s & 1 ? (n === IE ? Hm++ : ((Hm = 0), (IE = n))) : (Hm = 0),
    Zc(),
    null
  );
}
function vh() {
  if (Sc !== null) {
    var n = RF(o1),
      e = Uo.transition,
      t = En;
    try {
      if (((Uo.transition = null), (En = 16 > n ? 16 : n), Sc === null))
        var r = !1;
      else {
        if (((n = Sc), (Sc = null), (o1 = 0), mn & 6)) throw Error(rt(331));
        var i = mn;
        for (mn |= 4, xt = n.current; xt !== null; ) {
          var s = xt,
            o = s.child;
          if (xt.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (xt = c; xt !== null; ) {
                  var u = xt;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Bm(8, u, s);
                  }
                  var d = u.child;
                  if (d !== null) (d.return = u), (xt = d);
                  else
                    for (; xt !== null; ) {
                      u = xt;
                      var h = u.sibling,
                        m = u.return;
                      if ((BU(u), u === c)) {
                        xt = null;
                        break;
                      }
                      if (h !== null) {
                        (h.return = m), (xt = h);
                        break;
                      }
                      xt = m;
                    }
                }
              }
              var g = s.alternate;
              if (g !== null) {
                var x = g.child;
                if (x !== null) {
                  g.child = null;
                  do {
                    var y = x.sibling;
                    (x.sibling = null), (x = y);
                  } while (x !== null);
                }
              }
              xt = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (xt = o);
          else
            e: for (; xt !== null; ) {
              if (((s = xt), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Bm(9, s, s.return);
                }
              var v = s.sibling;
              if (v !== null) {
                (v.return = s.return), (xt = v);
                break e;
              }
              xt = s.return;
            }
        }
        var _ = n.current;
        for (xt = _; xt !== null; ) {
          o = xt;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (xt = S);
          else
            e: for (o = _; xt !== null; ) {
              if (((a = xt), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      n_(9, a);
                  }
                } catch (T) {
                  cr(a, a.return, T);
                }
              if (a === o) {
                xt = null;
                break e;
              }
              var w = a.sibling;
              if (w !== null) {
                (w.return = a.return), (xt = w);
                break e;
              }
              xt = a.return;
            }
        }
        if (
          ((mn = i), Zc(), Ha && typeof Ha.onPostCommitFiberRoot == "function")
        )
          try {
            Ha.onPostCommitFiberRoot(Y1, n);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (En = t), (Uo.transition = e);
    }
  }
  return !1;
}
function _3(n, e, t) {
  (e = Ih(t, e)),
    (e = RU(n, e, 1)),
    (n = Pc(n, e, 1)),
    (e = es()),
    n !== null && (s0(n, 1, e), As(n, e));
}
function cr(n, e, t) {
  if (n.tag === 3) _3(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        _3(e, n, t);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Ic === null || !Ic.has(r)))
        ) {
          (n = Ih(t, n)),
            (n = NU(e, n, 1)),
            (e = Pc(e, n, 1)),
            (n = es()),
            e !== null && (s0(e, 1, n), As(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function g9(n, e, t) {
  var r = n.pingCache;
  r !== null && r.delete(e),
    (e = es()),
    (n.pingedLanes |= n.suspendedLanes & t),
    si === n &&
      (hi & t) === t &&
      ($r === 4 || ($r === 3 && (hi & 130023424) === hi && 500 > Er() - PC)
        ? nd(n, 0)
        : (NC |= t)),
    As(n, e);
}
function KU(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Cv), (Cv <<= 1), !(Cv & 130023424) && (Cv = 4194304))
      : (e = 1));
  var t = es();
  (n = Ll(n, e)), n !== null && (s0(n, e, t), As(n, t));
}
function v9(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), KU(n, t);
}
function y9(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var r = n.stateNode,
        i = n.memoizedState;
      i !== null && (t = i.retryLane);
      break;
    case 19:
      r = n.stateNode;
      break;
    default:
      throw Error(rt(314));
  }
  r !== null && r.delete(e), KU(n, t);
}
var ZU;
ZU = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || _s.current) vs = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (vs = !1), s9(n, e, t);
      vs = !!(n.flags & 131072);
    }
  else (vs = !1), Xn && e.flags & 1048576 && tU(e, Zx, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      dx(n, e), (n = e.pendingProps);
      var i = Ch(e, Vi.current);
      gh(e, t), (i = bC(null, e, r, n, i, t));
      var s = EC();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Ss(r) ? ((s = !0), qx(e)) : (s = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            xC(e),
            (i.updater = t_),
            (e.stateNode = i),
            (i._reactInternals = e),
            _E(e, r, n, t),
            (e = wE(null, e, r, !0, s, t)))
          : ((e.tag = 0), Xn && s && fC(e), Qi(null, e, i, t), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (dx(n, e),
          (n = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = _9(r)),
          (n = ea(r, n)),
          i)
        ) {
          case 0:
            e = AE(null, e, r, n, t);
            break e;
          case 1:
            e = u3(null, e, r, n, t);
            break e;
          case 11:
            e = l3(null, e, r, n, t);
            break e;
          case 14:
            e = c3(null, e, r, ea(r.type, n), t);
            break e;
        }
        throw Error(rt(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : ea(r, i)),
        AE(n, e, r, i, t)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : ea(r, i)),
        u3(n, e, r, i, t)
      );
    case 3:
      e: {
        if ((OU(e), n === null)) throw Error(rt(387));
        (r = e.pendingProps),
          (s = e.memoizedState),
          (i = s.element),
          aU(n, e),
          e1(e, r, null, t);
        var o = e.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (i = Ih(Error(rt(423)), e)), (e = d3(n, e, r, t, i));
            break e;
          } else if (r !== i) {
            (i = Ih(Error(rt(424)), e)), (e = d3(n, e, r, t, i));
            break e;
          } else
            for (
              Ks = Nc(e.stateNode.containerInfo.firstChild),
                ro = e,
                Xn = !0,
                oa = null,
                t = sU(e, null, r, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Rh(), r === i)) {
            e = Ol(n, e, t);
            break e;
          }
          Qi(n, e, r, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        lU(e),
        n === null && vE(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = i.children),
        fE(r, i) ? (o = null) : s !== null && fE(r, s) && (e.flags |= 32),
        LU(n, e),
        Qi(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && vE(e), null;
    case 13:
      return DU(n, e, t);
    case 4:
      return (
        _C(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        n === null ? (e.child = Nh(e, null, r, t)) : Qi(n, e, r, t),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : ea(r, i)),
        l3(n, e, r, i, t)
      );
    case 7:
      return Qi(n, e, e.pendingProps, t), e.child;
    case 8:
      return Qi(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return Qi(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (o = i.value),
          zn(Qx, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (ga(s.value, o)) {
            if (s.children === i.children && !_s.current) {
              e = Ol(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = Tl(-1, t & -t)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      yE(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(rt(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  yE(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        Qi(n, e, i.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        gh(e, t),
        (i = ko(i)),
        (r = r(i)),
        (e.flags |= 1),
        Qi(n, e, r, t),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = ea(r, e.pendingProps)),
        (i = ea(r.type, i)),
        c3(n, e, r, i, t)
      );
    case 15:
      return PU(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : ea(r, i)),
        dx(n, e),
        (e.tag = 1),
        Ss(r) ? ((n = !0), qx(e)) : (n = !1),
        gh(e, t),
        CU(e, r, i),
        _E(e, r, i, t),
        wE(null, e, r, !0, n, t)
      );
    case 19:
      return FU(n, e, t);
    case 22:
      return IU(n, e, t);
  }
  throw Error(rt(156, e.tag));
};
function QU(n, e) {
  return EF(n, e);
}
function x9(n, e, t, r) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Lo(n, e, t, r) {
  return new x9(n, e, t, r);
}
function DC(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function _9(n) {
  if (typeof n == "function") return DC(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === eC)) return 11;
    if (n === tC) return 14;
  }
  return 2;
}
function Oc(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Lo(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function px(n, e, t, r, i, s) {
  var o = 2;
  if (((r = n), typeof n == "function")) DC(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case Hf:
        return rd(t.children, i, s, e);
      case JT:
        (o = 8), (i |= 8);
        break;
      case Wb:
        return (
          (n = Lo(12, t, e, i | 2)), (n.elementType = Wb), (n.lanes = s), n
        );
      case jb:
        return (n = Lo(13, t, e, i)), (n.elementType = jb), (n.lanes = s), n;
      case $b:
        return (n = Lo(19, t, e, i)), (n.elementType = $b), (n.lanes = s), n;
      case lF:
        return i_(t, i, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case oF:
              o = 10;
              break e;
            case aF:
              o = 9;
              break e;
            case eC:
              o = 11;
              break e;
            case tC:
              o = 14;
              break e;
            case hc:
              (o = 16), (r = null);
              break e;
          }
        throw Error(rt(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Lo(o, t, e, i)), (e.elementType = n), (e.type = r), (e.lanes = s), e
  );
}
function rd(n, e, t, r) {
  return (n = Lo(7, n, r, e)), (n.lanes = t), n;
}
function i_(n, e, t, r) {
  return (
    (n = Lo(22, n, r, e)),
    (n.elementType = lF),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function YA(n, e, t) {
  return (n = Lo(6, n, null, e)), (n.lanes = t), n;
}
function qA(n, e, t) {
  return (
    (e = Lo(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function S9(n, e, t, r, i) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = RA(0)),
    (this.expirationTimes = RA(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = RA(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function FC(n, e, t, r, i, s, o, a, l) {
  return (
    (n = new S9(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Lo(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: r,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    xC(s),
    n
  );
}
function A9(n, e, t) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Vf,
    key: r == null ? null : "" + r,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function JU(n) {
  if (!n) return kc;
  n = n._reactInternals;
  e: {
    if (Pd(n) !== n || n.tag !== 1) throw Error(rt(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Ss(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(rt(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Ss(t)) return JF(n, t, e);
  }
  return e;
}
function e4(n, e, t, r, i, s, o, a, l) {
  return (
    (n = FC(t, r, !0, n, i, s, o, a, l)),
    (n.context = JU(null)),
    (t = n.current),
    (r = es()),
    (i = Lc(t)),
    (s = Tl(r, i)),
    (s.callback = e ?? null),
    Pc(t, s, i),
    (n.current.lanes = i),
    s0(n, i, r),
    As(n, r),
    n
  );
}
function s_(n, e, t, r) {
  var i = e.current,
    s = es(),
    o = Lc(i);
  return (
    (t = JU(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Tl(s, o)),
    (e.payload = { element: n }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (n = Pc(i, e, o)),
    n !== null && (da(n, i, o, s), lx(n, i, o)),
    o
  );
}
function l1(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function S3(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function UC(n, e) {
  S3(n, e), (n = n.alternate) && S3(n, e);
}
function w9() {
  return null;
}
var t4 =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function kC(n) {
  this._internalRoot = n;
}
o_.prototype.render = kC.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(rt(409));
  s_(n, e, null, null);
};
o_.prototype.unmount = kC.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    yd(function () {
      s_(null, n, null, null);
    }),
      (e[Il] = null);
  }
};
function o_(n) {
  this._internalRoot = n;
}
o_.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = IF();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < vc.length && e !== 0 && e < vc[t].priority; t++);
    vc.splice(t, 0, n), t === 0 && OF(n);
  }
};
function zC(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function a_(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function A3() {}
function b9(n, e, t, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var c = l1(o);
        s.call(c);
      };
    }
    var o = e4(e, r, n, 0, null, !1, !1, "", A3);
    return (
      (n._reactRootContainer = o),
      (n[Il] = o.current),
      dg(n.nodeType === 8 ? n.parentNode : n),
      yd(),
      o
    );
  }
  for (; (i = n.lastChild); ) n.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var c = l1(l);
      a.call(c);
    };
  }
  var l = FC(n, 0, !1, null, null, !1, !1, "", A3);
  return (
    (n._reactRootContainer = l),
    (n[Il] = l.current),
    dg(n.nodeType === 8 ? n.parentNode : n),
    yd(function () {
      s_(e, l, t, r);
    }),
    l
  );
}
function l_(n, e, t, r, i) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = l1(o);
        a.call(l);
      };
    }
    s_(e, o, n, i);
  } else o = b9(t, e, n, i, r);
  return l1(o);
}
NF = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Mm(e.pendingLanes);
        t !== 0 &&
          (iC(e, t | 1), As(e, Er()), !(mn & 6) && ((Lh = Er() + 500), Zc()));
      }
      break;
    case 13:
      yd(function () {
        var r = Ll(n, 1);
        if (r !== null) {
          var i = es();
          da(r, n, 1, i);
        }
      }),
        UC(n, 1);
  }
};
sC = function (n) {
  if (n.tag === 13) {
    var e = Ll(n, 134217728);
    if (e !== null) {
      var t = es();
      da(e, n, 134217728, t);
    }
    UC(n, 134217728);
  }
};
PF = function (n) {
  if (n.tag === 13) {
    var e = Lc(n),
      t = Ll(n, e);
    if (t !== null) {
      var r = es();
      da(t, n, e, r);
    }
    UC(n, e);
  }
};
IF = function () {
  return En;
};
LF = function (n, e) {
  var t = En;
  try {
    return (En = n), e();
  } finally {
    En = t;
  }
};
nE = function (n, e, t) {
  switch (e) {
    case "input":
      if ((qb(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var r = t[e];
          if (r !== n && r.form === n.form) {
            var i = Q1(r);
            if (!i) throw Error(rt(90));
            uF(r), qb(r, i);
          }
        }
      }
      break;
    case "textarea":
      fF(n, t);
      break;
    case "select":
      (e = t.value), e != null && fh(n, !!t.multiple, e, !1);
  }
};
xF = IC;
_F = yd;
var E9 = { usingClientEntryPoint: !1, Events: [a0, $f, Q1, vF, yF, IC] },
  nm = {
    findFiberByHostInstance: Gu,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  M9 = {
    bundleType: nm.bundleType,
    version: nm.version,
    rendererPackageName: nm.rendererPackageName,
    rendererConfig: nm.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Hl.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = wF(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: nm.findFiberByHostInstance || w9,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var zv = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!zv.isDisabled && zv.supportsFiber)
    try {
      (Y1 = zv.inject(M9)), (Ha = zv);
    } catch {}
}
ho.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = E9;
ho.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!zC(e)) throw Error(rt(200));
  return A9(n, e, null, t);
};
ho.createRoot = function (n, e) {
  if (!zC(n)) throw Error(rt(299));
  var t = !1,
    r = "",
    i = t4;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = FC(n, 1, !1, null, null, t, !1, r, i)),
    (n[Il] = e.current),
    dg(n.nodeType === 8 ? n.parentNode : n),
    new kC(e)
  );
};
ho.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(rt(188))
      : ((n = Object.keys(n).join(",")), Error(rt(268, n)));
  return (n = wF(e)), (n = n === null ? null : n.stateNode), n;
};
ho.flushSync = function (n) {
  return yd(n);
};
ho.hydrate = function (n, e, t) {
  if (!a_(e)) throw Error(rt(200));
  return l_(null, n, e, !0, t);
};
ho.hydrateRoot = function (n, e, t) {
  if (!zC(n)) throw Error(rt(405));
  var r = (t != null && t.hydratedSources) || null,
    i = !1,
    s = "",
    o = t4;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (i = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = e4(e, null, n, 1, t ?? null, i, !1, s, o)),
    (n[Il] = e.current),
    dg(n),
    r)
  )
    for (n = 0; n < r.length; n++)
      (t = r[n]),
        (i = t._getVersion),
        (i = i(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, i])
          : e.mutableSourceEagerHydrationData.push(t, i);
  return new o_(e);
};
ho.render = function (n, e, t) {
  if (!a_(e)) throw Error(rt(200));
  return l_(null, n, e, !1, t);
};
ho.unmountComponentAtNode = function (n) {
  if (!a_(n)) throw Error(rt(40));
  return n._reactRootContainer
    ? (yd(function () {
        l_(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Il] = null);
        });
      }),
      !0)
    : !1;
};
ho.unstable_batchedUpdates = IC;
ho.unstable_renderSubtreeIntoContainer = function (n, e, t, r) {
  if (!a_(t)) throw Error(rt(200));
  if (n == null || n._reactInternals === void 0) throw Error(rt(38));
  return l_(n, e, t, !1, r);
};
ho.version = "18.3.1-next-f1338f8080-20240426";
function n4() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n4);
    } catch (n) {
      console.error(n);
    }
}
n4(), (nF.exports = ho);
var c_ = nF.exports;
const DE = Qh(c_),
  T9 = WD({ __proto__: null, default: DE }, [c_]);
var r4,
  w3 = c_;
(r4 = Hb.createRoot = w3.createRoot), (Hb.hydrateRoot = w3.hydrateRoot);
var i4 = { exports: {} },
  s4 = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var c0 = I;
function C9(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var R9 = typeof Object.is == "function" ? Object.is : C9,
  N9 = c0.useSyncExternalStore,
  P9 = c0.useRef,
  I9 = c0.useEffect,
  L9 = c0.useMemo,
  O9 = c0.useDebugValue;
s4.useSyncExternalStoreWithSelector = function (n, e, t, r, i) {
  var s = P9(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = L9(
    function () {
      function l(m) {
        if (!c) {
          if (((c = !0), (u = m), (m = r(m)), i !== void 0 && o.hasValue)) {
            var g = o.value;
            if (i(g, m)) return (d = g);
          }
          return (d = m);
        }
        if (((g = d), R9(u, m))) return g;
        var x = r(m);
        return i !== void 0 && i(g, x) ? g : ((u = m), (d = x));
      }
      var c = !1,
        u,
        d,
        h = t === void 0 ? null : t;
      return [
        function () {
          return l(e());
        },
        h === null
          ? void 0
          : function () {
              return l(h());
            },
      ];
    },
    [e, t, r, i]
  );
  var a = N9(n, s[0], s[1]);
  return (
    I9(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a]
    ),
    O9(a),
    a
  );
};
i4.exports = s4;
var D9 = i4.exports,
  Zs = "default" in ng ? Je : ng,
  b3 = Symbol.for("react-redux-context"),
  E3 = typeof globalThis < "u" ? globalThis : {};
function F9() {
  if (!Zs.createContext) return {};
  const n = E3[b3] ?? (E3[b3] = new Map());
  let e = n.get(Zs.createContext);
  return e || ((e = Zs.createContext(null)), n.set(Zs.createContext, e)), e;
}
var zc = F9(),
  U9 = () => {
    throw new Error("uSES not initialized!");
  };
function BC(n = zc) {
  return function () {
    return Zs.useContext(n);
  };
}
var o4 = BC(),
  a4 = U9,
  k9 = (n) => {
    a4 = n;
  },
  z9 = (n, e) => n === e;
function B9(n = zc) {
  const e = n === zc ? o4 : BC(n),
    t = (r, i = {}) => {
      const { equalityFn: s = z9, devModeChecks: o = {} } =
          typeof i == "function" ? { equalityFn: i } : i,
        {
          store: a,
          subscription: l,
          getServerState: c,
          stabilityCheck: u,
          identityFunctionCheck: d,
        } = e();
      Zs.useRef(!0);
      const h = Zs.useCallback(
          {
            [r.name](g) {
              return r(g);
            },
          }[r.name],
          [r, u, o.stabilityCheck]
        ),
        m = a4(l.addNestedSub, a.getState, c || a.getState, h, s);
      return Zs.useDebugValue(m), m;
    };
  return Object.assign(t, { withTypes: () => t }), t;
}
var Cs = B9();
function V9(n) {
  n();
}
function H9() {
  let n = null,
    e = null;
  return {
    clear() {
      (n = null), (e = null);
    },
    notify() {
      V9(() => {
        let t = n;
        for (; t; ) t.callback(), (t = t.next);
      });
    },
    get() {
      const t = [];
      let r = n;
      for (; r; ) t.push(r), (r = r.next);
      return t;
    },
    subscribe(t) {
      let r = !0;
      const i = (e = { callback: t, next: null, prev: e });
      return (
        i.prev ? (i.prev.next = i) : (n = i),
        function () {
          !r ||
            n === null ||
            ((r = !1),
            i.next ? (i.next.prev = i.prev) : (e = i.prev),
            i.prev ? (i.prev.next = i.next) : (n = i.next));
        }
      );
    },
  };
}
var M3 = { notify() {}, get: () => [] };
function G9(n, e) {
  let t,
    r = M3,
    i = 0,
    s = !1;
  function o(x) {
    u();
    const y = r.subscribe(x);
    let v = !1;
    return () => {
      v || ((v = !0), y(), d());
    };
  }
  function a() {
    r.notify();
  }
  function l() {
    g.onStateChange && g.onStateChange();
  }
  function c() {
    return s;
  }
  function u() {
    i++, t || ((t = n.subscribe(l)), (r = H9()));
  }
  function d() {
    i--, t && i === 0 && (t(), (t = void 0), r.clear(), (r = M3));
  }
  function h() {
    s || ((s = !0), u());
  }
  function m() {
    s && ((s = !1), d());
  }
  const g = {
    addNestedSub: o,
    notifyNestedSubs: a,
    handleChangeWrapper: l,
    isSubscribed: c,
    trySubscribe: h,
    tryUnsubscribe: m,
    getListeners: () => r,
  };
  return g;
}
var W9 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  j9 = typeof navigator < "u" && navigator.product === "ReactNative",
  $9 = W9 || j9 ? Zs.useLayoutEffect : Zs.useEffect;
function X9({
  store: n,
  context: e,
  children: t,
  serverState: r,
  stabilityCheck: i = "once",
  identityFunctionCheck: s = "once",
}) {
  const o = Zs.useMemo(() => {
      const c = G9(n);
      return {
        store: n,
        subscription: c,
        getServerState: r ? () => r : void 0,
        stabilityCheck: i,
        identityFunctionCheck: s,
      };
    }, [n, r, i, s]),
    a = Zs.useMemo(() => n.getState(), [n]);
  $9(() => {
    const { subscription: c } = o;
    return (
      (c.onStateChange = c.notifyNestedSubs),
      c.trySubscribe(),
      a !== n.getState() && c.notifyNestedSubs(),
      () => {
        c.tryUnsubscribe(), (c.onStateChange = void 0);
      }
    );
  }, [o, a]);
  const l = e || zc;
  return Zs.createElement(l.Provider, { value: o }, t);
}
var Y9 = X9;
function l4(n = zc) {
  const e = n === zc ? o4 : BC(n),
    t = () => {
      const { store: r } = e();
      return r;
    };
  return Object.assign(t, { withTypes: () => t }), t;
}
var q9 = l4();
function K9(n = zc) {
  const e = n === zc ? q9 : l4(n),
    t = () => e().dispatch;
  return Object.assign(t, { withTypes: () => t }), t;
}
var Sa = K9();
k9(D9.useSyncExternalStoreWithSelector);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const u_ = "164",
  Ou = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Du = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  c4 = 0,
  FE = 1,
  u4 = 2,
  Z9 = 3,
  d4 = 0,
  d_ = 1,
  Gm = 2,
  ta = 3,
  ja = 0,
  pi = 1,
  Ys = 2,
  Cl = 0,
  id = 1,
  UE = 2,
  kE = 3,
  zE = 4,
  f4 = 5,
  xc = 100,
  h4 = 101,
  p4 = 102,
  m4 = 103,
  g4 = 104,
  v4 = 200,
  y4 = 201,
  x4 = 202,
  _4 = 203,
  c1 = 204,
  u1 = 205,
  S4 = 206,
  A4 = 207,
  w4 = 208,
  b4 = 209,
  E4 = 210,
  M4 = 211,
  T4 = 212,
  C4 = 213,
  R4 = 214,
  N4 = 0,
  P4 = 1,
  I4 = 2,
  _g = 3,
  L4 = 4,
  O4 = 5,
  D4 = 6,
  F4 = 7,
  u0 = 0,
  U4 = 1,
  k4 = 2,
  ws = 0,
  VC = 1,
  HC = 2,
  GC = 3,
  f_ = 4,
  z4 = 5,
  WC = 6,
  B4 = 7,
  BE = "attached",
  V4 = "detached",
  h_ = 300,
  Dl = 301,
  Bc = 302,
  Sg = 303,
  Ag = 304,
  np = 306,
  wg = 1e3,
  Oo = 1001,
  bg = 1002,
  Dr = 1003,
  jC = 1004,
  Q9 = 1004,
  Jf = 1005,
  J9 = 1005,
  dr = 1006,
  Wm = 1007,
  ej = 1007,
  ca = 1008,
  tj = 1008,
  $a = 1009,
  H4 = 1010,
  G4 = 1011,
  $C = 1012,
  XC = 1013,
  xd = 1014,
  Qs = 1015,
  rp = 1016,
  YC = 1017,
  qC = 1018,
  ip = 1020,
  W4 = 35902,
  j4 = 1021,
  $4 = 1022,
  ys = 1023,
  X4 = 1024,
  Y4 = 1025,
  sd = 1026,
  Oh = 1027,
  KC = 1028,
  ZC = 1029,
  q4 = 1030,
  QC = 1031,
  JC = 1033,
  mx = 33776,
  gx = 33777,
  vx = 33778,
  yx = 33779,
  VE = 35840,
  HE = 35841,
  GE = 35842,
  WE = 35843,
  jE = 36196,
  $E = 37492,
  XE = 37496,
  YE = 37808,
  qE = 37809,
  KE = 37810,
  ZE = 37811,
  QE = 37812,
  JE = 37813,
  eM = 37814,
  tM = 37815,
  nM = 37816,
  rM = 37817,
  iM = 37818,
  sM = 37819,
  oM = 37820,
  aM = 37821,
  xx = 36492,
  lM = 36494,
  cM = 36495,
  K4 = 36283,
  uM = 36284,
  dM = 36285,
  fM = 36286,
  Z4 = 2200,
  Q4 = 2201,
  J4 = 2202,
  Eg = 2300,
  Mg = 2301,
  _x = 2302,
  $u = 2400,
  Xu = 2401,
  Tg = 2402,
  p_ = 2500,
  e2 = 2501,
  nj = 0,
  rj = 1,
  ij = 2,
  ek = 3200,
  t2 = 3201,
  Xa = 0,
  n2 = 1,
  Al = "",
  Xs = "srgb",
  Ho = "srgb-linear",
  m_ = "display-p3",
  d0 = "display-p3-linear",
  Cg = "linear",
  kn = "srgb",
  Rg = "rec709",
  Ng = "p3",
  sj = 0,
  Fu = 7680,
  oj = 7681,
  aj = 7682,
  lj = 7683,
  cj = 34055,
  uj = 34056,
  dj = 5386,
  fj = 512,
  hj = 513,
  pj = 514,
  mj = 515,
  gj = 516,
  vj = 517,
  yj = 518,
  hM = 519,
  tk = 512,
  r2 = 513,
  nk = 514,
  i2 = 515,
  rk = 516,
  ik = 517,
  sk = 518,
  ok = 519,
  Dh = 35044,
  d1 = 35048,
  xj = 35040,
  _j = 35045,
  Sj = 35049,
  Aj = 35041,
  wj = 35046,
  bj = 35050,
  Ej = 35042,
  Mj = "100",
  pM = "300 es",
  Do = 2e3,
  _d = 2001;
let Go = class {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
};
const Ii = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let T3 = 1234567;
const od = Math.PI / 180,
  Fh = 180 / Math.PI;
function io() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Ii[n & 255] +
    Ii[(n >> 8) & 255] +
    Ii[(n >> 16) & 255] +
    Ii[(n >> 24) & 255] +
    "-" +
    Ii[e & 255] +
    Ii[(e >> 8) & 255] +
    "-" +
    Ii[((e >> 16) & 15) | 64] +
    Ii[(e >> 24) & 255] +
    "-" +
    Ii[(t & 63) | 128] +
    Ii[(t >> 8) & 255] +
    "-" +
    Ii[(t >> 16) & 255] +
    Ii[(t >> 24) & 255] +
    Ii[r & 255] +
    Ii[(r >> 8) & 255] +
    Ii[(r >> 16) & 255] +
    Ii[(r >> 24) & 255]
  ).toLowerCase();
}
function ur(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function s2(n, e) {
  return ((n % e) + e) % e;
}
function Tj(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function Cj(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function jm(n, e, t) {
  return (1 - t) * n + t * e;
}
function Rj(n, e, t, r) {
  return jm(n, e, 1 - Math.exp(-t * r));
}
function Nj(n, e = 1) {
  return e - Math.abs(s2(n, e * 2) - e);
}
function Pj(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function Ij(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function Lj(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function Oj(n, e) {
  return n + Math.random() * (e - n);
}
function Dj(n) {
  return n * (0.5 - Math.random());
}
function Fj(n) {
  n !== void 0 && (T3 = n);
  let e = (T3 += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function Uj(n) {
  return n * od;
}
function kj(n) {
  return n * Fh;
}
function zj(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function Bj(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Vj(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Hj(n, e, t, r, i) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + r) / 2),
    u = o((e + r) / 2),
    d = s((e - r) / 2),
    h = o((e - r) / 2),
    m = s((r - e) / 2),
    g = o((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(a * u, l * d, l * h, a * c);
      break;
    case "YZY":
      n.set(l * h, a * u, l * d, a * c);
      break;
    case "ZXZ":
      n.set(l * d, l * h, a * u, a * c);
      break;
    case "XZX":
      n.set(a * u, l * g, l * m, a * c);
      break;
    case "YXY":
      n.set(l * m, a * u, l * g, a * c);
      break;
    case "ZYZ":
      n.set(l * g, l * m, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Ji(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Jt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const o2 = {
  DEG2RAD: od,
  RAD2DEG: Fh,
  generateUUID: io,
  clamp: ur,
  euclideanModulo: s2,
  mapLinear: Tj,
  inverseLerp: Cj,
  lerp: jm,
  damp: Rj,
  pingpong: Nj,
  smoothstep: Pj,
  smootherstep: Ij,
  randInt: Lj,
  randFloat: Oj,
  randFloatSpread: Dj,
  seededRandom: Fj,
  degToRad: Uj,
  radToDeg: kj,
  isPowerOfTwo: zj,
  ceilPowerOfTwo: Bj,
  floorPowerOfTwo: Vj,
  setQuaternionFromProperEuler: Hj,
  normalize: Jt,
  denormalize: Ji,
};
let He = class ak {
    constructor(e = 0, t = 0) {
      (ak.prototype.isVector2 = !0), (this.x = e), (this.y = t);
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
      return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
      return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
      return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x,
        r = this.y,
        i = e.elements;
      return (
        (this.x = i[0] * t + i[3] * r + i[6]),
        (this.y = i[1] * t + i[4] * r + i[7]),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        this
      );
    }
    clampLength(e, t) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const r = this.dot(e) / t;
      return Math.acos(ur(r, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        r = this.y - e.y;
      return t * t + r * r;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
      );
    }
    lerpVectors(e, t, r) {
      return (
        (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
      );
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t) {
      return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
    }
    rotateAround(e, t) {
      const r = Math.cos(t),
        i = Math.sin(t),
        s = this.x - e.x,
        o = this.y - e.y;
      return (
        (this.x = s * r - o * i + e.x), (this.y = s * i + o * r + e.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  },
  Qt = class lk {
    constructor(e, t, r, i, s, o, a, l, c) {
      (lk.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        e !== void 0 && this.set(e, t, r, i, s, o, a, l, c);
    }
    set(e, t, r, i, s, o, a, l, c) {
      const u = this.elements;
      return (
        (u[0] = e),
        (u[1] = i),
        (u[2] = a),
        (u[3] = t),
        (u[4] = s),
        (u[5] = l),
        (u[6] = r),
        (u[7] = o),
        (u[8] = c),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements,
        r = e.elements;
      return (
        (t[0] = r[0]),
        (t[1] = r[1]),
        (t[2] = r[2]),
        (t[3] = r[3]),
        (t[4] = r[4]),
        (t[5] = r[5]),
        (t[6] = r[6]),
        (t[7] = r[7]),
        (t[8] = r[8]),
        this
      );
    }
    extractBasis(e, t, r) {
      return (
        e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return (
        this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const r = e.elements,
        i = t.elements,
        s = this.elements,
        o = r[0],
        a = r[3],
        l = r[6],
        c = r[1],
        u = r[4],
        d = r[7],
        h = r[2],
        m = r[5],
        g = r[8],
        x = i[0],
        y = i[3],
        v = i[6],
        _ = i[1],
        S = i[4],
        w = i[7],
        T = i[2],
        E = i[5],
        M = i[8];
      return (
        (s[0] = o * x + a * _ + l * T),
        (s[3] = o * y + a * S + l * E),
        (s[6] = o * v + a * w + l * M),
        (s[1] = c * x + u * _ + d * T),
        (s[4] = c * y + u * S + d * E),
        (s[7] = c * v + u * w + d * M),
        (s[2] = h * x + m * _ + g * T),
        (s[5] = h * y + m * S + g * E),
        (s[8] = h * v + m * w + g * M),
        this
      );
    }
    multiplyScalar(e) {
      const t = this.elements;
      return (
        (t[0] *= e),
        (t[3] *= e),
        (t[6] *= e),
        (t[1] *= e),
        (t[4] *= e),
        (t[7] *= e),
        (t[2] *= e),
        (t[5] *= e),
        (t[8] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        i = e[2],
        s = e[3],
        o = e[4],
        a = e[5],
        l = e[6],
        c = e[7],
        u = e[8];
      return (
        t * o * u - t * a * c - r * s * u + r * a * l + i * s * c - i * o * l
      );
    }
    invert() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        i = e[2],
        s = e[3],
        o = e[4],
        a = e[5],
        l = e[6],
        c = e[7],
        u = e[8],
        d = u * o - a * c,
        h = a * l - u * s,
        m = c * s - o * l,
        g = t * d + r * h + i * m;
      if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const x = 1 / g;
      return (
        (e[0] = d * x),
        (e[1] = (i * c - u * r) * x),
        (e[2] = (a * r - i * o) * x),
        (e[3] = h * x),
        (e[4] = (u * t - i * l) * x),
        (e[5] = (i * s - a * t) * x),
        (e[6] = m * x),
        (e[7] = (r * l - c * t) * x),
        (e[8] = (o * t - r * s) * x),
        this
      );
    }
    transpose() {
      let e;
      const t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[3]),
        (t[3] = e),
        (e = t[2]),
        (t[2] = t[6]),
        (t[6] = e),
        (e = t[5]),
        (t[5] = t[7]),
        (t[7] = e),
        this
      );
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return (
        (e[0] = t[0]),
        (e[1] = t[3]),
        (e[2] = t[6]),
        (e[3] = t[1]),
        (e[4] = t[4]),
        (e[5] = t[7]),
        (e[6] = t[2]),
        (e[7] = t[5]),
        (e[8] = t[8]),
        this
      );
    }
    setUvTransform(e, t, r, i, s, o, a) {
      const l = Math.cos(s),
        c = Math.sin(s);
      return (
        this.set(
          r * l,
          r * c,
          -r * (l * o + c * a) + o + e,
          -i * c,
          i * l,
          -i * (-c * o + l * a) + a + t,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(e, t) {
      return this.premultiply(KA.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(KA.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(KA.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return (
        e.isVector2
          ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
          : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
      );
    }
    makeRotation(e) {
      const t = Math.cos(e),
        r = Math.sin(e);
      return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      const t = this.elements,
        r = e.elements;
      for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const r = this.elements;
      return (
        (e[t] = r[0]),
        (e[t + 1] = r[1]),
        (e[t + 2] = r[2]),
        (e[t + 3] = r[3]),
        (e[t + 4] = r[4]),
        (e[t + 5] = r[5]),
        (e[t + 6] = r[6]),
        (e[t + 7] = r[7]),
        (e[t + 8] = r[8]),
        e
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
const KA = new Qt();
function ck(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const Gj = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function eh(n, e) {
  return new Gj[n](e);
}
function Pg(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function uk() {
  const n = Pg("canvas");
  return (n.style.display = "block"), n;
}
const C3 = {};
function dk(n) {
  n in C3 || ((C3[n] = !0), console.warn(n));
}
const R3 = new Qt().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  N3 = new Qt().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  Bv = {
    [Ho]: {
      transfer: Cg,
      primaries: Rg,
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Xs]: {
      transfer: kn,
      primaries: Rg,
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [d0]: {
      transfer: Cg,
      primaries: Ng,
      toReference: (n) => n.applyMatrix3(N3),
      fromReference: (n) => n.applyMatrix3(R3),
    },
    [m_]: {
      transfer: kn,
      primaries: Ng,
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(N3),
      fromReference: (n) => n.applyMatrix3(R3).convertLinearToSRGB(),
    },
  },
  Wj = new Set([Ho, d0]),
  bn = {
    enabled: !0,
    _workingColorSpace: Ho,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!Wj.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const r = Bv[e].toReference,
        i = Bv[t].fromReference;
      return i(r(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return Bv[n].primaries;
    },
    getTransfer: function (n) {
      return n === Al ? Cg : Bv[n].transfer;
    },
  };
function yh(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function ZA(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let af,
  fk = class {
    static getDataURL(e) {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        af === void 0 && (af = Pg("canvas")),
          (af.width = e.width),
          (af.height = e.height);
        const r = af.getContext("2d");
        e instanceof ImageData
          ? r.putImageData(e, 0, 0)
          : r.drawImage(e, 0, 0, e.width, e.height),
          (t = af);
      }
      return t.width > 2048 || t.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            e
          ),
          t.toDataURL("image/jpeg", 0.6))
        : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (
        (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
      ) {
        const t = Pg("canvas");
        (t.width = e.width), (t.height = e.height);
        const r = t.getContext("2d");
        r.drawImage(e, 0, 0, e.width, e.height);
        const i = r.getImageData(0, 0, e.width, e.height),
          s = i.data;
        for (let o = 0; o < s.length; o++) s[o] = yh(s[o] / 255) * 255;
        return r.putImageData(i, 0, 0), t;
      } else if (e.data) {
        const t = e.data.slice(0);
        for (let r = 0; r < t.length; r++)
          t instanceof Uint8Array || t instanceof Uint8ClampedArray
            ? (t[r] = Math.floor(yh(t[r] / 255) * 255))
            : (t[r] = yh(t[r]));
        return { data: t, width: e.width, height: e.height };
      } else
        return (
          console.warn(
            "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
          ),
          e
        );
    }
  },
  jj = 0,
  Yu = class {
    constructor(e = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: jj++ }),
        (this.uuid = io()),
        (this.data = e),
        (this.dataReady = !0),
        (this.version = 0);
    }
    set needsUpdate(e) {
      e === !0 && this.version++;
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const r = { uuid: this.uuid, url: "" },
        i = this.data;
      if (i !== null) {
        let s;
        if (Array.isArray(i)) {
          s = [];
          for (let o = 0, a = i.length; o < a; o++)
            i[o].isDataTexture ? s.push(QA(i[o].image)) : s.push(QA(i[o]));
        } else s = QA(i);
        r.url = s;
      }
      return t || (e.images[this.uuid] = r), r;
    }
  };
function QA(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? fk.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let $j = 0,
  Fr = class Sx extends Go {
    constructor(
      e = Sx.DEFAULT_IMAGE,
      t = Sx.DEFAULT_MAPPING,
      r = Oo,
      i = Oo,
      s = dr,
      o = ca,
      a = ys,
      l = $a,
      c = Sx.DEFAULT_ANISOTROPY,
      u = Al
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: $j++ }),
        (this.uuid = io()),
        (this.name = ""),
        (this.source = new Yu(e)),
        (this.mipmaps = []),
        (this.mapping = t),
        (this.channel = 0),
        (this.wrapS = r),
        (this.wrapT = i),
        (this.magFilter = s),
        (this.minFilter = o),
        (this.anisotropy = c),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = l),
        (this.offset = new He(0, 0)),
        (this.repeat = new He(1, 1)),
        (this.center = new He(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Qt()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.colorSpace = u),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.pmremVersion = 0);
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.source = e.source),
        (this.mipmaps = e.mipmaps.slice(0)),
        (this.mapping = e.mapping),
        (this.channel = e.channel),
        (this.wrapS = e.wrapS),
        (this.wrapT = e.wrapT),
        (this.magFilter = e.magFilter),
        (this.minFilter = e.minFilter),
        (this.anisotropy = e.anisotropy),
        (this.format = e.format),
        (this.internalFormat = e.internalFormat),
        (this.type = e.type),
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        (this.rotation = e.rotation),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this.matrix.copy(e.matrix),
        (this.generateMipmaps = e.generateMipmaps),
        (this.premultiplyAlpha = e.premultiplyAlpha),
        (this.flipY = e.flipY),
        (this.unpackAlignment = e.unpackAlignment),
        (this.colorSpace = e.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const r = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (this.mapping !== h_) return e;
      if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
        switch (this.wrapS) {
          case wg:
            e.x = e.x - Math.floor(e.x);
            break;
          case Oo:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case bg:
            Math.abs(Math.floor(e.x) % 2) === 1
              ? (e.x = Math.ceil(e.x) - e.x)
              : (e.x = e.x - Math.floor(e.x));
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case wg:
            e.y = e.y - Math.floor(e.y);
            break;
          case Oo:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case bg:
            Math.abs(Math.floor(e.y) % 2) === 1
              ? (e.y = Math.ceil(e.y) - e.y)
              : (e.y = e.y - Math.floor(e.y));
            break;
        }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
    set needsPMREMUpdate(e) {
      e === !0 && this.pmremVersion++;
    }
  };
Fr.DEFAULT_IMAGE = null;
Fr.DEFAULT_MAPPING = h_;
Fr.DEFAULT_ANISOTROPY = 1;
class rn {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (rn.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s),
      (this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s),
      (this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s),
      (this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      h = l[1],
      m = l[5],
      g = l[9],
      x = l[2],
      y = l[6],
      v = l[10];
    if (
      Math.abs(u - h) < 0.01 &&
      Math.abs(d - x) < 0.01 &&
      Math.abs(g - y) < 0.01
    ) {
      if (
        Math.abs(u + h) < 0.1 &&
        Math.abs(d + x) < 0.1 &&
        Math.abs(g + y) < 0.1 &&
        Math.abs(c + m + v - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (c + 1) / 2,
        w = (m + 1) / 2,
        T = (v + 1) / 2,
        E = (u + h) / 4,
        M = (d + x) / 4,
        N = (g + y) / 4;
      return (
        S > w && S > T
          ? S < 0.01
            ? ((r = 0), (i = 0.707106781), (s = 0.707106781))
            : ((r = Math.sqrt(S)), (i = E / r), (s = M / r))
          : w > T
          ? w < 0.01
            ? ((r = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(w)), (r = E / i), (s = N / i))
          : T < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(T)), (r = M / s), (i = N / s)),
        this.set(r, i, s, t),
        this
      );
    }
    let _ = Math.sqrt(
      (y - g) * (y - g) + (d - x) * (d - x) + (h - u) * (h - u)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (y - g) / _),
      (this.y = (d - x) / _),
      (this.z = (h - u) / _),
      (this.w = Math.acos((c + m + v - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Fl extends Go {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new rn(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new rn(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    r = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: dr,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      r
    );
    const s = new Fr(
      i,
      r.mapping,
      r.wrapS,
      r.wrapT,
      r.magFilter,
      r.minFilter,
      r.format,
      r.type,
      r.anisotropy,
      r.colorSpace
    );
    (s.flipY = !1),
      (s.generateMipmaps = r.generateMipmaps),
      (s.internalFormat = r.internalFormat),
      (this.textures = []);
    const o = r.count;
    for (let a = 0; a < o; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0);
    (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, s = this.textures.length; i < s; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = r);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let r = 0, i = e.textures.length; r < i; r++)
      (this.textures[r] = e.textures[r].clone()),
        (this.textures[r].isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Yu(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class va extends Fl {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class f0 extends Fr {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = Dr),
      (this.minFilter = Dr),
      (this.wrapR = Oo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Xj extends va {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new f0(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class a2 extends Fr {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = Dr),
      (this.minFilter = Dr),
      (this.wrapR = Oo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Yj extends va {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new a2(null, e, t, r)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class ki {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, s, o, a) {
    let l = r[i + 0],
      c = r[i + 1],
      u = r[i + 2],
      d = r[i + 3];
    const h = s[o + 0],
      m = s[o + 1],
      g = s[o + 2],
      x = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = h), (e[t + 1] = m), (e[t + 2] = g), (e[t + 3] = x);
      return;
    }
    if (d !== x || l !== h || c !== m || u !== g) {
      let y = 1 - a;
      const v = l * h + c * m + u * g + d * x,
        _ = v >= 0 ? 1 : -1,
        S = 1 - v * v;
      if (S > Number.EPSILON) {
        const T = Math.sqrt(S),
          E = Math.atan2(T, v * _);
        (y = Math.sin(y * E) / T), (a = Math.sin(a * E) / T);
      }
      const w = a * _;
      if (
        ((l = l * y + h * w),
        (c = c * y + m * w),
        (u = u * y + g * w),
        (d = d * y + x * w),
        y === 1 - a)
      ) {
        const T = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
        (l *= T), (c *= T), (u *= T), (d *= T);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, r, i, s, o) {
    const a = r[i],
      l = r[i + 1],
      c = r[i + 2],
      u = r[i + 3],
      d = s[o],
      h = s[o + 1],
      m = s[o + 2],
      g = s[o + 3];
    return (
      (e[t] = a * g + u * d + l * m - c * h),
      (e[t + 1] = l * g + u * h + c * d - a * m),
      (e[t + 2] = c * g + u * m + a * h - l * d),
      (e[t + 3] = u * g - a * d - l * h - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(r / 2),
      u = a(i / 2),
      d = a(s / 2),
      h = l(r / 2),
      m = l(i / 2),
      g = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = h * u * d + c * m * g),
          (this._y = c * m * d - h * u * g),
          (this._z = c * u * g + h * m * d),
          (this._w = c * u * d - h * m * g);
        break;
      case "YXZ":
        (this._x = h * u * d + c * m * g),
          (this._y = c * m * d - h * u * g),
          (this._z = c * u * g - h * m * d),
          (this._w = c * u * d + h * m * g);
        break;
      case "ZXY":
        (this._x = h * u * d - c * m * g),
          (this._y = c * m * d + h * u * g),
          (this._z = c * u * g + h * m * d),
          (this._w = c * u * d - h * m * g);
        break;
      case "ZYX":
        (this._x = h * u * d - c * m * g),
          (this._y = c * m * d + h * u * g),
          (this._z = c * u * g - h * m * d),
          (this._w = c * u * d + h * m * g);
        break;
      case "YZX":
        (this._x = h * u * d + c * m * g),
          (this._y = c * m * d + h * u * g),
          (this._z = c * u * g - h * m * d),
          (this._w = c * u * d - h * m * g);
        break;
      case "XZY":
        (this._x = h * u * d - c * m * g),
          (this._y = c * m * d - h * u * g),
          (this._z = c * u * g + h * m * d),
          (this._w = c * u * d + h * m * g);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      d = t[10],
      h = r + a + d;
    if (h > 0) {
      const m = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / m),
        (this._x = (u - l) * m),
        (this._y = (s - c) * m),
        (this._z = (o - i) * m);
    } else if (r > a && r > d) {
      const m = 2 * Math.sqrt(1 + r - a - d);
      (this._w = (u - l) / m),
        (this._x = 0.25 * m),
        (this._y = (i + o) / m),
        (this._z = (s + c) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - r - d);
      (this._w = (s - c) / m),
        (this._x = (i + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + u) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - r - a);
      (this._w = (o - i) / m),
        (this._x = (s + c) / m),
        (this._y = (l + u) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < Number.EPSILON
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(ur(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = r * u + o * a + i * c - s * l),
      (this._y = i * u + o * l + s * a - r * c),
      (this._z = s * u + o * c + r * l - i * a),
      (this._w = o * u - r * a - i * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + r * e._x + i * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = r), (this._y = i), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * r + t * this._x),
        (this._y = m * i + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      d = Math.sin((1 - t) * u) / c,
      h = Math.sin(t * u) / c;
    return (
      (this._w = o * d + this._w * h),
      (this._x = r * d + this._x * h),
      (this._y = i * d + this._y * h),
      (this._z = s * d + this._z * h),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      s = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Q {
  constructor(e = 0, t = 0, r = 0) {
    (Q.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(P3.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(P3.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * r + s[6] * i),
      (this.y = s[1] * t + s[4] * r + s[7] * i),
      (this.z = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o),
      (this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o),
      (this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * i - a * r),
      u = 2 * (a * t - s * i),
      d = 2 * (s * r - o * t);
    return (
      (this.x = t + l * c + o * d - a * u),
      (this.y = r + l * u + a * c - s * d),
      (this.z = i + l * d + s * u - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i),
      (this.y = s[1] * t + s[5] * r + s[9] * i),
      (this.z = s[2] * t + s[6] * r + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = i * l - s * a),
      (this.y = s * o - r * l),
      (this.z = r * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return JA.copy(this).projectOnVector(e), this.sub(JA);
  }
  reflect(e) {
    return this.sub(JA.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(ur(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const JA = new Q(),
  P3 = new ki();
class zi {
  constructor(
    e = new Q(1 / 0, 1 / 0, 1 / 0),
    t = new Q(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(Ko.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(Ko.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = Ko.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const s = r.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Ko)
            : Ko.fromBufferAttribute(s, o),
            Ko.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Ko);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            Vv.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            Vv.copy(r.boundingBox)),
          Vv.applyMatrix4(e.matrixWorld),
          this.union(Vv);
    }
    const i = e.children;
    for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ko),
      Ko.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(rm),
      Hv.subVectors(this.max, rm),
      lf.subVectors(e.a, rm),
      cf.subVectors(e.b, rm),
      uf.subVectors(e.c, rm),
      ic.subVectors(cf, lf),
      sc.subVectors(uf, cf),
      vu.subVectors(lf, uf);
    let t = [
      0,
      -ic.z,
      ic.y,
      0,
      -sc.z,
      sc.y,
      0,
      -vu.z,
      vu.y,
      ic.z,
      0,
      -ic.x,
      sc.z,
      0,
      -sc.x,
      vu.z,
      0,
      -vu.x,
      -ic.y,
      ic.x,
      0,
      -sc.y,
      sc.x,
      0,
      -vu.y,
      vu.x,
      0,
    ];
    return !ew(t, lf, cf, uf, Hv) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ew(t, lf, cf, uf, Hv))
      ? !1
      : (Gv.crossVectors(ic, sc),
        (t = [Gv.x, Gv.y, Gv.z]),
        ew(t, lf, cf, uf, Hv));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ko).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ko).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (ul[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ul[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ul[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ul[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ul[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ul[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ul[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ul[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ul),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ul = [
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
    new Q(),
  ],
  Ko = new Q(),
  Vv = new zi(),
  lf = new Q(),
  cf = new Q(),
  uf = new Q(),
  ic = new Q(),
  sc = new Q(),
  vu = new Q(),
  rm = new Q(),
  Hv = new Q(),
  Gv = new Q(),
  yu = new Q();
function ew(n, e, t, r, i) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    yu.fromArray(n, s);
    const a =
        i.x * Math.abs(yu.x) + i.y * Math.abs(yu.y) + i.z * Math.abs(yu.z),
      l = e.dot(yu),
      c = t.dot(yu),
      u = r.dot(yu);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const qj = new zi(),
  im = new Q(),
  tw = new Q();
class mi {
  constructor(e = new Q(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : qj.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, r.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    im.subVectors(e, this.center);
    const t = im.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(im, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (tw.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(im.copy(e.center).add(tw)),
            this.expandByPoint(im.copy(e.center).sub(tw))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const dl = new Q(),
  nw = new Q(),
  Wv = new Q(),
  oc = new Q(),
  rw = new Q(),
  jv = new Q(),
  iw = new Q();
class Id {
  constructor(e = new Q(), t = new Q(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, dl)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = dl.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (dl.copy(this.origin).addScaledVector(this.direction, t),
        dl.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    nw.copy(e).add(t).multiplyScalar(0.5),
      Wv.copy(t).sub(e).normalize(),
      oc.copy(this.origin).sub(nw);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Wv),
      a = oc.dot(this.direction),
      l = -oc.dot(Wv),
      c = oc.lengthSq(),
      u = Math.abs(1 - o * o);
    let d, h, m, g;
    if (u > 0)
      if (((d = o * l - a), (h = o * a - l), (g = s * u), d >= 0))
        if (h >= -g)
          if (h <= g) {
            const x = 1 / u;
            (d *= x),
              (h *= x),
              (m = d * (d + o * h + 2 * a) + h * (o * d + h + 2 * l) + c);
          } else
            (h = s),
              (d = Math.max(0, -(o * h + a))),
              (m = -d * d + h * (h + 2 * l) + c);
        else
          (h = -s),
            (d = Math.max(0, -(o * h + a))),
            (m = -d * d + h * (h + 2 * l) + c);
      else
        h <= -g
          ? ((d = Math.max(0, -(-o * s + a))),
            (h = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + h * (h + 2 * l) + c))
          : h <= g
          ? ((d = 0),
            (h = Math.min(Math.max(-s, -l), s)),
            (m = h * (h + 2 * l) + c))
          : ((d = Math.max(0, -(o * s + a))),
            (h = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + h * (h + 2 * l) + c));
    else
      (h = o > 0 ? -s : s),
        (d = Math.max(0, -(o * h + a))),
        (m = -d * d + h * (h + 2 * l) + c);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, d),
      i && i.copy(nw).addScaledVector(Wv, h),
      m
    );
  }
  intersectSphere(e, t) {
    dl.subVectors(e.center, this.origin);
    const r = dl.dot(this.direction),
      i = dl.dot(dl) - r * r,
      s = e.radius * e.radius;
    if (i > s) return null;
    const o = Math.sqrt(s - i),
      a = r - o,
      l = r + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, s, o, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      h = this.origin;
    return (
      c >= 0
        ? ((r = (e.min.x - h.x) * c), (i = (e.max.x - h.x) * c))
        : ((r = (e.max.x - h.x) * c), (i = (e.min.x - h.x) * c)),
      u >= 0
        ? ((s = (e.min.y - h.y) * u), (o = (e.max.y - h.y) * u))
        : ((s = (e.max.y - h.y) * u), (o = (e.min.y - h.y) * u)),
      r > o ||
      s > i ||
      ((s > r || isNaN(r)) && (r = s),
      (o < i || isNaN(i)) && (i = o),
      d >= 0
        ? ((a = (e.min.z - h.z) * d), (l = (e.max.z - h.z) * d))
        : ((a = (e.max.z - h.z) * d), (l = (e.min.z - h.z) * d)),
      r > l || a > i) ||
      ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, dl) !== null;
  }
  intersectTriangle(e, t, r, i, s) {
    rw.subVectors(t, e), jv.subVectors(r, e), iw.crossVectors(rw, jv);
    let o = this.direction.dot(iw),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    oc.subVectors(this.origin, e);
    const l = a * this.direction.dot(jv.crossVectors(oc, jv));
    if (l < 0) return null;
    const c = a * this.direction.dot(rw.cross(oc));
    if (c < 0 || l + c > o) return null;
    const u = -a * oc.dot(iw);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ut {
  constructor(e, t, r, i, s, o, a, l, c, u, d, h, m, g, x, y) {
    (Ut.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, c, u, d, h, m, g, x, y);
  }
  set(e, t, r, i, s, o, a, l, c, u, d, h, m, g, x, y) {
    const v = this.elements;
    return (
      (v[0] = e),
      (v[4] = t),
      (v[8] = r),
      (v[12] = i),
      (v[1] = s),
      (v[5] = o),
      (v[9] = a),
      (v[13] = l),
      (v[2] = c),
      (v[6] = u),
      (v[10] = d),
      (v[14] = h),
      (v[3] = m),
      (v[7] = g),
      (v[11] = x),
      (v[15] = y),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Ut().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / df.setFromMatrixColumn(e, 0).length(),
      s = 1 / df.setFromMatrixColumn(e, 1).length(),
      o = 1 / df.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * s),
      (t[5] = r[5] * s),
      (t[6] = r[6] * s),
      (t[7] = 0),
      (t[8] = r[8] * o),
      (t[9] = r[9] * o),
      (t[10] = r[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z,
      o = Math.cos(r),
      a = Math.sin(r),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const h = o * u,
        m = o * d,
        g = a * u,
        x = a * d;
      (t[0] = l * u),
        (t[4] = -l * d),
        (t[8] = c),
        (t[1] = m + g * c),
        (t[5] = h - x * c),
        (t[9] = -a * l),
        (t[2] = x - h * c),
        (t[6] = g + m * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const h = l * u,
        m = l * d,
        g = c * u,
        x = c * d;
      (t[0] = h + x * a),
        (t[4] = g * a - m),
        (t[8] = o * c),
        (t[1] = o * d),
        (t[5] = o * u),
        (t[9] = -a),
        (t[2] = m * a - g),
        (t[6] = x + h * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const h = l * u,
        m = l * d,
        g = c * u,
        x = c * d;
      (t[0] = h - x * a),
        (t[4] = -o * d),
        (t[8] = g + m * a),
        (t[1] = m + g * a),
        (t[5] = o * u),
        (t[9] = x - h * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const h = o * u,
        m = o * d,
        g = a * u,
        x = a * d;
      (t[0] = l * u),
        (t[4] = g * c - m),
        (t[8] = h * c + x),
        (t[1] = l * d),
        (t[5] = x * c + h),
        (t[9] = m * c - g),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const h = o * l,
        m = o * c,
        g = a * l,
        x = a * c;
      (t[0] = l * u),
        (t[4] = x - h * d),
        (t[8] = g * d + m),
        (t[1] = d),
        (t[5] = o * u),
        (t[9] = -a * u),
        (t[2] = -c * u),
        (t[6] = m * d + g),
        (t[10] = h - x * d);
    } else if (e.order === "XZY") {
      const h = o * l,
        m = o * c,
        g = a * l,
        x = a * c;
      (t[0] = l * u),
        (t[4] = -d),
        (t[8] = c * u),
        (t[1] = h * d + x),
        (t[5] = o * u),
        (t[9] = m * d - g),
        (t[2] = g * d - m),
        (t[6] = a * u),
        (t[10] = x * d + h);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Kj, e, Zj);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      Bs.subVectors(e, t),
      Bs.lengthSq() === 0 && (Bs.z = 1),
      Bs.normalize(),
      ac.crossVectors(r, Bs),
      ac.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (Bs.x += 1e-4) : (Bs.z += 1e-4),
        Bs.normalize(),
        ac.crossVectors(r, Bs)),
      ac.normalize(),
      $v.crossVectors(Bs, ac),
      (i[0] = ac.x),
      (i[4] = $v.x),
      (i[8] = Bs.x),
      (i[1] = ac.y),
      (i[5] = $v.y),
      (i[9] = Bs.y),
      (i[2] = ac.z),
      (i[6] = $v.z),
      (i[10] = Bs.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[4],
      l = r[8],
      c = r[12],
      u = r[1],
      d = r[5],
      h = r[9],
      m = r[13],
      g = r[2],
      x = r[6],
      y = r[10],
      v = r[14],
      _ = r[3],
      S = r[7],
      w = r[11],
      T = r[15],
      E = i[0],
      M = i[4],
      N = i[8],
      R = i[12],
      C = i[1],
      L = i[5],
      O = i[9],
      D = i[13],
      B = i[2],
      $ = i[6],
      G = i[10],
      j = i[14],
      U = i[3],
      H = i[7],
      V = i[11],
      k = i[15];
    return (
      (s[0] = o * E + a * C + l * B + c * U),
      (s[4] = o * M + a * L + l * $ + c * H),
      (s[8] = o * N + a * O + l * G + c * V),
      (s[12] = o * R + a * D + l * j + c * k),
      (s[1] = u * E + d * C + h * B + m * U),
      (s[5] = u * M + d * L + h * $ + m * H),
      (s[9] = u * N + d * O + h * G + m * V),
      (s[13] = u * R + d * D + h * j + m * k),
      (s[2] = g * E + x * C + y * B + v * U),
      (s[6] = g * M + x * L + y * $ + v * H),
      (s[10] = g * N + x * O + y * G + v * V),
      (s[14] = g * R + x * D + y * j + v * k),
      (s[3] = _ * E + S * C + w * B + T * U),
      (s[7] = _ * M + S * L + w * $ + T * H),
      (s[11] = _ * N + S * O + w * G + T * V),
      (s[15] = _ * R + S * D + w * j + T * k),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      h = e[10],
      m = e[14],
      g = e[3],
      x = e[7],
      y = e[11],
      v = e[15];
    return (
      g *
        (+s * l * d -
          i * c * d -
          s * a * h +
          r * c * h +
          i * a * m -
          r * l * m) +
      x *
        (+t * l * m -
          t * c * h +
          s * o * h -
          i * o * m +
          i * c * u -
          s * l * u) +
      y *
        (+t * c * d -
          t * a * m -
          s * o * d +
          r * o * m +
          s * a * u -
          r * c * u) +
      v *
        (-i * a * u - t * l * d + t * a * h + i * o * d - r * o * h + r * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      h = e[10],
      m = e[11],
      g = e[12],
      x = e[13],
      y = e[14],
      v = e[15],
      _ = d * y * c - x * h * c + x * l * m - a * y * m - d * l * v + a * h * v,
      S = g * h * c - u * y * c - g * l * m + o * y * m + u * l * v - o * h * v,
      w = u * x * c - g * d * c + g * a * m - o * x * m - u * a * v + o * d * v,
      T = g * d * l - u * x * l - g * a * h + o * x * h + u * a * y - o * d * y,
      E = t * _ + r * S + i * w + s * T;
    if (E === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / E;
    return (
      (e[0] = _ * M),
      (e[1] =
        (x * h * s -
          d * y * s -
          x * i * m +
          r * y * m +
          d * i * v -
          r * h * v) *
        M),
      (e[2] =
        (a * y * s -
          x * l * s +
          x * i * c -
          r * y * c -
          a * i * v +
          r * l * v) *
        M),
      (e[3] =
        (d * l * s -
          a * h * s -
          d * i * c +
          r * h * c +
          a * i * m -
          r * l * m) *
        M),
      (e[4] = S * M),
      (e[5] =
        (u * y * s -
          g * h * s +
          g * i * m -
          t * y * m -
          u * i * v +
          t * h * v) *
        M),
      (e[6] =
        (g * l * s -
          o * y * s -
          g * i * c +
          t * y * c +
          o * i * v -
          t * l * v) *
        M),
      (e[7] =
        (o * h * s -
          u * l * s +
          u * i * c -
          t * h * c -
          o * i * m +
          t * l * m) *
        M),
      (e[8] = w * M),
      (e[9] =
        (g * d * s -
          u * x * s -
          g * r * m +
          t * x * m +
          u * r * v -
          t * d * v) *
        M),
      (e[10] =
        (o * x * s -
          g * a * s +
          g * r * c -
          t * x * c -
          o * r * v +
          t * a * v) *
        M),
      (e[11] =
        (u * a * s -
          o * d * s -
          u * r * c +
          t * d * c +
          o * r * m -
          t * a * m) *
        M),
      (e[12] = T * M),
      (e[13] =
        (u * x * i -
          g * d * i +
          g * r * h -
          t * x * h -
          u * r * y +
          t * d * y) *
        M),
      (e[14] =
        (g * a * i -
          o * x * i -
          g * r * l +
          t * x * l +
          o * r * y -
          t * a * y) *
        M),
      (e[15] =
        (o * d * i -
          u * a * i +
          u * r * l -
          t * d * l -
          o * r * h +
          t * a * h) *
        M),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = 1 - r,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a;
    return (
      this.set(
        c * o + r,
        c * a - i * l,
        c * l + i * a,
        0,
        c * a + i * l,
        u * a + r,
        u * l - i * o,
        0,
        c * l - i * a,
        u * l + i * o,
        s * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, s, o) {
    return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      u = o + o,
      d = a + a,
      h = s * c,
      m = s * u,
      g = s * d,
      x = o * u,
      y = o * d,
      v = a * d,
      _ = l * c,
      S = l * u,
      w = l * d,
      T = r.x,
      E = r.y,
      M = r.z;
    return (
      (i[0] = (1 - (x + v)) * T),
      (i[1] = (m + w) * T),
      (i[2] = (g - S) * T),
      (i[3] = 0),
      (i[4] = (m - w) * E),
      (i[5] = (1 - (h + v)) * E),
      (i[6] = (y + _) * E),
      (i[7] = 0),
      (i[8] = (g + S) * M),
      (i[9] = (y - _) * M),
      (i[10] = (1 - (h + x)) * M),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let s = df.set(i[0], i[1], i[2]).length();
    const o = df.set(i[4], i[5], i[6]).length(),
      a = df.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      Zo.copy(this);
    const c = 1 / s,
      u = 1 / o,
      d = 1 / a;
    return (
      (Zo.elements[0] *= c),
      (Zo.elements[1] *= c),
      (Zo.elements[2] *= c),
      (Zo.elements[4] *= u),
      (Zo.elements[5] *= u),
      (Zo.elements[6] *= u),
      (Zo.elements[8] *= d),
      (Zo.elements[9] *= d),
      (Zo.elements[10] *= d),
      t.setFromRotationMatrix(Zo),
      (r.x = s),
      (r.y = o),
      (r.z = a),
      this
    );
  }
  makePerspective(e, t, r, i, s, o, a = Do) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      u = (2 * s) / (r - i),
      d = (t + e) / (t - e),
      h = (r + i) / (r - i);
    let m, g;
    if (a === Do) (m = -(o + s) / (o - s)), (g = (-2 * o * s) / (o - s));
    else if (a === _d) (m = -o / (o - s)), (g = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = h),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = m),
      (l[14] = g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, s, o, a = Do) {
    const l = this.elements,
      c = 1 / (t - e),
      u = 1 / (r - i),
      d = 1 / (o - s),
      h = (t + e) * c,
      m = (r + i) * u;
    let g, x;
    if (a === Do) (g = (o + s) * d), (x = -2 * d);
    else if (a === _d) (g = s * d), (x = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -h),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -m),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = x),
      (l[14] = -g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const df = new Q(),
  Zo = new Ut(),
  Kj = new Q(0, 0, 0),
  Zj = new Q(1, 1, 1),
  ac = new Q(),
  $v = new Q(),
  Bs = new Q(),
  I3 = new Ut(),
  L3 = new ki();
class ao {
  constructor(e = 0, t = 0, r = 0, i = ao.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      s = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      d = i[2],
      h = i[6],
      m = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(ur(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(h, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-ur(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(ur(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-ur(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(h, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(ur(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-ur(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(h, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      I3.makeRotationFromQuaternion(e), this.setFromRotationMatrix(I3, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return L3.setFromEuler(this), this.setFromQuaternion(L3, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ao.DEFAULT_ORDER = "XYZ";
class ad {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Qj = 0;
const O3 = new Q(),
  ff = new ki(),
  fl = new Ut(),
  Xv = new Q(),
  sm = new Q(),
  Jj = new Q(),
  e7 = new ki(),
  D3 = new Q(1, 0, 0),
  F3 = new Q(0, 1, 0),
  U3 = new Q(0, 0, 1),
  k3 = { type: "added" },
  t7 = { type: "removed" },
  hf = { type: "childadded", child: null },
  sw = { type: "childremoved", child: null };
class xn extends Go {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Qj++ }),
      (this.uuid = io()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = xn.DEFAULT_UP.clone());
    const e = new Q(),
      t = new ao(),
      r = new ki(),
      i = new Q(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s),
      r._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Ut() },
        normalMatrix: { value: new Qt() },
      }),
      (this.matrix = new Ut()),
      (this.matrixWorld = new Ut()),
      (this.matrixAutoUpdate = xn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new ad()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return ff.setFromAxisAngle(e, t), this.quaternion.multiply(ff), this;
  }
  rotateOnWorldAxis(e, t) {
    return ff.setFromAxisAngle(e, t), this.quaternion.premultiply(ff), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(D3, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(F3, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(U3, e);
  }
  translateOnAxis(e, t) {
    return (
      O3.copy(e).applyQuaternion(this.quaternion),
      this.position.add(O3.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(D3, e);
  }
  translateY(e) {
    return this.translateOnAxis(F3, e);
  }
  translateZ(e) {
    return this.translateOnAxis(U3, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(fl.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? Xv.copy(e) : Xv.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      sm.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? fl.lookAt(sm, Xv, this.up)
        : fl.lookAt(Xv, sm, this.up),
      this.quaternion.setFromRotationMatrix(fl),
      i &&
        (fl.extractRotation(i.matrixWorld),
        ff.setFromRotationMatrix(fl),
        this.quaternion.premultiply(ff.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(k3),
            (hf.child = e),
            this.dispatchEvent(hf),
            (hf.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(t7),
        (sw.child = e),
        this.dispatchEvent(sw),
        (sw.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      fl.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), fl.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(fl),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(k3),
      (hf.child = e),
      this.dispatchEvent(hf),
      (hf.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let s = 0, o = i.length; s < o; s++)
      i[s].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sm, e, Jj), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sm, e7, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 &&
        r !== null &&
        r.matrixWorldAutoUpdate === !0 &&
        r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++) {
        const a = i[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map((a) => ({
          boxInitialized: a.boxInitialized,
          boxMin: a.box.min.toArray(),
          boxMax: a.box.max.toArray(),
          sphereInitialized: a.sphereInitialized,
          sphereRadius: a.sphere.radius,
          sphereCenter: a.sphere.center.toArray(),
        }))),
        (i.maxGeometryCount = this._maxGeometryCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        d = o(e.shapes),
        h = o(e.skeletons),
        m = o(e.animations),
        g = o(e.nodes);
      a.length > 0 && (r.geometries = a),
        l.length > 0 && (r.materials = l),
        c.length > 0 && (r.textures = c),
        u.length > 0 && (r.images = u),
        d.length > 0 && (r.shapes = d),
        h.length > 0 && (r.skeletons = h),
        m.length > 0 && (r.animations = m),
        g.length > 0 && (r.nodes = g);
    }
    return (r.object = i), r;
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
xn.DEFAULT_UP = new Q(0, 1, 0);
xn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
xn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Qo = new Q(),
  hl = new Q(),
  ow = new Q(),
  pl = new Q(),
  pf = new Q(),
  mf = new Q(),
  z3 = new Q(),
  aw = new Q(),
  lw = new Q(),
  cw = new Q();
class qs {
  constructor(e = new Q(), t = new Q(), r = new Q()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), Qo.subVectors(e, t), i.cross(Qo);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, s) {
    Qo.subVectors(i, t), hl.subVectors(r, t), ow.subVectors(e, t);
    const o = Qo.dot(Qo),
      a = Qo.dot(hl),
      l = Qo.dot(ow),
      c = hl.dot(hl),
      u = hl.dot(ow),
      d = o * c - a * a;
    if (d === 0) return s.set(0, 0, 0), null;
    const h = 1 / d,
      m = (c * l - a * u) * h,
      g = (o * u - a * l) * h;
    return s.set(1 - m - g, g, m);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, pl) === null
      ? !1
      : pl.x >= 0 && pl.y >= 0 && pl.x + pl.y <= 1;
  }
  static getInterpolation(e, t, r, i, s, o, a, l) {
    return this.getBarycoord(e, t, r, i, pl) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, pl.x),
        l.addScaledVector(o, pl.y),
        l.addScaledVector(a, pl.z),
        l);
  }
  static isFrontFacing(e, t, r, i) {
    return Qo.subVectors(r, t), hl.subVectors(e, t), Qo.cross(hl).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      Qo.subVectors(this.c, this.b),
      hl.subVectors(this.a, this.b),
      Qo.cross(hl).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return qs.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return qs.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, s) {
    return qs.getInterpolation(e, this.a, this.b, this.c, t, r, i, s);
  }
  containsPoint(e) {
    return qs.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return qs.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      s = this.c;
    let o, a;
    pf.subVectors(i, r), mf.subVectors(s, r), aw.subVectors(e, r);
    const l = pf.dot(aw),
      c = mf.dot(aw);
    if (l <= 0 && c <= 0) return t.copy(r);
    lw.subVectors(e, i);
    const u = pf.dot(lw),
      d = mf.dot(lw);
    if (u >= 0 && d <= u) return t.copy(i);
    const h = l * d - u * c;
    if (h <= 0 && l >= 0 && u <= 0)
      return (o = l / (l - u)), t.copy(r).addScaledVector(pf, o);
    cw.subVectors(e, s);
    const m = pf.dot(cw),
      g = mf.dot(cw);
    if (g >= 0 && m <= g) return t.copy(s);
    const x = m * c - l * g;
    if (x <= 0 && c >= 0 && g <= 0)
      return (a = c / (c - g)), t.copy(r).addScaledVector(mf, a);
    const y = u * g - m * d;
    if (y <= 0 && d - u >= 0 && m - g >= 0)
      return (
        z3.subVectors(s, i),
        (a = (d - u) / (d - u + (m - g))),
        t.copy(i).addScaledVector(z3, a)
      );
    const v = 1 / (y + x + h);
    return (
      (o = x * v),
      (a = h * v),
      t.copy(r).addScaledVector(pf, o).addScaledVector(mf, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const hk = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  lc = { h: 0, s: 0, l: 0 },
  Yv = { h: 0, s: 0, l: 0 };
function uw(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class pt {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Xs) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      bn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, r, i = bn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      bn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, r, i = bn.workingColorSpace) {
    if (((e = s2(e, 1)), (t = ur(t, 0, 1)), (r = ur(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        o = 2 * r - s;
      (this.r = uw(o, s, e + 1 / 3)),
        (this.g = uw(o, s, e)),
        (this.b = uw(o, s, e - 1 / 3));
    }
    return bn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Xs) {
    function r(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = i[1],
        a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Xs) {
    const r = hk[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = yh(e.r)), (this.g = yh(e.g)), (this.b = yh(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = ZA(e.r)), (this.g = ZA(e.g)), (this.b = ZA(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Xs) {
    return (
      bn.fromWorkingColorSpace(Li.copy(this), e),
      Math.round(ur(Li.r * 255, 0, 255)) * 65536 +
        Math.round(ur(Li.g * 255, 0, 255)) * 256 +
        Math.round(ur(Li.b * 255, 0, 255))
    );
  }
  getHexString(e = Xs) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = bn.workingColorSpace) {
    bn.fromWorkingColorSpace(Li.copy(this), t);
    const r = Li.r,
      i = Li.g,
      s = Li.b,
      o = Math.max(r, i, s),
      a = Math.min(r, i, s);
    let l, c;
    const u = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const d = o - a;
      switch (((c = u <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case r:
          l = (i - s) / d + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - r) / d + 2;
          break;
        case s:
          l = (r - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = bn.workingColorSpace) {
    return (
      bn.fromWorkingColorSpace(Li.copy(this), t),
      (e.r = Li.r),
      (e.g = Li.g),
      (e.b = Li.b),
      e
    );
  }
  getStyle(e = Xs) {
    bn.fromWorkingColorSpace(Li.copy(this), e);
    const t = Li.r,
      r = Li.g,
      i = Li.b;
    return e !== Xs
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(lc), this.setHSL(lc.h + e, lc.s + t, lc.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(lc), e.getHSL(Yv);
    const r = jm(lc.h, Yv.h, t),
      i = jm(lc.s, Yv.s, t),
      s = jm(lc.l, Yv.l, t);
    return this.setHSL(r, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * r + s[6] * i),
      (this.g = s[1] * t + s[4] * r + s[7] * i),
      (this.b = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Li = new pt();
pt.NAMES = hk;
let n7 = 0;
class oi extends Go {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: n7++ }),
      (this.uuid = io()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = id),
      (this.side = ja),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = c1),
      (this.blendDst = u1),
      (this.blendEquation = xc),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new pt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = _g),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = hM),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Fu),
      (this.stencilZFail = Fu),
      (this.stencilZPass = Fu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== id && (r.blending = this.blending),
      this.side !== ja && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== c1 && (r.blendSrc = this.blendSrc),
      this.blendDst !== u1 && (r.blendDst = this.blendDst),
      this.blendEquation !== xc && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== _g && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== hM && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Fu && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== Fu && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Fu && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = i(e.textures),
        o = i(e.images);
      s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let s = 0; s !== i; ++s) r[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Za extends oi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ao()),
      (this.combine = u0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const wl = r7();
function r7() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((r[l] = 1024 >> (-c - 14)),
        (r[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((r[l] = (c + 15) << 10),
        (r[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (s[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function hs(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = ur(n, -65504, 65504)),
    (wl.floatView[0] = n);
  const e = wl.uint32View[0],
    t = (e >> 23) & 511;
  return wl.baseTable[t] + ((e & 8388607) >> wl.shiftTable[t]);
}
function Cm(n) {
  const e = n >> 10;
  return (
    (wl.uint32View[0] =
      wl.mantissaTable[wl.offsetTable[e] + (n & 1023)] + wl.exponentTable[e]),
    wl.floatView[0]
  );
}
const i7 = { toHalfFloat: hs, fromHalfFloat: Cm },
  Nr = new Q(),
  qv = new He();
class Mn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = Dh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.gpuType = Qs),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      dk(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        qv.fromBufferAttribute(this, t),
          qv.applyMatrix3(e),
          this.setXY(t, qv.x, qv.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        Nr.fromBufferAttribute(this, t),
          Nr.applyMatrix3(e),
          this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Nr.fromBufferAttribute(this, t),
        Nr.applyMatrix4(e),
        this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Nr.fromBufferAttribute(this, t),
        Nr.applyNormalMatrix(e),
        this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Nr.fromBufferAttribute(this, t),
        Nr.transformDirection(e),
        this.setXYZ(t, Nr.x, Nr.y, Nr.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = Ji(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = Jt(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Jt(t, this.array)), (r = Jt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array)),
        (s = Jt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Dh && (e.usage = this.usage),
      e
    );
  }
}
class s7 extends Mn {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class o7 extends Mn {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class a7 extends Mn {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class l7 extends Mn {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class l2 extends Mn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class c7 extends Mn {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class c2 extends Mn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class u7 extends Mn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Cm(this.array[e * this.itemSize]);
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize] = hs(t)),
      this
    );
  }
  getY(e) {
    let t = Cm(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 1] = hs(t)),
      this
    );
  }
  getZ(e) {
    let t = Cm(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 2] = hs(t)),
      this
    );
  }
  getW(e) {
    let t = Cm(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.array[e * this.itemSize + 3] = hs(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Jt(t, this.array)), (r = Jt(r, this.array))),
      (this.array[e + 0] = hs(t)),
      (this.array[e + 1] = hs(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array))),
      (this.array[e + 0] = hs(t)),
      (this.array[e + 1] = hs(r)),
      (this.array[e + 2] = hs(i)),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array)),
        (s = Jt(s, this.array))),
      (this.array[e + 0] = hs(t)),
      (this.array[e + 1] = hs(r)),
      (this.array[e + 2] = hs(i)),
      (this.array[e + 3] = hs(s)),
      this
    );
  }
}
class At extends Mn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let d7 = 0;
const Eo = new Ut(),
  dw = new xn(),
  gf = new Q(),
  Vs = new zi(),
  om = new zi(),
  ti = new Q();
class qt extends Go {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: d7++ }),
      (this.uuid = io()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (ck(e) ? c2 : l2)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Qt().getNormalMatrix(e);
      r.applyNormalMatrix(s), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Eo.makeRotationFromQuaternion(e), this.applyMatrix4(Eo), this;
  }
  rotateX(e) {
    return Eo.makeRotationX(e), this.applyMatrix4(Eo), this;
  }
  rotateY(e) {
    return Eo.makeRotationY(e), this.applyMatrix4(Eo), this;
  }
  rotateZ(e) {
    return Eo.makeRotationZ(e), this.applyMatrix4(Eo), this;
  }
  translate(e, t, r) {
    return Eo.makeTranslation(e, t, r), this.applyMatrix4(Eo), this;
  }
  scale(e, t, r) {
    return Eo.makeScale(e, t, r), this.applyMatrix4(Eo), this;
  }
  lookAt(e) {
    return dw.lookAt(e), dw.updateMatrix(), this.applyMatrix4(dw.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(gf).negate(),
      this.translate(gf.x, gf.y, gf.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new At(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new zi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new Q(-1 / 0, -1 / 0, -1 / 0),
          new Q(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const s = t[r];
          Vs.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (ti.addVectors(this.boundingBox.min, Vs.min),
                this.boundingBox.expandByPoint(ti),
                ti.addVectors(this.boundingBox.max, Vs.max),
                this.boundingBox.expandByPoint(ti))
              : (this.boundingBox.expandByPoint(Vs.min),
                this.boundingBox.expandByPoint(Vs.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new Q(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((Vs.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          om.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (ti.addVectors(Vs.min, om.min),
                Vs.expandByPoint(ti),
                ti.addVectors(Vs.max, om.max),
                Vs.expandByPoint(ti))
              : (Vs.expandByPoint(om.min), Vs.expandByPoint(om.max));
        }
      Vs.getCenter(r);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        ti.fromBufferAttribute(e, s),
          (i = Math.max(i, r.distanceToSquared(ti)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            ti.fromBufferAttribute(a, c),
              l && (gf.fromBufferAttribute(e, c), ti.add(gf)),
              (i = Math.max(i, r.distanceToSquared(ti)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      i = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Mn(new Float32Array(4 * r.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let N = 0; N < r.count; N++) (a[N] = new Q()), (l[N] = new Q());
    const c = new Q(),
      u = new Q(),
      d = new Q(),
      h = new He(),
      m = new He(),
      g = new He(),
      x = new Q(),
      y = new Q();
    function v(N, R, C) {
      c.fromBufferAttribute(r, N),
        u.fromBufferAttribute(r, R),
        d.fromBufferAttribute(r, C),
        h.fromBufferAttribute(s, N),
        m.fromBufferAttribute(s, R),
        g.fromBufferAttribute(s, C),
        u.sub(c),
        d.sub(c),
        m.sub(h),
        g.sub(h);
      const L = 1 / (m.x * g.y - g.x * m.y);
      isFinite(L) &&
        (x
          .copy(u)
          .multiplyScalar(g.y)
          .addScaledVector(d, -m.y)
          .multiplyScalar(L),
        y
          .copy(d)
          .multiplyScalar(m.x)
          .addScaledVector(u, -g.x)
          .multiplyScalar(L),
        a[N].add(x),
        a[R].add(x),
        a[C].add(x),
        l[N].add(y),
        l[R].add(y),
        l[C].add(y));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{ start: 0, count: e.count }]);
    for (let N = 0, R = _.length; N < R; ++N) {
      const C = _[N],
        L = C.start,
        O = C.count;
      for (let D = L, B = L + O; D < B; D += 3)
        v(e.getX(D + 0), e.getX(D + 1), e.getX(D + 2));
    }
    const S = new Q(),
      w = new Q(),
      T = new Q(),
      E = new Q();
    function M(N) {
      T.fromBufferAttribute(i, N), E.copy(T);
      const R = a[N];
      S.copy(R),
        S.sub(T.multiplyScalar(T.dot(R))).normalize(),
        w.crossVectors(E, R);
      const L = w.dot(l[N]) < 0 ? -1 : 1;
      o.setXYZW(N, S.x, S.y, S.z, L);
    }
    for (let N = 0, R = _.length; N < R; ++N) {
      const C = _[N],
        L = C.start,
        O = C.count;
      for (let D = L, B = L + O; D < B; D += 3)
        M(e.getX(D + 0)), M(e.getX(D + 1)), M(e.getX(D + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new Mn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let h = 0, m = r.count; h < m; h++) r.setXYZ(h, 0, 0, 0);
      const i = new Q(),
        s = new Q(),
        o = new Q(),
        a = new Q(),
        l = new Q(),
        c = new Q(),
        u = new Q(),
        d = new Q();
      if (e)
        for (let h = 0, m = e.count; h < m; h += 3) {
          const g = e.getX(h + 0),
            x = e.getX(h + 1),
            y = e.getX(h + 2);
          i.fromBufferAttribute(t, g),
            s.fromBufferAttribute(t, x),
            o.fromBufferAttribute(t, y),
            u.subVectors(o, s),
            d.subVectors(i, s),
            u.cross(d),
            a.fromBufferAttribute(r, g),
            l.fromBufferAttribute(r, x),
            c.fromBufferAttribute(r, y),
            a.add(u),
            l.add(u),
            c.add(u),
            r.setXYZ(g, a.x, a.y, a.z),
            r.setXYZ(x, l.x, l.y, l.z),
            r.setXYZ(y, c.x, c.y, c.z);
        }
      else
        for (let h = 0, m = t.count; h < m; h += 3)
          i.fromBufferAttribute(t, h + 0),
            s.fromBufferAttribute(t, h + 1),
            o.fromBufferAttribute(t, h + 2),
            u.subVectors(o, s),
            d.subVectors(i, s),
            u.cross(d),
            r.setXYZ(h + 0, u.x, u.y, u.z),
            r.setXYZ(h + 1, u.x, u.y, u.z),
            r.setXYZ(h + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      ti.fromBufferAttribute(e, t),
        ti.normalize(),
        e.setXYZ(t, ti.x, ti.y, ti.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        d = a.normalized,
        h = new c.constructor(l.length * u);
      let m = 0,
        g = 0;
      for (let x = 0, y = l.length; x < y; x++) {
        a.isInterleavedBufferAttribute
          ? (m = l[x] * a.data.stride + a.offset)
          : (m = l[x] * u);
        for (let v = 0; v < u; v++) h[g++] = c[m++];
      }
      return new Mn(h, u, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new qt(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        c = e(l, r);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let u = 0, d = c.length; u < d; u++) {
        const h = c[u],
          m = e(h, r);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const c = r[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let d = 0, h = c.length; d < h; d++) {
        const m = c[d];
        u.push(m.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        d = s[c];
      for (let h = 0, m = d.length; h < m; h++) u.push(d[h].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const B3 = new Ut(),
  xu = new Id(),
  Kv = new mi(),
  V3 = new Q(),
  vf = new Q(),
  yf = new Q(),
  xf = new Q(),
  fw = new Q(),
  Zv = new Q(),
  Qv = new He(),
  Jv = new He(),
  ey = new He(),
  H3 = new Q(),
  G3 = new Q(),
  W3 = new Q(),
  ty = new Q(),
  ny = new Q();
class qn extends xn {
  constructor(e = new qt(), t = new Za()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      s = r.morphAttributes.position,
      o = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Zv.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          d = s[l];
        u !== 0 &&
          (fw.fromBufferAttribute(d, e),
          o ? Zv.addScaledVector(fw, u) : Zv.addScaledVector(fw.sub(t), u));
      }
      t.add(Zv);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Kv.copy(r.boundingSphere),
      Kv.applyMatrix4(s),
      xu.copy(e.ray).recast(e.near),
      !(
        Kv.containsPoint(xu.origin) === !1 &&
        (xu.intersectSphere(Kv, V3) === null ||
          xu.origin.distanceToSquared(V3) > (e.far - e.near) ** 2)
      ) &&
        (B3.copy(s).invert(),
        xu.copy(e.ray).applyMatrix4(B3),
        !(r.boundingBox !== null && xu.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, xu)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      d = s.attributes.normal,
      h = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let g = 0, x = h.length; g < x; g++) {
          const y = h[g],
            v = o[y.materialIndex],
            _ = Math.max(y.start, m.start),
            S = Math.min(
              a.count,
              Math.min(y.start + y.count, m.start + m.count)
            );
          for (let w = _, T = S; w < T; w += 3) {
            const E = a.getX(w),
              M = a.getX(w + 1),
              N = a.getX(w + 2);
            (i = ry(this, v, e, r, c, u, d, E, M, N)),
              i &&
                ((i.faceIndex = Math.floor(w / 3)),
                (i.face.materialIndex = y.materialIndex),
                t.push(i));
          }
        }
      else {
        const g = Math.max(0, m.start),
          x = Math.min(a.count, m.start + m.count);
        for (let y = g, v = x; y < v; y += 3) {
          const _ = a.getX(y),
            S = a.getX(y + 1),
            w = a.getX(y + 2);
          (i = ry(this, o, e, r, c, u, d, _, S, w)),
            i && ((i.faceIndex = Math.floor(y / 3)), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let g = 0, x = h.length; g < x; g++) {
          const y = h[g],
            v = o[y.materialIndex],
            _ = Math.max(y.start, m.start),
            S = Math.min(
              l.count,
              Math.min(y.start + y.count, m.start + m.count)
            );
          for (let w = _, T = S; w < T; w += 3) {
            const E = w,
              M = w + 1,
              N = w + 2;
            (i = ry(this, v, e, r, c, u, d, E, M, N)),
              i &&
                ((i.faceIndex = Math.floor(w / 3)),
                (i.face.materialIndex = y.materialIndex),
                t.push(i));
          }
        }
      else {
        const g = Math.max(0, m.start),
          x = Math.min(l.count, m.start + m.count);
        for (let y = g, v = x; y < v; y += 3) {
          const _ = y,
            S = y + 1,
            w = y + 2;
          (i = ry(this, o, e, r, c, u, d, _, S, w)),
            i && ((i.faceIndex = Math.floor(y / 3)), t.push(i));
        }
      }
  }
}
function f7(n, e, t, r, i, s, o, a) {
  let l;
  if (
    (e.side === pi
      ? (l = r.intersectTriangle(o, s, i, !0, a))
      : (l = r.intersectTriangle(i, s, o, e.side === ja, a)),
    l === null)
  )
    return null;
  ny.copy(a), ny.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(ny);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: ny.clone(), object: n };
}
function ry(n, e, t, r, i, s, o, a, l, c) {
  n.getVertexPosition(a, vf),
    n.getVertexPosition(l, yf),
    n.getVertexPosition(c, xf);
  const u = f7(n, e, t, r, vf, yf, xf, ty);
  if (u) {
    i &&
      (Qv.fromBufferAttribute(i, a),
      Jv.fromBufferAttribute(i, l),
      ey.fromBufferAttribute(i, c),
      (u.uv = qs.getInterpolation(ty, vf, yf, xf, Qv, Jv, ey, new He()))),
      s &&
        (Qv.fromBufferAttribute(s, a),
        Jv.fromBufferAttribute(s, l),
        ey.fromBufferAttribute(s, c),
        (u.uv1 = qs.getInterpolation(ty, vf, yf, xf, Qv, Jv, ey, new He()))),
      o &&
        (H3.fromBufferAttribute(o, a),
        G3.fromBufferAttribute(o, l),
        W3.fromBufferAttribute(o, c),
        (u.normal = qs.getInterpolation(ty, vf, yf, xf, H3, G3, W3, new Q())),
        u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = { a, b: l, c, normal: new Q(), materialIndex: 0 };
    qs.getNormal(vf, yf, xf, d.normal), (u.face = d);
  }
  return u;
}
class Ld extends qt {
  constructor(e = 1, t = 1, r = 1, i = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      c = [],
      u = [],
      d = [];
    let h = 0,
      m = 0;
    g("z", "y", "x", -1, -1, r, t, e, o, s, 0),
      g("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
      g("x", "z", "y", 1, 1, e, r, t, i, o, 2),
      g("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
      g("x", "y", "z", 1, -1, e, t, r, i, s, 4),
      g("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new At(c, 3)),
      this.setAttribute("normal", new At(u, 3)),
      this.setAttribute("uv", new At(d, 2));
    function g(x, y, v, _, S, w, T, E, M, N, R) {
      const C = w / M,
        L = T / N,
        O = w / 2,
        D = T / 2,
        B = E / 2,
        $ = M + 1,
        G = N + 1;
      let j = 0,
        U = 0;
      const H = new Q();
      for (let V = 0; V < G; V++) {
        const k = V * L - D;
        for (let W = 0; W < $; W++) {
          const ee = W * C - O;
          (H[x] = ee * _),
            (H[y] = k * S),
            (H[v] = B),
            c.push(H.x, H.y, H.z),
            (H[x] = 0),
            (H[y] = 0),
            (H[v] = E > 0 ? 1 : -1),
            u.push(H.x, H.y, H.z),
            d.push(W / M),
            d.push(1 - V / N),
            (j += 1);
        }
      }
      for (let V = 0; V < N; V++)
        for (let k = 0; k < M; k++) {
          const W = h + k + $ * V,
            ee = h + k + $ * (V + 1),
            Y = h + (k + 1) + $ * (V + 1),
            K = h + (k + 1) + $ * V;
          l.push(W, ee, K), l.push(ee, Y, K), (U += 6);
        }
      a.addGroup(m, U, R), (m += U), (h += j);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ld(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Uh(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function Zi(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = Uh(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function h7(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function pk(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : bn.workingColorSpace;
}
const u2 = { clone: Uh, merge: Zi };
var p7 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  m7 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Bo extends oi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = p7),
      (this.fragmentShader = m7),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Uh(e.uniforms)),
      (this.uniformsGroups = h7(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class h0 extends xn {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Ut()),
      (this.projectionMatrix = new Ut()),
      (this.projectionMatrixInverse = new Ut()),
      (this.coordinateSystem = Do);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const cc = new Q(),
  j3 = new He(),
  $3 = new He();
class Yn extends h0 {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Fh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(od * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Fh * 2 * Math.atan(Math.tan(od * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    cc.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(cc.x, cc.y).multiplyScalar(-e / cc.z),
      cc.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(cc.x, cc.y).multiplyScalar(-e / cc.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, j3, $3), t.subVectors($3, j3);
  }
  setViewOffset(e, t, r, i, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(od * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (s += (o.offsetX * i) / l),
        (t -= (o.offsetY * r) / c),
        (i *= o.width / l),
        (r *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const _f = -90,
  Sf = 1;
class mk extends xn {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new Yn(_f, Sf, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new Yn(_f, Sf, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new Yn(_f, Sf, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new Yn(_f, Sf, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new Yn(_f, Sf, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new Yn(_f, Sf, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, s, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === Do)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === _d)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, c, u] = this.children,
      d = e.getRenderTarget(),
      h = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      g = e.xr.enabled;
    e.xr.enabled = !1;
    const x = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(t, s),
      e.setRenderTarget(r, 1, i),
      e.render(t, o),
      e.setRenderTarget(r, 2, i),
      e.render(t, a),
      e.setRenderTarget(r, 3, i),
      e.render(t, l),
      e.setRenderTarget(r, 4, i),
      e.render(t, c),
      (r.texture.generateMipmaps = x),
      e.setRenderTarget(r, 5, i),
      e.render(t, u),
      e.setRenderTarget(d, h, m),
      (e.xr.enabled = g),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class p0 extends Fr {
  constructor(e, t, r, i, s, o, a, l, c, u) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Dl),
      super(e, t, r, i, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class gk extends va {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new p0(
      i,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : dr);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Ld(5, 5, 5),
      s = new Bo({
        name: "CubemapFromEquirect",
        uniforms: Uh(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: pi,
        blending: Cl,
      });
    s.uniforms.tEquirect.value = t;
    const o = new qn(i, s),
      a = t.minFilter;
    return (
      t.minFilter === ca && (t.minFilter = dr),
      new mk(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, r, i) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, r, i);
    e.setRenderTarget(s);
  }
}
const hw = new Q(),
  g7 = new Q(),
  v7 = new Qt();
class Fa {
  constructor(e = new Q(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = hw.subVectors(r, t).cross(g7.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(hw),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || v7.getNormalMatrix(e),
      i = this.coplanarPoint(hw).applyMatrix4(e),
      s = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _u = new mi(),
  iy = new Q();
class m0 {
  constructor(
    e = new Fa(),
    t = new Fa(),
    r = new Fa(),
    i = new Fa(),
    s = new Fa(),
    o = new Fa()
  ) {
    this.planes = [e, t, r, i, s, o];
  }
  set(e, t, r, i, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = Do) {
    const r = this.planes,
      i = e.elements,
      s = i[0],
      o = i[1],
      a = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = i[6],
      h = i[7],
      m = i[8],
      g = i[9],
      x = i[10],
      y = i[11],
      v = i[12],
      _ = i[13],
      S = i[14],
      w = i[15];
    if (
      (r[0].setComponents(l - s, h - c, y - m, w - v).normalize(),
      r[1].setComponents(l + s, h + c, y + m, w + v).normalize(),
      r[2].setComponents(l + o, h + u, y + g, w + _).normalize(),
      r[3].setComponents(l - o, h - u, y - g, w - _).normalize(),
      r[4].setComponents(l - a, h - d, y - x, w - S).normalize(),
      t === Do)
    )
      r[5].setComponents(l + a, h + d, y + x, w + S).normalize();
    else if (t === _d) r[5].setComponents(a, d, x, S).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        _u.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        _u.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(_u);
  }
  intersectsSprite(e) {
    return (
      _u.center.set(0, 0, 0),
      (_u.radius = 0.7071067811865476),
      _u.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(_u)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((iy.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (iy.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (iy.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(iy) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function vk() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(s, o) {
    t(s, o), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function y7(n) {
  const e = new WeakMap();
  function t(a, l) {
    const c = a.array,
      u = a.usage,
      d = c.byteLength,
      h = n.createBuffer();
    n.bindBuffer(l, h), n.bufferData(l, c, u), a.onUploadCallback();
    let m;
    if (c instanceof Float32Array) m = n.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (m = n.HALF_FLOAT) : (m = n.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) m = n.SHORT;
    else if (c instanceof Uint32Array) m = n.UNSIGNED_INT;
    else if (c instanceof Int32Array) m = n.INT;
    else if (c instanceof Int8Array) m = n.BYTE;
    else if (c instanceof Uint8Array) m = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) m = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: h,
      type: m,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: d,
    };
  }
  function r(a, l, c) {
    const u = l.array,
      d = l._updateRange,
      h = l.updateRanges;
    if (
      (n.bindBuffer(c, a),
      d.count === -1 && h.length === 0 && n.bufferSubData(c, 0, u),
      h.length !== 0)
    ) {
      for (let m = 0, g = h.length; m < g; m++) {
        const x = h[m];
        n.bufferSubData(c, x.start * u.BYTES_PER_ELEMENT, u, x.start, x.count);
      }
      l.clearUpdateRanges();
    }
    d.count !== -1 &&
      (n.bufferSubData(c, d.offset * u.BYTES_PER_ELEMENT, u, d.offset, d.count),
      (d.count = -1)),
      l.onUploadCallback();
  }
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (n.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (a.isGLBufferAttribute) {
      const u = e.get(a);
      (!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    a.isInterleavedBufferAttribute && (a = a.data);
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(c.buffer, a, l), (c.version = a.version);
    }
  }
  return { get: i, remove: s, update: o };
}
class Gl extends qt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(r),
      l = Math.floor(i),
      c = a + 1,
      u = l + 1,
      d = e / a,
      h = t / l,
      m = [],
      g = [],
      x = [],
      y = [];
    for (let v = 0; v < u; v++) {
      const _ = v * h - o;
      for (let S = 0; S < c; S++) {
        const w = S * d - s;
        g.push(w, -_, 0), x.push(0, 0, 1), y.push(S / a), y.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++)
      for (let _ = 0; _ < a; _++) {
        const S = _ + c * v,
          w = _ + c * (v + 1),
          T = _ + 1 + c * (v + 1),
          E = _ + 1 + c * v;
        m.push(S, w, E), m.push(w, T, E);
      }
    this.setIndex(m),
      this.setAttribute("position", new At(g, 3)),
      this.setAttribute("normal", new At(x, 3)),
      this.setAttribute("uv", new At(y, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Gl(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var x7 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  _7 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  S7 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  A7 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  w7 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  b7 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  E7 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  M7 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  T7 = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  C7 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  R7 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  N7 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  P7 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  I7 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  L7 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  O7 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  D7 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  F7 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  U7 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  k7 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  z7 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  B7 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  V7 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  H7 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  G7 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  W7 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  j7 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  $7 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  X7 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Y7 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  q7 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  K7 = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  Z7 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  Q7 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  J7 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  e$ = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  t$ = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  n$ = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  r$ = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  i$ = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  s$ = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  o$ = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  a$ = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  l$ = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  c$ = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  u$ = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  d$ = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  f$ = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  h$ = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  p$ = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  m$ = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  g$ = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  v$ = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  y$ = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  x$ = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  _$ = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  S$ = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  A$ = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  w$ = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  b$ = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  E$ = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  M$ = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  T$ = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  C$ = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  R$ = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  N$ = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  P$ = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  I$ = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  L$ = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  O$ = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  D$ = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  F$ = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  U$ = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  k$ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  z$ = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  B$ = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  V$ = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  H$ = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  G$ = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  W$ = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  j$ = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  $$ = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  X$ = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  Y$ = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  q$ = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  K$ = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  Z$ = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  Q$ = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  J$ = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  eX = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,
  tX = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  nX = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  rX = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  iX = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  sX = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  oX = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  aX = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  lX = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  cX = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  uX = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  dX = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  fX = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  hX = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  pX = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  mX = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  gX = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  vX = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const yX = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  xX = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  _X = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  SX = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  AX = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  wX = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  bX = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  EX = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  MX = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  TX = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  CX = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  RX = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  NX = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  PX = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  IX = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  LX = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  OX = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  DX = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  FX = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  UX = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kX = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  zX = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  BX = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  VX = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  HX = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  GX = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  WX = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  jX = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  $X = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  XX = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  YX = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qX = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  KX = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ZX = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Kt = {
    alphahash_fragment: x7,
    alphahash_pars_fragment: _7,
    alphamap_fragment: S7,
    alphamap_pars_fragment: A7,
    alphatest_fragment: w7,
    alphatest_pars_fragment: b7,
    aomap_fragment: E7,
    aomap_pars_fragment: M7,
    batching_pars_vertex: T7,
    batching_vertex: C7,
    begin_vertex: R7,
    beginnormal_vertex: N7,
    bsdfs: P7,
    iridescence_fragment: I7,
    bumpmap_pars_fragment: L7,
    clipping_planes_fragment: O7,
    clipping_planes_pars_fragment: D7,
    clipping_planes_pars_vertex: F7,
    clipping_planes_vertex: U7,
    color_fragment: k7,
    color_pars_fragment: z7,
    color_pars_vertex: B7,
    color_vertex: V7,
    common: H7,
    cube_uv_reflection_fragment: G7,
    defaultnormal_vertex: W7,
    displacementmap_pars_vertex: j7,
    displacementmap_vertex: $7,
    emissivemap_fragment: X7,
    emissivemap_pars_fragment: Y7,
    colorspace_fragment: q7,
    colorspace_pars_fragment: K7,
    envmap_fragment: Z7,
    envmap_common_pars_fragment: Q7,
    envmap_pars_fragment: J7,
    envmap_pars_vertex: e$,
    envmap_physical_pars_fragment: d$,
    envmap_vertex: t$,
    fog_vertex: n$,
    fog_pars_vertex: r$,
    fog_fragment: i$,
    fog_pars_fragment: s$,
    gradientmap_pars_fragment: o$,
    lightmap_pars_fragment: a$,
    lights_lambert_fragment: l$,
    lights_lambert_pars_fragment: c$,
    lights_pars_begin: u$,
    lights_toon_fragment: f$,
    lights_toon_pars_fragment: h$,
    lights_phong_fragment: p$,
    lights_phong_pars_fragment: m$,
    lights_physical_fragment: g$,
    lights_physical_pars_fragment: v$,
    lights_fragment_begin: y$,
    lights_fragment_maps: x$,
    lights_fragment_end: _$,
    logdepthbuf_fragment: S$,
    logdepthbuf_pars_fragment: A$,
    logdepthbuf_pars_vertex: w$,
    logdepthbuf_vertex: b$,
    map_fragment: E$,
    map_pars_fragment: M$,
    map_particle_fragment: T$,
    map_particle_pars_fragment: C$,
    metalnessmap_fragment: R$,
    metalnessmap_pars_fragment: N$,
    morphinstance_vertex: P$,
    morphcolor_vertex: I$,
    morphnormal_vertex: L$,
    morphtarget_pars_vertex: O$,
    morphtarget_vertex: D$,
    normal_fragment_begin: F$,
    normal_fragment_maps: U$,
    normal_pars_fragment: k$,
    normal_pars_vertex: z$,
    normal_vertex: B$,
    normalmap_pars_fragment: V$,
    clearcoat_normal_fragment_begin: H$,
    clearcoat_normal_fragment_maps: G$,
    clearcoat_pars_fragment: W$,
    iridescence_pars_fragment: j$,
    opaque_fragment: $$,
    packing: X$,
    premultiplied_alpha_fragment: Y$,
    project_vertex: q$,
    dithering_fragment: K$,
    dithering_pars_fragment: Z$,
    roughnessmap_fragment: Q$,
    roughnessmap_pars_fragment: J$,
    shadowmap_pars_fragment: eX,
    shadowmap_pars_vertex: tX,
    shadowmap_vertex: nX,
    shadowmask_pars_fragment: rX,
    skinbase_vertex: iX,
    skinning_pars_vertex: sX,
    skinning_vertex: oX,
    skinnormal_vertex: aX,
    specularmap_fragment: lX,
    specularmap_pars_fragment: cX,
    tonemapping_fragment: uX,
    tonemapping_pars_fragment: dX,
    transmission_fragment: fX,
    transmission_pars_fragment: hX,
    uv_pars_fragment: pX,
    uv_pars_vertex: mX,
    uv_vertex: gX,
    worldpos_vertex: vX,
    background_vert: yX,
    background_frag: xX,
    backgroundCube_vert: _X,
    backgroundCube_frag: SX,
    cube_vert: AX,
    cube_frag: wX,
    depth_vert: bX,
    depth_frag: EX,
    distanceRGBA_vert: MX,
    distanceRGBA_frag: TX,
    equirect_vert: CX,
    equirect_frag: RX,
    linedashed_vert: NX,
    linedashed_frag: PX,
    meshbasic_vert: IX,
    meshbasic_frag: LX,
    meshlambert_vert: OX,
    meshlambert_frag: DX,
    meshmatcap_vert: FX,
    meshmatcap_frag: UX,
    meshnormal_vert: kX,
    meshnormal_frag: zX,
    meshphong_vert: BX,
    meshphong_frag: VX,
    meshphysical_vert: HX,
    meshphysical_frag: GX,
    meshtoon_vert: WX,
    meshtoon_frag: jX,
    points_vert: $X,
    points_frag: XX,
    shadow_vert: YX,
    shadow_frag: qX,
    sprite_vert: KX,
    sprite_frag: ZX,
  },
  ht = {
    common: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Qt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Qt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Qt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Qt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Qt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Qt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Qt() },
      normalScale: { value: new He(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Qt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Qt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Qt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Qt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new pt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Qt() },
    },
    sprite: {
      diffuse: { value: new pt(16777215) },
      opacity: { value: 1 },
      center: { value: new He(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Qt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Qt() },
      alphaTest: { value: 0 },
    },
  },
  aa = {
    basic: {
      uniforms: Zi([
        ht.common,
        ht.specularmap,
        ht.envmap,
        ht.aomap,
        ht.lightmap,
        ht.fog,
      ]),
      vertexShader: Kt.meshbasic_vert,
      fragmentShader: Kt.meshbasic_frag,
    },
    lambert: {
      uniforms: Zi([
        ht.common,
        ht.specularmap,
        ht.envmap,
        ht.aomap,
        ht.lightmap,
        ht.emissivemap,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        ht.fog,
        ht.lights,
        { emissive: { value: new pt(0) } },
      ]),
      vertexShader: Kt.meshlambert_vert,
      fragmentShader: Kt.meshlambert_frag,
    },
    phong: {
      uniforms: Zi([
        ht.common,
        ht.specularmap,
        ht.envmap,
        ht.aomap,
        ht.lightmap,
        ht.emissivemap,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        ht.fog,
        ht.lights,
        {
          emissive: { value: new pt(0) },
          specular: { value: new pt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Kt.meshphong_vert,
      fragmentShader: Kt.meshphong_frag,
    },
    standard: {
      uniforms: Zi([
        ht.common,
        ht.envmap,
        ht.aomap,
        ht.lightmap,
        ht.emissivemap,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        ht.roughnessmap,
        ht.metalnessmap,
        ht.fog,
        ht.lights,
        {
          emissive: { value: new pt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Kt.meshphysical_vert,
      fragmentShader: Kt.meshphysical_frag,
    },
    toon: {
      uniforms: Zi([
        ht.common,
        ht.aomap,
        ht.lightmap,
        ht.emissivemap,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        ht.gradientmap,
        ht.fog,
        ht.lights,
        { emissive: { value: new pt(0) } },
      ]),
      vertexShader: Kt.meshtoon_vert,
      fragmentShader: Kt.meshtoon_frag,
    },
    matcap: {
      uniforms: Zi([
        ht.common,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        ht.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Kt.meshmatcap_vert,
      fragmentShader: Kt.meshmatcap_frag,
    },
    points: {
      uniforms: Zi([ht.points, ht.fog]),
      vertexShader: Kt.points_vert,
      fragmentShader: Kt.points_frag,
    },
    dashed: {
      uniforms: Zi([
        ht.common,
        ht.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Kt.linedashed_vert,
      fragmentShader: Kt.linedashed_frag,
    },
    depth: {
      uniforms: Zi([ht.common, ht.displacementmap]),
      vertexShader: Kt.depth_vert,
      fragmentShader: Kt.depth_frag,
    },
    normal: {
      uniforms: Zi([
        ht.common,
        ht.bumpmap,
        ht.normalmap,
        ht.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Kt.meshnormal_vert,
      fragmentShader: Kt.meshnormal_frag,
    },
    sprite: {
      uniforms: Zi([ht.sprite, ht.fog]),
      vertexShader: Kt.sprite_vert,
      fragmentShader: Kt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Qt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Kt.background_vert,
      fragmentShader: Kt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Qt() },
      },
      vertexShader: Kt.backgroundCube_vert,
      fragmentShader: Kt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Kt.cube_vert,
      fragmentShader: Kt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Kt.equirect_vert,
      fragmentShader: Kt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Zi([
        ht.common,
        ht.displacementmap,
        {
          referencePosition: { value: new Q() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Kt.distanceRGBA_vert,
      fragmentShader: Kt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Zi([
        ht.lights,
        ht.fog,
        { color: { value: new pt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Kt.shadow_vert,
      fragmentShader: Kt.shadow_frag,
    },
  };
aa.physical = {
  uniforms: Zi([
    aa.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Qt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Qt() },
      clearcoatNormalScale: { value: new He(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Qt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Qt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Qt() },
      sheen: { value: 0 },
      sheenColor: { value: new pt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Qt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Qt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Qt() },
      transmissionSamplerSize: { value: new He() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Qt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new pt(0) },
      specularColor: { value: new pt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Qt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Qt() },
      anisotropyVector: { value: new He() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Qt() },
    },
  ]),
  vertexShader: Kt.meshphysical_vert,
  fragmentShader: Kt.meshphysical_frag,
};
const sy = { r: 0, b: 0, g: 0 },
  Su = new ao(),
  QX = new Ut();
function JX(n, e, t, r, i, s, o) {
  const a = new pt(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    d = null,
    h = 0,
    m = null;
  function g(_) {
    let S = _.isScene === !0 ? _.background : null;
    return (
      S && S.isTexture && (S = (_.backgroundBlurriness > 0 ? t : e).get(S)), S
    );
  }
  function x(_) {
    let S = !1;
    const w = g(_);
    w === null ? v(a, l) : w && w.isColor && (v(w, 1), (S = !0));
    const T = n.xr.getEnvironmentBlendMode();
    T === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, o)
      : T === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || S) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil);
  }
  function y(_, S) {
    const w = g(S);
    w && (w.isCubeTexture || w.mapping === np)
      ? (u === void 0 &&
          ((u = new qn(
            new Ld(1, 1, 1),
            new Bo({
              name: "BackgroundCubeMaterial",
              uniforms: Uh(aa.backgroundCube.uniforms),
              vertexShader: aa.backgroundCube.vertexShader,
              fragmentShader: aa.backgroundCube.fragmentShader,
              side: pi,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (T, E, M) {
            this.matrixWorld.copyPosition(M.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(u)),
        Su.copy(S.backgroundRotation),
        (Su.x *= -1),
        (Su.y *= -1),
        (Su.z *= -1),
        w.isCubeTexture &&
          w.isRenderTargetTexture === !1 &&
          ((Su.y *= -1), (Su.z *= -1)),
        (u.material.uniforms.envMap.value = w),
        (u.material.uniforms.flipEnvMap.value =
          w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          S.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          QX.makeRotationFromEuler(Su)
        ),
        (u.material.toneMapped = bn.getTransfer(w.colorSpace) !== kn),
        (d !== w || h !== w.version || m !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (d = w),
          (h = w.version),
          (m = n.toneMapping)),
        u.layers.enableAll(),
        _.unshift(u, u.geometry, u.material, 0, 0, null))
      : w &&
        w.isTexture &&
        (c === void 0 &&
          ((c = new qn(
            new Gl(2, 2),
            new Bo({
              name: "BackgroundMaterial",
              uniforms: Uh(aa.background.uniforms),
              vertexShader: aa.background.vertexShader,
              fragmentShader: aa.background.fragmentShader,
              side: ja,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(c)),
        (c.material.uniforms.t2D.value = w),
        (c.material.uniforms.backgroundIntensity.value = S.backgroundIntensity),
        (c.material.toneMapped = bn.getTransfer(w.colorSpace) !== kn),
        w.matrixAutoUpdate === !0 && w.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(w.matrix),
        (d !== w || h !== w.version || m !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (d = w),
          (h = w.version),
          (m = n.toneMapping)),
        c.layers.enableAll(),
        _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function v(_, S) {
    _.getRGB(sy, pk(n)), r.buffers.color.setClear(sy.r, sy.g, sy.b, S, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (_, S = 1) {
      a.set(_), (l = S), v(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (_) {
      (l = _), v(a, l);
    },
    render: x,
    addToRenderList: y,
  };
}
function eY(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    i = h(null);
  let s = i,
    o = !1;
  function a(C, L, O, D, B) {
    let $ = !1;
    const G = d(D, O, L);
    s !== G && ((s = G), c(s.object)),
      ($ = m(C, D, O, B)),
      $ && g(C, D, O, B),
      B !== null && e.update(B, n.ELEMENT_ARRAY_BUFFER),
      ($ || o) &&
        ((o = !1),
        w(C, L, O, D),
        B !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(B).buffer));
  }
  function l() {
    return n.createVertexArray();
  }
  function c(C) {
    return n.bindVertexArray(C);
  }
  function u(C) {
    return n.deleteVertexArray(C);
  }
  function d(C, L, O) {
    const D = O.wireframe === !0;
    let B = r[C.id];
    B === void 0 && ((B = {}), (r[C.id] = B));
    let $ = B[L.id];
    $ === void 0 && (($ = {}), (B[L.id] = $));
    let G = $[D];
    return G === void 0 && ((G = h(l())), ($[D] = G)), G;
  }
  function h(C) {
    const L = [],
      O = [],
      D = [];
    for (let B = 0; B < t; B++) (L[B] = 0), (O[B] = 0), (D[B] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: L,
      enabledAttributes: O,
      attributeDivisors: D,
      object: C,
      attributes: {},
      index: null,
    };
  }
  function m(C, L, O, D) {
    const B = s.attributes,
      $ = L.attributes;
    let G = 0;
    const j = O.getAttributes();
    for (const U in j)
      if (j[U].location >= 0) {
        const V = B[U];
        let k = $[U];
        if (
          (k === void 0 &&
            (U === "instanceMatrix" &&
              C.instanceMatrix &&
              (k = C.instanceMatrix),
            U === "instanceColor" && C.instanceColor && (k = C.instanceColor)),
          V === void 0 || V.attribute !== k || (k && V.data !== k.data))
        )
          return !0;
        G++;
      }
    return s.attributesNum !== G || s.index !== D;
  }
  function g(C, L, O, D) {
    const B = {},
      $ = L.attributes;
    let G = 0;
    const j = O.getAttributes();
    for (const U in j)
      if (j[U].location >= 0) {
        let V = $[U];
        V === void 0 &&
          (U === "instanceMatrix" && C.instanceMatrix && (V = C.instanceMatrix),
          U === "instanceColor" && C.instanceColor && (V = C.instanceColor));
        const k = {};
        (k.attribute = V), V && V.data && (k.data = V.data), (B[U] = k), G++;
      }
    (s.attributes = B), (s.attributesNum = G), (s.index = D);
  }
  function x() {
    const C = s.newAttributes;
    for (let L = 0, O = C.length; L < O; L++) C[L] = 0;
  }
  function y(C) {
    v(C, 0);
  }
  function v(C, L) {
    const O = s.newAttributes,
      D = s.enabledAttributes,
      B = s.attributeDivisors;
    (O[C] = 1),
      D[C] === 0 && (n.enableVertexAttribArray(C), (D[C] = 1)),
      B[C] !== L && (n.vertexAttribDivisor(C, L), (B[C] = L));
  }
  function _() {
    const C = s.newAttributes,
      L = s.enabledAttributes;
    for (let O = 0, D = L.length; O < D; O++)
      L[O] !== C[O] && (n.disableVertexAttribArray(O), (L[O] = 0));
  }
  function S(C, L, O, D, B, $, G) {
    G === !0
      ? n.vertexAttribIPointer(C, L, O, B, $)
      : n.vertexAttribPointer(C, L, O, D, B, $);
  }
  function w(C, L, O, D) {
    x();
    const B = D.attributes,
      $ = O.getAttributes(),
      G = L.defaultAttributeValues;
    for (const j in $) {
      const U = $[j];
      if (U.location >= 0) {
        let H = B[j];
        if (
          (H === void 0 &&
            (j === "instanceMatrix" &&
              C.instanceMatrix &&
              (H = C.instanceMatrix),
            j === "instanceColor" && C.instanceColor && (H = C.instanceColor)),
          H !== void 0)
        ) {
          const V = H.normalized,
            k = H.itemSize,
            W = e.get(H);
          if (W === void 0) continue;
          const ee = W.buffer,
            Y = W.type,
            K = W.bytesPerElement,
            ae = Y === n.INT || Y === n.UNSIGNED_INT || H.gpuType === XC;
          if (H.isInterleavedBufferAttribute) {
            const se = H.data,
              we = se.stride,
              Be = H.offset;
            if (se.isInstancedInterleavedBuffer) {
              for (let te = 0; te < U.locationSize; te++)
                v(U.location + te, se.meshPerAttribute);
              C.isInstancedMesh !== !0 &&
                D._maxInstanceCount === void 0 &&
                (D._maxInstanceCount = se.meshPerAttribute * se.count);
            } else
              for (let te = 0; te < U.locationSize; te++) y(U.location + te);
            n.bindBuffer(n.ARRAY_BUFFER, ee);
            for (let te = 0; te < U.locationSize; te++)
              S(
                U.location + te,
                k / U.locationSize,
                Y,
                V,
                we * K,
                (Be + (k / U.locationSize) * te) * K,
                ae
              );
          } else {
            if (H.isInstancedBufferAttribute) {
              for (let se = 0; se < U.locationSize; se++)
                v(U.location + se, H.meshPerAttribute);
              C.isInstancedMesh !== !0 &&
                D._maxInstanceCount === void 0 &&
                (D._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let se = 0; se < U.locationSize; se++) y(U.location + se);
            n.bindBuffer(n.ARRAY_BUFFER, ee);
            for (let se = 0; se < U.locationSize; se++)
              S(
                U.location + se,
                k / U.locationSize,
                Y,
                V,
                k * K,
                (k / U.locationSize) * se * K,
                ae
              );
          }
        } else if (G !== void 0) {
          const V = G[j];
          if (V !== void 0)
            switch (V.length) {
              case 2:
                n.vertexAttrib2fv(U.location, V);
                break;
              case 3:
                n.vertexAttrib3fv(U.location, V);
                break;
              case 4:
                n.vertexAttrib4fv(U.location, V);
                break;
              default:
                n.vertexAttrib1fv(U.location, V);
            }
        }
      }
    }
    _();
  }
  function T() {
    N();
    for (const C in r) {
      const L = r[C];
      for (const O in L) {
        const D = L[O];
        for (const B in D) u(D[B].object), delete D[B];
        delete L[O];
      }
      delete r[C];
    }
  }
  function E(C) {
    if (r[C.id] === void 0) return;
    const L = r[C.id];
    for (const O in L) {
      const D = L[O];
      for (const B in D) u(D[B].object), delete D[B];
      delete L[O];
    }
    delete r[C.id];
  }
  function M(C) {
    for (const L in r) {
      const O = r[L];
      if (O[C.id] === void 0) continue;
      const D = O[C.id];
      for (const B in D) u(D[B].object), delete D[B];
      delete O[C.id];
    }
  }
  function N() {
    R(), (o = !0), s !== i && ((s = i), c(s.object));
  }
  function R() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: a,
    reset: N,
    resetDefaultState: R,
    dispose: T,
    releaseStatesOfGeometry: E,
    releaseStatesOfProgram: M,
    initAttributes: x,
    enableAttribute: y,
    disableUnusedAttributes: _,
  };
}
function tY(n, e, t) {
  let r;
  function i(c) {
    r = c;
  }
  function s(c, u) {
    n.drawArrays(r, c, u), t.update(u, r, 1);
  }
  function o(c, u, d) {
    d !== 0 && (n.drawArraysInstanced(r, c, u, d), t.update(u, r, d));
  }
  function a(c, u, d) {
    if (d === 0) return;
    const h = e.get("WEBGL_multi_draw");
    if (h === null) for (let m = 0; m < d; m++) this.render(c[m], u[m]);
    else {
      h.multiDrawArraysWEBGL(r, c, 0, u, 0, d);
      let m = 0;
      for (let g = 0; g < d; g++) m += u[g];
      t.update(m, r, 1);
    }
  }
  function l(c, u, d, h) {
    if (d === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let g = 0; g < c.length; g++) o(c[g], u[g], h[g]);
    else {
      m.multiDrawArraysInstancedWEBGL(r, c, 0, u, 0, h, 0, d);
      let g = 0;
      for (let x = 0; x < d; x++) g += u[x];
      for (let x = 0; x < h.length; x++) t.update(g, r, h[x]);
    }
  }
  (this.setMode = i),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function nY(n, e, t, r) {
  let i;
  function s() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const E = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function o(E) {
    return !(
      E !== ys &&
      r.convert(E) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(E) {
    const M =
      E === rp &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      E !== $a &&
      r.convert(E) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      E !== Qs &&
      !M
    );
  }
  function l(E) {
    if (E === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      E = "mediump";
    }
    return E === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead."
    ),
    (c = u));
  const d = t.logarithmicDepthBuffer === !0,
    h = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    m = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    g = n.getParameter(n.MAX_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    y = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    v = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    _ = n.getParameter(n.MAX_VARYING_VECTORS),
    S = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    w = m > 0,
    T = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: d,
    maxTextures: h,
    maxVertexTextures: m,
    maxTextureSize: g,
    maxCubemapSize: x,
    maxAttributes: y,
    maxVertexUniforms: v,
    maxVaryings: _,
    maxFragmentUniforms: S,
    vertexTextures: w,
    maxSamples: T,
  };
}
function rY(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    s = !1;
  const o = new Fa(),
    a = new Qt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, h) {
      const m = d.length !== 0 || h || r !== 0 || i;
      return (i = h), (r = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, h) {
      t = u(d, h, 0);
    }),
    (this.setState = function (d, h, m) {
      const g = d.clippingPlanes,
        x = d.clipIntersection,
        y = d.clipShadows,
        v = n.get(d);
      if (!i || g === null || g.length === 0 || (s && !y)) s ? u(null) : c();
      else {
        const _ = s ? 0 : r,
          S = _ * 4;
        let w = v.clippingState || null;
        (l.value = w), (w = u(g, h, S, m));
        for (let T = 0; T !== S; ++T) w[T] = t[T];
        (v.clippingState = w),
          (this.numIntersection = x ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function u(d, h, m, g) {
    const x = d !== null ? d.length : 0;
    let y = null;
    if (x !== 0) {
      if (((y = l.value), g !== !0 || y === null)) {
        const v = m + x * 4,
          _ = h.matrixWorldInverse;
        a.getNormalMatrix(_),
          (y === null || y.length < v) && (y = new Float32Array(v));
        for (let S = 0, w = m; S !== x; ++S, w += 4)
          o.copy(d[S]).applyMatrix4(_, a),
            o.normal.toArray(y, w),
            (y[w + 3] = o.constant);
      }
      (l.value = y), (l.needsUpdate = !0);
    }
    return (e.numPlanes = x), (e.numIntersection = 0), y;
  }
}
function iY(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Sg ? (o.mapping = Dl) : a === Ag && (o.mapping = Bc), o;
  }
  function r(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Sg || a === Ag)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new gk(l.height);
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", i),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: r, dispose: s };
}
class Fo extends h0 {
  constructor(e = -1, t = 1, r = 1, i = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = r - e,
      o = r + e,
      a = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const th = 4,
  X3 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Bu = 20,
  pw = new Fo(),
  Y3 = new pt();
let mw = null,
  gw = 0,
  vw = 0,
  yw = !1;
const Uu = (1 + Math.sqrt(5)) / 2,
  Af = 1 / Uu,
  q3 = [
    new Q(-Uu, Af, 0),
    new Q(Uu, Af, 0),
    new Q(-Af, 0, Uu),
    new Q(Af, 0, Uu),
    new Q(0, Uu, -Af),
    new Q(0, Uu, Af),
    new Q(-1, 1, -1),
    new Q(1, 1, -1),
    new Q(-1, 1, 1),
    new Q(1, 1, 1),
  ];
class mM {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    (mw = this._renderer.getRenderTarget()),
      (gw = this._renderer.getActiveCubeFace()),
      (vw = this._renderer.getActiveMipmapLevel()),
      (yw = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Q3()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Z3()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(mw, gw, vw),
      (this._renderer.xr.enabled = yw),
      (e.scissorTest = !1),
      oy(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Dl || e.mapping === Bc
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (mw = this._renderer.getRenderTarget()),
      (gw = this._renderer.getActiveCubeFace()),
      (vw = this._renderer.getActiveMipmapLevel()),
      (yw = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: dr,
        minFilter: dr,
        generateMipmaps: !1,
        type: rp,
        format: ys,
        colorSpace: Ho,
        depthBuffer: !1,
      },
      i = K3(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = K3(e, t, r));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = sY(s)),
        (this._blurMaterial = oY(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new qn(this._lodPlanes[0], e);
    this._renderer.compile(t, pw);
  }
  _sceneToCubeUV(e, t, r, i) {
    const a = new Yn(90, 1, t, r),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      h = u.toneMapping;
    u.getClearColor(Y3), (u.toneMapping = ws), (u.autoClear = !1);
    const m = new Za({
        name: "PMREM.Background",
        side: pi,
        depthWrite: !1,
        depthTest: !1,
      }),
      g = new qn(new Ld(), m);
    let x = !1;
    const y = e.background;
    y
      ? y.isColor && (m.color.copy(y), (e.background = null), (x = !0))
      : (m.color.copy(Y3), (x = !0));
    for (let v = 0; v < 6; v++) {
      const _ = v % 3;
      _ === 0
        ? (a.up.set(0, l[v], 0), a.lookAt(c[v], 0, 0))
        : _ === 1
        ? (a.up.set(0, 0, l[v]), a.lookAt(0, c[v], 0))
        : (a.up.set(0, l[v], 0), a.lookAt(0, 0, c[v]));
      const S = this._cubeSize;
      oy(i, _ * S, v > 2 ? S : 0, S, S),
        u.setRenderTarget(i),
        x && u.render(g, a),
        u.render(e, a);
    }
    g.geometry.dispose(),
      g.material.dispose(),
      (u.toneMapping = h),
      (u.autoClear = d),
      (e.background = y);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === Dl || e.mapping === Bc;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Q3()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Z3());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new qn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    oy(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(o, pw);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let s = 1; s < i; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        a = q3[(i - s - 1) % q3.length];
      this._blur(e, s - 1, s, o, a);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, r, i, "latitudinal", s),
      this._halfBlur(o, e, r, r, i, "longitudinal", s);
  }
  _halfBlur(e, t, r, i, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      d = new qn(this._lodPlanes[i], c),
      h = c.uniforms,
      m = this._sizeLods[r] - 1,
      g = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Bu - 1),
      x = s / g,
      y = isFinite(s) ? 1 + Math.floor(u * x) : Bu;
    y > Bu &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${Bu}`
      );
    const v = [];
    let _ = 0;
    for (let M = 0; M < Bu; ++M) {
      const N = M / x,
        R = Math.exp((-N * N) / 2);
      v.push(R), M === 0 ? (_ += R) : M < y && (_ += 2 * R);
    }
    for (let M = 0; M < v.length; M++) v[M] = v[M] / _;
    (h.envMap.value = e.texture),
      (h.samples.value = y),
      (h.weights.value = v),
      (h.latitudinal.value = o === "latitudinal"),
      a && (h.poleAxis.value = a);
    const { _lodMax: S } = this;
    (h.dTheta.value = g), (h.mipInt.value = S - r);
    const w = this._sizeLods[i],
      T = 3 * w * (i > S - th ? i - S + th : 0),
      E = 4 * (this._cubeSize - w);
    oy(t, T, E, 3 * w, 2 * w), l.setRenderTarget(t), l.render(d, pw);
  }
}
function sY(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const s = n - th + 1 + X3.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > n - th ? (l = X3[o - n + th - 1]) : o === 0 && (l = 0), r.push(l);
    const c = 1 / (a - 2),
      u = -c,
      d = 1 + c,
      h = [u, u, d, u, d, d, u, u, d, d, u, d],
      m = 6,
      g = 6,
      x = 3,
      y = 2,
      v = 1,
      _ = new Float32Array(x * g * m),
      S = new Float32Array(y * g * m),
      w = new Float32Array(v * g * m);
    for (let E = 0; E < m; E++) {
      const M = ((E % 3) * 2) / 3 - 1,
        N = E > 2 ? 0 : -1,
        R = [
          M,
          N,
          0,
          M + 2 / 3,
          N,
          0,
          M + 2 / 3,
          N + 1,
          0,
          M,
          N,
          0,
          M + 2 / 3,
          N + 1,
          0,
          M,
          N + 1,
          0,
        ];
      _.set(R, x * g * E), S.set(h, y * g * E);
      const C = [E, E, E, E, E, E];
      w.set(C, v * g * E);
    }
    const T = new qt();
    T.setAttribute("position", new Mn(_, x)),
      T.setAttribute("uv", new Mn(S, y)),
      T.setAttribute("faceIndex", new Mn(w, v)),
      e.push(T),
      i > th && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function K3(n, e, t) {
  const r = new va(n, e, t);
  return (
    (r.texture.mapping = np),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function oy(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function oY(n, e, t) {
  const r = new Float32Array(Bu),
    i = new Q(0, 1, 0);
  return new Bo({
    name: "SphericalGaussianBlur",
    defines: {
      n: Bu,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: d2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Cl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Z3() {
  return new Bo({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: d2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Cl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Q3() {
  return new Bo({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: d2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Cl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function d2() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function aY(n) {
  let e = new WeakMap(),
    t = null;
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === Sg || l === Ag,
        u = l === Dl || l === Bc;
      if (c || u) {
        let d = e.get(a);
        const h = d !== void 0 ? d.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== h)
          return (
            t === null && (t = new mM(n)),
            (d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            (d.texture.pmremVersion = a.pmremVersion),
            e.set(a, d),
            d.texture
          );
        if (d !== void 0) return d.texture;
        {
          const m = a.image;
          return (c && m && m.height > 0) || (u && m && i(m))
            ? (t === null && (t = new mM(n)),
              (d = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (d.texture.pmremVersion = a.pmremVersion),
              e.set(a, d),
              a.addEventListener("dispose", s),
              d.texture)
            : null;
        }
      }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: o };
}
function lY(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + r + " extension not supported."
          ),
        i
      );
    },
  };
}
function cY(n, e, t, r) {
  const i = {},
    s = new WeakMap();
  function o(d) {
    const h = d.target;
    h.index !== null && e.remove(h.index);
    for (const g in h.attributes) e.remove(h.attributes[g]);
    for (const g in h.morphAttributes) {
      const x = h.morphAttributes[g];
      for (let y = 0, v = x.length; y < v; y++) e.remove(x[y]);
    }
    h.removeEventListener("dispose", o), delete i[h.id];
    const m = s.get(h);
    m && (e.remove(m), s.delete(h)),
      r.releaseStatesOfGeometry(h),
      h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, h) {
    return (
      i[h.id] === !0 ||
        (h.addEventListener("dispose", o),
        (i[h.id] = !0),
        t.memory.geometries++),
      h
    );
  }
  function l(d) {
    const h = d.attributes;
    for (const g in h) e.update(h[g], n.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const g in m) {
      const x = m[g];
      for (let y = 0, v = x.length; y < v; y++) e.update(x[y], n.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const h = [],
      m = d.index,
      g = d.attributes.position;
    let x = 0;
    if (m !== null) {
      const _ = m.array;
      x = m.version;
      for (let S = 0, w = _.length; S < w; S += 3) {
        const T = _[S + 0],
          E = _[S + 1],
          M = _[S + 2];
        h.push(T, E, E, M, M, T);
      }
    } else if (g !== void 0) {
      const _ = g.array;
      x = g.version;
      for (let S = 0, w = _.length / 3 - 1; S < w; S += 3) {
        const T = S + 0,
          E = S + 1,
          M = S + 2;
        h.push(T, E, E, M, M, T);
      }
    } else return;
    const y = new (ck(h) ? c2 : l2)(h, 1);
    y.version = x;
    const v = s.get(d);
    v && e.remove(v), s.set(d, y);
  }
  function u(d) {
    const h = s.get(d);
    if (h) {
      const m = d.index;
      m !== null && h.version < m.version && c(d);
    } else c(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function uY(n, e, t) {
  let r;
  function i(h) {
    r = h;
  }
  let s, o;
  function a(h) {
    (s = h.type), (o = h.bytesPerElement);
  }
  function l(h, m) {
    n.drawElements(r, m, s, h * o), t.update(m, r, 1);
  }
  function c(h, m, g) {
    g !== 0 && (n.drawElementsInstanced(r, m, s, h * o, g), t.update(m, r, g));
  }
  function u(h, m, g) {
    if (g === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let y = 0; y < g; y++) this.render(h[y] / o, m[y]);
    else {
      x.multiDrawElementsWEBGL(r, m, 0, s, h, 0, g);
      let y = 0;
      for (let v = 0; v < g; v++) y += m[v];
      t.update(y, r, 1);
    }
  }
  function d(h, m, g, x) {
    if (g === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null) for (let v = 0; v < h.length; v++) c(h[v] / o, m[v], x[v]);
    else {
      y.multiDrawElementsInstancedWEBGL(r, m, 0, s, h, 0, x, 0, g);
      let v = 0;
      for (let _ = 0; _ < g; _++) v += m[_];
      for (let _ = 0; _ < x.length; _++) t.update(v, r, x[_]);
    }
  }
  (this.setMode = i),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = d);
}
function dY(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function fY(n, e, t) {
  const r = new WeakMap(),
    i = new rn();
  function s(o, a, l) {
    const c = o.morphTargetInfluences,
      u =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      d = u !== void 0 ? u.length : 0;
    let h = r.get(a);
    if (h === void 0 || h.count !== d) {
      let C = function () {
        N.dispose(), r.delete(a), a.removeEventListener("dispose", C);
      };
      var m = C;
      h !== void 0 && h.texture.dispose();
      const g = a.morphAttributes.position !== void 0,
        x = a.morphAttributes.normal !== void 0,
        y = a.morphAttributes.color !== void 0,
        v = a.morphAttributes.position || [],
        _ = a.morphAttributes.normal || [],
        S = a.morphAttributes.color || [];
      let w = 0;
      g === !0 && (w = 1), x === !0 && (w = 2), y === !0 && (w = 3);
      let T = a.attributes.position.count * w,
        E = 1;
      T > e.maxTextureSize &&
        ((E = Math.ceil(T / e.maxTextureSize)), (T = e.maxTextureSize));
      const M = new Float32Array(T * E * 4 * d),
        N = new f0(M, T, E, d);
      (N.type = Qs), (N.needsUpdate = !0);
      const R = w * 4;
      for (let L = 0; L < d; L++) {
        const O = v[L],
          D = _[L],
          B = S[L],
          $ = T * E * 4 * L;
        for (let G = 0; G < O.count; G++) {
          const j = G * R;
          g === !0 &&
            (i.fromBufferAttribute(O, G),
            (M[$ + j + 0] = i.x),
            (M[$ + j + 1] = i.y),
            (M[$ + j + 2] = i.z),
            (M[$ + j + 3] = 0)),
            x === !0 &&
              (i.fromBufferAttribute(D, G),
              (M[$ + j + 4] = i.x),
              (M[$ + j + 5] = i.y),
              (M[$ + j + 6] = i.z),
              (M[$ + j + 7] = 0)),
            y === !0 &&
              (i.fromBufferAttribute(B, G),
              (M[$ + j + 8] = i.x),
              (M[$ + j + 9] = i.y),
              (M[$ + j + 10] = i.z),
              (M[$ + j + 11] = B.itemSize === 4 ? i.w : 1));
        }
      }
      (h = { count: d, texture: N, size: new He(T, E) }),
        r.set(a, h),
        a.addEventListener("dispose", C);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
    else {
      let g = 0;
      for (let y = 0; y < c.length; y++) g += c[y];
      const x = a.morphTargetsRelative ? 1 : 1 - g;
      l.getUniforms().setValue(n, "morphTargetBaseInfluence", x),
        l.getUniforms().setValue(n, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(n, "morphTargetsTexture", h.texture, t),
      l.getUniforms().setValue(n, "morphTargetsTextureSize", h.size);
  }
  return { update: s };
}
function hY(n, e, t, r) {
  let i = new WeakMap();
  function s(l) {
    const c = r.render.frame,
      u = l.geometry,
      d = e.get(l, u);
    if (
      (i.get(d) !== c && (e.update(d), i.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          i.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const h = l.skeleton;
      i.get(h) !== c && (h.update(), i.set(h, c));
    }
    return d;
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: o };
}
class sp extends Fr {
  constructor(e, t, r, i, s, o, a, l, c, u) {
    if (((u = u !== void 0 ? u : sd), u !== sd && u !== Oh))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    r === void 0 && u === sd && (r = xd),
      r === void 0 && u === Oh && (r = ip),
      super(null, i, s, o, a, l, u, r, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : Dr),
      (this.minFilter = l !== void 0 ? l : Dr),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
const yk = new Fr(),
  xk = new sp(1, 1);
xk.compareFunction = i2;
const _k = new f0(),
  Sk = new a2(),
  Ak = new p0(),
  J3 = [],
  eI = [],
  tI = new Float32Array(16),
  nI = new Float32Array(9),
  rI = new Float32Array(4);
function op(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let s = J3[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (J3[i] = s)), e !== 0)) {
    r.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Xr(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Yr(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function g_(n, e) {
  let t = eI[e];
  t === void 0 && ((t = new Int32Array(e)), (eI[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function pY(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function mY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xr(t, e)) return;
    n.uniform2fv(this.addr, e), Yr(t, e);
  }
}
function gY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Xr(t, e)) return;
    n.uniform3fv(this.addr, e), Yr(t, e);
  }
}
function vY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xr(t, e)) return;
    n.uniform4fv(this.addr, e), Yr(t, e);
  }
}
function yY(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Xr(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Yr(t, e);
  } else {
    if (Xr(t, r)) return;
    rI.set(r), n.uniformMatrix2fv(this.addr, !1, rI), Yr(t, r);
  }
}
function xY(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Xr(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Yr(t, e);
  } else {
    if (Xr(t, r)) return;
    nI.set(r), n.uniformMatrix3fv(this.addr, !1, nI), Yr(t, r);
  }
}
function _Y(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Xr(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Yr(t, e);
  } else {
    if (Xr(t, r)) return;
    tI.set(r), n.uniformMatrix4fv(this.addr, !1, tI), Yr(t, r);
  }
}
function SY(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function AY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xr(t, e)) return;
    n.uniform2iv(this.addr, e), Yr(t, e);
  }
}
function wY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Xr(t, e)) return;
    n.uniform3iv(this.addr, e), Yr(t, e);
  }
}
function bY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xr(t, e)) return;
    n.uniform4iv(this.addr, e), Yr(t, e);
  }
}
function EY(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function MY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Xr(t, e)) return;
    n.uniform2uiv(this.addr, e), Yr(t, e);
  }
}
function TY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Xr(t, e)) return;
    n.uniform3uiv(this.addr, e), Yr(t, e);
  }
}
function CY(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Xr(t, e)) return;
    n.uniform4uiv(this.addr, e), Yr(t, e);
  }
}
function RY(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i));
  const s = this.type === n.SAMPLER_2D_SHADOW ? xk : yk;
  t.setTexture2D(e || s, i);
}
function NY(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || Sk, i);
}
function PY(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || Ak, i);
}
function IY(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || _k, i);
}
function LY(n) {
  switch (n) {
    case 5126:
      return pY;
    case 35664:
      return mY;
    case 35665:
      return gY;
    case 35666:
      return vY;
    case 35674:
      return yY;
    case 35675:
      return xY;
    case 35676:
      return _Y;
    case 5124:
    case 35670:
      return SY;
    case 35667:
    case 35671:
      return AY;
    case 35668:
    case 35672:
      return wY;
    case 35669:
    case 35673:
      return bY;
    case 5125:
      return EY;
    case 36294:
      return MY;
    case 36295:
      return TY;
    case 36296:
      return CY;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return RY;
    case 35679:
    case 36299:
    case 36307:
      return NY;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return PY;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return IY;
  }
}
function OY(n, e) {
  n.uniform1fv(this.addr, e);
}
function DY(n, e) {
  const t = op(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function FY(n, e) {
  const t = op(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function UY(n, e) {
  const t = op(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function kY(n, e) {
  const t = op(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function zY(n, e) {
  const t = op(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function BY(n, e) {
  const t = op(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function VY(n, e) {
  n.uniform1iv(this.addr, e);
}
function HY(n, e) {
  n.uniform2iv(this.addr, e);
}
function GY(n, e) {
  n.uniform3iv(this.addr, e);
}
function WY(n, e) {
  n.uniform4iv(this.addr, e);
}
function jY(n, e) {
  n.uniform1uiv(this.addr, e);
}
function $Y(n, e) {
  n.uniform2uiv(this.addr, e);
}
function XY(n, e) {
  n.uniform3uiv(this.addr, e);
}
function YY(n, e) {
  n.uniform4uiv(this.addr, e);
}
function qY(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = g_(t, i);
  Xr(r, s) || (n.uniform1iv(this.addr, s), Yr(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || yk, s[o]);
}
function KY(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = g_(t, i);
  Xr(r, s) || (n.uniform1iv(this.addr, s), Yr(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || Sk, s[o]);
}
function ZY(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = g_(t, i);
  Xr(r, s) || (n.uniform1iv(this.addr, s), Yr(r, s));
  for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || Ak, s[o]);
}
function QY(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = g_(t, i);
  Xr(r, s) || (n.uniform1iv(this.addr, s), Yr(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || _k, s[o]);
}
function JY(n) {
  switch (n) {
    case 5126:
      return OY;
    case 35664:
      return DY;
    case 35665:
      return FY;
    case 35666:
      return UY;
    case 35674:
      return kY;
    case 35675:
      return zY;
    case 35676:
      return BY;
    case 5124:
    case 35670:
      return VY;
    case 35667:
    case 35671:
      return HY;
    case 35668:
    case 35672:
      return GY;
    case 35669:
    case 35673:
      return WY;
    case 5125:
      return jY;
    case 36294:
      return $Y;
    case 36295:
      return XY;
    case 36296:
      return YY;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return qY;
    case 35679:
    case 36299:
    case 36307:
      return KY;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return ZY;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return QY;
  }
}
class eq {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = LY(t.type));
  }
}
class tq {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = JY(t.type));
  }
}
class nq {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const a = i[s];
      a.setValue(e, t[a.id], r);
    }
  }
}
const xw = /(\w+)(\])?(\[|\.)?/g;
function iI(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function rq(n, e, t) {
  const r = n.name,
    i = r.length;
  for (xw.lastIndex = 0; ; ) {
    const s = xw.exec(r),
      o = xw.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
      iI(t, c === void 0 ? new eq(a, n, e) : new tq(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new nq(a)), iI(t, d)), (t = d);
    }
  }
}
class Ax {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const s = e.getActiveUniform(t, i),
        o = e.getUniformLocation(t, s.name);
      rq(s, o, this);
    }
  }
  setValue(e, t, r, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = r[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in t && r.push(o);
    }
    return r;
  }
}
function sI(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const iq = 37297;
let sq = 0;
function oq(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    const a = o + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return r.join(`
`);
}
function aq(n) {
  const e = bn.getPrimaries(bn.workingColorSpace),
    t = bn.getPrimaries(n);
  let r;
  switch (
    (e === t
      ? (r = "")
      : e === Ng && t === Rg
      ? (r = "LinearDisplayP3ToLinearSRGB")
      : e === Rg && t === Ng && (r = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case Ho:
    case d0:
      return [r, "LinearTransferOETF"];
    case Xs:
    case m_:
      return [r, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [r, "LinearTransferOETF"]
      );
  }
}
function oI(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    i = n.getShaderInfoLog(e).trim();
  if (r && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      oq(n.getShaderSource(e), o)
    );
  } else return i;
}
function lq(n, e) {
  const t = aq(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function cq(n, e) {
  let t;
  switch (e) {
    case VC:
      t = "Linear";
      break;
    case HC:
      t = "Reinhard";
      break;
    case GC:
      t = "OptimizedCineon";
      break;
    case f_:
      t = "ACESFilmic";
      break;
    case WC:
      t = "AgX";
      break;
    case B4:
      t = "Neutral";
      break;
    case z4:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function uq(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Rm).join(`
`);
}
function dq(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function fq(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const s = n.getActiveAttrib(e, i),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function Rm(n) {
  return n !== "";
}
function aI(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lI(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const hq = /^[ \t]*#include +<([\w\d./]+)>/gm;
function gM(n) {
  return n.replace(hq, mq);
}
const pq = new Map();
function mq(n, e) {
  let t = Kt[e];
  if (t === void 0) {
    const r = pq.get(e);
    if (r !== void 0)
      (t = Kt[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return gM(t);
}
const gq =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function cI(n) {
  return n.replace(gq, vq);
}
function vq(n, e, t, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function uI(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function yq(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === d_
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === Gm
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === ta && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function xq(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Dl:
      case Bc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case np:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function _q(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Bc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Sq(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case u0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case U4:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case k4:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Aq(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function wq(n, e, t, r) {
  const i = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = yq(t),
    c = xq(t),
    u = _q(t),
    d = Sq(t),
    h = Aq(t),
    m = uq(t),
    g = dq(s),
    x = i.createProgram();
  let y,
    v,
    _ = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((y = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(Rm).join(`
`)),
      y.length > 0 &&
        (y += `
`),
      (v = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(Rm).join(`
`)),
      v.length > 0 &&
        (v += `
`))
    : ((y = [
        uI(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Rm).join(`
`)),
      (v = [
        uI(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + d : "",
        h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
        h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
        h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== ws ? "#define TONE_MAPPING" : "",
        t.toneMapping !== ws ? Kt.tonemapping_pars_fragment : "",
        t.toneMapping !== ws ? cq("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Kt.colorspace_pars_fragment,
        lq("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(Rm).join(`
`))),
    (o = gM(o)),
    (o = aI(o, t)),
    (o = lI(o, t)),
    (a = gM(a)),
    (a = aI(a, t)),
    (a = lI(a, t)),
    (o = cI(o)),
    (a = cI(a)),
    t.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (y =
        [
          m,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        y),
      (v =
        [
          "#define varying in",
          t.glslVersion === pM
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === pM ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        v));
  const S = _ + y + o,
    w = _ + v + a,
    T = sI(i, i.VERTEX_SHADER, S),
    E = sI(i, i.FRAGMENT_SHADER, w);
  i.attachShader(x, T),
    i.attachShader(x, E),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(x, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
    i.linkProgram(x);
  function M(L) {
    if (n.debug.checkShaderErrors) {
      const O = i.getProgramInfoLog(x).trim(),
        D = i.getShaderInfoLog(T).trim(),
        B = i.getShaderInfoLog(E).trim();
      let $ = !0,
        G = !0;
      if (i.getProgramParameter(x, i.LINK_STATUS) === !1)
        if ((($ = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(i, x, T, E);
        else {
          const j = oI(i, T, "vertex"),
            U = oI(i, E, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(x, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              L.name +
              `
Material Type: ` +
              L.type +
              `

Program Info Log: ` +
              O +
              `
` +
              j +
              `
` +
              U
          );
        }
      else
        O !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", O)
          : (D === "" || B === "") && (G = !1);
      G &&
        (L.diagnostics = {
          runnable: $,
          programLog: O,
          vertexShader: { log: D, prefix: y },
          fragmentShader: { log: B, prefix: v },
        });
    }
    i.deleteShader(T), i.deleteShader(E), (N = new Ax(i, x)), (R = fq(i, x));
  }
  let N;
  this.getUniforms = function () {
    return N === void 0 && M(this), N;
  };
  let R;
  this.getAttributes = function () {
    return R === void 0 && M(this), R;
  };
  let C = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return C === !1 && (C = i.getProgramParameter(x, iq)), C;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(x),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = sq++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = T),
    (this.fragmentShader = E),
    this
  );
}
let bq = 0;
class Eq {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(r),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Mq(e)), t.set(e, r)), r;
  }
}
class Mq {
  constructor(e) {
    (this.id = bq++), (this.code = e), (this.usedTimes = 0);
  }
}
function Tq(n, e, t, r, i, s, o) {
  const a = new ad(),
    l = new Eq(),
    c = new Set(),
    u = [],
    d = i.logarithmicDepthBuffer,
    h = i.vertexTextures;
  let m = i.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function x(R) {
    return c.add(R), R === 0 ? "uv" : `uv${R}`;
  }
  function y(R, C, L, O, D) {
    const B = O.fog,
      $ = D.geometry,
      G = R.isMeshStandardMaterial ? O.environment : null,
      j = (R.isMeshStandardMaterial ? t : e).get(R.envMap || G),
      U = j && j.mapping === np ? j.image.height : null,
      H = g[R.type];
    R.precision !== null &&
      ((m = i.getMaxPrecision(R.precision)),
      m !== R.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          R.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const V =
        $.morphAttributes.position ||
        $.morphAttributes.normal ||
        $.morphAttributes.color,
      k = V !== void 0 ? V.length : 0;
    let W = 0;
    $.morphAttributes.position !== void 0 && (W = 1),
      $.morphAttributes.normal !== void 0 && (W = 2),
      $.morphAttributes.color !== void 0 && (W = 3);
    let ee, Y, K, ae;
    if (H) {
      const lt = aa[H];
      (ee = lt.vertexShader), (Y = lt.fragmentShader);
    } else
      (ee = R.vertexShader),
        (Y = R.fragmentShader),
        l.update(R),
        (K = l.getVertexShaderID(R)),
        (ae = l.getFragmentShaderID(R));
    const se = n.getRenderTarget(),
      we = D.isInstancedMesh === !0,
      Be = D.isBatchedMesh === !0,
      te = !!R.map,
      ge = !!R.matcap,
      ie = !!j,
      me = !!R.aoMap,
      fe = !!R.lightMap,
      Ee = !!R.bumpMap,
      Se = !!R.normalMap,
      Ue = !!R.displacementMap,
      Ce = !!R.emissiveMap,
      X = !!R.metalnessMap,
      z = !!R.roughnessMap,
      q = R.anisotropy > 0,
      ue = R.clearcoat > 0,
      de = R.dispersion > 0,
      he = R.iridescence > 0,
      Ie = R.sheen > 0,
      ke = R.transmission > 0,
      Me = q && !!R.anisotropyMap,
      et = ue && !!R.clearcoatMap,
      Ne = ue && !!R.clearcoatNormalMap,
      We = ue && !!R.clearcoatRoughnessMap,
      ot = he && !!R.iridescenceMap,
      nt = he && !!R.iridescenceThicknessMap,
      Ke = Ie && !!R.sheenColorMap,
      it = Ie && !!R.sheenRoughnessMap,
      re = !!R.specularMap,
      ze = !!R.specularColorMap,
      Xe = !!R.specularIntensityMap,
      le = ke && !!R.transmissionMap,
      Re = ke && !!R.thicknessMap,
      xe = !!R.gradientMap,
      Ye = !!R.alphaMap,
      at = R.alphaTest > 0,
      vt = !!R.alphaHash,
      dt = !!R.extensions;
    let mt = ws;
    R.toneMapped &&
      (se === null || se.isXRRenderTarget === !0) &&
      (mt = n.toneMapping);
    const kt = {
      shaderID: H,
      shaderType: R.type,
      shaderName: R.name,
      vertexShader: ee,
      fragmentShader: Y,
      defines: R.defines,
      customVertexShaderID: K,
      customFragmentShaderID: ae,
      isRawShaderMaterial: R.isRawShaderMaterial === !0,
      glslVersion: R.glslVersion,
      precision: m,
      batching: Be,
      instancing: we,
      instancingColor: we && D.instanceColor !== null,
      instancingMorph: we && D.morphTexture !== null,
      supportsVertexTextures: h,
      outputColorSpace:
        se === null
          ? n.outputColorSpace
          : se.isXRRenderTarget === !0
          ? se.texture.colorSpace
          : Ho,
      alphaToCoverage: !!R.alphaToCoverage,
      map: te,
      matcap: ge,
      envMap: ie,
      envMapMode: ie && j.mapping,
      envMapCubeUVHeight: U,
      aoMap: me,
      lightMap: fe,
      bumpMap: Ee,
      normalMap: Se,
      displacementMap: h && Ue,
      emissiveMap: Ce,
      normalMapObjectSpace: Se && R.normalMapType === n2,
      normalMapTangentSpace: Se && R.normalMapType === Xa,
      metalnessMap: X,
      roughnessMap: z,
      anisotropy: q,
      anisotropyMap: Me,
      clearcoat: ue,
      clearcoatMap: et,
      clearcoatNormalMap: Ne,
      clearcoatRoughnessMap: We,
      dispersion: de,
      iridescence: he,
      iridescenceMap: ot,
      iridescenceThicknessMap: nt,
      sheen: Ie,
      sheenColorMap: Ke,
      sheenRoughnessMap: it,
      specularMap: re,
      specularColorMap: ze,
      specularIntensityMap: Xe,
      transmission: ke,
      transmissionMap: le,
      thicknessMap: Re,
      gradientMap: xe,
      opaque:
        R.transparent === !1 && R.blending === id && R.alphaToCoverage === !1,
      alphaMap: Ye,
      alphaTest: at,
      alphaHash: vt,
      combine: R.combine,
      mapUv: te && x(R.map.channel),
      aoMapUv: me && x(R.aoMap.channel),
      lightMapUv: fe && x(R.lightMap.channel),
      bumpMapUv: Ee && x(R.bumpMap.channel),
      normalMapUv: Se && x(R.normalMap.channel),
      displacementMapUv: Ue && x(R.displacementMap.channel),
      emissiveMapUv: Ce && x(R.emissiveMap.channel),
      metalnessMapUv: X && x(R.metalnessMap.channel),
      roughnessMapUv: z && x(R.roughnessMap.channel),
      anisotropyMapUv: Me && x(R.anisotropyMap.channel),
      clearcoatMapUv: et && x(R.clearcoatMap.channel),
      clearcoatNormalMapUv: Ne && x(R.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: We && x(R.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ot && x(R.iridescenceMap.channel),
      iridescenceThicknessMapUv: nt && x(R.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ke && x(R.sheenColorMap.channel),
      sheenRoughnessMapUv: it && x(R.sheenRoughnessMap.channel),
      specularMapUv: re && x(R.specularMap.channel),
      specularColorMapUv: ze && x(R.specularColorMap.channel),
      specularIntensityMapUv: Xe && x(R.specularIntensityMap.channel),
      transmissionMapUv: le && x(R.transmissionMap.channel),
      thicknessMapUv: Re && x(R.thicknessMap.channel),
      alphaMapUv: Ye && x(R.alphaMap.channel),
      vertexTangents: !!$.attributes.tangent && (Se || q),
      vertexColors: R.vertexColors,
      vertexAlphas:
        R.vertexColors === !0 &&
        !!$.attributes.color &&
        $.attributes.color.itemSize === 4,
      pointsUvs: D.isPoints === !0 && !!$.attributes.uv && (te || Ye),
      fog: !!B,
      useFog: R.fog === !0,
      fogExp2: !!B && B.isFogExp2,
      flatShading: R.flatShading === !0,
      sizeAttenuation: R.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: D.isSkinnedMesh === !0,
      morphTargets: $.morphAttributes.position !== void 0,
      morphNormals: $.morphAttributes.normal !== void 0,
      morphColors: $.morphAttributes.color !== void 0,
      morphTargetsCount: k,
      morphTextureStride: W,
      numDirLights: C.directional.length,
      numPointLights: C.point.length,
      numSpotLights: C.spot.length,
      numSpotLightMaps: C.spotLightMap.length,
      numRectAreaLights: C.rectArea.length,
      numHemiLights: C.hemi.length,
      numDirLightShadows: C.directionalShadowMap.length,
      numPointLightShadows: C.pointShadowMap.length,
      numSpotLightShadows: C.spotShadowMap.length,
      numSpotLightShadowsWithMaps: C.numSpotLightShadowsWithMaps,
      numLightProbes: C.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: R.dithering,
      shadowMapEnabled: n.shadowMap.enabled && L.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: mt,
      useLegacyLights: n._useLegacyLights,
      decodeVideoTexture:
        te &&
        R.map.isVideoTexture === !0 &&
        bn.getTransfer(R.map.colorSpace) === kn,
      premultipliedAlpha: R.premultipliedAlpha,
      doubleSided: R.side === Ys,
      flipSided: R.side === pi,
      useDepthPacking: R.depthPacking >= 0,
      depthPacking: R.depthPacking || 0,
      index0AttributeName: R.index0AttributeName,
      extensionClipCullDistance:
        dt &&
        R.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        dt && R.extensions.multiDraw === !0 && r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: R.customProgramCacheKey(),
    };
    return (
      (kt.vertexUv1s = c.has(1)),
      (kt.vertexUv2s = c.has(2)),
      (kt.vertexUv3s = c.has(3)),
      c.clear(),
      kt
    );
  }
  function v(R) {
    const C = [];
    if (
      (R.shaderID
        ? C.push(R.shaderID)
        : (C.push(R.customVertexShaderID), C.push(R.customFragmentShaderID)),
      R.defines !== void 0)
    )
      for (const L in R.defines) C.push(L), C.push(R.defines[L]);
    return (
      R.isRawShaderMaterial === !1 &&
        (_(C, R), S(C, R), C.push(n.outputColorSpace)),
      C.push(R.customProgramCacheKey),
      C.join()
    );
  }
  function _(R, C) {
    R.push(C.precision),
      R.push(C.outputColorSpace),
      R.push(C.envMapMode),
      R.push(C.envMapCubeUVHeight),
      R.push(C.mapUv),
      R.push(C.alphaMapUv),
      R.push(C.lightMapUv),
      R.push(C.aoMapUv),
      R.push(C.bumpMapUv),
      R.push(C.normalMapUv),
      R.push(C.displacementMapUv),
      R.push(C.emissiveMapUv),
      R.push(C.metalnessMapUv),
      R.push(C.roughnessMapUv),
      R.push(C.anisotropyMapUv),
      R.push(C.clearcoatMapUv),
      R.push(C.clearcoatNormalMapUv),
      R.push(C.clearcoatRoughnessMapUv),
      R.push(C.iridescenceMapUv),
      R.push(C.iridescenceThicknessMapUv),
      R.push(C.sheenColorMapUv),
      R.push(C.sheenRoughnessMapUv),
      R.push(C.specularMapUv),
      R.push(C.specularColorMapUv),
      R.push(C.specularIntensityMapUv),
      R.push(C.transmissionMapUv),
      R.push(C.thicknessMapUv),
      R.push(C.combine),
      R.push(C.fogExp2),
      R.push(C.sizeAttenuation),
      R.push(C.morphTargetsCount),
      R.push(C.morphAttributeCount),
      R.push(C.numDirLights),
      R.push(C.numPointLights),
      R.push(C.numSpotLights),
      R.push(C.numSpotLightMaps),
      R.push(C.numHemiLights),
      R.push(C.numRectAreaLights),
      R.push(C.numDirLightShadows),
      R.push(C.numPointLightShadows),
      R.push(C.numSpotLightShadows),
      R.push(C.numSpotLightShadowsWithMaps),
      R.push(C.numLightProbes),
      R.push(C.shadowMapType),
      R.push(C.toneMapping),
      R.push(C.numClippingPlanes),
      R.push(C.numClipIntersection),
      R.push(C.depthPacking);
  }
  function S(R, C) {
    a.disableAll(),
      C.supportsVertexTextures && a.enable(0),
      C.instancing && a.enable(1),
      C.instancingColor && a.enable(2),
      C.instancingMorph && a.enable(3),
      C.matcap && a.enable(4),
      C.envMap && a.enable(5),
      C.normalMapObjectSpace && a.enable(6),
      C.normalMapTangentSpace && a.enable(7),
      C.clearcoat && a.enable(8),
      C.iridescence && a.enable(9),
      C.alphaTest && a.enable(10),
      C.vertexColors && a.enable(11),
      C.vertexAlphas && a.enable(12),
      C.vertexUv1s && a.enable(13),
      C.vertexUv2s && a.enable(14),
      C.vertexUv3s && a.enable(15),
      C.vertexTangents && a.enable(16),
      C.anisotropy && a.enable(17),
      C.alphaHash && a.enable(18),
      C.batching && a.enable(19),
      C.dispersion && a.enable(20),
      R.push(a.mask),
      a.disableAll(),
      C.fog && a.enable(0),
      C.useFog && a.enable(1),
      C.flatShading && a.enable(2),
      C.logarithmicDepthBuffer && a.enable(3),
      C.skinning && a.enable(4),
      C.morphTargets && a.enable(5),
      C.morphNormals && a.enable(6),
      C.morphColors && a.enable(7),
      C.premultipliedAlpha && a.enable(8),
      C.shadowMapEnabled && a.enable(9),
      C.useLegacyLights && a.enable(10),
      C.doubleSided && a.enable(11),
      C.flipSided && a.enable(12),
      C.useDepthPacking && a.enable(13),
      C.dithering && a.enable(14),
      C.transmission && a.enable(15),
      C.sheen && a.enable(16),
      C.opaque && a.enable(17),
      C.pointsUvs && a.enable(18),
      C.decodeVideoTexture && a.enable(19),
      C.alphaToCoverage && a.enable(20),
      R.push(a.mask);
  }
  function w(R) {
    const C = g[R.type];
    let L;
    if (C) {
      const O = aa[C];
      L = u2.clone(O.uniforms);
    } else L = R.uniforms;
    return L;
  }
  function T(R, C) {
    let L;
    for (let O = 0, D = u.length; O < D; O++) {
      const B = u[O];
      if (B.cacheKey === C) {
        (L = B), ++L.usedTimes;
        break;
      }
    }
    return L === void 0 && ((L = new wq(n, C, R, s)), u.push(L)), L;
  }
  function E(R) {
    if (--R.usedTimes === 0) {
      const C = u.indexOf(R);
      (u[C] = u[u.length - 1]), u.pop(), R.destroy();
    }
  }
  function M(R) {
    l.remove(R);
  }
  function N() {
    l.dispose();
  }
  return {
    getParameters: y,
    getProgramCacheKey: v,
    getUniforms: w,
    acquireProgram: T,
    releaseProgram: E,
    releaseShaderCache: M,
    programs: u,
    dispose: N,
  };
}
function Cq() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function r(s, o, a) {
    n.get(s)[o] = a;
  }
  function i() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: r, dispose: i };
}
function Rq(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function dI(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function fI() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function o(d, h, m, g, x, y) {
    let v = n[e];
    return (
      v === void 0
        ? ((v = {
            id: d.id,
            object: d,
            geometry: h,
            material: m,
            groupOrder: g,
            renderOrder: d.renderOrder,
            z: x,
            group: y,
          }),
          (n[e] = v))
        : ((v.id = d.id),
          (v.object = d),
          (v.geometry = h),
          (v.material = m),
          (v.groupOrder = g),
          (v.renderOrder = d.renderOrder),
          (v.z = x),
          (v.group = y)),
      e++,
      v
    );
  }
  function a(d, h, m, g, x, y) {
    const v = o(d, h, m, g, x, y);
    m.transmission > 0
      ? r.push(v)
      : m.transparent === !0
      ? i.push(v)
      : t.push(v);
  }
  function l(d, h, m, g, x, y) {
    const v = o(d, h, m, g, x, y);
    m.transmission > 0
      ? r.unshift(v)
      : m.transparent === !0
      ? i.unshift(v)
      : t.unshift(v);
  }
  function c(d, h) {
    t.length > 1 && t.sort(d || Rq),
      r.length > 1 && r.sort(h || dI),
      i.length > 1 && i.sort(h || dI);
  }
  function u() {
    for (let d = e, h = n.length; d < h; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function Nq() {
  let n = new WeakMap();
  function e(r, i) {
    const s = n.get(r);
    let o;
    return (
      s === void 0
        ? ((o = new fI()), n.set(r, [o]))
        : i >= s.length
        ? ((o = new fI()), s.push(o))
        : (o = s[i]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function Pq() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new Q(), color: new pt() };
          break;
        case "SpotLight":
          t = {
            position: new Q(),
            direction: new Q(),
            color: new pt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new Q(), color: new pt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new Q(), skyColor: new pt(), groundColor: new pt() };
          break;
        case "RectAreaLight":
          t = {
            color: new pt(),
            position: new Q(),
            halfWidth: new Q(),
            halfHeight: new Q(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function Iq() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new He(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new He(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new He(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let Lq = 0;
function Oq(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function Dq(n) {
  const e = new Pq(),
    t = Iq(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) r.probe.push(new Q());
  const i = new Q(),
    s = new Ut(),
    o = new Ut();
  function a(c, u) {
    let d = 0,
      h = 0,
      m = 0;
    for (let L = 0; L < 9; L++) r.probe[L].set(0, 0, 0);
    let g = 0,
      x = 0,
      y = 0,
      v = 0,
      _ = 0,
      S = 0,
      w = 0,
      T = 0,
      E = 0,
      M = 0,
      N = 0;
    c.sort(Oq);
    const R = u === !0 ? Math.PI : 1;
    for (let L = 0, O = c.length; L < O; L++) {
      const D = c[L],
        B = D.color,
        $ = D.intensity,
        G = D.distance,
        j = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        (d += B.r * $ * R), (h += B.g * $ * R), (m += B.b * $ * R);
      else if (D.isLightProbe) {
        for (let U = 0; U < 9; U++)
          r.probe[U].addScaledVector(D.sh.coefficients[U], $);
        N++;
      } else if (D.isDirectionalLight) {
        const U = e.get(D);
        if (
          (U.color.copy(D.color).multiplyScalar(D.intensity * R), D.castShadow)
        ) {
          const H = D.shadow,
            V = t.get(D);
          (V.shadowBias = H.bias),
            (V.shadowNormalBias = H.normalBias),
            (V.shadowRadius = H.radius),
            (V.shadowMapSize = H.mapSize),
            (r.directionalShadow[g] = V),
            (r.directionalShadowMap[g] = j),
            (r.directionalShadowMatrix[g] = D.shadow.matrix),
            S++;
        }
        (r.directional[g] = U), g++;
      } else if (D.isSpotLight) {
        const U = e.get(D);
        U.position.setFromMatrixPosition(D.matrixWorld),
          U.color.copy(B).multiplyScalar($ * R),
          (U.distance = G),
          (U.coneCos = Math.cos(D.angle)),
          (U.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (U.decay = D.decay),
          (r.spot[y] = U);
        const H = D.shadow;
        if (
          (D.map &&
            ((r.spotLightMap[E] = D.map),
            E++,
            H.updateMatrices(D),
            D.castShadow && M++),
          (r.spotLightMatrix[y] = H.matrix),
          D.castShadow)
        ) {
          const V = t.get(D);
          (V.shadowBias = H.bias),
            (V.shadowNormalBias = H.normalBias),
            (V.shadowRadius = H.radius),
            (V.shadowMapSize = H.mapSize),
            (r.spotShadow[y] = V),
            (r.spotShadowMap[y] = j),
            T++;
        }
        y++;
      } else if (D.isRectAreaLight) {
        const U = e.get(D);
        U.color.copy(B).multiplyScalar($),
          U.halfWidth.set(D.width * 0.5, 0, 0),
          U.halfHeight.set(0, D.height * 0.5, 0),
          (r.rectArea[v] = U),
          v++;
      } else if (D.isPointLight) {
        const U = e.get(D);
        if (
          (U.color.copy(D.color).multiplyScalar(D.intensity * R),
          (U.distance = D.distance),
          (U.decay = D.decay),
          D.castShadow)
        ) {
          const H = D.shadow,
            V = t.get(D);
          (V.shadowBias = H.bias),
            (V.shadowNormalBias = H.normalBias),
            (V.shadowRadius = H.radius),
            (V.shadowMapSize = H.mapSize),
            (V.shadowCameraNear = H.camera.near),
            (V.shadowCameraFar = H.camera.far),
            (r.pointShadow[x] = V),
            (r.pointShadowMap[x] = j),
            (r.pointShadowMatrix[x] = D.shadow.matrix),
            w++;
        }
        (r.point[x] = U), x++;
      } else if (D.isHemisphereLight) {
        const U = e.get(D);
        U.skyColor.copy(D.color).multiplyScalar($ * R),
          U.groundColor.copy(D.groundColor).multiplyScalar($ * R),
          (r.hemi[_] = U),
          _++;
      }
    }
    v > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = ht.LTC_FLOAT_1), (r.rectAreaLTC2 = ht.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = ht.LTC_HALF_1), (r.rectAreaLTC2 = ht.LTC_HALF_2))),
      (r.ambient[0] = d),
      (r.ambient[1] = h),
      (r.ambient[2] = m);
    const C = r.hash;
    (C.directionalLength !== g ||
      C.pointLength !== x ||
      C.spotLength !== y ||
      C.rectAreaLength !== v ||
      C.hemiLength !== _ ||
      C.numDirectionalShadows !== S ||
      C.numPointShadows !== w ||
      C.numSpotShadows !== T ||
      C.numSpotMaps !== E ||
      C.numLightProbes !== N) &&
      ((r.directional.length = g),
      (r.spot.length = y),
      (r.rectArea.length = v),
      (r.point.length = x),
      (r.hemi.length = _),
      (r.directionalShadow.length = S),
      (r.directionalShadowMap.length = S),
      (r.pointShadow.length = w),
      (r.pointShadowMap.length = w),
      (r.spotShadow.length = T),
      (r.spotShadowMap.length = T),
      (r.directionalShadowMatrix.length = S),
      (r.pointShadowMatrix.length = w),
      (r.spotLightMatrix.length = T + E - M),
      (r.spotLightMap.length = E),
      (r.numSpotLightShadowsWithMaps = M),
      (r.numLightProbes = N),
      (C.directionalLength = g),
      (C.pointLength = x),
      (C.spotLength = y),
      (C.rectAreaLength = v),
      (C.hemiLength = _),
      (C.numDirectionalShadows = S),
      (C.numPointShadows = w),
      (C.numSpotShadows = T),
      (C.numSpotMaps = E),
      (C.numLightProbes = N),
      (r.version = Lq++));
  }
  function l(c, u) {
    let d = 0,
      h = 0,
      m = 0,
      g = 0,
      x = 0;
    const y = u.matrixWorldInverse;
    for (let v = 0, _ = c.length; v < _; v++) {
      const S = c[v];
      if (S.isDirectionalLight) {
        const w = r.directional[d];
        w.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          w.direction.sub(i),
          w.direction.transformDirection(y),
          d++;
      } else if (S.isSpotLight) {
        const w = r.spot[m];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(y),
          w.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          w.direction.sub(i),
          w.direction.transformDirection(y),
          m++;
      } else if (S.isRectAreaLight) {
        const w = r.rectArea[g];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(y),
          o.identity(),
          s.copy(S.matrixWorld),
          s.premultiply(y),
          o.extractRotation(s),
          w.halfWidth.set(S.width * 0.5, 0, 0),
          w.halfHeight.set(0, S.height * 0.5, 0),
          w.halfWidth.applyMatrix4(o),
          w.halfHeight.applyMatrix4(o),
          g++;
      } else if (S.isPointLight) {
        const w = r.point[h];
        w.position.setFromMatrixPosition(S.matrixWorld),
          w.position.applyMatrix4(y),
          h++;
      } else if (S.isHemisphereLight) {
        const w = r.hemi[x];
        w.direction.setFromMatrixPosition(S.matrixWorld),
          w.direction.transformDirection(y),
          x++;
      }
    }
  }
  return { setup: a, setupView: l, state: r };
}
function hI(n) {
  const e = new Dq(n),
    t = [],
    r = [];
  function i(u) {
    (c.camera = u), (t.length = 0), (r.length = 0);
  }
  function s(u) {
    t.push(u);
  }
  function o(u) {
    r.push(u);
  }
  function a(u) {
    e.setup(t, u);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o,
  };
}
function Fq(n) {
  let e = new WeakMap();
  function t(i, s = 0) {
    const o = e.get(i);
    let a;
    return (
      o === void 0
        ? ((a = new hI(n)), e.set(i, [a]))
        : s >= o.length
        ? ((a = new hI(n)), o.push(a))
        : (a = o[s]),
      a
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
class v_ extends oi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = ek),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class y_ extends oi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const Uq = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  kq = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function zq(n, e, t) {
  let r = new m0();
  const i = new He(),
    s = new He(),
    o = new rn(),
    a = new v_({ depthPacking: t2 }),
    l = new y_(),
    c = {},
    u = t.maxTextureSize,
    d = { [ja]: pi, [pi]: ja, [Ys]: Ys },
    h = new Bo({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new He() },
        radius: { value: 4 },
      },
      vertexShader: Uq,
      fragmentShader: kq,
    }),
    m = h.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const g = new qt();
  g.setAttribute(
    "position",
    new Mn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const x = new qn(g, h),
    y = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = d_);
  let v = this.type;
  this.render = function (E, M, N) {
    if (
      y.enabled === !1 ||
      (y.autoUpdate === !1 && y.needsUpdate === !1) ||
      E.length === 0
    )
      return;
    const R = n.getRenderTarget(),
      C = n.getActiveCubeFace(),
      L = n.getActiveMipmapLevel(),
      O = n.state;
    O.setBlending(Cl),
      O.buffers.color.setClear(1, 1, 1, 1),
      O.buffers.depth.setTest(!0),
      O.setScissorTest(!1);
    const D = v !== ta && this.type === ta,
      B = v === ta && this.type !== ta;
    for (let $ = 0, G = E.length; $ < G; $++) {
      const j = E[$],
        U = j.shadow;
      if (U === void 0) {
        console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
        continue;
      }
      if (U.autoUpdate === !1 && U.needsUpdate === !1) continue;
      i.copy(U.mapSize);
      const H = U.getFrameExtents();
      if (
        (i.multiply(H),
        s.copy(U.mapSize),
        (i.x > u || i.y > u) &&
          (i.x > u &&
            ((s.x = Math.floor(u / H.x)),
            (i.x = s.x * H.x),
            (U.mapSize.x = s.x)),
          i.y > u &&
            ((s.y = Math.floor(u / H.y)),
            (i.y = s.y * H.y),
            (U.mapSize.y = s.y))),
        U.map === null || D === !0 || B === !0)
      ) {
        const k = this.type !== ta ? { minFilter: Dr, magFilter: Dr } : {};
        U.map !== null && U.map.dispose(),
          (U.map = new va(i.x, i.y, k)),
          (U.map.texture.name = j.name + ".shadowMap"),
          U.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(U.map), n.clear();
      const V = U.getViewportCount();
      for (let k = 0; k < V; k++) {
        const W = U.getViewport(k);
        o.set(s.x * W.x, s.y * W.y, s.x * W.z, s.y * W.w),
          O.viewport(o),
          U.updateMatrices(j, k),
          (r = U.getFrustum()),
          w(M, N, U.camera, j, this.type);
      }
      U.isPointLightShadow !== !0 && this.type === ta && _(U, N),
        (U.needsUpdate = !1);
    }
    (v = this.type), (y.needsUpdate = !1), n.setRenderTarget(R, C, L);
  };
  function _(E, M) {
    const N = e.update(x);
    h.defines.VSM_SAMPLES !== E.blurSamples &&
      ((h.defines.VSM_SAMPLES = E.blurSamples),
      (m.defines.VSM_SAMPLES = E.blurSamples),
      (h.needsUpdate = !0),
      (m.needsUpdate = !0)),
      E.mapPass === null && (E.mapPass = new va(i.x, i.y)),
      (h.uniforms.shadow_pass.value = E.map.texture),
      (h.uniforms.resolution.value = E.mapSize),
      (h.uniforms.radius.value = E.radius),
      n.setRenderTarget(E.mapPass),
      n.clear(),
      n.renderBufferDirect(M, null, N, h, x, null),
      (m.uniforms.shadow_pass.value = E.mapPass.texture),
      (m.uniforms.resolution.value = E.mapSize),
      (m.uniforms.radius.value = E.radius),
      n.setRenderTarget(E.map),
      n.clear(),
      n.renderBufferDirect(M, null, N, m, x, null);
  }
  function S(E, M, N, R) {
    let C = null;
    const L =
      N.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (L !== void 0) C = L;
    else if (
      ((C = N.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        M.clipShadows === !0 &&
        Array.isArray(M.clippingPlanes) &&
        M.clippingPlanes.length !== 0) ||
        (M.displacementMap && M.displacementScale !== 0) ||
        (M.alphaMap && M.alphaTest > 0) ||
        (M.map && M.alphaTest > 0))
    ) {
      const O = C.uuid,
        D = M.uuid;
      let B = c[O];
      B === void 0 && ((B = {}), (c[O] = B));
      let $ = B[D];
      $ === void 0 &&
        (($ = C.clone()), (B[D] = $), M.addEventListener("dispose", T)),
        (C = $);
    }
    if (
      ((C.visible = M.visible),
      (C.wireframe = M.wireframe),
      R === ta
        ? (C.side = M.shadowSide !== null ? M.shadowSide : M.side)
        : (C.side = M.shadowSide !== null ? M.shadowSide : d[M.side]),
      (C.alphaMap = M.alphaMap),
      (C.alphaTest = M.alphaTest),
      (C.map = M.map),
      (C.clipShadows = M.clipShadows),
      (C.clippingPlanes = M.clippingPlanes),
      (C.clipIntersection = M.clipIntersection),
      (C.displacementMap = M.displacementMap),
      (C.displacementScale = M.displacementScale),
      (C.displacementBias = M.displacementBias),
      (C.wireframeLinewidth = M.wireframeLinewidth),
      (C.linewidth = M.linewidth),
      N.isPointLight === !0 && C.isMeshDistanceMaterial === !0)
    ) {
      const O = n.properties.get(C);
      O.light = N;
    }
    return C;
  }
  function w(E, M, N, R, C) {
    if (E.visible === !1) return;
    if (
      E.layers.test(M.layers) &&
      (E.isMesh || E.isLine || E.isPoints) &&
      (E.castShadow || (E.receiveShadow && C === ta)) &&
      (!E.frustumCulled || r.intersectsObject(E))
    ) {
      E.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, E.matrixWorld);
      const D = e.update(E),
        B = E.material;
      if (Array.isArray(B)) {
        const $ = D.groups;
        for (let G = 0, j = $.length; G < j; G++) {
          const U = $[G],
            H = B[U.materialIndex];
          if (H && H.visible) {
            const V = S(E, H, R, C);
            E.onBeforeShadow(n, E, M, N, D, V, U),
              n.renderBufferDirect(N, null, D, V, E, U),
              E.onAfterShadow(n, E, M, N, D, V, U);
          }
        }
      } else if (B.visible) {
        const $ = S(E, B, R, C);
        E.onBeforeShadow(n, E, M, N, D, $, null),
          n.renderBufferDirect(N, null, D, $, E, null),
          E.onAfterShadow(n, E, M, N, D, $, null);
      }
    }
    const O = E.children;
    for (let D = 0, B = O.length; D < B; D++) w(O[D], M, N, R, C);
  }
  function T(E) {
    E.target.removeEventListener("dispose", T);
    for (const N in c) {
      const R = c[N],
        C = E.target.uuid;
      C in R && (R[C].dispose(), delete R[C]);
    }
  }
}
function Bq(n) {
  function e() {
    let le = !1;
    const Re = new rn();
    let xe = null;
    const Ye = new rn(0, 0, 0, 0);
    return {
      setMask: function (at) {
        xe !== at && !le && (n.colorMask(at, at, at, at), (xe = at));
      },
      setLocked: function (at) {
        le = at;
      },
      setClear: function (at, vt, dt, mt, kt) {
        kt === !0 && ((at *= mt), (vt *= mt), (dt *= mt)),
          Re.set(at, vt, dt, mt),
          Ye.equals(Re) === !1 && (n.clearColor(at, vt, dt, mt), Ye.copy(Re));
      },
      reset: function () {
        (le = !1), (xe = null), Ye.set(-1, 0, 0, 0);
      },
    };
  }
  function t() {
    let le = !1,
      Re = null,
      xe = null,
      Ye = null;
    return {
      setTest: function (at) {
        at ? ae(n.DEPTH_TEST) : se(n.DEPTH_TEST);
      },
      setMask: function (at) {
        Re !== at && !le && (n.depthMask(at), (Re = at));
      },
      setFunc: function (at) {
        if (xe !== at) {
          switch (at) {
            case N4:
              n.depthFunc(n.NEVER);
              break;
            case P4:
              n.depthFunc(n.ALWAYS);
              break;
            case I4:
              n.depthFunc(n.LESS);
              break;
            case _g:
              n.depthFunc(n.LEQUAL);
              break;
            case L4:
              n.depthFunc(n.EQUAL);
              break;
            case O4:
              n.depthFunc(n.GEQUAL);
              break;
            case D4:
              n.depthFunc(n.GREATER);
              break;
            case F4:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          xe = at;
        }
      },
      setLocked: function (at) {
        le = at;
      },
      setClear: function (at) {
        Ye !== at && (n.clearDepth(at), (Ye = at));
      },
      reset: function () {
        (le = !1), (Re = null), (xe = null), (Ye = null);
      },
    };
  }
  function r() {
    let le = !1,
      Re = null,
      xe = null,
      Ye = null,
      at = null,
      vt = null,
      dt = null,
      mt = null,
      kt = null;
    return {
      setTest: function (lt) {
        le || (lt ? ae(n.STENCIL_TEST) : se(n.STENCIL_TEST));
      },
      setMask: function (lt) {
        Re !== lt && !le && (n.stencilMask(lt), (Re = lt));
      },
      setFunc: function (lt, St, Nt) {
        (xe !== lt || Ye !== St || at !== Nt) &&
          (n.stencilFunc(lt, St, Nt), (xe = lt), (Ye = St), (at = Nt));
      },
      setOp: function (lt, St, Nt) {
        (vt !== lt || dt !== St || mt !== Nt) &&
          (n.stencilOp(lt, St, Nt), (vt = lt), (dt = St), (mt = Nt));
      },
      setLocked: function (lt) {
        le = lt;
      },
      setClear: function (lt) {
        kt !== lt && (n.clearStencil(lt), (kt = lt));
      },
      reset: function () {
        (le = !1),
          (Re = null),
          (xe = null),
          (Ye = null),
          (at = null),
          (vt = null),
          (dt = null),
          (mt = null),
          (kt = null);
      },
    };
  }
  const i = new e(),
    s = new t(),
    o = new r(),
    a = new WeakMap(),
    l = new WeakMap();
  let c = {},
    u = {},
    d = new WeakMap(),
    h = [],
    m = null,
    g = !1,
    x = null,
    y = null,
    v = null,
    _ = null,
    S = null,
    w = null,
    T = null,
    E = new pt(0, 0, 0),
    M = 0,
    N = !1,
    R = null,
    C = null,
    L = null,
    O = null,
    D = null;
  const B = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let $ = !1,
    G = 0;
  const j = n.getParameter(n.VERSION);
  j.indexOf("WebGL") !== -1
    ? ((G = parseFloat(/^WebGL (\d)/.exec(j)[1])), ($ = G >= 1))
    : j.indexOf("OpenGL ES") !== -1 &&
      ((G = parseFloat(/^OpenGL ES (\d)/.exec(j)[1])), ($ = G >= 2));
  let U = null,
    H = {};
  const V = n.getParameter(n.SCISSOR_BOX),
    k = n.getParameter(n.VIEWPORT),
    W = new rn().fromArray(V),
    ee = new rn().fromArray(k);
  function Y(le, Re, xe, Ye) {
    const at = new Uint8Array(4),
      vt = n.createTexture();
    n.bindTexture(le, vt),
      n.texParameteri(le, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(le, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let dt = 0; dt < xe; dt++)
      le === n.TEXTURE_3D || le === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Re, 0, n.RGBA, 1, 1, Ye, 0, n.RGBA, n.UNSIGNED_BYTE, at)
        : n.texImage2D(
            Re + dt,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            at
          );
    return vt;
  }
  const K = {};
  (K[n.TEXTURE_2D] = Y(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (K[n.TEXTURE_CUBE_MAP] = Y(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (K[n.TEXTURE_2D_ARRAY] = Y(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (K[n.TEXTURE_3D] = Y(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    s.setClear(1),
    o.setClear(0),
    ae(n.DEPTH_TEST),
    s.setFunc(_g),
    Ee(!1),
    Se(FE),
    ae(n.CULL_FACE),
    me(Cl);
  function ae(le) {
    c[le] !== !0 && (n.enable(le), (c[le] = !0));
  }
  function se(le) {
    c[le] !== !1 && (n.disable(le), (c[le] = !1));
  }
  function we(le, Re) {
    return u[le] !== Re
      ? (n.bindFramebuffer(le, Re),
        (u[le] = Re),
        le === n.DRAW_FRAMEBUFFER && (u[n.FRAMEBUFFER] = Re),
        le === n.FRAMEBUFFER && (u[n.DRAW_FRAMEBUFFER] = Re),
        !0)
      : !1;
  }
  function Be(le, Re) {
    let xe = h,
      Ye = !1;
    if (le) {
      (xe = d.get(Re)), xe === void 0 && ((xe = []), d.set(Re, xe));
      const at = le.textures;
      if (xe.length !== at.length || xe[0] !== n.COLOR_ATTACHMENT0) {
        for (let vt = 0, dt = at.length; vt < dt; vt++)
          xe[vt] = n.COLOR_ATTACHMENT0 + vt;
        (xe.length = at.length), (Ye = !0);
      }
    } else xe[0] !== n.BACK && ((xe[0] = n.BACK), (Ye = !0));
    Ye && n.drawBuffers(xe);
  }
  function te(le) {
    return m !== le ? (n.useProgram(le), (m = le), !0) : !1;
  }
  const ge = {
    [xc]: n.FUNC_ADD,
    [h4]: n.FUNC_SUBTRACT,
    [p4]: n.FUNC_REVERSE_SUBTRACT,
  };
  (ge[m4] = n.MIN), (ge[g4] = n.MAX);
  const ie = {
    [v4]: n.ZERO,
    [y4]: n.ONE,
    [x4]: n.SRC_COLOR,
    [c1]: n.SRC_ALPHA,
    [E4]: n.SRC_ALPHA_SATURATE,
    [w4]: n.DST_COLOR,
    [S4]: n.DST_ALPHA,
    [_4]: n.ONE_MINUS_SRC_COLOR,
    [u1]: n.ONE_MINUS_SRC_ALPHA,
    [b4]: n.ONE_MINUS_DST_COLOR,
    [A4]: n.ONE_MINUS_DST_ALPHA,
    [M4]: n.CONSTANT_COLOR,
    [T4]: n.ONE_MINUS_CONSTANT_COLOR,
    [C4]: n.CONSTANT_ALPHA,
    [R4]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function me(le, Re, xe, Ye, at, vt, dt, mt, kt, lt) {
    if (le === Cl) {
      g === !0 && (se(n.BLEND), (g = !1));
      return;
    }
    if ((g === !1 && (ae(n.BLEND), (g = !0)), le !== f4)) {
      if (le !== x || lt !== N) {
        if (
          ((y !== xc || S !== xc) &&
            (n.blendEquation(n.FUNC_ADD), (y = xc), (S = xc)),
          lt)
        )
          switch (le) {
            case id:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case UE:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case kE:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case zE:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", le);
              break;
          }
        else
          switch (le) {
            case id:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case UE:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case kE:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case zE:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", le);
              break;
          }
        (v = null),
          (_ = null),
          (w = null),
          (T = null),
          E.set(0, 0, 0),
          (M = 0),
          (x = le),
          (N = lt);
      }
      return;
    }
    (at = at || Re),
      (vt = vt || xe),
      (dt = dt || Ye),
      (Re !== y || at !== S) &&
        (n.blendEquationSeparate(ge[Re], ge[at]), (y = Re), (S = at)),
      (xe !== v || Ye !== _ || vt !== w || dt !== T) &&
        (n.blendFuncSeparate(ie[xe], ie[Ye], ie[vt], ie[dt]),
        (v = xe),
        (_ = Ye),
        (w = vt),
        (T = dt)),
      (mt.equals(E) === !1 || kt !== M) &&
        (n.blendColor(mt.r, mt.g, mt.b, kt), E.copy(mt), (M = kt)),
      (x = le),
      (N = !1);
  }
  function fe(le, Re) {
    le.side === Ys ? se(n.CULL_FACE) : ae(n.CULL_FACE);
    let xe = le.side === pi;
    Re && (xe = !xe),
      Ee(xe),
      le.blending === id && le.transparent === !1
        ? me(Cl)
        : me(
            le.blending,
            le.blendEquation,
            le.blendSrc,
            le.blendDst,
            le.blendEquationAlpha,
            le.blendSrcAlpha,
            le.blendDstAlpha,
            le.blendColor,
            le.blendAlpha,
            le.premultipliedAlpha
          ),
      s.setFunc(le.depthFunc),
      s.setTest(le.depthTest),
      s.setMask(le.depthWrite),
      i.setMask(le.colorWrite);
    const Ye = le.stencilWrite;
    o.setTest(Ye),
      Ye &&
        (o.setMask(le.stencilWriteMask),
        o.setFunc(le.stencilFunc, le.stencilRef, le.stencilFuncMask),
        o.setOp(le.stencilFail, le.stencilZFail, le.stencilZPass)),
      Ce(le.polygonOffset, le.polygonOffsetFactor, le.polygonOffsetUnits),
      le.alphaToCoverage === !0
        ? ae(n.SAMPLE_ALPHA_TO_COVERAGE)
        : se(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ee(le) {
    R !== le && (le ? n.frontFace(n.CW) : n.frontFace(n.CCW), (R = le));
  }
  function Se(le) {
    le !== c4
      ? (ae(n.CULL_FACE),
        le !== C &&
          (le === FE
            ? n.cullFace(n.BACK)
            : le === u4
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : se(n.CULL_FACE),
      (C = le);
  }
  function Ue(le) {
    le !== L && ($ && n.lineWidth(le), (L = le));
  }
  function Ce(le, Re, xe) {
    le
      ? (ae(n.POLYGON_OFFSET_FILL),
        (O !== Re || D !== xe) && (n.polygonOffset(Re, xe), (O = Re), (D = xe)))
      : se(n.POLYGON_OFFSET_FILL);
  }
  function X(le) {
    le ? ae(n.SCISSOR_TEST) : se(n.SCISSOR_TEST);
  }
  function z(le) {
    le === void 0 && (le = n.TEXTURE0 + B - 1),
      U !== le && (n.activeTexture(le), (U = le));
  }
  function q(le, Re, xe) {
    xe === void 0 && (U === null ? (xe = n.TEXTURE0 + B - 1) : (xe = U));
    let Ye = H[xe];
    Ye === void 0 && ((Ye = { type: void 0, texture: void 0 }), (H[xe] = Ye)),
      (Ye.type !== le || Ye.texture !== Re) &&
        (U !== xe && (n.activeTexture(xe), (U = xe)),
        n.bindTexture(le, Re || K[le]),
        (Ye.type = le),
        (Ye.texture = Re));
  }
  function ue() {
    const le = H[U];
    le !== void 0 &&
      le.type !== void 0 &&
      (n.bindTexture(le.type, null), (le.type = void 0), (le.texture = void 0));
  }
  function de() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function he() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ie() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function ke() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Me() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function et() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ne() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function We() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function ot() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function nt() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (le) {
      console.error("THREE.WebGLState:", le);
    }
  }
  function Ke(le) {
    W.equals(le) === !1 && (n.scissor(le.x, le.y, le.z, le.w), W.copy(le));
  }
  function it(le) {
    ee.equals(le) === !1 && (n.viewport(le.x, le.y, le.z, le.w), ee.copy(le));
  }
  function re(le, Re) {
    let xe = l.get(Re);
    xe === void 0 && ((xe = new WeakMap()), l.set(Re, xe));
    let Ye = xe.get(le);
    Ye === void 0 &&
      ((Ye = n.getUniformBlockIndex(Re, le.name)), xe.set(le, Ye));
  }
  function ze(le, Re) {
    const Ye = l.get(Re).get(le);
    a.get(Re) !== Ye &&
      (n.uniformBlockBinding(Re, Ye, le.__bindingPointIndex), a.set(Re, Ye));
  }
  function Xe() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (c = {}),
      (U = null),
      (H = {}),
      (u = {}),
      (d = new WeakMap()),
      (h = []),
      (m = null),
      (g = !1),
      (x = null),
      (y = null),
      (v = null),
      (_ = null),
      (S = null),
      (w = null),
      (T = null),
      (E = new pt(0, 0, 0)),
      (M = 0),
      (N = !1),
      (R = null),
      (C = null),
      (L = null),
      (O = null),
      (D = null),
      W.set(0, 0, n.canvas.width, n.canvas.height),
      ee.set(0, 0, n.canvas.width, n.canvas.height),
      i.reset(),
      s.reset(),
      o.reset();
  }
  return {
    buffers: { color: i, depth: s, stencil: o },
    enable: ae,
    disable: se,
    bindFramebuffer: we,
    drawBuffers: Be,
    useProgram: te,
    setBlending: me,
    setMaterial: fe,
    setFlipSided: Ee,
    setCullFace: Se,
    setLineWidth: Ue,
    setPolygonOffset: Ce,
    setScissorTest: X,
    activeTexture: z,
    bindTexture: q,
    unbindTexture: ue,
    compressedTexImage2D: de,
    compressedTexImage3D: he,
    texImage2D: ot,
    texImage3D: nt,
    updateUBOMapping: re,
    uniformBlockBinding: ze,
    texStorage2D: Ne,
    texStorage3D: We,
    texSubImage2D: Ie,
    texSubImage3D: ke,
    compressedTexSubImage2D: Me,
    compressedTexSubImage3D: et,
    scissor: Ke,
    viewport: it,
    reset: Xe,
  };
}
function Vq(n, e, t, r, i, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new He(),
    u = new WeakMap();
  let d;
  const h = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function g(X, z) {
    return m ? new OffscreenCanvas(X, z) : Pg("canvas");
  }
  function x(X, z, q) {
    let ue = 1;
    const de = Ce(X);
    if (
      ((de.width > q || de.height > q) &&
        (ue = q / Math.max(de.width, de.height)),
      ue < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && X instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && X instanceof VideoFrame)
      ) {
        const he = Math.floor(ue * de.width),
          Ie = Math.floor(ue * de.height);
        d === void 0 && (d = g(he, Ie));
        const ke = z ? g(he, Ie) : d;
        return (
          (ke.width = he),
          (ke.height = Ie),
          ke.getContext("2d").drawImage(X, 0, 0, he, Ie),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              de.width +
              "x" +
              de.height +
              ") to (" +
              he +
              "x" +
              Ie +
              ")."
          ),
          ke
        );
      } else
        return (
          "data" in X &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                de.width +
                "x" +
                de.height +
                ")."
            ),
          X
        );
    return X;
  }
  function y(X) {
    return X.generateMipmaps && X.minFilter !== Dr && X.minFilter !== dr;
  }
  function v(X) {
    n.generateMipmap(X);
  }
  function _(X, z, q, ue, de = !1) {
    if (X !== null) {
      if (n[X] !== void 0) return n[X];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          X +
          "'"
      );
    }
    let he = z;
    if (
      (z === n.RED &&
        (q === n.FLOAT && (he = n.R32F),
        q === n.HALF_FLOAT && (he = n.R16F),
        q === n.UNSIGNED_BYTE && (he = n.R8)),
      z === n.RED_INTEGER &&
        (q === n.UNSIGNED_BYTE && (he = n.R8UI),
        q === n.UNSIGNED_SHORT && (he = n.R16UI),
        q === n.UNSIGNED_INT && (he = n.R32UI),
        q === n.BYTE && (he = n.R8I),
        q === n.SHORT && (he = n.R16I),
        q === n.INT && (he = n.R32I)),
      z === n.RG &&
        (q === n.FLOAT && (he = n.RG32F),
        q === n.HALF_FLOAT && (he = n.RG16F),
        q === n.UNSIGNED_BYTE && (he = n.RG8)),
      z === n.RG_INTEGER &&
        (q === n.UNSIGNED_BYTE && (he = n.RG8UI),
        q === n.UNSIGNED_SHORT && (he = n.RG16UI),
        q === n.UNSIGNED_INT && (he = n.RG32UI),
        q === n.BYTE && (he = n.RG8I),
        q === n.SHORT && (he = n.RG16I),
        q === n.INT && (he = n.RG32I)),
      z === n.RGB && q === n.UNSIGNED_INT_5_9_9_9_REV && (he = n.RGB9_E5),
      z === n.RGBA)
    ) {
      const Ie = de ? Cg : bn.getTransfer(ue);
      q === n.FLOAT && (he = n.RGBA32F),
        q === n.HALF_FLOAT && (he = n.RGBA16F),
        q === n.UNSIGNED_BYTE && (he = Ie === kn ? n.SRGB8_ALPHA8 : n.RGBA8),
        q === n.UNSIGNED_SHORT_4_4_4_4 && (he = n.RGBA4),
        q === n.UNSIGNED_SHORT_5_5_5_1 && (he = n.RGB5_A1);
    }
    return (
      (he === n.R16F ||
        he === n.R32F ||
        he === n.RG16F ||
        he === n.RG32F ||
        he === n.RGBA16F ||
        he === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      he
    );
  }
  function S(X, z) {
    return y(X) === !0 ||
      (X.isFramebufferTexture && X.minFilter !== Dr && X.minFilter !== dr)
      ? Math.log2(Math.max(z.width, z.height)) + 1
      : X.mipmaps !== void 0 && X.mipmaps.length > 0
      ? X.mipmaps.length
      : X.isCompressedTexture && Array.isArray(X.image)
      ? z.mipmaps.length
      : 1;
  }
  function w(X) {
    const z = X.target;
    z.removeEventListener("dispose", w), E(z), z.isVideoTexture && u.delete(z);
  }
  function T(X) {
    const z = X.target;
    z.removeEventListener("dispose", T), N(z);
  }
  function E(X) {
    const z = r.get(X);
    if (z.__webglInit === void 0) return;
    const q = X.source,
      ue = h.get(q);
    if (ue) {
      const de = ue[z.__cacheKey];
      de.usedTimes--,
        de.usedTimes === 0 && M(X),
        Object.keys(ue).length === 0 && h.delete(q);
    }
    r.remove(X);
  }
  function M(X) {
    const z = r.get(X);
    n.deleteTexture(z.__webglTexture);
    const q = X.source,
      ue = h.get(q);
    delete ue[z.__cacheKey], o.memory.textures--;
  }
  function N(X) {
    const z = r.get(X);
    if ((X.depthTexture && X.depthTexture.dispose(), X.isWebGLCubeRenderTarget))
      for (let ue = 0; ue < 6; ue++) {
        if (Array.isArray(z.__webglFramebuffer[ue]))
          for (let de = 0; de < z.__webglFramebuffer[ue].length; de++)
            n.deleteFramebuffer(z.__webglFramebuffer[ue][de]);
        else n.deleteFramebuffer(z.__webglFramebuffer[ue]);
        z.__webglDepthbuffer && n.deleteRenderbuffer(z.__webglDepthbuffer[ue]);
      }
    else {
      if (Array.isArray(z.__webglFramebuffer))
        for (let ue = 0; ue < z.__webglFramebuffer.length; ue++)
          n.deleteFramebuffer(z.__webglFramebuffer[ue]);
      else n.deleteFramebuffer(z.__webglFramebuffer);
      if (
        (z.__webglDepthbuffer && n.deleteRenderbuffer(z.__webglDepthbuffer),
        z.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(z.__webglMultisampledFramebuffer),
        z.__webglColorRenderbuffer)
      )
        for (let ue = 0; ue < z.__webglColorRenderbuffer.length; ue++)
          z.__webglColorRenderbuffer[ue] &&
            n.deleteRenderbuffer(z.__webglColorRenderbuffer[ue]);
      z.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(z.__webglDepthRenderbuffer);
    }
    const q = X.textures;
    for (let ue = 0, de = q.length; ue < de; ue++) {
      const he = r.get(q[ue]);
      he.__webglTexture &&
        (n.deleteTexture(he.__webglTexture), o.memory.textures--),
        r.remove(q[ue]);
    }
    r.remove(X);
  }
  let R = 0;
  function C() {
    R = 0;
  }
  function L() {
    const X = R;
    return (
      X >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            X +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (R += 1),
      X
    );
  }
  function O(X) {
    const z = [];
    return (
      z.push(X.wrapS),
      z.push(X.wrapT),
      z.push(X.wrapR || 0),
      z.push(X.magFilter),
      z.push(X.minFilter),
      z.push(X.anisotropy),
      z.push(X.internalFormat),
      z.push(X.format),
      z.push(X.type),
      z.push(X.generateMipmaps),
      z.push(X.premultiplyAlpha),
      z.push(X.flipY),
      z.push(X.unpackAlignment),
      z.push(X.colorSpace),
      z.join()
    );
  }
  function D(X, z) {
    const q = r.get(X);
    if (
      (X.isVideoTexture && Se(X),
      X.isRenderTargetTexture === !1 &&
        X.version > 0 &&
        q.__version !== X.version)
    ) {
      const ue = X.image;
      if (ue === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ue.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        W(q, X, z);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, q.__webglTexture, n.TEXTURE0 + z);
  }
  function B(X, z) {
    const q = r.get(X);
    if (X.version > 0 && q.__version !== X.version) {
      W(q, X, z);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, q.__webglTexture, n.TEXTURE0 + z);
  }
  function $(X, z) {
    const q = r.get(X);
    if (X.version > 0 && q.__version !== X.version) {
      W(q, X, z);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, q.__webglTexture, n.TEXTURE0 + z);
  }
  function G(X, z) {
    const q = r.get(X);
    if (X.version > 0 && q.__version !== X.version) {
      ee(q, X, z);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, q.__webglTexture, n.TEXTURE0 + z);
  }
  const j = { [wg]: n.REPEAT, [Oo]: n.CLAMP_TO_EDGE, [bg]: n.MIRRORED_REPEAT },
    U = {
      [Dr]: n.NEAREST,
      [jC]: n.NEAREST_MIPMAP_NEAREST,
      [Jf]: n.NEAREST_MIPMAP_LINEAR,
      [dr]: n.LINEAR,
      [Wm]: n.LINEAR_MIPMAP_NEAREST,
      [ca]: n.LINEAR_MIPMAP_LINEAR,
    },
    H = {
      [tk]: n.NEVER,
      [ok]: n.ALWAYS,
      [r2]: n.LESS,
      [i2]: n.LEQUAL,
      [nk]: n.EQUAL,
      [sk]: n.GEQUAL,
      [rk]: n.GREATER,
      [ik]: n.NOTEQUAL,
    };
  function V(X, z) {
    if (
      (z.type === Qs &&
        e.has("OES_texture_float_linear") === !1 &&
        (z.magFilter === dr ||
          z.magFilter === Wm ||
          z.magFilter === Jf ||
          z.magFilter === ca ||
          z.minFilter === dr ||
          z.minFilter === Wm ||
          z.minFilter === Jf ||
          z.minFilter === ca) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(X, n.TEXTURE_WRAP_S, j[z.wrapS]),
      n.texParameteri(X, n.TEXTURE_WRAP_T, j[z.wrapT]),
      (X === n.TEXTURE_3D || X === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(X, n.TEXTURE_WRAP_R, j[z.wrapR]),
      n.texParameteri(X, n.TEXTURE_MAG_FILTER, U[z.magFilter]),
      n.texParameteri(X, n.TEXTURE_MIN_FILTER, U[z.minFilter]),
      z.compareFunction &&
        (n.texParameteri(X, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(X, n.TEXTURE_COMPARE_FUNC, H[z.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        z.magFilter === Dr ||
        (z.minFilter !== Jf && z.minFilter !== ca) ||
        (z.type === Qs && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (z.anisotropy > 1 || r.get(z).__currentAnisotropy) {
        const q = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          X,
          q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(z.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(z).__currentAnisotropy = z.anisotropy);
      }
    }
  }
  function k(X, z) {
    let q = !1;
    X.__webglInit === void 0 &&
      ((X.__webglInit = !0), z.addEventListener("dispose", w));
    const ue = z.source;
    let de = h.get(ue);
    de === void 0 && ((de = {}), h.set(ue, de));
    const he = O(z);
    if (he !== X.__cacheKey) {
      de[he] === void 0 &&
        ((de[he] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (q = !0)),
        de[he].usedTimes++;
      const Ie = de[X.__cacheKey];
      Ie !== void 0 &&
        (de[X.__cacheKey].usedTimes--, Ie.usedTimes === 0 && M(z)),
        (X.__cacheKey = he),
        (X.__webglTexture = de[he].texture);
    }
    return q;
  }
  function W(X, z, q) {
    let ue = n.TEXTURE_2D;
    (z.isDataArrayTexture || z.isCompressedArrayTexture) &&
      (ue = n.TEXTURE_2D_ARRAY),
      z.isData3DTexture && (ue = n.TEXTURE_3D);
    const de = k(X, z),
      he = z.source;
    t.bindTexture(ue, X.__webglTexture, n.TEXTURE0 + q);
    const Ie = r.get(he);
    if (he.version !== Ie.__version || de === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const ke = bn.getPrimaries(bn.workingColorSpace),
        Me = z.colorSpace === Al ? null : bn.getPrimaries(z.colorSpace),
        et =
          z.colorSpace === Al || ke === Me ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, z.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, z.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, et);
      let Ne = x(z.image, !1, i.maxTextureSize);
      Ne = Ue(z, Ne);
      const We = s.convert(z.format, z.colorSpace),
        ot = s.convert(z.type);
      let nt = _(z.internalFormat, We, ot, z.colorSpace, z.isVideoTexture);
      V(ue, z);
      let Ke;
      const it = z.mipmaps,
        re = z.isVideoTexture !== !0,
        ze = Ie.__version === void 0 || de === !0,
        Xe = he.dataReady,
        le = S(z, Ne);
      if (z.isDepthTexture)
        (nt = n.DEPTH_COMPONENT16),
          z.type === Qs
            ? (nt = n.DEPTH_COMPONENT32F)
            : z.type === xd
            ? (nt = n.DEPTH_COMPONENT24)
            : z.type === ip && (nt = n.DEPTH24_STENCIL8),
          ze &&
            (re
              ? t.texStorage2D(n.TEXTURE_2D, 1, nt, Ne.width, Ne.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  nt,
                  Ne.width,
                  Ne.height,
                  0,
                  We,
                  ot,
                  null
                ));
      else if (z.isDataTexture)
        if (it.length > 0) {
          re &&
            ze &&
            t.texStorage2D(n.TEXTURE_2D, le, nt, it[0].width, it[0].height);
          for (let Re = 0, xe = it.length; Re < xe; Re++)
            (Ke = it[Re]),
              re
                ? Xe &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    We,
                    ot,
                    Ke.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    nt,
                    Ke.width,
                    Ke.height,
                    0,
                    We,
                    ot,
                    Ke.data
                  );
          z.generateMipmaps = !1;
        } else
          re
            ? (ze && t.texStorage2D(n.TEXTURE_2D, le, nt, Ne.width, Ne.height),
              Xe &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Ne.width,
                  Ne.height,
                  We,
                  ot,
                  Ne.data
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                nt,
                Ne.width,
                Ne.height,
                0,
                We,
                ot,
                Ne.data
              );
      else if (z.isCompressedTexture)
        if (z.isCompressedArrayTexture) {
          re &&
            ze &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              le,
              nt,
              it[0].width,
              it[0].height,
              Ne.depth
            );
          for (let Re = 0, xe = it.length; Re < xe; Re++)
            (Ke = it[Re]),
              z.format !== ys
                ? We !== null
                  ? re
                    ? Xe &&
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Re,
                        0,
                        0,
                        0,
                        Ke.width,
                        Ke.height,
                        Ne.depth,
                        We,
                        Ke.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Re,
                        nt,
                        Ke.width,
                        Ke.height,
                        Ne.depth,
                        0,
                        Ke.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : re
                ? Xe &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    0,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    Ne.depth,
                    We,
                    ot,
                    Ke.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Re,
                    nt,
                    Ke.width,
                    Ke.height,
                    Ne.depth,
                    0,
                    We,
                    ot,
                    Ke.data
                  );
        } else {
          re &&
            ze &&
            t.texStorage2D(n.TEXTURE_2D, le, nt, it[0].width, it[0].height);
          for (let Re = 0, xe = it.length; Re < xe; Re++)
            (Ke = it[Re]),
              z.format !== ys
                ? We !== null
                  ? re
                    ? Xe &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Re,
                        0,
                        0,
                        Ke.width,
                        Ke.height,
                        We,
                        Ke.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Re,
                        nt,
                        Ke.width,
                        Ke.height,
                        0,
                        Ke.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : re
                ? Xe &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Re,
                    0,
                    0,
                    Ke.width,
                    Ke.height,
                    We,
                    ot,
                    Ke.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Re,
                    nt,
                    Ke.width,
                    Ke.height,
                    0,
                    We,
                    ot,
                    Ke.data
                  );
        }
      else if (z.isDataArrayTexture)
        re
          ? (ze &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                le,
                nt,
                Ne.width,
                Ne.height,
                Ne.depth
              ),
            Xe &&
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ne.width,
                Ne.height,
                Ne.depth,
                We,
                ot,
                Ne.data
              ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              nt,
              Ne.width,
              Ne.height,
              Ne.depth,
              0,
              We,
              ot,
              Ne.data
            );
      else if (z.isData3DTexture)
        re
          ? (ze &&
              t.texStorage3D(
                n.TEXTURE_3D,
                le,
                nt,
                Ne.width,
                Ne.height,
                Ne.depth
              ),
            Xe &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ne.width,
                Ne.height,
                Ne.depth,
                We,
                ot,
                Ne.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              nt,
              Ne.width,
              Ne.height,
              Ne.depth,
              0,
              We,
              ot,
              Ne.data
            );
      else if (z.isFramebufferTexture) {
        if (ze)
          if (re) t.texStorage2D(n.TEXTURE_2D, le, nt, Ne.width, Ne.height);
          else {
            let Re = Ne.width,
              xe = Ne.height;
            for (let Ye = 0; Ye < le; Ye++)
              t.texImage2D(n.TEXTURE_2D, Ye, nt, Re, xe, 0, We, ot, null),
                (Re >>= 1),
                (xe >>= 1);
          }
      } else if (it.length > 0) {
        if (re && ze) {
          const Re = Ce(it[0]);
          t.texStorage2D(n.TEXTURE_2D, le, nt, Re.width, Re.height);
        }
        for (let Re = 0, xe = it.length; Re < xe; Re++)
          (Ke = it[Re]),
            re
              ? Xe && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, We, ot, Ke)
              : t.texImage2D(n.TEXTURE_2D, Re, nt, We, ot, Ke);
        z.generateMipmaps = !1;
      } else if (re) {
        if (ze) {
          const Re = Ce(Ne);
          t.texStorage2D(n.TEXTURE_2D, le, nt, Re.width, Re.height);
        }
        Xe && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, We, ot, Ne);
      } else t.texImage2D(n.TEXTURE_2D, 0, nt, We, ot, Ne);
      y(z) && v(ue), (Ie.__version = he.version), z.onUpdate && z.onUpdate(z);
    }
    X.__version = z.version;
  }
  function ee(X, z, q) {
    if (z.image.length !== 6) return;
    const ue = k(X, z),
      de = z.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, X.__webglTexture, n.TEXTURE0 + q);
    const he = r.get(de);
    if (de.version !== he.__version || ue === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const Ie = bn.getPrimaries(bn.workingColorSpace),
        ke = z.colorSpace === Al ? null : bn.getPrimaries(z.colorSpace),
        Me =
          z.colorSpace === Al || Ie === ke ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, z.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, z.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Me);
      const et = z.isCompressedTexture || z.image[0].isCompressedTexture,
        Ne = z.image[0] && z.image[0].isDataTexture,
        We = [];
      for (let xe = 0; xe < 6; xe++)
        !et && !Ne
          ? (We[xe] = x(z.image[xe], !0, i.maxCubemapSize))
          : (We[xe] = Ne ? z.image[xe].image : z.image[xe]),
          (We[xe] = Ue(z, We[xe]));
      const ot = We[0],
        nt = s.convert(z.format, z.colorSpace),
        Ke = s.convert(z.type),
        it = _(z.internalFormat, nt, Ke, z.colorSpace),
        re = z.isVideoTexture !== !0,
        ze = he.__version === void 0 || ue === !0,
        Xe = de.dataReady;
      let le = S(z, ot);
      V(n.TEXTURE_CUBE_MAP, z);
      let Re;
      if (et) {
        re &&
          ze &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, le, it, ot.width, ot.height);
        for (let xe = 0; xe < 6; xe++) {
          Re = We[xe].mipmaps;
          for (let Ye = 0; Ye < Re.length; Ye++) {
            const at = Re[Ye];
            z.format !== ys
              ? nt !== null
                ? re
                  ? Xe &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                      Ye,
                      0,
                      0,
                      at.width,
                      at.height,
                      nt,
                      at.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                      Ye,
                      it,
                      at.width,
                      at.height,
                      0,
                      at.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : re
              ? Xe &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  Ye,
                  0,
                  0,
                  at.width,
                  at.height,
                  nt,
                  Ke,
                  at.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  Ye,
                  it,
                  at.width,
                  at.height,
                  0,
                  nt,
                  Ke,
                  at.data
                );
          }
        }
      } else {
        if (((Re = z.mipmaps), re && ze)) {
          Re.length > 0 && le++;
          const xe = Ce(We[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, le, it, xe.width, xe.height);
        }
        for (let xe = 0; xe < 6; xe++)
          if (Ne) {
            re
              ? Xe &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  0,
                  0,
                  0,
                  We[xe].width,
                  We[xe].height,
                  nt,
                  Ke,
                  We[xe].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  0,
                  it,
                  We[xe].width,
                  We[xe].height,
                  0,
                  nt,
                  Ke,
                  We[xe].data
                );
            for (let Ye = 0; Ye < Re.length; Ye++) {
              const vt = Re[Ye].image[xe].image;
              re
                ? Xe &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                    Ye + 1,
                    0,
                    0,
                    vt.width,
                    vt.height,
                    nt,
                    Ke,
                    vt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                    Ye + 1,
                    it,
                    vt.width,
                    vt.height,
                    0,
                    nt,
                    Ke,
                    vt.data
                  );
            }
          } else {
            re
              ? Xe &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  0,
                  0,
                  0,
                  nt,
                  Ke,
                  We[xe]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                  0,
                  it,
                  nt,
                  Ke,
                  We[xe]
                );
            for (let Ye = 0; Ye < Re.length; Ye++) {
              const at = Re[Ye];
              re
                ? Xe &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                    Ye + 1,
                    0,
                    0,
                    nt,
                    Ke,
                    at.image[xe]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + xe,
                    Ye + 1,
                    it,
                    nt,
                    Ke,
                    at.image[xe]
                  );
            }
          }
      }
      y(z) && v(n.TEXTURE_CUBE_MAP),
        (he.__version = de.version),
        z.onUpdate && z.onUpdate(z);
    }
    X.__version = z.version;
  }
  function Y(X, z, q, ue, de, he) {
    const Ie = s.convert(q.format, q.colorSpace),
      ke = s.convert(q.type),
      Me = _(q.internalFormat, Ie, ke, q.colorSpace);
    if (!r.get(z).__hasExternalTextures) {
      const Ne = Math.max(1, z.width >> he),
        We = Math.max(1, z.height >> he);
      de === n.TEXTURE_3D || de === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(de, he, Me, Ne, We, z.depth, 0, Ie, ke, null)
        : t.texImage2D(de, he, Me, Ne, We, 0, Ie, ke, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, X),
      Ee(z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            ue,
            de,
            r.get(q).__webglTexture,
            0,
            fe(z)
          )
        : (de === n.TEXTURE_2D ||
            (de >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              de <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            ue,
            de,
            r.get(q).__webglTexture,
            he
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function K(X, z, q) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, X), z.depthBuffer && !z.stencilBuffer)
    ) {
      let ue = n.DEPTH_COMPONENT24;
      if (q || Ee(z)) {
        const de = z.depthTexture;
        de &&
          de.isDepthTexture &&
          (de.type === Qs
            ? (ue = n.DEPTH_COMPONENT32F)
            : de.type === xd && (ue = n.DEPTH_COMPONENT24));
        const he = fe(z);
        Ee(z)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              he,
              ue,
              z.width,
              z.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              he,
              ue,
              z.width,
              z.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, ue, z.width, z.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        X
      );
    } else if (z.depthBuffer && z.stencilBuffer) {
      const ue = fe(z);
      q && Ee(z) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            ue,
            n.DEPTH24_STENCIL8,
            z.width,
            z.height
          )
        : Ee(z)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            ue,
            n.DEPTH24_STENCIL8,
            z.width,
            z.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            z.width,
            z.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          X
        );
    } else {
      const ue = z.textures;
      for (let de = 0; de < ue.length; de++) {
        const he = ue[de],
          Ie = s.convert(he.format, he.colorSpace),
          ke = s.convert(he.type),
          Me = _(he.internalFormat, Ie, ke, he.colorSpace),
          et = fe(z);
        q && Ee(z) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              et,
              Me,
              z.width,
              z.height
            )
          : Ee(z)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              et,
              Me,
              z.width,
              z.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, Me, z.width, z.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function ae(X, z) {
    if (z && z.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, X),
      !(z.depthTexture && z.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!r.get(z.depthTexture).__webglTexture ||
      z.depthTexture.image.width !== z.width ||
      z.depthTexture.image.height !== z.height) &&
      ((z.depthTexture.image.width = z.width),
      (z.depthTexture.image.height = z.height),
      (z.depthTexture.needsUpdate = !0)),
      D(z.depthTexture, 0);
    const ue = r.get(z.depthTexture).__webglTexture,
      de = fe(z);
    if (z.depthTexture.format === sd)
      Ee(z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ue,
            0,
            de
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            ue,
            0
          );
    else if (z.depthTexture.format === Oh)
      Ee(z)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ue,
            0,
            de
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            ue,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function se(X) {
    const z = r.get(X),
      q = X.isWebGLCubeRenderTarget === !0;
    if (X.depthTexture && !z.__autoAllocateDepthBuffer) {
      if (q)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      ae(z.__webglFramebuffer, X);
    } else if (q) {
      z.__webglDepthbuffer = [];
      for (let ue = 0; ue < 6; ue++)
        t.bindFramebuffer(n.FRAMEBUFFER, z.__webglFramebuffer[ue]),
          (z.__webglDepthbuffer[ue] = n.createRenderbuffer()),
          K(z.__webglDepthbuffer[ue], X, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, z.__webglFramebuffer),
        (z.__webglDepthbuffer = n.createRenderbuffer()),
        K(z.__webglDepthbuffer, X, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function we(X, z, q) {
    const ue = r.get(X);
    z !== void 0 &&
      Y(
        ue.__webglFramebuffer,
        X,
        X.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      q !== void 0 && se(X);
  }
  function Be(X) {
    const z = X.texture,
      q = r.get(X),
      ue = r.get(z);
    X.addEventListener("dispose", T);
    const de = X.textures,
      he = X.isWebGLCubeRenderTarget === !0,
      Ie = de.length > 1;
    if (
      (Ie ||
        (ue.__webglTexture === void 0 &&
          (ue.__webglTexture = n.createTexture()),
        (ue.__version = z.version),
        o.memory.textures++),
      he)
    ) {
      q.__webglFramebuffer = [];
      for (let ke = 0; ke < 6; ke++)
        if (z.mipmaps && z.mipmaps.length > 0) {
          q.__webglFramebuffer[ke] = [];
          for (let Me = 0; Me < z.mipmaps.length; Me++)
            q.__webglFramebuffer[ke][Me] = n.createFramebuffer();
        } else q.__webglFramebuffer[ke] = n.createFramebuffer();
    } else {
      if (z.mipmaps && z.mipmaps.length > 0) {
        q.__webglFramebuffer = [];
        for (let ke = 0; ke < z.mipmaps.length; ke++)
          q.__webglFramebuffer[ke] = n.createFramebuffer();
      } else q.__webglFramebuffer = n.createFramebuffer();
      if (Ie)
        for (let ke = 0, Me = de.length; ke < Me; ke++) {
          const et = r.get(de[ke]);
          et.__webglTexture === void 0 &&
            ((et.__webglTexture = n.createTexture()), o.memory.textures++);
        }
      if (X.samples > 0 && Ee(X) === !1) {
        (q.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
        for (let ke = 0; ke < de.length; ke++) {
          const Me = de[ke];
          (q.__webglColorRenderbuffer[ke] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, q.__webglColorRenderbuffer[ke]);
          const et = s.convert(Me.format, Me.colorSpace),
            Ne = s.convert(Me.type),
            We = _(
              Me.internalFormat,
              et,
              Ne,
              Me.colorSpace,
              X.isXRRenderTarget === !0
            ),
            ot = fe(X);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            ot,
            We,
            X.width,
            X.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + ke,
              n.RENDERBUFFER,
              q.__webglColorRenderbuffer[ke]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          X.depthBuffer &&
            ((q.__webglDepthRenderbuffer = n.createRenderbuffer()),
            K(q.__webglDepthRenderbuffer, X, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (he) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, ue.__webglTexture),
        V(n.TEXTURE_CUBE_MAP, z);
      for (let ke = 0; ke < 6; ke++)
        if (z.mipmaps && z.mipmaps.length > 0)
          for (let Me = 0; Me < z.mipmaps.length; Me++)
            Y(
              q.__webglFramebuffer[ke][Me],
              X,
              z,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + ke,
              Me
            );
        else
          Y(
            q.__webglFramebuffer[ke],
            X,
            z,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + ke,
            0
          );
      y(z) && v(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Ie) {
      for (let ke = 0, Me = de.length; ke < Me; ke++) {
        const et = de[ke],
          Ne = r.get(et);
        t.bindTexture(n.TEXTURE_2D, Ne.__webglTexture),
          V(n.TEXTURE_2D, et),
          Y(
            q.__webglFramebuffer,
            X,
            et,
            n.COLOR_ATTACHMENT0 + ke,
            n.TEXTURE_2D,
            0
          ),
          y(et) && v(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ke = n.TEXTURE_2D;
      if (
        ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) &&
          (ke = X.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(ke, ue.__webglTexture),
        V(ke, z),
        z.mipmaps && z.mipmaps.length > 0)
      )
        for (let Me = 0; Me < z.mipmaps.length; Me++)
          Y(q.__webglFramebuffer[Me], X, z, n.COLOR_ATTACHMENT0, ke, Me);
      else Y(q.__webglFramebuffer, X, z, n.COLOR_ATTACHMENT0, ke, 0);
      y(z) && v(ke), t.unbindTexture();
    }
    X.depthBuffer && se(X);
  }
  function te(X) {
    const z = X.textures;
    for (let q = 0, ue = z.length; q < ue; q++) {
      const de = z[q];
      if (y(de)) {
        const he = X.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          Ie = r.get(de).__webglTexture;
        t.bindTexture(he, Ie), v(he), t.unbindTexture();
      }
    }
  }
  const ge = [],
    ie = [];
  function me(X) {
    if (X.samples > 0) {
      if (Ee(X) === !1) {
        const z = X.textures,
          q = X.width,
          ue = X.height;
        let de = n.COLOR_BUFFER_BIT;
        const he = X.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Ie = r.get(X),
          ke = z.length > 1;
        if (ke)
          for (let Me = 0; Me < z.length; Me++)
            t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Me,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Me,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Ie.__webglMultisampledFramebuffer
        ),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ie.__webglFramebuffer);
        for (let Me = 0; Me < z.length; Me++) {
          if (
            (X.resolveDepthBuffer &&
              (X.depthBuffer && (de |= n.DEPTH_BUFFER_BIT),
              X.stencilBuffer &&
                X.resolveStencilBuffer &&
                (de |= n.STENCIL_BUFFER_BIT)),
            ke)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Ie.__webglColorRenderbuffer[Me]
            );
            const et = r.get(z[Me]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              et,
              0
            );
          }
          n.blitFramebuffer(0, 0, q, ue, 0, 0, q, ue, de, n.NEAREST),
            l === !0 &&
              ((ge.length = 0),
              (ie.length = 0),
              ge.push(n.COLOR_ATTACHMENT0 + Me),
              X.depthBuffer &&
                X.resolveDepthBuffer === !1 &&
                (ge.push(he),
                ie.push(he),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, ie)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, ge));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          ke)
        )
          for (let Me = 0; Me < z.length; Me++) {
            t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Me,
                n.RENDERBUFFER,
                Ie.__webglColorRenderbuffer[Me]
              );
            const et = r.get(z[Me]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, Ie.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + Me,
                n.TEXTURE_2D,
                et,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          Ie.__webglMultisampledFramebuffer
        );
      } else if (X.depthBuffer && X.resolveDepthBuffer === !1 && l) {
        const z = X.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [z]);
      }
    }
  }
  function fe(X) {
    return Math.min(i.maxSamples, X.samples);
  }
  function Ee(X) {
    const z = r.get(X);
    return (
      X.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      z.__useRenderToTexture !== !1
    );
  }
  function Se(X) {
    const z = o.render.frame;
    u.get(X) !== z && (u.set(X, z), X.update());
  }
  function Ue(X, z) {
    const q = X.colorSpace,
      ue = X.format,
      de = X.type;
    return (
      X.isCompressedTexture === !0 ||
        X.isVideoTexture === !0 ||
        (q !== Ho &&
          q !== Al &&
          (bn.getTransfer(q) === kn
            ? (ue !== ys || de !== $a) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                q
              ))),
      z
    );
  }
  function Ce(X) {
    return (
      typeof HTMLImageElement < "u" && X instanceof HTMLImageElement
        ? ((c.width = X.naturalWidth || X.width),
          (c.height = X.naturalHeight || X.height))
        : typeof VideoFrame < "u" && X instanceof VideoFrame
        ? ((c.width = X.displayWidth), (c.height = X.displayHeight))
        : ((c.width = X.width), (c.height = X.height)),
      c
    );
  }
  (this.allocateTextureUnit = L),
    (this.resetTextureUnits = C),
    (this.setTexture2D = D),
    (this.setTexture2DArray = B),
    (this.setTexture3D = $),
    (this.setTextureCube = G),
    (this.rebindTextures = we),
    (this.setupRenderTarget = Be),
    (this.updateRenderTargetMipmap = te),
    (this.updateMultisampleRenderTarget = me),
    (this.setupDepthRenderbuffer = se),
    (this.setupFrameBufferTexture = Y),
    (this.useMultisampledRTT = Ee);
}
function wk(n, e) {
  function t(r, i = Al) {
    let s;
    const o = bn.getTransfer(i);
    if (r === $a) return n.UNSIGNED_BYTE;
    if (r === YC) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === qC) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === W4) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === H4) return n.BYTE;
    if (r === G4) return n.SHORT;
    if (r === $C) return n.UNSIGNED_SHORT;
    if (r === XC) return n.INT;
    if (r === xd) return n.UNSIGNED_INT;
    if (r === Qs) return n.FLOAT;
    if (r === rp) return n.HALF_FLOAT;
    if (r === j4) return n.ALPHA;
    if (r === $4) return n.RGB;
    if (r === ys) return n.RGBA;
    if (r === X4) return n.LUMINANCE;
    if (r === Y4) return n.LUMINANCE_ALPHA;
    if (r === sd) return n.DEPTH_COMPONENT;
    if (r === Oh) return n.DEPTH_STENCIL;
    if (r === KC) return n.RED;
    if (r === ZC) return n.RED_INTEGER;
    if (r === q4) return n.RG;
    if (r === QC) return n.RG_INTEGER;
    if (r === JC) return n.RGBA_INTEGER;
    if (r === mx || r === gx || r === vx || r === yx)
      if (o === kn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (r === mx) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === gx) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === vx) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === yx) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (r === mx) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === gx) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === vx) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === yx) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === VE || r === HE || r === GE || r === WE)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (r === VE) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === HE) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === GE) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === WE) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === jE || r === $E || r === XE)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (r === jE || r === $E)
          return o === kn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (r === XE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === YE ||
      r === qE ||
      r === KE ||
      r === ZE ||
      r === QE ||
      r === JE ||
      r === eM ||
      r === tM ||
      r === nM ||
      r === rM ||
      r === iM ||
      r === sM ||
      r === oM ||
      r === aM
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (r === YE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === qE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === KE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === ZE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === QE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === JE)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === eM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === tM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === nM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === rM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === iM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === sM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === oM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === aM)
          return o === kn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === xx || r === lM || r === cM)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (r === xx)
          return o === kn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === lM) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === cM) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === K4 || r === uM || r === dM || r === fM)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (r === xx) return s.COMPRESSED_RED_RGTC1_EXT;
        if (r === uM) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === dM) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === fM) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === ip ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class bk extends Yn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
let nh = class extends xn {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
};
const Hq = { type: "move" };
class _w {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new nh()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new nh()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Q()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Q())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new nh()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Q()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Q())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const x of e.hand.values()) {
          const y = t.getJointPose(x, r),
            v = this._getHandJoint(c, x);
          y !== null &&
            (v.matrix.fromArray(y.transform.matrix),
            v.matrix.decompose(v.position, v.rotation, v.scale),
            (v.matrixWorldNeedsUpdate = !0),
            (v.jointRadius = y.radius)),
            (v.visible = y !== null);
        }
        const u = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          h = u.position.distanceTo(d.position),
          m = 0.02,
          g = 0.005;
        c.inputState.pinching && h > m + g
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            h <= m - g &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, r)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && s !== null && (i = s),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(Hq)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new nh();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
const Gq = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  Wq = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class jq {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t, r) {
    if (this.texture === null) {
      const i = new Fr(),
        s = e.properties.get(i);
      (s.__webglTexture = t.texture),
        (t.depthNear != r.depthNear || t.depthFar != r.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = i);
    }
  }
  render(e, t) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const r = t.cameras[0].viewport,
          i = new Bo({
            vertexShader: Gq,
            fragmentShader: Wq,
            uniforms: {
              depthColor: { value: this.texture },
              depthWidth: { value: r.z },
              depthHeight: { value: r.w },
            },
          });
        this.mesh = new qn(new Gl(20, 20), i);
      }
      e.render(this.mesh, t);
    }
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
}
class $q extends Go {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      d = null,
      h = null,
      m = null,
      g = null;
    const x = new jq(),
      y = t.getContextAttributes();
    let v = null,
      _ = null;
    const S = [],
      w = [],
      T = new He();
    let E = null;
    const M = new Yn();
    M.layers.enable(1), (M.viewport = new rn());
    const N = new Yn();
    N.layers.enable(2), (N.viewport = new rn());
    const R = [M, N],
      C = new bk();
    C.layers.enable(1), C.layers.enable(2);
    let L = null,
      O = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Y) {
        let K = S[Y];
        return (
          K === void 0 && ((K = new _w()), (S[Y] = K)), K.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (Y) {
        let K = S[Y];
        return K === void 0 && ((K = new _w()), (S[Y] = K)), K.getGripSpace();
      }),
      (this.getHand = function (Y) {
        let K = S[Y];
        return K === void 0 && ((K = new _w()), (S[Y] = K)), K.getHandSpace();
      });
    function D(Y) {
      const K = w.indexOf(Y.inputSource);
      if (K === -1) return;
      const ae = S[K];
      ae !== void 0 &&
        (ae.update(Y.inputSource, Y.frame, c || o),
        ae.dispatchEvent({ type: Y.type, data: Y.inputSource }));
    }
    function B() {
      i.removeEventListener("select", D),
        i.removeEventListener("selectstart", D),
        i.removeEventListener("selectend", D),
        i.removeEventListener("squeeze", D),
        i.removeEventListener("squeezestart", D),
        i.removeEventListener("squeezeend", D),
        i.removeEventListener("end", B),
        i.removeEventListener("inputsourceschange", $);
      for (let Y = 0; Y < S.length; Y++) {
        const K = w[Y];
        K !== null && ((w[Y] = null), S[Y].disconnect(K));
      }
      (L = null),
        (O = null),
        x.reset(),
        e.setRenderTarget(v),
        (m = null),
        (h = null),
        (d = null),
        (i = null),
        (_ = null),
        ee.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(E),
        e.setSize(T.width, T.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (Y) {
      (s = Y),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (Y) {
        (a = Y),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (Y) {
        c = Y;
      }),
      (this.getBaseLayer = function () {
        return h !== null ? h : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return g;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (Y) {
        if (((i = Y), i !== null)) {
          if (
            ((v = e.getRenderTarget()),
            i.addEventListener("select", D),
            i.addEventListener("selectstart", D),
            i.addEventListener("selectend", D),
            i.addEventListener("squeeze", D),
            i.addEventListener("squeezestart", D),
            i.addEventListener("squeezeend", D),
            i.addEventListener("end", B),
            i.addEventListener("inputsourceschange", $),
            y.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (E = e.getPixelRatio()),
            e.getSize(T),
            i.renderState.layers === void 0)
          ) {
            const K = {
              antialias: y.antialias,
              alpha: !0,
              depth: y.depth,
              stencil: y.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(i, t, K)),
              i.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (_ = new va(m.framebufferWidth, m.framebufferHeight, {
                format: ys,
                type: $a,
                colorSpace: e.outputColorSpace,
                stencilBuffer: y.stencil,
              }));
          } else {
            let K = null,
              ae = null,
              se = null;
            y.depth &&
              ((se = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (K = y.stencil ? Oh : sd),
              (ae = y.stencil ? ip : xd));
            const we = {
              colorFormat: t.RGBA8,
              depthFormat: se,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(i, t)),
              (h = d.createProjectionLayer(we)),
              i.updateRenderState({ layers: [h] }),
              e.setPixelRatio(1),
              e.setSize(h.textureWidth, h.textureHeight, !1),
              (_ = new va(h.textureWidth, h.textureHeight, {
                format: ys,
                type: $a,
                depthTexture: new sp(
                  h.textureWidth,
                  h.textureHeight,
                  ae,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  K
                ),
                stencilBuffer: y.stencil,
                colorSpace: e.outputColorSpace,
                samples: y.antialias ? 4 : 0,
                resolveDepthBuffer: h.ignoreDepthValues === !1,
              }));
          }
          (_.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await i.requestReferenceSpace(a)),
            ee.setContext(i),
            ee.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function $(Y) {
      for (let K = 0; K < Y.removed.length; K++) {
        const ae = Y.removed[K],
          se = w.indexOf(ae);
        se >= 0 && ((w[se] = null), S[se].disconnect(ae));
      }
      for (let K = 0; K < Y.added.length; K++) {
        const ae = Y.added[K];
        let se = w.indexOf(ae);
        if (se === -1) {
          for (let Be = 0; Be < S.length; Be++)
            if (Be >= w.length) {
              w.push(ae), (se = Be);
              break;
            } else if (w[Be] === null) {
              (w[Be] = ae), (se = Be);
              break;
            }
          if (se === -1) break;
        }
        const we = S[se];
        we && we.connect(ae);
      }
    }
    const G = new Q(),
      j = new Q();
    function U(Y, K, ae) {
      G.setFromMatrixPosition(K.matrixWorld),
        j.setFromMatrixPosition(ae.matrixWorld);
      const se = G.distanceTo(j),
        we = K.projectionMatrix.elements,
        Be = ae.projectionMatrix.elements,
        te = we[14] / (we[10] - 1),
        ge = we[14] / (we[10] + 1),
        ie = (we[9] + 1) / we[5],
        me = (we[9] - 1) / we[5],
        fe = (we[8] - 1) / we[0],
        Ee = (Be[8] + 1) / Be[0],
        Se = te * fe,
        Ue = te * Ee,
        Ce = se / (-fe + Ee),
        X = Ce * -fe;
      K.matrixWorld.decompose(Y.position, Y.quaternion, Y.scale),
        Y.translateX(X),
        Y.translateZ(Ce),
        Y.matrixWorld.compose(Y.position, Y.quaternion, Y.scale),
        Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
      const z = te + Ce,
        q = ge + Ce,
        ue = Se - X,
        de = Ue + (se - X),
        he = ((ie * ge) / q) * z,
        Ie = ((me * ge) / q) * z;
      Y.projectionMatrix.makePerspective(ue, de, he, Ie, z, q),
        Y.projectionMatrixInverse.copy(Y.projectionMatrix).invert();
    }
    function H(Y, K) {
      K === null
        ? Y.matrixWorld.copy(Y.matrix)
        : Y.matrixWorld.multiplyMatrices(K.matrixWorld, Y.matrix),
        Y.matrixWorldInverse.copy(Y.matrixWorld).invert();
    }
    this.updateCamera = function (Y) {
      if (i === null) return;
      x.texture !== null && ((Y.near = x.depthNear), (Y.far = x.depthFar)),
        (C.near = N.near = M.near = Y.near),
        (C.far = N.far = M.far = Y.far),
        (L !== C.near || O !== C.far) &&
          (i.updateRenderState({ depthNear: C.near, depthFar: C.far }),
          (L = C.near),
          (O = C.far),
          (M.near = L),
          (M.far = O),
          (N.near = L),
          (N.far = O),
          M.updateProjectionMatrix(),
          N.updateProjectionMatrix(),
          Y.updateProjectionMatrix());
      const K = Y.parent,
        ae = C.cameras;
      H(C, K);
      for (let se = 0; se < ae.length; se++) H(ae[se], K);
      ae.length === 2
        ? U(C, M, N)
        : C.projectionMatrix.copy(M.projectionMatrix),
        V(Y, C, K);
    };
    function V(Y, K, ae) {
      ae === null
        ? Y.matrix.copy(K.matrixWorld)
        : (Y.matrix.copy(ae.matrixWorld),
          Y.matrix.invert(),
          Y.matrix.multiply(K.matrixWorld)),
        Y.matrix.decompose(Y.position, Y.quaternion, Y.scale),
        Y.updateMatrixWorld(!0),
        Y.projectionMatrix.copy(K.projectionMatrix),
        Y.projectionMatrixInverse.copy(K.projectionMatrixInverse),
        Y.isPerspectiveCamera &&
          ((Y.fov = Fh * 2 * Math.atan(1 / Y.projectionMatrix.elements[5])),
          (Y.zoom = 1));
    }
    (this.getCamera = function () {
      return C;
    }),
      (this.getFoveation = function () {
        if (!(h === null && m === null)) return l;
      }),
      (this.setFoveation = function (Y) {
        (l = Y),
          h !== null && (h.fixedFoveation = Y),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = Y);
      }),
      (this.hasDepthSensing = function () {
        return x.texture !== null;
      });
    let k = null;
    function W(Y, K) {
      if (((u = K.getViewerPose(c || o)), (g = K), u !== null)) {
        const ae = u.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(_, m.framebuffer),
          e.setRenderTarget(_));
        let se = !1;
        ae.length !== C.cameras.length && ((C.cameras.length = 0), (se = !0));
        for (let Be = 0; Be < ae.length; Be++) {
          const te = ae[Be];
          let ge = null;
          if (m !== null) ge = m.getViewport(te);
          else {
            const me = d.getViewSubImage(h, te);
            (ge = me.viewport),
              Be === 0 &&
                (e.setRenderTargetTextures(
                  _,
                  me.colorTexture,
                  h.ignoreDepthValues ? void 0 : me.depthStencilTexture
                ),
                e.setRenderTarget(_));
          }
          let ie = R[Be];
          ie === void 0 &&
            ((ie = new Yn()),
            ie.layers.enable(Be),
            (ie.viewport = new rn()),
            (R[Be] = ie)),
            ie.matrix.fromArray(te.transform.matrix),
            ie.matrix.decompose(ie.position, ie.quaternion, ie.scale),
            ie.projectionMatrix.fromArray(te.projectionMatrix),
            ie.projectionMatrixInverse.copy(ie.projectionMatrix).invert(),
            ie.viewport.set(ge.x, ge.y, ge.width, ge.height),
            Be === 0 &&
              (C.matrix.copy(ie.matrix),
              C.matrix.decompose(C.position, C.quaternion, C.scale)),
            se === !0 && C.cameras.push(ie);
        }
        const we = i.enabledFeatures;
        if (we && we.includes("depth-sensing")) {
          const Be = d.getDepthInformation(ae[0]);
          Be && Be.isValid && Be.texture && x.init(e, Be, i.renderState);
        }
      }
      for (let ae = 0; ae < S.length; ae++) {
        const se = w[ae],
          we = S[ae];
        se !== null && we !== void 0 && we.update(se, K, c || o);
      }
      x.render(e, C),
        k && k(Y, K),
        K.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: K }),
        (g = null);
    }
    const ee = new vk();
    ee.setAnimationLoop(W),
      (this.setAnimationLoop = function (Y) {
        k = Y;
      }),
      (this.dispose = function () {});
  }
}
const Au = new ao(),
  Xq = new Ut();
function Yq(n, e) {
  function t(y, v) {
    y.matrixAutoUpdate === !0 && y.updateMatrix(), v.value.copy(y.matrix);
  }
  function r(y, v) {
    v.color.getRGB(y.fogColor.value, pk(n)),
      v.isFog
        ? ((y.fogNear.value = v.near), (y.fogFar.value = v.far))
        : v.isFogExp2 && (y.fogDensity.value = v.density);
  }
  function i(y, v, _, S, w) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial
      ? s(y, v)
      : v.isMeshToonMaterial
      ? (s(y, v), d(y, v))
      : v.isMeshPhongMaterial
      ? (s(y, v), u(y, v))
      : v.isMeshStandardMaterial
      ? (s(y, v), h(y, v), v.isMeshPhysicalMaterial && m(y, v, w))
      : v.isMeshMatcapMaterial
      ? (s(y, v), g(y, v))
      : v.isMeshDepthMaterial
      ? s(y, v)
      : v.isMeshDistanceMaterial
      ? (s(y, v), x(y, v))
      : v.isMeshNormalMaterial
      ? s(y, v)
      : v.isLineBasicMaterial
      ? (o(y, v), v.isLineDashedMaterial && a(y, v))
      : v.isPointsMaterial
      ? l(y, v, _, S)
      : v.isSpriteMaterial
      ? c(y, v)
      : v.isShadowMaterial
      ? (y.color.value.copy(v.color), (y.opacity.value = v.opacity))
      : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function s(y, v) {
    (y.opacity.value = v.opacity),
      v.color && y.diffuse.value.copy(v.color),
      v.emissive &&
        y.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),
      v.map && ((y.map.value = v.map), t(v.map, y.mapTransform)),
      v.alphaMap &&
        ((y.alphaMap.value = v.alphaMap), t(v.alphaMap, y.alphaMapTransform)),
      v.bumpMap &&
        ((y.bumpMap.value = v.bumpMap),
        t(v.bumpMap, y.bumpMapTransform),
        (y.bumpScale.value = v.bumpScale),
        v.side === pi && (y.bumpScale.value *= -1)),
      v.normalMap &&
        ((y.normalMap.value = v.normalMap),
        t(v.normalMap, y.normalMapTransform),
        y.normalScale.value.copy(v.normalScale),
        v.side === pi && y.normalScale.value.negate()),
      v.displacementMap &&
        ((y.displacementMap.value = v.displacementMap),
        t(v.displacementMap, y.displacementMapTransform),
        (y.displacementScale.value = v.displacementScale),
        (y.displacementBias.value = v.displacementBias)),
      v.emissiveMap &&
        ((y.emissiveMap.value = v.emissiveMap),
        t(v.emissiveMap, y.emissiveMapTransform)),
      v.specularMap &&
        ((y.specularMap.value = v.specularMap),
        t(v.specularMap, y.specularMapTransform)),
      v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
    const _ = e.get(v),
      S = _.envMap,
      w = _.envMapRotation;
    if (
      (S &&
        ((y.envMap.value = S),
        Au.copy(w),
        (Au.x *= -1),
        (Au.y *= -1),
        (Au.z *= -1),
        S.isCubeTexture &&
          S.isRenderTargetTexture === !1 &&
          ((Au.y *= -1), (Au.z *= -1)),
        y.envMapRotation.value.setFromMatrix4(Xq.makeRotationFromEuler(Au)),
        (y.flipEnvMap.value =
          S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
        (y.reflectivity.value = v.reflectivity),
        (y.ior.value = v.ior),
        (y.refractionRatio.value = v.refractionRatio)),
      v.lightMap)
    ) {
      y.lightMap.value = v.lightMap;
      const T = n._useLegacyLights === !0 ? Math.PI : 1;
      (y.lightMapIntensity.value = v.lightMapIntensity * T),
        t(v.lightMap, y.lightMapTransform);
    }
    v.aoMap &&
      ((y.aoMap.value = v.aoMap),
      (y.aoMapIntensity.value = v.aoMapIntensity),
      t(v.aoMap, y.aoMapTransform));
  }
  function o(y, v) {
    y.diffuse.value.copy(v.color),
      (y.opacity.value = v.opacity),
      v.map && ((y.map.value = v.map), t(v.map, y.mapTransform));
  }
  function a(y, v) {
    (y.dashSize.value = v.dashSize),
      (y.totalSize.value = v.dashSize + v.gapSize),
      (y.scale.value = v.scale);
  }
  function l(y, v, _, S) {
    y.diffuse.value.copy(v.color),
      (y.opacity.value = v.opacity),
      (y.size.value = v.size * _),
      (y.scale.value = S * 0.5),
      v.map && ((y.map.value = v.map), t(v.map, y.uvTransform)),
      v.alphaMap &&
        ((y.alphaMap.value = v.alphaMap), t(v.alphaMap, y.alphaMapTransform)),
      v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
  }
  function c(y, v) {
    y.diffuse.value.copy(v.color),
      (y.opacity.value = v.opacity),
      (y.rotation.value = v.rotation),
      v.map && ((y.map.value = v.map), t(v.map, y.mapTransform)),
      v.alphaMap &&
        ((y.alphaMap.value = v.alphaMap), t(v.alphaMap, y.alphaMapTransform)),
      v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
  }
  function u(y, v) {
    y.specular.value.copy(v.specular),
      (y.shininess.value = Math.max(v.shininess, 1e-4));
  }
  function d(y, v) {
    v.gradientMap && (y.gradientMap.value = v.gradientMap);
  }
  function h(y, v) {
    (y.metalness.value = v.metalness),
      v.metalnessMap &&
        ((y.metalnessMap.value = v.metalnessMap),
        t(v.metalnessMap, y.metalnessMapTransform)),
      (y.roughness.value = v.roughness),
      v.roughnessMap &&
        ((y.roughnessMap.value = v.roughnessMap),
        t(v.roughnessMap, y.roughnessMapTransform)),
      v.envMap && (y.envMapIntensity.value = v.envMapIntensity);
  }
  function m(y, v, _) {
    (y.ior.value = v.ior),
      v.sheen > 0 &&
        (y.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),
        (y.sheenRoughness.value = v.sheenRoughness),
        v.sheenColorMap &&
          ((y.sheenColorMap.value = v.sheenColorMap),
          t(v.sheenColorMap, y.sheenColorMapTransform)),
        v.sheenRoughnessMap &&
          ((y.sheenRoughnessMap.value = v.sheenRoughnessMap),
          t(v.sheenRoughnessMap, y.sheenRoughnessMapTransform))),
      v.clearcoat > 0 &&
        ((y.clearcoat.value = v.clearcoat),
        (y.clearcoatRoughness.value = v.clearcoatRoughness),
        v.clearcoatMap &&
          ((y.clearcoatMap.value = v.clearcoatMap),
          t(v.clearcoatMap, y.clearcoatMapTransform)),
        v.clearcoatRoughnessMap &&
          ((y.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap),
          t(v.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)),
        v.clearcoatNormalMap &&
          ((y.clearcoatNormalMap.value = v.clearcoatNormalMap),
          t(v.clearcoatNormalMap, y.clearcoatNormalMapTransform),
          y.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),
          v.side === pi && y.clearcoatNormalScale.value.negate())),
      v.dispersion > 0 && (y.dispersion.value = v.dispersion),
      v.iridescence > 0 &&
        ((y.iridescence.value = v.iridescence),
        (y.iridescenceIOR.value = v.iridescenceIOR),
        (y.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0]),
        (y.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1]),
        v.iridescenceMap &&
          ((y.iridescenceMap.value = v.iridescenceMap),
          t(v.iridescenceMap, y.iridescenceMapTransform)),
        v.iridescenceThicknessMap &&
          ((y.iridescenceThicknessMap.value = v.iridescenceThicknessMap),
          t(v.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))),
      v.transmission > 0 &&
        ((y.transmission.value = v.transmission),
        (y.transmissionSamplerMap.value = _.texture),
        y.transmissionSamplerSize.value.set(_.width, _.height),
        v.transmissionMap &&
          ((y.transmissionMap.value = v.transmissionMap),
          t(v.transmissionMap, y.transmissionMapTransform)),
        (y.thickness.value = v.thickness),
        v.thicknessMap &&
          ((y.thicknessMap.value = v.thicknessMap),
          t(v.thicknessMap, y.thicknessMapTransform)),
        (y.attenuationDistance.value = v.attenuationDistance),
        y.attenuationColor.value.copy(v.attenuationColor)),
      v.anisotropy > 0 &&
        (y.anisotropyVector.value.set(
          v.anisotropy * Math.cos(v.anisotropyRotation),
          v.anisotropy * Math.sin(v.anisotropyRotation)
        ),
        v.anisotropyMap &&
          ((y.anisotropyMap.value = v.anisotropyMap),
          t(v.anisotropyMap, y.anisotropyMapTransform))),
      (y.specularIntensity.value = v.specularIntensity),
      y.specularColor.value.copy(v.specularColor),
      v.specularColorMap &&
        ((y.specularColorMap.value = v.specularColorMap),
        t(v.specularColorMap, y.specularColorMapTransform)),
      v.specularIntensityMap &&
        ((y.specularIntensityMap.value = v.specularIntensityMap),
        t(v.specularIntensityMap, y.specularIntensityMapTransform));
  }
  function g(y, v) {
    v.matcap && (y.matcap.value = v.matcap);
  }
  function x(y, v) {
    const _ = e.get(v).light;
    y.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (y.nearDistance.value = _.shadow.camera.near),
      (y.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function qq(n, e, t, r) {
  let i = {},
    s = {},
    o = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(_, S) {
    const w = S.program;
    r.uniformBlockBinding(_, w);
  }
  function c(_, S) {
    let w = i[_.id];
    w === void 0 &&
      (g(_), (w = u(_)), (i[_.id] = w), _.addEventListener("dispose", y));
    const T = S.program;
    r.updateUBOMapping(_, T);
    const E = e.render.frame;
    s[_.id] !== E && (h(_), (s[_.id] = E));
  }
  function u(_) {
    const S = d();
    _.__bindingPointIndex = S;
    const w = n.createBuffer(),
      T = _.__size,
      E = _.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, w),
      n.bufferData(n.UNIFORM_BUFFER, T, E),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, S, w),
      w
    );
  }
  function d() {
    for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function h(_) {
    const S = i[_.id],
      w = _.uniforms,
      T = _.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, S);
    for (let E = 0, M = w.length; E < M; E++) {
      const N = Array.isArray(w[E]) ? w[E] : [w[E]];
      for (let R = 0, C = N.length; R < C; R++) {
        const L = N[R];
        if (m(L, E, R, T) === !0) {
          const O = L.__offset,
            D = Array.isArray(L.value) ? L.value : [L.value];
          let B = 0;
          for (let $ = 0; $ < D.length; $++) {
            const G = D[$],
              j = x(G);
            typeof G == "number" || typeof G == "boolean"
              ? ((L.__data[0] = G),
                n.bufferSubData(n.UNIFORM_BUFFER, O + B, L.__data))
              : G.isMatrix3
              ? ((L.__data[0] = G.elements[0]),
                (L.__data[1] = G.elements[1]),
                (L.__data[2] = G.elements[2]),
                (L.__data[3] = 0),
                (L.__data[4] = G.elements[3]),
                (L.__data[5] = G.elements[4]),
                (L.__data[6] = G.elements[5]),
                (L.__data[7] = 0),
                (L.__data[8] = G.elements[6]),
                (L.__data[9] = G.elements[7]),
                (L.__data[10] = G.elements[8]),
                (L.__data[11] = 0))
              : (G.toArray(L.__data, B),
                (B += j.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, O, L.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(_, S, w, T) {
    const E = _.value,
      M = S + "_" + w;
    if (T[M] === void 0)
      return (
        typeof E == "number" || typeof E == "boolean"
          ? (T[M] = E)
          : (T[M] = E.clone()),
        !0
      );
    {
      const N = T[M];
      if (typeof E == "number" || typeof E == "boolean") {
        if (N !== E) return (T[M] = E), !0;
      } else if (N.equals(E) === !1) return N.copy(E), !0;
    }
    return !1;
  }
  function g(_) {
    const S = _.uniforms;
    let w = 0;
    const T = 16;
    for (let M = 0, N = S.length; M < N; M++) {
      const R = Array.isArray(S[M]) ? S[M] : [S[M]];
      for (let C = 0, L = R.length; C < L; C++) {
        const O = R[C],
          D = Array.isArray(O.value) ? O.value : [O.value];
        for (let B = 0, $ = D.length; B < $; B++) {
          const G = D[B],
            j = x(G),
            U = w % T;
          U !== 0 && T - U < j.boundary && (w += T - U),
            (O.__data = new Float32Array(
              j.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (O.__offset = w),
            (w += j.storage);
        }
      }
    }
    const E = w % T;
    return E > 0 && (w += T - E), (_.__size = w), (_.__cache = {}), this;
  }
  function x(_) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number" || typeof _ == "boolean"
        ? ((S.boundary = 4), (S.storage = 4))
        : _.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : _.isVector3 || _.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : _.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : _.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : _.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      S
    );
  }
  function y(_) {
    const S = _.target;
    S.removeEventListener("dispose", y);
    const w = o.indexOf(S.__bindingPointIndex);
    o.splice(w, 1), n.deleteBuffer(i[S.id]), delete i[S.id], delete s[S.id];
  }
  function v() {
    for (const _ in i) n.deleteBuffer(i[_]);
    (o = []), (i = {}), (s = {});
  }
  return { bind: l, update: c, dispose: v };
}
class Ek {
  constructor(e = {}) {
    const {
      canvas: t = uk(),
      context: r = null,
      depth: i = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let h;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      h = r.getContextAttributes().alpha;
    } else h = o;
    const m = new Uint32Array(4),
      g = new Int32Array(4);
    let x = null,
      y = null;
    const v = [],
      _ = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Xs),
      (this._useLegacyLights = !1),
      (this.toneMapping = ws),
      (this.toneMappingExposure = 1);
    const S = this;
    let w = !1,
      T = 0,
      E = 0,
      M = null,
      N = -1,
      R = null;
    const C = new rn(),
      L = new rn();
    let O = null;
    const D = new pt(0);
    let B = 0,
      $ = t.width,
      G = t.height,
      j = 1,
      U = null,
      H = null;
    const V = new rn(0, 0, $, G),
      k = new rn(0, 0, $, G);
    let W = !1;
    const ee = new m0();
    let Y = !1,
      K = !1;
    const ae = new Ut(),
      se = new Q(),
      we = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Be() {
      return M === null ? j : 1;
    }
    let te = r;
    function ge(Z, be) {
      return t.getContext(Z, be);
    }
    try {
      const Z = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${u_}`),
        t.addEventListener("webglcontextlost", le, !1),
        t.addEventListener("webglcontextrestored", Re, !1),
        t.addEventListener("webglcontextcreationerror", xe, !1),
        te === null)
      ) {
        const be = "webgl2";
        if (((te = ge(be, Z)), te === null))
          throw ge(be)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (Z) {
      throw (console.error("THREE.WebGLRenderer: " + Z.message), Z);
    }
    let ie,
      me,
      fe,
      Ee,
      Se,
      Ue,
      Ce,
      X,
      z,
      q,
      ue,
      de,
      he,
      Ie,
      ke,
      Me,
      et,
      Ne,
      We,
      ot,
      nt,
      Ke,
      it,
      re;
    function ze() {
      (ie = new lY(te)),
        ie.init(),
        (Ke = new wk(te, ie)),
        (me = new nY(te, ie, e, Ke)),
        (fe = new Bq(te)),
        (Ee = new dY(te)),
        (Se = new Cq()),
        (Ue = new Vq(te, ie, fe, Se, me, Ke, Ee)),
        (Ce = new iY(S)),
        (X = new aY(S)),
        (z = new y7(te)),
        (it = new eY(te, z)),
        (q = new cY(te, z, Ee, it)),
        (ue = new hY(te, q, z, Ee)),
        (We = new fY(te, me, Ue)),
        (Me = new rY(Se)),
        (de = new Tq(S, Ce, X, ie, me, it, Me)),
        (he = new Yq(S, Se)),
        (Ie = new Nq()),
        (ke = new Fq(ie)),
        (Ne = new JX(S, Ce, X, fe, ue, h, l)),
        (et = new zq(S, ue, me)),
        (re = new qq(te, Ee, me, fe)),
        (ot = new tY(te, ie, Ee)),
        (nt = new uY(te, ie, Ee)),
        (Ee.programs = de.programs),
        (S.capabilities = me),
        (S.extensions = ie),
        (S.properties = Se),
        (S.renderLists = Ie),
        (S.shadowMap = et),
        (S.state = fe),
        (S.info = Ee);
    }
    ze();
    const Xe = new $q(S, te);
    (this.xr = Xe),
      (this.getContext = function () {
        return te;
      }),
      (this.getContextAttributes = function () {
        return te.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const Z = ie.get("WEBGL_lose_context");
        Z && Z.loseContext();
      }),
      (this.forceContextRestore = function () {
        const Z = ie.get("WEBGL_lose_context");
        Z && Z.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return j;
      }),
      (this.setPixelRatio = function (Z) {
        Z !== void 0 && ((j = Z), this.setSize($, G, !1));
      }),
      (this.getSize = function (Z) {
        return Z.set($, G);
      }),
      (this.setSize = function (Z, be, Fe = !0) {
        if (Xe.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        ($ = Z),
          (G = be),
          (t.width = Math.floor(Z * j)),
          (t.height = Math.floor(be * j)),
          Fe === !0 &&
            ((t.style.width = Z + "px"), (t.style.height = be + "px")),
          this.setViewport(0, 0, Z, be);
      }),
      (this.getDrawingBufferSize = function (Z) {
        return Z.set($ * j, G * j).floor();
      }),
      (this.setDrawingBufferSize = function (Z, be, Fe) {
        ($ = Z),
          (G = be),
          (j = Fe),
          (t.width = Math.floor(Z * Fe)),
          (t.height = Math.floor(be * Fe)),
          this.setViewport(0, 0, Z, be);
      }),
      (this.getCurrentViewport = function (Z) {
        return Z.copy(C);
      }),
      (this.getViewport = function (Z) {
        return Z.copy(V);
      }),
      (this.setViewport = function (Z, be, Fe, Pe) {
        Z.isVector4 ? V.set(Z.x, Z.y, Z.z, Z.w) : V.set(Z, be, Fe, Pe),
          fe.viewport(C.copy(V).multiplyScalar(j).round());
      }),
      (this.getScissor = function (Z) {
        return Z.copy(k);
      }),
      (this.setScissor = function (Z, be, Fe, Pe) {
        Z.isVector4 ? k.set(Z.x, Z.y, Z.z, Z.w) : k.set(Z, be, Fe, Pe),
          fe.scissor(L.copy(k).multiplyScalar(j).round());
      }),
      (this.getScissorTest = function () {
        return W;
      }),
      (this.setScissorTest = function (Z) {
        fe.setScissorTest((W = Z));
      }),
      (this.setOpaqueSort = function (Z) {
        U = Z;
      }),
      (this.setTransparentSort = function (Z) {
        H = Z;
      }),
      (this.getClearColor = function (Z) {
        return Z.copy(Ne.getClearColor());
      }),
      (this.setClearColor = function () {
        Ne.setClearColor.apply(Ne, arguments);
      }),
      (this.getClearAlpha = function () {
        return Ne.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ne.setClearAlpha.apply(Ne, arguments);
      }),
      (this.clear = function (Z = !0, be = !0, Fe = !0) {
        let Pe = 0;
        if (Z) {
          let Le = !1;
          if (M !== null) {
            const ft = M.texture.format;
            Le = ft === JC || ft === QC || ft === ZC;
          }
          if (Le) {
            const ft = M.texture.type,
              wt =
                ft === $a ||
                ft === xd ||
                ft === $C ||
                ft === ip ||
                ft === YC ||
                ft === qC,
              bt = Ne.getClearColor(),
              Dt = Ne.getClearAlpha(),
              Ht = bt.r,
              tt = bt.g,
              Vt = bt.b;
            wt
              ? ((m[0] = Ht),
                (m[1] = tt),
                (m[2] = Vt),
                (m[3] = Dt),
                te.clearBufferuiv(te.COLOR, 0, m))
              : ((g[0] = Ht),
                (g[1] = tt),
                (g[2] = Vt),
                (g[3] = Dt),
                te.clearBufferiv(te.COLOR, 0, g));
          } else Pe |= te.COLOR_BUFFER_BIT;
        }
        be && (Pe |= te.DEPTH_BUFFER_BIT),
          Fe &&
            ((Pe |= te.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          te.clear(Pe);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", le, !1),
          t.removeEventListener("webglcontextrestored", Re, !1),
          t.removeEventListener("webglcontextcreationerror", xe, !1),
          Ie.dispose(),
          ke.dispose(),
          Se.dispose(),
          Ce.dispose(),
          X.dispose(),
          ue.dispose(),
          it.dispose(),
          re.dispose(),
          de.dispose(),
          Xe.dispose(),
          Xe.removeEventListener("sessionstart", lt),
          Xe.removeEventListener("sessionend", St),
          Nt.stop();
      });
    function le(Z) {
      Z.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (w = !0);
    }
    function Re() {
      console.log("THREE.WebGLRenderer: Context Restored."), (w = !1);
      const Z = Ee.autoReset,
        be = et.enabled,
        Fe = et.autoUpdate,
        Pe = et.needsUpdate,
        Le = et.type;
      ze(),
        (Ee.autoReset = Z),
        (et.enabled = be),
        (et.autoUpdate = Fe),
        (et.needsUpdate = Pe),
        (et.type = Le);
    }
    function xe(Z) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        Z.statusMessage
      );
    }
    function Ye(Z) {
      const be = Z.target;
      be.removeEventListener("dispose", Ye), at(be);
    }
    function at(Z) {
      vt(Z), Se.remove(Z);
    }
    function vt(Z) {
      const be = Se.get(Z).programs;
      be !== void 0 &&
        (be.forEach(function (Fe) {
          de.releaseProgram(Fe);
        }),
        Z.isShaderMaterial && de.releaseShaderCache(Z));
    }
    this.renderBufferDirect = function (Z, be, Fe, Pe, Le, ft) {
      be === null && (be = we);
      const wt = Le.isMesh && Le.matrixWorld.determinant() < 0,
        bt = vr(Z, be, Fe, Pe, Le);
      fe.setMaterial(Pe, wt);
      let Dt = Fe.index,
        Ht = 1;
      if (Pe.wireframe === !0) {
        if (((Dt = q.getWireframeAttribute(Fe)), Dt === void 0)) return;
        Ht = 2;
      }
      const tt = Fe.drawRange,
        Vt = Fe.attributes.position;
      let Un = tt.start * Ht,
        Nn = (tt.start + tt.count) * Ht;
      ft !== null &&
        ((Un = Math.max(Un, ft.start * Ht)),
        (Nn = Math.min(Nn, (ft.start + ft.count) * Ht))),
        Dt !== null
          ? ((Un = Math.max(Un, 0)), (Nn = Math.min(Nn, Dt.count)))
          : Vt != null &&
            ((Un = Math.max(Un, 0)), (Nn = Math.min(Nn, Vt.count)));
      const Tr = Nn - Un;
      if (Tr < 0 || Tr === 1 / 0) return;
      it.setup(Le, Pe, bt, Fe, Dt);
      let bi,
        en = ot;
      if (
        (Dt !== null && ((bi = z.get(Dt)), (en = nt), en.setIndex(bi)),
        Le.isMesh)
      )
        Pe.wireframe === !0
          ? (fe.setLineWidth(Pe.wireframeLinewidth * Be()),
            en.setMode(te.LINES))
          : en.setMode(te.TRIANGLES);
      else if (Le.isLine) {
        let It = Pe.linewidth;
        It === void 0 && (It = 1),
          fe.setLineWidth(It * Be()),
          Le.isLineSegments
            ? en.setMode(te.LINES)
            : Le.isLineLoop
            ? en.setMode(te.LINE_LOOP)
            : en.setMode(te.LINE_STRIP);
      } else
        Le.isPoints
          ? en.setMode(te.POINTS)
          : Le.isSprite && en.setMode(te.TRIANGLES);
      if (Le.isBatchedMesh)
        Le._multiDrawInstances !== null
          ? en.renderMultiDrawInstances(
              Le._multiDrawStarts,
              Le._multiDrawCounts,
              Le._multiDrawCount,
              Le._multiDrawInstances
            )
          : en.renderMultiDraw(
              Le._multiDrawStarts,
              Le._multiDrawCounts,
              Le._multiDrawCount
            );
      else if (Le.isInstancedMesh) en.renderInstances(Un, Tr, Le.count);
      else if (Fe.isInstancedBufferGeometry) {
        const It =
            Fe._maxInstanceCount !== void 0 ? Fe._maxInstanceCount : 1 / 0,
          cn = Math.min(Fe.instanceCount, It);
        en.renderInstances(Un, Tr, cn);
      } else en.render(Un, Tr);
    };
    function dt(Z, be, Fe) {
      Z.transparent === !0 && Z.side === Ys && Z.forceSinglePass === !1
        ? ((Z.side = pi),
          (Z.needsUpdate = !0),
          kr(Z, be, Fe),
          (Z.side = ja),
          (Z.needsUpdate = !0),
          kr(Z, be, Fe),
          (Z.side = Ys))
        : kr(Z, be, Fe);
    }
    (this.compile = function (Z, be, Fe = null) {
      Fe === null && (Fe = Z),
        (y = ke.get(Fe)),
        y.init(be),
        _.push(y),
        Fe.traverseVisible(function (Le) {
          Le.isLight &&
            Le.layers.test(be.layers) &&
            (y.pushLight(Le), Le.castShadow && y.pushShadow(Le));
        }),
        Z !== Fe &&
          Z.traverseVisible(function (Le) {
            Le.isLight &&
              Le.layers.test(be.layers) &&
              (y.pushLight(Le), Le.castShadow && y.pushShadow(Le));
          }),
        y.setupLights(S._useLegacyLights);
      const Pe = new Set();
      return (
        Z.traverse(function (Le) {
          const ft = Le.material;
          if (ft)
            if (Array.isArray(ft))
              for (let wt = 0; wt < ft.length; wt++) {
                const bt = ft[wt];
                dt(bt, Fe, Le), Pe.add(bt);
              }
            else dt(ft, Fe, Le), Pe.add(ft);
        }),
        _.pop(),
        (y = null),
        Pe
      );
    }),
      (this.compileAsync = function (Z, be, Fe = null) {
        const Pe = this.compile(Z, be, Fe);
        return new Promise((Le) => {
          function ft() {
            if (
              (Pe.forEach(function (wt) {
                Se.get(wt).currentProgram.isReady() && Pe.delete(wt);
              }),
              Pe.size === 0)
            ) {
              Le(Z);
              return;
            }
            setTimeout(ft, 10);
          }
          ie.get("KHR_parallel_shader_compile") !== null
            ? ft()
            : setTimeout(ft, 10);
        });
      });
    let mt = null;
    function kt(Z) {
      mt && mt(Z);
    }
    function lt() {
      Nt.stop();
    }
    function St() {
      Nt.start();
    }
    const Nt = new vk();
    Nt.setAnimationLoop(kt),
      typeof self < "u" && Nt.setContext(self),
      (this.setAnimationLoop = function (Z) {
        (mt = Z), Xe.setAnimationLoop(Z), Z === null ? Nt.stop() : Nt.start();
      }),
      Xe.addEventListener("sessionstart", lt),
      Xe.addEventListener("sessionend", St),
      (this.render = function (Z, be) {
        if (be !== void 0 && be.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (w === !0) return;
        Z.matrixWorldAutoUpdate === !0 && Z.updateMatrixWorld(),
          be.parent === null &&
            be.matrixWorldAutoUpdate === !0 &&
            be.updateMatrixWorld(),
          Xe.enabled === !0 &&
            Xe.isPresenting === !0 &&
            (Xe.cameraAutoUpdate === !0 && Xe.updateCamera(be),
            (be = Xe.getCamera())),
          Z.isScene === !0 && Z.onBeforeRender(S, Z, be, M),
          (y = ke.get(Z, _.length)),
          y.init(be),
          _.push(y),
          ae.multiplyMatrices(be.projectionMatrix, be.matrixWorldInverse),
          ee.setFromProjectionMatrix(ae),
          (K = this.localClippingEnabled),
          (Y = Me.init(this.clippingPlanes, K)),
          (x = Ie.get(Z, v.length)),
          x.init(),
          v.push(x),
          gn(Z, be, 0, S.sortObjects),
          x.finish(),
          S.sortObjects === !0 && x.sort(U, H);
        const Fe =
          Xe.enabled === !1 ||
          Xe.isPresenting === !1 ||
          Xe.hasDepthSensing() === !1;
        Fe && Ne.addToRenderList(x, Z),
          this.info.render.frame++,
          Y === !0 && Me.beginShadows();
        const Pe = y.state.shadowsArray;
        et.render(Pe, Z, be),
          Y === !0 && Me.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const Le = x.opaque,
          ft = x.transmissive;
        if ((y.setupLights(S._useLegacyLights), be.isArrayCamera)) {
          const wt = be.cameras;
          if (ft.length > 0)
            for (let bt = 0, Dt = wt.length; bt < Dt; bt++) {
              const Ht = wt[bt];
              gr(Le, ft, Z, Ht);
            }
          Fe && Ne.render(Z);
          for (let bt = 0, Dt = wt.length; bt < Dt; bt++) {
            const Ht = wt[bt];
            dn(x, Z, Ht, Ht.viewport);
          }
        } else
          ft.length > 0 && gr(Le, ft, Z, be), Fe && Ne.render(Z), dn(x, Z, be);
        M !== null &&
          (Ue.updateMultisampleRenderTarget(M), Ue.updateRenderTargetMipmap(M)),
          Z.isScene === !0 && Z.onAfterRender(S, Z, be),
          it.resetDefaultState(),
          (N = -1),
          (R = null),
          _.pop(),
          _.length > 0
            ? ((y = _[_.length - 1]),
              Y === !0 && Me.setGlobalState(S.clippingPlanes, y.state.camera))
            : (y = null),
          v.pop(),
          v.length > 0 ? (x = v[v.length - 1]) : (x = null);
      });
    function gn(Z, be, Fe, Pe) {
      if (Z.visible === !1) return;
      if (Z.layers.test(be.layers)) {
        if (Z.isGroup) Fe = Z.renderOrder;
        else if (Z.isLOD) Z.autoUpdate === !0 && Z.update(be);
        else if (Z.isLight) y.pushLight(Z), Z.castShadow && y.pushShadow(Z);
        else if (Z.isSprite) {
          if (!Z.frustumCulled || ee.intersectsSprite(Z)) {
            Pe && se.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(ae);
            const wt = ue.update(Z),
              bt = Z.material;
            bt.visible && x.push(Z, wt, bt, Fe, se.z, null);
          }
        } else if (
          (Z.isMesh || Z.isLine || Z.isPoints) &&
          (!Z.frustumCulled || ee.intersectsObject(Z))
        ) {
          const wt = ue.update(Z),
            bt = Z.material;
          if (
            (Pe &&
              (Z.boundingSphere !== void 0
                ? (Z.boundingSphere === null && Z.computeBoundingSphere(),
                  se.copy(Z.boundingSphere.center))
                : (wt.boundingSphere === null && wt.computeBoundingSphere(),
                  se.copy(wt.boundingSphere.center)),
              se.applyMatrix4(Z.matrixWorld).applyMatrix4(ae)),
            Array.isArray(bt))
          ) {
            const Dt = wt.groups;
            for (let Ht = 0, tt = Dt.length; Ht < tt; Ht++) {
              const Vt = Dt[Ht],
                Un = bt[Vt.materialIndex];
              Un && Un.visible && x.push(Z, wt, Un, Fe, se.z, Vt);
            }
          } else bt.visible && x.push(Z, wt, bt, Fe, se.z, null);
        }
      }
      const ft = Z.children;
      for (let wt = 0, bt = ft.length; wt < bt; wt++) gn(ft[wt], be, Fe, Pe);
    }
    function dn(Z, be, Fe, Pe) {
      const Le = Z.opaque,
        ft = Z.transmissive,
        wt = Z.transparent;
      y.setupLightsView(Fe),
        Y === !0 && Me.setGlobalState(S.clippingPlanes, Fe),
        Pe && fe.viewport(C.copy(Pe)),
        Le.length > 0 && Kr(Le, be, Fe),
        ft.length > 0 && Kr(ft, be, Fe),
        wt.length > 0 && Kr(wt, be, Fe),
        fe.buffers.depth.setTest(!0),
        fe.buffers.depth.setMask(!0),
        fe.buffers.color.setMask(!0),
        fe.setPolygonOffset(!1);
    }
    function gr(Z, be, Fe, Pe) {
      if ((Fe.isScene === !0 ? Fe.overrideMaterial : null) !== null) return;
      y.state.transmissionRenderTarget[Pe.id] === void 0 &&
        (y.state.transmissionRenderTarget[Pe.id] = new va(1, 1, {
          generateMipmaps: !0,
          type:
            ie.has("EXT_color_buffer_half_float") ||
            ie.has("EXT_color_buffer_float")
              ? rp
              : $a,
          minFilter: ca,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
        }));
      const ft = y.state.transmissionRenderTarget[Pe.id],
        wt = Pe.viewport || C;
      ft.setSize(wt.z, wt.w);
      const bt = S.getRenderTarget();
      S.setRenderTarget(ft),
        S.getClearColor(D),
        (B = S.getClearAlpha()),
        B < 1 && S.setClearColor(16777215, 0.5),
        S.clear();
      const Dt = S.toneMapping;
      S.toneMapping = ws;
      const Ht = Pe.viewport;
      if (
        (Pe.viewport !== void 0 && (Pe.viewport = void 0),
        y.setupLightsView(Pe),
        Y === !0 && Me.setGlobalState(S.clippingPlanes, Pe),
        Kr(Z, Fe, Pe),
        Ue.updateMultisampleRenderTarget(ft),
        Ue.updateRenderTargetMipmap(ft),
        ie.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let tt = !1;
        for (let Vt = 0, Un = be.length; Vt < Un; Vt++) {
          const Nn = be[Vt],
            Tr = Nn.object,
            bi = Nn.geometry,
            en = Nn.material,
            It = Nn.group;
          if (en.side === Ys && Tr.layers.test(Pe.layers)) {
            const cn = en.side;
            (en.side = pi),
              (en.needsUpdate = !0),
              Ur(Tr, Fe, Pe, bi, en, It),
              (en.side = cn),
              (en.needsUpdate = !0),
              (tt = !0);
          }
        }
        tt === !0 &&
          (Ue.updateMultisampleRenderTarget(ft),
          Ue.updateRenderTargetMipmap(ft));
      }
      S.setRenderTarget(bt),
        S.setClearColor(D, B),
        Ht !== void 0 && (Pe.viewport = Ht),
        (S.toneMapping = Dt);
    }
    function Kr(Z, be, Fe) {
      const Pe = be.isScene === !0 ? be.overrideMaterial : null;
      for (let Le = 0, ft = Z.length; Le < ft; Le++) {
        const wt = Z[Le],
          bt = wt.object,
          Dt = wt.geometry,
          Ht = Pe === null ? wt.material : Pe,
          tt = wt.group;
        bt.layers.test(Fe.layers) && Ur(bt, be, Fe, Dt, Ht, tt);
      }
    }
    function Ur(Z, be, Fe, Pe, Le, ft) {
      Z.onBeforeRender(S, be, Fe, Pe, Le, ft),
        Z.modelViewMatrix.multiplyMatrices(
          Fe.matrixWorldInverse,
          Z.matrixWorld
        ),
        Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix),
        Le.onBeforeRender(S, be, Fe, Pe, Z, ft),
        Le.transparent === !0 && Le.side === Ys && Le.forceSinglePass === !1
          ? ((Le.side = pi),
            (Le.needsUpdate = !0),
            S.renderBufferDirect(Fe, be, Pe, Le, Z, ft),
            (Le.side = ja),
            (Le.needsUpdate = !0),
            S.renderBufferDirect(Fe, be, Pe, Le, Z, ft),
            (Le.side = Ys))
          : S.renderBufferDirect(Fe, be, Pe, Le, Z, ft),
        Z.onAfterRender(S, be, Fe, Pe, Le, ft);
    }
    function kr(Z, be, Fe) {
      be.isScene !== !0 && (be = we);
      const Pe = Se.get(Z),
        Le = y.state.lights,
        ft = y.state.shadowsArray,
        wt = Le.state.version,
        bt = de.getParameters(Z, Le.state, ft, be, Fe),
        Dt = de.getProgramCacheKey(bt);
      let Ht = Pe.programs;
      (Pe.environment = Z.isMeshStandardMaterial ? be.environment : null),
        (Pe.fog = be.fog),
        (Pe.envMap = (Z.isMeshStandardMaterial ? X : Ce).get(
          Z.envMap || Pe.environment
        )),
        (Pe.envMapRotation =
          Pe.environment !== null && Z.envMap === null
            ? be.environmentRotation
            : Z.envMapRotation),
        Ht === void 0 &&
          (Z.addEventListener("dispose", Ye),
          (Ht = new Map()),
          (Pe.programs = Ht));
      let tt = Ht.get(Dt);
      if (tt !== void 0) {
        if (Pe.currentProgram === tt && Pe.lightsStateVersion === wt)
          return Ai(Z, bt), tt;
      } else
        (bt.uniforms = de.getUniforms(Z)),
          Z.onBuild(Fe, bt, S),
          Z.onBeforeCompile(bt, S),
          (tt = de.acquireProgram(bt, Dt)),
          Ht.set(Dt, tt),
          (Pe.uniforms = bt.uniforms);
      const Vt = Pe.uniforms;
      return (
        ((!Z.isShaderMaterial && !Z.isRawShaderMaterial) ||
          Z.clipping === !0) &&
          (Vt.clippingPlanes = Me.uniform),
        Ai(Z, bt),
        (Pe.needsLights = wi(Z)),
        (Pe.lightsStateVersion = wt),
        Pe.needsLights &&
          ((Vt.ambientLightColor.value = Le.state.ambient),
          (Vt.lightProbe.value = Le.state.probe),
          (Vt.directionalLights.value = Le.state.directional),
          (Vt.directionalLightShadows.value = Le.state.directionalShadow),
          (Vt.spotLights.value = Le.state.spot),
          (Vt.spotLightShadows.value = Le.state.spotShadow),
          (Vt.rectAreaLights.value = Le.state.rectArea),
          (Vt.ltc_1.value = Le.state.rectAreaLTC1),
          (Vt.ltc_2.value = Le.state.rectAreaLTC2),
          (Vt.pointLights.value = Le.state.point),
          (Vt.pointLightShadows.value = Le.state.pointShadow),
          (Vt.hemisphereLights.value = Le.state.hemi),
          (Vt.directionalShadowMap.value = Le.state.directionalShadowMap),
          (Vt.directionalShadowMatrix.value = Le.state.directionalShadowMatrix),
          (Vt.spotShadowMap.value = Le.state.spotShadowMap),
          (Vt.spotLightMatrix.value = Le.state.spotLightMatrix),
          (Vt.spotLightMap.value = Le.state.spotLightMap),
          (Vt.pointShadowMap.value = Le.state.pointShadowMap),
          (Vt.pointShadowMatrix.value = Le.state.pointShadowMatrix)),
        (Pe.currentProgram = tt),
        (Pe.uniformsList = null),
        tt
      );
    }
    function zr(Z) {
      if (Z.uniformsList === null) {
        const be = Z.currentProgram.getUniforms();
        Z.uniformsList = Ax.seqWithValue(be.seq, Z.uniforms);
      }
      return Z.uniformsList;
    }
    function Ai(Z, be) {
      const Fe = Se.get(Z);
      (Fe.outputColorSpace = be.outputColorSpace),
        (Fe.batching = be.batching),
        (Fe.instancing = be.instancing),
        (Fe.instancingColor = be.instancingColor),
        (Fe.instancingMorph = be.instancingMorph),
        (Fe.skinning = be.skinning),
        (Fe.morphTargets = be.morphTargets),
        (Fe.morphNormals = be.morphNormals),
        (Fe.morphColors = be.morphColors),
        (Fe.morphTargetsCount = be.morphTargetsCount),
        (Fe.numClippingPlanes = be.numClippingPlanes),
        (Fe.numIntersection = be.numClipIntersection),
        (Fe.vertexAlphas = be.vertexAlphas),
        (Fe.vertexTangents = be.vertexTangents),
        (Fe.toneMapping = be.toneMapping);
    }
    function vr(Z, be, Fe, Pe, Le) {
      be.isScene !== !0 && (be = we), Ue.resetTextureUnits();
      const ft = be.fog,
        wt = Pe.isMeshStandardMaterial ? be.environment : null,
        bt =
          M === null
            ? S.outputColorSpace
            : M.isXRRenderTarget === !0
            ? M.texture.colorSpace
            : Ho,
        Dt = (Pe.isMeshStandardMaterial ? X : Ce).get(Pe.envMap || wt),
        Ht =
          Pe.vertexColors === !0 &&
          !!Fe.attributes.color &&
          Fe.attributes.color.itemSize === 4,
        tt = !!Fe.attributes.tangent && (!!Pe.normalMap || Pe.anisotropy > 0),
        Vt = !!Fe.morphAttributes.position,
        Un = !!Fe.morphAttributes.normal,
        Nn = !!Fe.morphAttributes.color;
      let Tr = ws;
      Pe.toneMapped &&
        (M === null || M.isXRRenderTarget === !0) &&
        (Tr = S.toneMapping);
      const bi =
          Fe.morphAttributes.position ||
          Fe.morphAttributes.normal ||
          Fe.morphAttributes.color,
        en = bi !== void 0 ? bi.length : 0,
        It = Se.get(Pe),
        cn = y.state.lights;
      if (Y === !0 && (K === !0 || Z !== R)) {
        const Br = Z === R && Pe.id === N;
        Me.setState(Pe, Z, Br);
      }
      let Ft = !1;
      Pe.version === It.__version
        ? ((It.needsLights && It.lightsStateVersion !== cn.state.version) ||
            It.outputColorSpace !== bt ||
            (Le.isBatchedMesh && It.batching === !1) ||
            (!Le.isBatchedMesh && It.batching === !0) ||
            (Le.isInstancedMesh && It.instancing === !1) ||
            (!Le.isInstancedMesh && It.instancing === !0) ||
            (Le.isSkinnedMesh && It.skinning === !1) ||
            (!Le.isSkinnedMesh && It.skinning === !0) ||
            (Le.isInstancedMesh &&
              It.instancingColor === !0 &&
              Le.instanceColor === null) ||
            (Le.isInstancedMesh &&
              It.instancingColor === !1 &&
              Le.instanceColor !== null) ||
            (Le.isInstancedMesh &&
              It.instancingMorph === !0 &&
              Le.morphTexture === null) ||
            (Le.isInstancedMesh &&
              It.instancingMorph === !1 &&
              Le.morphTexture !== null) ||
            It.envMap !== Dt ||
            (Pe.fog === !0 && It.fog !== ft) ||
            (It.numClippingPlanes !== void 0 &&
              (It.numClippingPlanes !== Me.numPlanes ||
                It.numIntersection !== Me.numIntersection)) ||
            It.vertexAlphas !== Ht ||
            It.vertexTangents !== tt ||
            It.morphTargets !== Vt ||
            It.morphNormals !== Un ||
            It.morphColors !== Nn ||
            It.toneMapping !== Tr ||
            It.morphTargetsCount !== en) &&
          (Ft = !0)
        : ((Ft = !0), (It.__version = Pe.version));
      let yr = It.currentProgram;
      Ft === !0 && (yr = kr(Pe, be, Le));
      let sr = !1,
        jn = !1,
        ls = !1;
      const wn = yr.getUniforms(),
        Pn = It.uniforms;
      if (
        (fe.useProgram(yr.program) && ((sr = !0), (jn = !0), (ls = !0)),
        Pe.id !== N && ((N = Pe.id), (jn = !0)),
        sr || R !== Z)
      ) {
        wn.setValue(te, "projectionMatrix", Z.projectionMatrix),
          wn.setValue(te, "viewMatrix", Z.matrixWorldInverse);
        const Br = wn.map.cameraPosition;
        Br !== void 0 &&
          Br.setValue(te, se.setFromMatrixPosition(Z.matrixWorld)),
          me.logarithmicDepthBuffer &&
            wn.setValue(
              te,
              "logDepthBufFC",
              2 / (Math.log(Z.far + 1) / Math.LN2)
            ),
          (Pe.isMeshPhongMaterial ||
            Pe.isMeshToonMaterial ||
            Pe.isMeshLambertMaterial ||
            Pe.isMeshBasicMaterial ||
            Pe.isMeshStandardMaterial ||
            Pe.isShaderMaterial) &&
            wn.setValue(te, "isOrthographic", Z.isOrthographicCamera === !0),
          R !== Z && ((R = Z), (jn = !0), (ls = !0));
      }
      if (Le.isSkinnedMesh) {
        wn.setOptional(te, Le, "bindMatrix"),
          wn.setOptional(te, Le, "bindMatrixInverse");
        const Br = Le.skeleton;
        Br &&
          (Br.boneTexture === null && Br.computeBoneTexture(),
          wn.setValue(te, "boneTexture", Br.boneTexture, Ue));
      }
      Le.isBatchedMesh &&
        (wn.setOptional(te, Le, "batchingTexture"),
        wn.setValue(te, "batchingTexture", Le._matricesTexture, Ue));
      const Gi = Fe.morphAttributes;
      if (
        ((Gi.position !== void 0 ||
          Gi.normal !== void 0 ||
          Gi.color !== void 0) &&
          We.update(Le, Fe, yr),
        (jn || It.receiveShadow !== Le.receiveShadow) &&
          ((It.receiveShadow = Le.receiveShadow),
          wn.setValue(te, "receiveShadow", Le.receiveShadow)),
        Pe.isMeshGouraudMaterial &&
          Pe.envMap !== null &&
          ((Pn.envMap.value = Dt),
          (Pn.flipEnvMap.value =
            Dt.isCubeTexture && Dt.isRenderTargetTexture === !1 ? -1 : 1)),
        Pe.isMeshStandardMaterial &&
          Pe.envMap === null &&
          be.environment !== null &&
          (Pn.envMapIntensity.value = be.environmentIntensity),
        jn &&
          (wn.setValue(te, "toneMappingExposure", S.toneMappingExposure),
          It.needsLights && Ps(Pn, ls),
          ft && Pe.fog === !0 && he.refreshFogUniforms(Pn, ft),
          he.refreshMaterialUniforms(
            Pn,
            Pe,
            j,
            G,
            y.state.transmissionRenderTarget[Z.id]
          ),
          Ax.upload(te, zr(It), Pn, Ue)),
        Pe.isShaderMaterial &&
          Pe.uniformsNeedUpdate === !0 &&
          (Ax.upload(te, zr(It), Pn, Ue), (Pe.uniformsNeedUpdate = !1)),
        Pe.isSpriteMaterial && wn.setValue(te, "center", Le.center),
        wn.setValue(te, "modelViewMatrix", Le.modelViewMatrix),
        wn.setValue(te, "normalMatrix", Le.normalMatrix),
        wn.setValue(te, "modelMatrix", Le.matrixWorld),
        Pe.isShaderMaterial || Pe.isRawShaderMaterial)
      ) {
        const Br = Pe.uniformsGroups;
        for (let ba = 0, Ea = Br.length; ba < Ea; ba++) {
          const Ei = Br[ba];
          re.update(Ei, yr), re.bind(Ei, yr);
        }
      }
      return yr;
    }
    function Ps(Z, be) {
      (Z.ambientLightColor.needsUpdate = be),
        (Z.lightProbe.needsUpdate = be),
        (Z.directionalLights.needsUpdate = be),
        (Z.directionalLightShadows.needsUpdate = be),
        (Z.pointLights.needsUpdate = be),
        (Z.pointLightShadows.needsUpdate = be),
        (Z.spotLights.needsUpdate = be),
        (Z.spotLightShadows.needsUpdate = be),
        (Z.rectAreaLights.needsUpdate = be),
        (Z.hemisphereLights.needsUpdate = be);
    }
    function wi(Z) {
      return (
        Z.isMeshLambertMaterial ||
        Z.isMeshToonMaterial ||
        Z.isMeshPhongMaterial ||
        Z.isMeshStandardMaterial ||
        Z.isShadowMaterial ||
        (Z.isShaderMaterial && Z.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return E;
      }),
      (this.getRenderTarget = function () {
        return M;
      }),
      (this.setRenderTargetTextures = function (Z, be, Fe) {
        (Se.get(Z.texture).__webglTexture = be),
          (Se.get(Z.depthTexture).__webglTexture = Fe);
        const Pe = Se.get(Z);
        (Pe.__hasExternalTextures = !0),
          (Pe.__autoAllocateDepthBuffer = Fe === void 0),
          Pe.__autoAllocateDepthBuffer ||
            (ie.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (Pe.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (Z, be) {
        const Fe = Se.get(Z);
        (Fe.__webglFramebuffer = be),
          (Fe.__useDefaultFramebuffer = be === void 0);
      }),
      (this.setRenderTarget = function (Z, be = 0, Fe = 0) {
        (M = Z), (T = be), (E = Fe);
        let Pe = !0,
          Le = null,
          ft = !1,
          wt = !1;
        if (Z) {
          const Dt = Se.get(Z);
          Dt.__useDefaultFramebuffer !== void 0
            ? (fe.bindFramebuffer(te.FRAMEBUFFER, null), (Pe = !1))
            : Dt.__webglFramebuffer === void 0
            ? Ue.setupRenderTarget(Z)
            : Dt.__hasExternalTextures &&
              Ue.rebindTextures(
                Z,
                Se.get(Z.texture).__webglTexture,
                Se.get(Z.depthTexture).__webglTexture
              );
          const Ht = Z.texture;
          (Ht.isData3DTexture ||
            Ht.isDataArrayTexture ||
            Ht.isCompressedArrayTexture) &&
            (wt = !0);
          const tt = Se.get(Z).__webglFramebuffer;
          Z.isWebGLCubeRenderTarget
            ? (Array.isArray(tt[be]) ? (Le = tt[be][Fe]) : (Le = tt[be]),
              (ft = !0))
            : Z.samples > 0 && Ue.useMultisampledRTT(Z) === !1
            ? (Le = Se.get(Z).__webglMultisampledFramebuffer)
            : Array.isArray(tt)
            ? (Le = tt[Fe])
            : (Le = tt),
            C.copy(Z.viewport),
            L.copy(Z.scissor),
            (O = Z.scissorTest);
        } else
          C.copy(V).multiplyScalar(j).floor(),
            L.copy(k).multiplyScalar(j).floor(),
            (O = W);
        if (
          (fe.bindFramebuffer(te.FRAMEBUFFER, Le) &&
            Pe &&
            fe.drawBuffers(Z, Le),
          fe.viewport(C),
          fe.scissor(L),
          fe.setScissorTest(O),
          ft)
        ) {
          const Dt = Se.get(Z.texture);
          te.framebufferTexture2D(
            te.FRAMEBUFFER,
            te.COLOR_ATTACHMENT0,
            te.TEXTURE_CUBE_MAP_POSITIVE_X + be,
            Dt.__webglTexture,
            Fe
          );
        } else if (wt) {
          const Dt = Se.get(Z.texture),
            Ht = be || 0;
          te.framebufferTextureLayer(
            te.FRAMEBUFFER,
            te.COLOR_ATTACHMENT0,
            Dt.__webglTexture,
            Fe || 0,
            Ht
          );
        }
        N = -1;
      }),
      (this.readRenderTargetPixels = function (Z, be, Fe, Pe, Le, ft, wt) {
        if (!(Z && Z.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let bt = Se.get(Z).__webglFramebuffer;
        if ((Z.isWebGLCubeRenderTarget && wt !== void 0 && (bt = bt[wt]), bt)) {
          fe.bindFramebuffer(te.FRAMEBUFFER, bt);
          try {
            const Dt = Z.texture,
              Ht = Dt.format,
              tt = Dt.type;
            if (!me.textureFormatReadable(Ht)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!me.textureTypeReadable(tt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            be >= 0 &&
              be <= Z.width - Pe &&
              Fe >= 0 &&
              Fe <= Z.height - Le &&
              te.readPixels(be, Fe, Pe, Le, Ke.convert(Ht), Ke.convert(tt), ft);
          } finally {
            const Dt = M !== null ? Se.get(M).__webglFramebuffer : null;
            fe.bindFramebuffer(te.FRAMEBUFFER, Dt);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (Z, be, Fe = 0) {
        const Pe = Math.pow(2, -Fe),
          Le = Math.floor(be.image.width * Pe),
          ft = Math.floor(be.image.height * Pe);
        Ue.setTexture2D(be, 0),
          te.copyTexSubImage2D(te.TEXTURE_2D, Fe, 0, 0, Z.x, Z.y, Le, ft),
          fe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (Z, be, Fe, Pe = 0) {
        const Le = be.image.width,
          ft = be.image.height,
          wt = Ke.convert(Fe.format),
          bt = Ke.convert(Fe.type);
        Ue.setTexture2D(Fe, 0),
          te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL, Fe.flipY),
          te.pixelStorei(
            te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Fe.premultiplyAlpha
          ),
          te.pixelStorei(te.UNPACK_ALIGNMENT, Fe.unpackAlignment),
          be.isDataTexture
            ? te.texSubImage2D(
                te.TEXTURE_2D,
                Pe,
                Z.x,
                Z.y,
                Le,
                ft,
                wt,
                bt,
                be.image.data
              )
            : be.isCompressedTexture
            ? te.compressedTexSubImage2D(
                te.TEXTURE_2D,
                Pe,
                Z.x,
                Z.y,
                be.mipmaps[0].width,
                be.mipmaps[0].height,
                wt,
                be.mipmaps[0].data
              )
            : te.texSubImage2D(te.TEXTURE_2D, Pe, Z.x, Z.y, wt, bt, be.image),
          Pe === 0 && Fe.generateMipmaps && te.generateMipmap(te.TEXTURE_2D),
          fe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (Z, be, Fe, Pe, Le = 0) {
        const ft = Z.max.x - Z.min.x,
          wt = Z.max.y - Z.min.y,
          bt = Z.max.z - Z.min.z,
          Dt = Ke.convert(Pe.format),
          Ht = Ke.convert(Pe.type);
        let tt;
        if (Pe.isData3DTexture) Ue.setTexture3D(Pe, 0), (tt = te.TEXTURE_3D);
        else if (Pe.isDataArrayTexture || Pe.isCompressedArrayTexture)
          Ue.setTexture2DArray(Pe, 0), (tt = te.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL, Pe.flipY),
          te.pixelStorei(
            te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Pe.premultiplyAlpha
          ),
          te.pixelStorei(te.UNPACK_ALIGNMENT, Pe.unpackAlignment);
        const Vt = te.getParameter(te.UNPACK_ROW_LENGTH),
          Un = te.getParameter(te.UNPACK_IMAGE_HEIGHT),
          Nn = te.getParameter(te.UNPACK_SKIP_PIXELS),
          Tr = te.getParameter(te.UNPACK_SKIP_ROWS),
          bi = te.getParameter(te.UNPACK_SKIP_IMAGES),
          en = Fe.isCompressedTexture ? Fe.mipmaps[Le] : Fe.image;
        te.pixelStorei(te.UNPACK_ROW_LENGTH, en.width),
          te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, en.height),
          te.pixelStorei(te.UNPACK_SKIP_PIXELS, Z.min.x),
          te.pixelStorei(te.UNPACK_SKIP_ROWS, Z.min.y),
          te.pixelStorei(te.UNPACK_SKIP_IMAGES, Z.min.z),
          Fe.isDataTexture || Fe.isData3DTexture
            ? te.texSubImage3D(
                tt,
                Le,
                be.x,
                be.y,
                be.z,
                ft,
                wt,
                bt,
                Dt,
                Ht,
                en.data
              )
            : Pe.isCompressedArrayTexture
            ? te.compressedTexSubImage3D(
                tt,
                Le,
                be.x,
                be.y,
                be.z,
                ft,
                wt,
                bt,
                Dt,
                en.data
              )
            : te.texSubImage3D(
                tt,
                Le,
                be.x,
                be.y,
                be.z,
                ft,
                wt,
                bt,
                Dt,
                Ht,
                en
              ),
          te.pixelStorei(te.UNPACK_ROW_LENGTH, Vt),
          te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, Un),
          te.pixelStorei(te.UNPACK_SKIP_PIXELS, Nn),
          te.pixelStorei(te.UNPACK_SKIP_ROWS, Tr),
          te.pixelStorei(te.UNPACK_SKIP_IMAGES, bi),
          Le === 0 && Pe.generateMipmaps && te.generateMipmap(tt),
          fe.unbindTexture();
      }),
      (this.initTexture = function (Z) {
        Z.isCubeTexture
          ? Ue.setTextureCube(Z, 0)
          : Z.isData3DTexture
          ? Ue.setTexture3D(Z, 0)
          : Z.isDataArrayTexture || Z.isCompressedArrayTexture
          ? Ue.setTexture2DArray(Z, 0)
          : Ue.setTexture2D(Z, 0),
          fe.unbindTexture();
      }),
      (this.resetState = function () {
        (T = 0), (E = 0), (M = null), fe.reset(), it.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Do;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === m_ ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        bn.workingColorSpace === d0 ? "display-p3" : "srgb");
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class x_ {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new pt(e)),
      (this.density = t);
  }
  clone() {
    return new x_(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class __ {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new pt(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new __(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class f1 extends xn {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new ao()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new ao()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class g0 {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Dh),
      (this._updateRange = { offset: 0, count: -1 }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = io());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      dk(
        "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = io()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = io()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Ki = new Q();
class Vc {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Ki.fromBufferAttribute(this, t),
        Ki.applyMatrix4(e),
        this.setXYZ(t, Ki.x, Ki.y, Ki.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Ki.fromBufferAttribute(this, t),
        Ki.applyNormalMatrix(e),
        this.setXYZ(t, Ki.x, Ki.y, Ki.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Ki.fromBufferAttribute(this, t),
        Ki.transformDirection(e),
        this.setXYZ(t, Ki.x, Ki.y, Ki.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = Ji(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = Jt(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Jt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Ji(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Jt(t, this.array)), (r = Jt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Jt(t, this.array)),
        (r = Jt(r, this.array)),
        (i = Jt(i, this.array)),
        (s = Jt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new Mn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Vc(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class S_ extends oi {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let wf;
const am = new Q(),
  bf = new Q(),
  Ef = new Q(),
  Mf = new He(),
  lm = new He(),
  Mk = new Ut(),
  ay = new Q(),
  cm = new Q(),
  ly = new Q(),
  pI = new He(),
  Sw = new He(),
  mI = new He();
class Tk extends xn {
  constructor(e = new S_()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), wf === void 0)
    ) {
      wf = new qt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new g0(t, 5);
      wf.setIndex([0, 1, 2, 0, 2, 3]),
        wf.setAttribute("position", new Vc(r, 3, 0, !1)),
        wf.setAttribute("uv", new Vc(r, 2, 3, !1));
    }
    (this.geometry = wf), (this.material = e), (this.center = new He(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      bf.setFromMatrixScale(this.matrixWorld),
      Mk.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Ef.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        bf.multiplyScalar(-Ef.z);
    const r = this.material.rotation;
    let i, s;
    r !== 0 && ((s = Math.cos(r)), (i = Math.sin(r)));
    const o = this.center;
    cy(ay.set(-0.5, -0.5, 0), Ef, o, bf, i, s),
      cy(cm.set(0.5, -0.5, 0), Ef, o, bf, i, s),
      cy(ly.set(0.5, 0.5, 0), Ef, o, bf, i, s),
      pI.set(0, 0),
      Sw.set(1, 0),
      mI.set(1, 1);
    let a = e.ray.intersectTriangle(ay, cm, ly, !1, am);
    if (
      a === null &&
      (cy(cm.set(-0.5, 0.5, 0), Ef, o, bf, i, s),
      Sw.set(0, 1),
      (a = e.ray.intersectTriangle(ay, ly, cm, !1, am)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(am);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: am.clone(),
        uv: qs.getInterpolation(am, ay, cm, ly, pI, Sw, mI, new He()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function cy(n, e, t, r, i, s) {
  Mf.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((lm.x = s * Mf.x - i * Mf.y), (lm.y = i * Mf.x + s * Mf.y))
      : lm.copy(Mf),
    n.copy(e),
    (n.x += lm.x),
    (n.y += lm.y),
    n.applyMatrix4(Mk);
}
const uy = new Q(),
  gI = new Q();
class Ck extends xn {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(t < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let s = t[r].distance;
        if ((t[r].object.visible && (s -= s * t[r].hysteresis), e < s)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      uy.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(uy);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      uy.setFromMatrixPosition(e.matrixWorld),
        gI.setFromMatrixPosition(this.matrixWorld);
      const r = uy.distanceTo(gI) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s; i++) {
        let o = t[i].distance;
        if ((t[i].object.visible && (o -= o * t[i].hysteresis), r >= o))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const vI = new Q(),
  yI = new rn(),
  xI = new rn(),
  Kq = new Q(),
  _I = new Ut(),
  dy = new Q(),
  Aw = new mi(),
  SI = new Ut(),
  ww = new Id();
class Rk extends qn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = BE),
      (this.bindMatrix = new Ut()),
      (this.bindMatrixInverse = new Ut()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new zi()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, dy), this.boundingBox.expandByPoint(dy);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new mi()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, dy), this.boundingSphere.expandByPoint(dy);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Aw.copy(this.boundingSphere),
      Aw.applyMatrix4(i),
      e.ray.intersectsSphere(Aw) !== !1 &&
        (SI.copy(i).invert(),
        ww.copy(e.ray).applyMatrix4(SI),
        !(
          this.boundingBox !== null && ww.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, ww)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new rn(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === BE
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === V4
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    yI.fromBufferAttribute(i.attributes.skinIndex, e),
      xI.fromBufferAttribute(i.attributes.skinWeight, e),
      vI.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = xI.getComponent(s);
      if (o !== 0) {
        const a = yI.getComponent(s);
        _I.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          t.addScaledVector(Kq.copy(vI).applyMatrix4(_I), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class f2 extends xn {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Dc extends Fr {
  constructor(e = null, t = 1, r = 1, i, s, o, a, l, c = Dr, u = Dr, d, h) {
    super(null, o, a, l, c, u, i, s, d, h),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const AI = new Ut(),
  Zq = new Ut();
class A_ {
  constructor(e = [], t = []) {
    (this.uuid = io()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Ut());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Ut();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : Zq;
      AI.multiplyMatrices(a, t[s]), AI.toArray(r, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new A_(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new Dc(t, e, e, ys, Qs);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const s = e.bones[r];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new f2())),
        this.bones.push(o),
        this.boneInverses.push(new Ut().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Hc extends Mn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Tf = new Ut(),
  wI = new Ut(),
  fy = [],
  bI = new zi(),
  Qq = new Ut(),
  um = new qn(),
  dm = new mi();
class Nk extends qn {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Hc(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, Qq);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new zi()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Tf),
        bI.copy(e.boundingBox).applyMatrix4(Tf),
        this.boundingBox.union(bI);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new mi()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, Tf),
        dm.copy(e.boundingSphere).applyMatrix4(Tf),
        this.boundingSphere.union(dm);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      s = r.length + 1,
      o = e * s + 1;
    for (let a = 0; a < r.length; a++) r[a] = i[o + a];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((um.geometry = this.geometry),
      (um.material = this.material),
      um.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        dm.copy(this.boundingSphere),
        dm.applyMatrix4(r),
        e.ray.intersectsSphere(dm) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, Tf),
          wI.multiplyMatrices(r, Tf),
          (um.matrixWorld = wI),
          um.raycast(e, fy);
        for (let o = 0, a = fy.length; o < a; o++) {
          const l = fy[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        fy.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Hc(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Dc(
        new Float32Array(i * this.count),
        i,
        this.count,
        KC,
        Qs
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < r.length; c++) o += r[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = i * e;
    (s[l] = a), s.set(r, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    );
  }
}
function Jq(n, e) {
  return n.z - e.z;
}
function eK(n, e) {
  return e.z - n.z;
}
class tK {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t) {
    const r = this.pool,
      i = this.list;
    this.index >= r.length && r.push({ start: -1, count: -1, z: -1 });
    const s = r[this.index];
    i.push(s),
      this.index++,
      (s.start = e.start),
      (s.count = e.count),
      (s.z = t);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const Cf = "batchId",
  uc = new Ut(),
  EI = new Ut(),
  nK = new Ut(),
  MI = new Ut(),
  bw = new m0(),
  hy = new zi(),
  wu = new mi(),
  fm = new Q(),
  Ew = new tK(),
  Oi = new qn(),
  py = [];
function rK(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const i = n.count;
    for (let s = 0; s < i; s++)
      for (let o = 0; o < r; o++)
        e.setComponent(s + t, o, n.getComponent(s, o));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
class Pk extends qn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, r = t * 2, i) {
    super(new qt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._drawRanges = []),
      (this._reservedRanges = []),
      (this._visibility = []),
      (this._active = []),
      (this._bounds = []),
      (this._maxGeometryCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._geometryInitialized = !1),
      (this._geometryCount = 0),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._visibilityChanged = !0),
      (this._matricesTexture = null),
      this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new Dc(t, e, e, ys, Qs);
    this._matricesTexture = r;
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      i = this._maxGeometryCount,
      s = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a),
          { array: c, itemSize: u, normalized: d } = l,
          h = new c.constructor(r * u),
          m = new Mn(h, u, d);
        t.setAttribute(a, m);
      }
      if (e.getIndex() !== null) {
        const a = r > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new Mn(a, 1));
      }
      const o = i > 65536 ? new Uint32Array(r) : new Uint16Array(r);
      t.setAttribute(Cf, new Mn(o, 1)), (this._geometryInitialized = !0);
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(Cf))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${Cf}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (r === Cf) continue;
      if (!e.hasAttribute(r))
        throw new Error(
          `BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        s = t.getAttribute(r);
      if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new zi());
    const e = this._geometryCount,
      t = this.boundingBox,
      r = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, uc),
        this.getBoundingBoxAt(i, hy).applyMatrix4(uc),
        t.union(hy));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi());
    const e = this._geometryCount,
      t = this.boundingSphere,
      r = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      r[i] !== !1 &&
        (this.getMatrixAt(i, uc),
        this.getBoundingSphereAt(i, wu).applyMatrix4(uc),
        t.union(wu));
  }
  addGeometry(e, t = -1, r = -1) {
    if (
      (this._initializeGeometry(e),
      this._validateGeometry(e),
      this._geometryCount >= this._maxGeometryCount)
    )
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let s = null;
    const o = this._reservedRanges,
      a = this._drawRanges,
      l = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]),
      t === -1
        ? (i.vertexCount = e.getAttribute("position").count)
        : (i.vertexCount = t),
      s === null
        ? (i.vertexStart = 0)
        : (i.vertexStart = s.vertexStart + s.vertexCount);
    const c = e.getIndex(),
      u = c !== null;
    if (
      (u &&
        (r === -1 ? (i.indexCount = c.count) : (i.indexCount = r),
        s === null
          ? (i.indexStart = 0)
          : (i.indexStart = s.indexStart + s.indexCount)),
      (i.indexStart !== -1 &&
        i.indexStart + i.indexCount > this._maxIndexCount) ||
        i.vertexStart + i.vertexCount > this._maxVertexCount)
    )
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    const d = this._visibility,
      h = this._active,
      m = this._matricesTexture,
      g = this._matricesTexture.image.data;
    d.push(!0), h.push(!0);
    const x = this._geometryCount;
    this._geometryCount++,
      nK.toArray(g, x * 16),
      (m.needsUpdate = !0),
      o.push(i),
      a.push({ start: u ? i.indexStart : i.vertexStart, count: -1 }),
      l.push({
        boxInitialized: !1,
        box: new zi(),
        sphereInitialized: !1,
        sphere: new mi(),
      });
    const y = this.geometry.getAttribute(Cf);
    for (let v = 0; v < i.vertexCount; v++) y.setX(i.vertexStart + v, x);
    return (y.needsUpdate = !0), this.setGeometryAt(x, e), x;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      i = r.getIndex() !== null,
      s = r.getIndex(),
      o = t.getIndex(),
      a = this._reservedRanges[e];
    if (
      (i && o.count > a.indexCount) ||
      t.attributes.position.count > a.vertexCount
    )
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = a.vertexStart,
      c = a.vertexCount;
    for (const m in r.attributes) {
      if (m === Cf) continue;
      const g = t.getAttribute(m),
        x = r.getAttribute(m);
      rK(g, x, l);
      const y = g.itemSize;
      for (let v = g.count, _ = c; v < _; v++) {
        const S = l + v;
        for (let w = 0; w < y; w++) x.setComponent(S, w, 0);
      }
      (x.needsUpdate = !0), x.addUpdateRange(l * y, c * y);
    }
    if (i) {
      const m = a.indexStart;
      for (let g = 0; g < o.count; g++) s.setX(m + g, l + o.getX(g));
      for (let g = o.count, x = a.indexCount; g < x; g++) s.setX(m + g, l);
      (s.needsUpdate = !0), s.addUpdateRange(m, a.indexCount);
    }
    const u = this._bounds[e];
    t.boundingBox !== null
      ? (u.box.copy(t.boundingBox), (u.boxInitialized = !0))
      : (u.boxInitialized = !1),
      t.boundingSphere !== null
        ? (u.sphere.copy(t.boundingSphere), (u.sphereInitialized = !0))
        : (u.sphereInitialized = !1);
    const d = this._drawRanges[e],
      h = t.getAttribute("position");
    return (d.count = i ? o.count : h.count), (this._visibilityChanged = !0), e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1
      ? this
      : ((t[e] = !1), (this._visibilityChanged = !0), this);
  }
  getInstanceCountAt(e) {
    return this._multiDrawInstances === null
      ? null
      : this._multiDrawInstances[e];
  }
  setInstanceCountAt(e, t) {
    return (
      this._multiDrawInstances === null &&
        (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(
          1
        )),
      (this._multiDrawInstances[e] = t),
      e
    );
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1) return null;
    const i = this._bounds[e],
      s = i.box,
      o = this.geometry;
    if (i.boxInitialized === !1) {
      s.makeEmpty();
      const a = o.index,
        l = o.attributes.position,
        c = this._drawRanges[e];
      for (let u = c.start, d = c.start + c.count; u < d; u++) {
        let h = u;
        a && (h = a.getX(h)), s.expandByPoint(fm.fromBufferAttribute(l, h));
      }
      i.boxInitialized = !0;
    }
    return t.copy(s), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1) return null;
    const i = this._bounds[e],
      s = i.sphere,
      o = this.geometry;
    if (i.sphereInitialized === !1) {
      s.makeEmpty(), this.getBoundingBoxAt(e, hy), hy.getCenter(s.center);
      const a = o.index,
        l = o.attributes.position,
        c = this._drawRanges[e];
      let u = 0;
      for (let d = c.start, h = c.start + c.count; d < h; d++) {
        let m = d;
        a && (m = a.getX(m)),
          fm.fromBufferAttribute(l, m),
          (u = Math.max(u, s.center.distanceToSquared(fm)));
      }
      (s.radius = Math.sqrt(u)), (i.sphereInitialized = !0);
    }
    return t.copy(s), t;
  }
  setMatrixAt(e, t) {
    const r = this._active,
      i = this._matricesTexture,
      s = this._matricesTexture.image.data,
      o = this._geometryCount;
    return e >= o || r[e] === !1
      ? this
      : (t.toArray(s, e * 16), (i.needsUpdate = !0), this);
  }
  getMatrixAt(e, t) {
    const r = this._active,
      i = this._matricesTexture.image.data,
      s = this._geometryCount;
    return e >= s || r[e] === !1 ? null : t.fromArray(i, e * 16);
  }
  setVisibleAt(e, t) {
    const r = this._visibility,
      i = this._active,
      s = this._geometryCount;
    return e >= s || i[e] === !1 || r[e] === t
      ? this
      : ((r[e] = t), (this._visibilityChanged = !0), this);
  }
  getVisibleAt(e) {
    const t = this._visibility,
      r = this._active,
      i = this._geometryCount;
    return e >= i || r[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const r = this._visibility,
      i = this._active,
      s = this._drawRanges,
      o = this._geometryCount,
      a = this.matrixWorld,
      l = this.geometry;
    (Oi.material = this.material),
      (Oi.geometry.index = l.index),
      (Oi.geometry.attributes = l.attributes),
      Oi.geometry.boundingBox === null && (Oi.geometry.boundingBox = new zi()),
      Oi.geometry.boundingSphere === null &&
        (Oi.geometry.boundingSphere = new mi());
    for (let c = 0; c < o; c++) {
      if (!r[c] || !i[c]) continue;
      const u = s[c];
      Oi.geometry.setDrawRange(u.start, u.count),
        this.getMatrixAt(c, Oi.matrixWorld).premultiply(a),
        this.getBoundingBoxAt(c, Oi.geometry.boundingBox),
        this.getBoundingSphereAt(c, Oi.geometry.boundingSphere),
        Oi.raycast(e, py);
      for (let d = 0, h = py.length; d < h; d++) {
        const m = py[d];
        (m.object = this), (m.batchId = c), t.push(m);
      }
      py.length = 0;
    }
    (Oi.material = null),
      (Oi.geometry.index = null),
      (Oi.geometry.attributes = {}),
      Oi.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
      (this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
      (this._visibility = e._visibility.slice()),
      (this._active = e._active.slice()),
      (this._bounds = e._bounds.map((t) => ({
        boxInitialized: t.boxInitialized,
        box: t.box.clone(),
        sphereInitialized: t.sphereInitialized,
        sphere: t.sphere.clone(),
      }))),
      (this._maxGeometryCount = e._maxGeometryCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._geometryCount = e._geometryCount),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data = this._matricesTexture.image.slice()),
      this
    );
  }
  dispose() {
    return (
      this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this
    );
  }
  onBeforeRender(e, t, r, i, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = i.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      l = this._active,
      c = this._visibility,
      u = this._multiDrawStarts,
      d = this._multiDrawCounts,
      h = this._drawRanges,
      m = this.perObjectFrustumCulled;
    m &&
      (MI.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse).multiply(
        this.matrixWorld
      ),
      bw.setFromProjectionMatrix(MI, e.coordinateSystem));
    let g = 0;
    if (this.sortObjects) {
      EI.copy(this.matrixWorld).invert(),
        fm.setFromMatrixPosition(r.matrixWorld).applyMatrix4(EI);
      for (let v = 0, _ = c.length; v < _; v++)
        if (c[v] && l[v]) {
          this.getMatrixAt(v, uc),
            this.getBoundingSphereAt(v, wu).applyMatrix4(uc);
          let S = !1;
          if ((m && (S = !bw.intersectsSphere(wu)), !S)) {
            const w = fm.distanceTo(wu.center);
            Ew.push(h[v], w);
          }
        }
      const x = Ew.list,
        y = this.customSort;
      y === null ? x.sort(s.transparent ? eK : Jq) : y.call(this, x, r);
      for (let v = 0, _ = x.length; v < _; v++) {
        const S = x[v];
        (u[g] = S.start * a), (d[g] = S.count), g++;
      }
      Ew.reset();
    } else
      for (let x = 0, y = c.length; x < y; x++)
        if (c[x] && l[x]) {
          let v = !1;
          if (
            (m &&
              (this.getMatrixAt(x, uc),
              this.getBoundingSphereAt(x, wu).applyMatrix4(uc),
              (v = !bw.intersectsSphere(wu))),
            !v)
          ) {
            const _ = h[x];
            (u[g] = _.start * a), (d[g] = _.count), g++;
          }
        }
    (this._multiDrawCount = g), (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, i, s, o) {
    this.onBeforeRender(e, null, i, s, o);
  }
}
class Hi extends oi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const h1 = new Q(),
  p1 = new Q(),
  TI = new Ut(),
  hm = new Id(),
  my = new mi(),
  Mw = new Q(),
  CI = new Q();
class Gc extends xn {
  constructor(e = new qt(), t = new Hi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, s = t.count; i < s; i++)
        h1.fromBufferAttribute(t, i - 1),
          p1.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += h1.distanceTo(p1));
      e.setAttribute("lineDistance", new At(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      my.copy(r.boundingSphere),
      my.applyMatrix4(i),
      (my.radius += s),
      e.ray.intersectsSphere(my) === !1)
    )
      return;
    TI.copy(i).invert(), hm.copy(e.ray).applyMatrix4(TI);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = r.index,
      h = r.attributes.position;
    if (u !== null) {
      const m = Math.max(0, o.start),
        g = Math.min(u.count, o.start + o.count);
      for (let x = m, y = g - 1; x < y; x += c) {
        const v = u.getX(x),
          _ = u.getX(x + 1),
          S = gy(this, e, hm, l, v, _);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const x = u.getX(g - 1),
          y = u.getX(m),
          v = gy(this, e, hm, l, x, y);
        v && t.push(v);
      }
    } else {
      const m = Math.max(0, o.start),
        g = Math.min(h.count, o.start + o.count);
      for (let x = m, y = g - 1; x < y; x += c) {
        const v = gy(this, e, hm, l, x, x + 1);
        v && t.push(v);
      }
      if (this.isLineLoop) {
        const x = gy(this, e, hm, l, g - 1, m);
        x && t.push(x);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function gy(n, e, t, r, i, s) {
  const o = n.geometry.attributes.position;
  if (
    (h1.fromBufferAttribute(o, i),
    p1.fromBufferAttribute(o, s),
    t.distanceSqToSegment(h1, p1, Mw, CI) > r)
  )
    return;
  Mw.applyMatrix4(n.matrixWorld);
  const l = e.ray.origin.distanceTo(Mw);
  if (!(l < e.near || l > e.far))
    return {
      distance: l,
      point: CI.clone().applyMatrix4(n.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: n,
    };
}
const RI = new Q(),
  NI = new Q();
class Qa extends Gc {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        RI.fromBufferAttribute(t, i),
          NI.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + RI.distanceTo(NI));
      e.setAttribute("lineDistance", new At(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class Ik extends Gc {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class v0 extends oi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const PI = new Ut(),
  vM = new Id(),
  vy = new mi(),
  yy = new Q();
class Lk extends xn {
  constructor(e = new qt(), t = new v0()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      vy.copy(r.boundingSphere),
      vy.applyMatrix4(i),
      (vy.radius += s),
      e.ray.intersectsSphere(vy) === !1)
    )
      return;
    PI.copy(i).invert(), vM.copy(e.ray).applyMatrix4(PI);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = r.index,
      d = r.attributes.position;
    if (c !== null) {
      const h = Math.max(0, o.start),
        m = Math.min(c.count, o.start + o.count);
      for (let g = h, x = m; g < x; g++) {
        const y = c.getX(g);
        yy.fromBufferAttribute(d, y), II(yy, y, l, i, e, t, this);
      }
    } else {
      const h = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let g = h, x = m; g < x; g++)
        yy.fromBufferAttribute(d, g), II(yy, g, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function II(n, e, t, r, i, s, o) {
  const a = vM.distanceSqToPoint(n);
  if (a < t) {
    const l = new Q();
    vM.closestPointToPoint(n, l), l.applyMatrix4(r);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class iK extends Fr {
  constructor(e, t, r, i, s, o, a, l, c) {
    super(e, t, r, i, s, o, a, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : dr),
      (this.magFilter = s !== void 0 ? s : dr),
      (this.generateMipmaps = !1);
    const u = this;
    function d() {
      (u.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class h2 extends Fr {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = Dr),
      (this.minFilter = Dr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class w_ extends Fr {
  constructor(e, t, r, i, s, o, a, l, c, u, d, h) {
    super(null, o, a, l, c, u, i, s, d, h),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class sK extends w_ {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Oo);
  }
}
class oK extends w_ {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, Dl),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class aK extends Fr {
  constructor(e, t, r, i, s, o, a, l, c) {
    super(e, t, r, i, s, o, a, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Aa {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (r = this.getPoint(o / e)), (s += r.distanceTo(i)), t.push(s), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const s = r.length;
    let o;
    t ? (o = t) : (o = e * r[s - 1]);
    let a = 0,
      l = s - 1,
      c;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (c = r[i] - o), c < 0)) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === o)) return i / (s - 1);
    const u = r[i],
      h = r[i + 1] - u,
      m = (o - u) / h;
    return (i + m) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const o = this.getPoint(i),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new He() : new Q());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new Q(),
      i = [],
      s = [],
      o = [],
      a = new Q(),
      l = new Ut();
    for (let m = 0; m <= e; m++) {
      const g = m / e;
      i[m] = this.getTangentAt(g, new Q());
    }
    (s[0] = new Q()), (o[0] = new Q());
    let c = Number.MAX_VALUE;
    const u = Math.abs(i[0].x),
      d = Math.abs(i[0].y),
      h = Math.abs(i[0].z);
    u <= c && ((c = u), r.set(1, 0, 0)),
      d <= c && ((c = d), r.set(0, 1, 0)),
      h <= c && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      s[0].crossVectors(i[0], a),
      o[0].crossVectors(i[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(i[m - 1], i[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const g = Math.acos(ur(i[m - 1].dot(i[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, g));
      }
      o[m].crossVectors(i[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(ur(s[0].dot(s[e]), -1, 1));
      (m /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let g = 1; g <= e; g++)
        s[g].applyMatrix4(l.makeRotationAxis(i[g], m * g)),
          o[g].crossVectors(i[g], s[g]);
    }
    return { tangents: i, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class b_ extends Aa {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t = new He()) {
    const r = t,
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (o ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !o && (s === i ? (s = -i) : (s = s - i));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        h = l - this.aX,
        m = c - this.aY;
      (l = h * u - m * d + this.aX), (c = h * d + m * u + this.aY);
    }
    return r.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class Ok extends b_ {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, r, i, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function p2() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (r = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, c) {
      i(o, a, c * (a - s), c * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, c, u, d) {
      let h = (o - s) / c - (a - s) / (c + u) + (a - o) / u,
        m = (a - o) / u - (l - o) / (u + d) + (l - a) / d;
      (h *= u), (m *= u), i(o, a, h, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + r * a;
    },
  };
}
const xy = new Q(),
  Tw = new p2(),
  Cw = new p2(),
  Rw = new p2();
class Dk extends Aa {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new Q()) {
    const r = t,
      i = this.points,
      s = i.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let c, u;
    this.closed || a > 0
      ? (c = i[(a - 1) % s])
      : (xy.subVectors(i[0], i[1]).add(i[0]), (c = xy));
    const d = i[a % s],
      h = i[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (u = i[(a + 2) % s])
        : (xy.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (u = xy)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let g = Math.pow(c.distanceToSquared(d), m),
        x = Math.pow(d.distanceToSquared(h), m),
        y = Math.pow(h.distanceToSquared(u), m);
      x < 1e-4 && (x = 1),
        g < 1e-4 && (g = x),
        y < 1e-4 && (y = x),
        Tw.initNonuniformCatmullRom(c.x, d.x, h.x, u.x, g, x, y),
        Cw.initNonuniformCatmullRom(c.y, d.y, h.y, u.y, g, x, y),
        Rw.initNonuniformCatmullRom(c.z, d.z, h.z, u.z, g, x, y);
    } else
      this.curveType === "catmullrom" &&
        (Tw.initCatmullRom(c.x, d.x, h.x, u.x, this.tension),
        Cw.initCatmullRom(c.y, d.y, h.y, u.y, this.tension),
        Rw.initCatmullRom(c.z, d.z, h.z, u.z, this.tension));
    return r.set(Tw.calc(l), Cw.calc(l), Rw.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new Q().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function LI(n, e, t, r, i) {
  const s = (r - e) * 0.5,
    o = (i - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * r + s + o) * l + (-3 * t + 3 * r - 2 * s - o) * a + s * n + t
  );
}
function lK(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function cK(n, e) {
  return 2 * (1 - n) * n * e;
}
function uK(n, e) {
  return n * n * e;
}
function $m(n, e, t, r) {
  return lK(n, e) + cK(n, t) + uK(n, r);
}
function dK(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function fK(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function hK(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function pK(n, e) {
  return n * n * n * e;
}
function Xm(n, e, t, r, i) {
  return dK(n, e) + fK(n, t) + hK(n, r) + pK(n, i);
}
class m2 extends Aa {
  constructor(e = new He(), t = new He(), r = new He(), i = new He()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new He()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return r.set(Xm(e, i.x, s.x, o.x, a.x), Xm(e, i.y, s.y, o.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Fk extends Aa {
  constructor(e = new Q(), t = new Q(), r = new Q(), i = new Q()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new Q()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      r.set(
        Xm(e, i.x, s.x, o.x, a.x),
        Xm(e, i.y, s.y, o.y, a.y),
        Xm(e, i.z, s.z, o.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class g2 extends Aa {
  constructor(e = new He(), t = new He()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new He()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new He()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Uk extends Aa {
  constructor(e = new Q(), t = new Q()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new Q()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Q()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class v2 extends Aa {
  constructor(e = new He(), t = new He(), r = new He()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new He()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return r.set($m(e, i.x, s.x, o.x), $m(e, i.y, s.y, o.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class y2 extends Aa {
  constructor(e = new Q(), t = new Q(), r = new Q()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new Q()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      r.set($m(e, i.x, s.x, o.x), $m(e, i.y, s.y, o.y), $m(e, i.z, s.z, o.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class x2 extends Aa {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new He()) {
    const r = t,
      i = this.points,
      s = (i.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = i[o === 0 ? o : o - 1],
      c = i[o],
      u = i[o > i.length - 2 ? i.length - 1 : o + 1],
      d = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return r.set(LI(a, l.x, c.x, u.x, d.x), LI(a, l.y, c.y, u.y, d.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new He().fromArray(i));
    }
    return this;
  }
}
var m1 = Object.freeze({
  __proto__: null,
  ArcCurve: Ok,
  CatmullRomCurve3: Dk,
  CubicBezierCurve: m2,
  CubicBezierCurve3: Fk,
  EllipseCurve: b_,
  LineCurve: g2,
  LineCurve3: Uk,
  QuadraticBezierCurve: v2,
  QuadraticBezierCurve3: y2,
  SplineCurve: x2,
});
class kk extends Aa {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new m1[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= r) {
        const o = i[s] - r,
          a = this.curves[s],
          l = a.getLength(),
          c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const o = s[i],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        (r && r.equals(u)) || (t.push(u), (r = u));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new m1[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Ig extends kk {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new He()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new g2(this.currentPoint.clone(), new He(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const s = new v2(this.currentPoint.clone(), new He(e, t), new He(r, i));
    return this.curves.push(s), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    const a = new m2(
      this.currentPoint.clone(),
      new He(e, t),
      new He(r, i),
      new He(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new x2(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, r, i, s, o), this;
  }
  absarc(e, t, r, i, s, o) {
    return this.absellipse(e, t, r, r, i, s, o), this;
  }
  ellipse(e, t, r, i, s, o, a, l) {
    const c = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, r, i, s, o, a, l), this;
  }
  absellipse(e, t, r, i, s, o, a, l) {
    const c = new b_(e, t, r, i, s, o, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class y0 extends qt {
  constructor(
    e = [new He(0, -0.5), new He(0.5, 0), new He(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = ur(i, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = [],
      u = 1 / t,
      d = new Q(),
      h = new He(),
      m = new Q(),
      g = new Q(),
      x = new Q();
    let y = 0,
      v = 0;
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          (y = e[_ + 1].x - e[_].x),
            (v = e[_ + 1].y - e[_].y),
            (m.x = v * 1),
            (m.y = -y),
            (m.z = v * 0),
            x.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(x.x, x.y, x.z);
          break;
        default:
          (y = e[_ + 1].x - e[_].x),
            (v = e[_ + 1].y - e[_].y),
            (m.x = v * 1),
            (m.y = -y),
            (m.z = v * 0),
            g.copy(m),
            (m.x += x.x),
            (m.y += x.y),
            (m.z += x.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            x.copy(g);
      }
    for (let _ = 0; _ <= t; _++) {
      const S = r + _ * u * i,
        w = Math.sin(S),
        T = Math.cos(S);
      for (let E = 0; E <= e.length - 1; E++) {
        (d.x = e[E].x * w),
          (d.y = e[E].y),
          (d.z = e[E].x * T),
          o.push(d.x, d.y, d.z),
          (h.x = _ / t),
          (h.y = E / (e.length - 1)),
          a.push(h.x, h.y);
        const M = l[3 * E + 0] * w,
          N = l[3 * E + 1],
          R = l[3 * E + 0] * T;
        c.push(M, N, R);
      }
    }
    for (let _ = 0; _ < t; _++)
      for (let S = 0; S < e.length - 1; S++) {
        const w = S + _ * e.length,
          T = w,
          E = w + e.length,
          M = w + e.length + 1,
          N = w + 1;
        s.push(T, E, N), s.push(M, N, E);
      }
    this.setIndex(s),
      this.setAttribute("position", new At(o, 3)),
      this.setAttribute("uv", new At(a, 2)),
      this.setAttribute("normal", new At(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new y0(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class E_ extends y0 {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const s = new Ig();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(r), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: t,
        capSegments: r,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new E_(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class M_ extends qt {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = new Q(),
      u = new He();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, h = 3; d <= t; d++, h += 3) {
      const m = r + (d / t) * i;
      (c.x = e * Math.cos(m)),
        (c.y = e * Math.sin(m)),
        o.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (u.x = (o[h] / e + 1) / 2),
        (u.y = (o[h + 1] / e + 1) / 2),
        l.push(u.x, u.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new At(o, 3)),
      this.setAttribute("normal", new At(a, 3)),
      this.setAttribute("uv", new At(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new M_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class ap extends qt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const u = [],
      d = [],
      h = [],
      m = [];
    let g = 0;
    const x = [],
      y = r / 2;
    let v = 0;
    _(),
      o === !1 && (e > 0 && S(!0), t > 0 && S(!1)),
      this.setIndex(u),
      this.setAttribute("position", new At(d, 3)),
      this.setAttribute("normal", new At(h, 3)),
      this.setAttribute("uv", new At(m, 2));
    function _() {
      const w = new Q(),
        T = new Q();
      let E = 0;
      const M = (t - e) / r;
      for (let N = 0; N <= s; N++) {
        const R = [],
          C = N / s,
          L = C * (t - e) + e;
        for (let O = 0; O <= i; O++) {
          const D = O / i,
            B = D * l + a,
            $ = Math.sin(B),
            G = Math.cos(B);
          (T.x = L * $),
            (T.y = -C * r + y),
            (T.z = L * G),
            d.push(T.x, T.y, T.z),
            w.set($, M, G).normalize(),
            h.push(w.x, w.y, w.z),
            m.push(D, 1 - C),
            R.push(g++);
        }
        x.push(R);
      }
      for (let N = 0; N < i; N++)
        for (let R = 0; R < s; R++) {
          const C = x[R][N],
            L = x[R + 1][N],
            O = x[R + 1][N + 1],
            D = x[R][N + 1];
          u.push(C, L, D), u.push(L, O, D), (E += 6);
        }
      c.addGroup(v, E, 0), (v += E);
    }
    function S(w) {
      const T = g,
        E = new He(),
        M = new Q();
      let N = 0;
      const R = w === !0 ? e : t,
        C = w === !0 ? 1 : -1;
      for (let O = 1; O <= i; O++)
        d.push(0, y * C, 0), h.push(0, C, 0), m.push(0.5, 0.5), g++;
      const L = g;
      for (let O = 0; O <= i; O++) {
        const B = (O / i) * l + a,
          $ = Math.cos(B),
          G = Math.sin(B);
        (M.x = R * G),
          (M.y = y * C),
          (M.z = R * $),
          d.push(M.x, M.y, M.z),
          h.push(0, C, 0),
          (E.x = $ * 0.5 + 0.5),
          (E.y = G * 0.5 * C + 0.5),
          m.push(E.x, E.y),
          g++;
      }
      for (let O = 0; O < i; O++) {
        const D = T + O,
          B = L + O;
        w === !0 ? u.push(B, B + 1, D) : u.push(B + 1, B, D), (N += 3);
      }
      c.addGroup(v, N, w === !0 ? 1 : 2), (v += N);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ap(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class T_ extends ap {
  constructor(e = 1, t = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, r, i, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new T_(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Qc extends qt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const s = [],
      o = [];
    a(i),
      c(r),
      u(),
      this.setAttribute("position", new At(s, 3)),
      this.setAttribute("normal", new At(s.slice(), 3)),
      this.setAttribute("uv", new At(o, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(_) {
      const S = new Q(),
        w = new Q(),
        T = new Q();
      for (let E = 0; E < t.length; E += 3)
        m(t[E + 0], S), m(t[E + 1], w), m(t[E + 2], T), l(S, w, T, _);
    }
    function l(_, S, w, T) {
      const E = T + 1,
        M = [];
      for (let N = 0; N <= E; N++) {
        M[N] = [];
        const R = _.clone().lerp(w, N / E),
          C = S.clone().lerp(w, N / E),
          L = E - N;
        for (let O = 0; O <= L; O++)
          O === 0 && N === E
            ? (M[N][O] = R)
            : (M[N][O] = R.clone().lerp(C, O / L));
      }
      for (let N = 0; N < E; N++)
        for (let R = 0; R < 2 * (E - N) - 1; R++) {
          const C = Math.floor(R / 2);
          R % 2 === 0
            ? (h(M[N][C + 1]), h(M[N + 1][C]), h(M[N][C]))
            : (h(M[N][C + 1]), h(M[N + 1][C + 1]), h(M[N + 1][C]));
        }
    }
    function c(_) {
      const S = new Q();
      for (let w = 0; w < s.length; w += 3)
        (S.x = s[w + 0]),
          (S.y = s[w + 1]),
          (S.z = s[w + 2]),
          S.normalize().multiplyScalar(_),
          (s[w + 0] = S.x),
          (s[w + 1] = S.y),
          (s[w + 2] = S.z);
    }
    function u() {
      const _ = new Q();
      for (let S = 0; S < s.length; S += 3) {
        (_.x = s[S + 0]), (_.y = s[S + 1]), (_.z = s[S + 2]);
        const w = y(_) / 2 / Math.PI + 0.5,
          T = v(_) / Math.PI + 0.5;
        o.push(w, 1 - T);
      }
      g(), d();
    }
    function d() {
      for (let _ = 0; _ < o.length; _ += 6) {
        const S = o[_ + 0],
          w = o[_ + 2],
          T = o[_ + 4],
          E = Math.max(S, w, T),
          M = Math.min(S, w, T);
        E > 0.9 &&
          M < 0.1 &&
          (S < 0.2 && (o[_ + 0] += 1),
          w < 0.2 && (o[_ + 2] += 1),
          T < 0.2 && (o[_ + 4] += 1));
      }
    }
    function h(_) {
      s.push(_.x, _.y, _.z);
    }
    function m(_, S) {
      const w = _ * 3;
      (S.x = e[w + 0]), (S.y = e[w + 1]), (S.z = e[w + 2]);
    }
    function g() {
      const _ = new Q(),
        S = new Q(),
        w = new Q(),
        T = new Q(),
        E = new He(),
        M = new He(),
        N = new He();
      for (let R = 0, C = 0; R < s.length; R += 9, C += 6) {
        _.set(s[R + 0], s[R + 1], s[R + 2]),
          S.set(s[R + 3], s[R + 4], s[R + 5]),
          w.set(s[R + 6], s[R + 7], s[R + 8]),
          E.set(o[C + 0], o[C + 1]),
          M.set(o[C + 2], o[C + 3]),
          N.set(o[C + 4], o[C + 5]),
          T.copy(_).add(S).add(w).divideScalar(3);
        const L = y(T);
        x(E, C + 0, _, L), x(M, C + 2, S, L), x(N, C + 4, w, L);
      }
    }
    function x(_, S, w, T) {
      T < 0 && _.x === 1 && (o[S] = _.x - 1),
        w.x === 0 && w.z === 0 && (o[S] = T / 2 / Math.PI + 0.5);
    }
    function y(_) {
      return Math.atan2(_.z, -_.x);
    }
    function v(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Qc(e.vertices, e.indices, e.radius, e.details);
  }
}
class C_ extends Qc {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new C_(e.radius, e.detail);
  }
}
const _y = new Q(),
  Sy = new Q(),
  Nw = new Q(),
  Ay = new qs();
class zk extends qt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        s = Math.cos(od * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        c = [0, 0, 0],
        u = ["a", "b", "c"],
        d = new Array(3),
        h = {},
        m = [];
      for (let g = 0; g < l; g += 3) {
        o
          ? ((c[0] = o.getX(g)), (c[1] = o.getX(g + 1)), (c[2] = o.getX(g + 2)))
          : ((c[0] = g), (c[1] = g + 1), (c[2] = g + 2));
        const { a: x, b: y, c: v } = Ay;
        if (
          (x.fromBufferAttribute(a, c[0]),
          y.fromBufferAttribute(a, c[1]),
          v.fromBufferAttribute(a, c[2]),
          Ay.getNormal(Nw),
          (d[0] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (d[1] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(
            y.z * i
          )}`),
          (d[2] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(
            v.z * i
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let _ = 0; _ < 3; _++) {
            const S = (_ + 1) % 3,
              w = d[_],
              T = d[S],
              E = Ay[u[_]],
              M = Ay[u[S]],
              N = `${w}_${T}`,
              R = `${T}_${w}`;
            R in h && h[R]
              ? (Nw.dot(h[R].normal) <= s &&
                  (m.push(E.x, E.y, E.z), m.push(M.x, M.y, M.z)),
                (h[R] = null))
              : N in h ||
                (h[N] = { index0: c[_], index1: c[S], normal: Nw.clone() });
          }
      }
      for (const g in h)
        if (h[g]) {
          const { index0: x, index1: y } = h[g];
          _y.fromBufferAttribute(a, x),
            Sy.fromBufferAttribute(a, y),
            m.push(_y.x, _y.y, _y.z),
            m.push(Sy.x, Sy.y, Sy.z);
        }
      this.setAttribute("position", new At(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class ld extends Ig {
  constructor(e) {
    super(e), (this.uuid = io()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new Ig().fromJSON(i));
    }
    return this;
  }
}
const mK = {
  triangulate: function (n, e, t = 2) {
    const r = e && e.length,
      i = r ? e[0] * t : n.length;
    let s = Bk(n, 0, i, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, c, u, d, h, m;
    if ((r && (s = _K(n, e, s, t)), n.length > 80 * t)) {
      (a = c = n[0]), (l = u = n[1]);
      for (let g = t; g < i; g += t)
        (d = n[g]),
          (h = n[g + 1]),
          d < a && (a = d),
          h < l && (l = h),
          d > c && (c = d),
          h > u && (u = h);
      (m = Math.max(c - a, u - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return Lg(s, o, t, a, l, m, 0), o;
  },
};
function Bk(n, e, t, r, i) {
  let s, o;
  if (i === PK(n, e, t, r) > 0)
    for (s = e; s < t; s += r) o = OI(s, n[s], n[s + 1], o);
  else for (s = t - r; s >= e; s -= r) o = OI(s, n[s], n[s + 1], o);
  return o && R_(o, o.next) && (Dg(o), (o = o.next)), o;
}
function Sd(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (R_(t, t.next) || nr(t.prev, t, t.next) === 0))
    ) {
      if ((Dg(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function Lg(n, e, t, r, i, s, o) {
  if (!n) return;
  !o && s && EK(n, r, i, s);
  let a = n,
    l,
    c;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (c = n.next), s ? vK(n, r, i, s) : gK(n))) {
      e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((c.i / t) | 0),
        Dg(n),
        (n = c.next),
        (a = c.next);
      continue;
    }
    if (((n = c), n === a)) {
      o
        ? o === 1
          ? ((n = yK(Sd(n), e, t)), Lg(n, e, t, r, i, s, 2))
          : o === 2 && xK(n, e, t, r, i, s)
        : Lg(Sd(n), e, t, r, i, s, 1);
      break;
    }
  }
}
function gK(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (nr(e, t, r) >= 0) return !1;
  const i = e.x,
    s = t.x,
    o = r.x,
    a = e.y,
    l = t.y,
    c = r.y,
    u = i < s ? (i < o ? i : o) : s < o ? s : o,
    d = a < l ? (a < c ? a : c) : l < c ? l : c,
    h = i > s ? (i > o ? i : o) : s > o ? s : o,
    m = a > l ? (a > c ? a : c) : l > c ? l : c;
  let g = r.next;
  for (; g !== e; ) {
    if (
      g.x >= u &&
      g.x <= h &&
      g.y >= d &&
      g.y <= m &&
      rh(i, a, s, l, o, c, g.x, g.y) &&
      nr(g.prev, g, g.next) >= 0
    )
      return !1;
    g = g.next;
  }
  return !0;
}
function vK(n, e, t, r) {
  const i = n.prev,
    s = n,
    o = n.next;
  if (nr(i, s, o) >= 0) return !1;
  const a = i.x,
    l = s.x,
    c = o.x,
    u = i.y,
    d = s.y,
    h = o.y,
    m = a < l ? (a < c ? a : c) : l < c ? l : c,
    g = u < d ? (u < h ? u : h) : d < h ? d : h,
    x = a > l ? (a > c ? a : c) : l > c ? l : c,
    y = u > d ? (u > h ? u : h) : d > h ? d : h,
    v = yM(m, g, e, t, r),
    _ = yM(x, y, e, t, r);
  let S = n.prevZ,
    w = n.nextZ;
  for (; S && S.z >= v && w && w.z <= _; ) {
    if (
      (S.x >= m &&
        S.x <= x &&
        S.y >= g &&
        S.y <= y &&
        S !== i &&
        S !== o &&
        rh(a, u, l, d, c, h, S.x, S.y) &&
        nr(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      w.x >= m &&
        w.x <= x &&
        w.y >= g &&
        w.y <= y &&
        w !== i &&
        w !== o &&
        rh(a, u, l, d, c, h, w.x, w.y) &&
        nr(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; S && S.z >= v; ) {
    if (
      S.x >= m &&
      S.x <= x &&
      S.y >= g &&
      S.y <= y &&
      S !== i &&
      S !== o &&
      rh(a, u, l, d, c, h, S.x, S.y) &&
      nr(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; w && w.z <= _; ) {
    if (
      w.x >= m &&
      w.x <= x &&
      w.y >= g &&
      w.y <= y &&
      w !== i &&
      w !== o &&
      rh(a, u, l, d, c, h, w.x, w.y) &&
      nr(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function yK(n, e, t) {
  let r = n;
  do {
    const i = r.prev,
      s = r.next.next;
    !R_(i, s) &&
      Vk(i, r, r.next, s) &&
      Og(i, s) &&
      Og(s, i) &&
      (e.push((i.i / t) | 0),
      e.push((r.i / t) | 0),
      e.push((s.i / t) | 0),
      Dg(r),
      Dg(r.next),
      (r = n = s)),
      (r = r.next);
  } while (r !== n);
  return Sd(r);
}
function xK(n, e, t, r, i, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && CK(o, a)) {
        let l = Hk(o, a);
        (o = Sd(o, o.next)),
          (l = Sd(l, l.next)),
          Lg(o, e, t, r, i, s, 0),
          Lg(l, e, t, r, i, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function _K(n, e, t, r) {
  const i = [];
  let s, o, a, l, c;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * r),
      (l = s < o - 1 ? e[s + 1] * r : n.length),
      (c = Bk(n, a, l, r, !1)),
      c === c.next && (c.steiner = !0),
      i.push(TK(c));
  for (i.sort(SK), s = 0; s < i.length; s++) t = AK(i[s], t);
  return t;
}
function SK(n, e) {
  return n.x - e.x;
}
function AK(n, e) {
  const t = wK(n, e);
  if (!t) return e;
  const r = Hk(t, n);
  return Sd(r, r.next), Sd(t, t.next);
}
function wK(n, e) {
  let t = e,
    r = -1 / 0,
    i;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const h = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        h <= s &&
        h > r &&
        ((r = h), (i = t.x < t.next.x ? t : t.next), h === s)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const a = i,
    l = i.x,
    c = i.y;
  let u = 1 / 0,
    d;
  t = i;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      rh(o < c ? s : r, o, l, c, o < c ? r : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      Og(t, n) &&
        (d < u || (d === u && (t.x > i.x || (t.x === i.x && bK(i, t))))) &&
        ((i = t), (u = d))),
      (t = t.next);
  while (t !== a);
  return i;
}
function bK(n, e) {
  return nr(n.prev, n, e.prev) < 0 && nr(e.next, n, n.next) < 0;
}
function EK(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = yM(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), MK(i);
}
function MK(n) {
  let e,
    t,
    r,
    i,
    s,
    o,
    a,
    l,
    c = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, r = t, a = 0, e = 0; e < c && (a++, (r = r.nextZ), !!r); e++);
      for (l = c; a > 0 || (l > 0 && r); )
        a !== 0 && (l === 0 || !r || t.z <= r.z)
          ? ((i = t), (t = t.nextZ), a--)
          : ((i = r), (r = r.nextZ), l--),
          s ? (s.nextZ = i) : (n = i),
          (i.prevZ = s),
          (s = i);
      t = r;
    }
    (s.nextZ = null), (c *= 2);
  } while (o > 1);
  return n;
}
function yM(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function TK(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function rh(n, e, t, r, i, s, o, a) {
  return (
    (i - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (r - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (i - o) * (r - a)
  );
}
function CK(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !RK(n, e) &&
    ((Og(n, e) &&
      Og(e, n) &&
      NK(n, e) &&
      (nr(n.prev, n, e.prev) || nr(n, e.prev, e))) ||
      (R_(n, e) && nr(n.prev, n, n.next) > 0 && nr(e.prev, e, e.next) > 0))
  );
}
function nr(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function R_(n, e) {
  return n.x === e.x && n.y === e.y;
}
function Vk(n, e, t, r) {
  const i = by(nr(n, e, t)),
    s = by(nr(n, e, r)),
    o = by(nr(t, r, n)),
    a = by(nr(t, r, e));
  return !!(
    (i !== s && o !== a) ||
    (i === 0 && wy(n, t, e)) ||
    (s === 0 && wy(n, r, e)) ||
    (o === 0 && wy(t, n, r)) ||
    (a === 0 && wy(t, e, r))
  );
}
function wy(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function by(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function RK(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      Vk(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Og(n, e) {
  return nr(n.prev, n, n.next) < 0
    ? nr(n, e, n.next) >= 0 && nr(n, n.prev, e) >= 0
    : nr(n, e, n.prev) < 0 || nr(n, n.next, e) < 0;
}
function NK(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function Hk(n, e) {
  const t = new xM(n.i, n.x, n.y),
    r = new xM(e.i, e.x, e.y),
    i = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (s.next = r),
    (r.prev = s),
    r
  );
}
function OI(n, e, t, r) {
  const i = new xM(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Dg(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function xM(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function PK(n, e, t, r) {
  let i = 0;
  for (let s = e, o = t - r; s < t; s += r)
    (i += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return i;
}
class Wa {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Wa.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      s = [];
    DI(e), FI(r, e);
    let o = e.length;
    t.forEach(DI);
    for (let l = 0; l < t.length; l++)
      i.push(o), (o += t[l].length), FI(r, t[l]);
    const a = mK.triangulate(r, i);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function DI(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function FI(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class N_ extends qt {
  constructor(
    e = new ld([
      new He(0.5, 0.5),
      new He(-0.5, 0.5),
      new He(-0.5, -0.5),
      new He(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new At(i, 3)),
      this.setAttribute("uv", new At(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        u = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let h = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        g = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        x = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        y = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath,
        _ = t.UVGenerator !== void 0 ? t.UVGenerator : IK;
      let S,
        w = !1,
        T,
        E,
        M,
        N;
      v &&
        ((S = v.getSpacedPoints(u)),
        (w = !0),
        (h = !1),
        (T = v.computeFrenetFrames(u, !1)),
        (E = new Q()),
        (M = new Q()),
        (N = new Q())),
        h || ((y = 0), (m = 0), (g = 0), (x = 0));
      const R = a.extractPoints(c);
      let C = R.shape;
      const L = R.holes;
      if (!Wa.isClockWise(C)) {
        C = C.reverse();
        for (let ie = 0, me = L.length; ie < me; ie++) {
          const fe = L[ie];
          Wa.isClockWise(fe) && (L[ie] = fe.reverse());
        }
      }
      const D = Wa.triangulateShape(C, L),
        B = C;
      for (let ie = 0, me = L.length; ie < me; ie++) {
        const fe = L[ie];
        C = C.concat(fe);
      }
      function $(ie, me, fe) {
        return (
          me || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          ie.clone().addScaledVector(me, fe)
        );
      }
      const G = C.length,
        j = D.length;
      function U(ie, me, fe) {
        let Ee, Se, Ue;
        const Ce = ie.x - me.x,
          X = ie.y - me.y,
          z = fe.x - ie.x,
          q = fe.y - ie.y,
          ue = Ce * Ce + X * X,
          de = Ce * q - X * z;
        if (Math.abs(de) > Number.EPSILON) {
          const he = Math.sqrt(ue),
            Ie = Math.sqrt(z * z + q * q),
            ke = me.x - X / he,
            Me = me.y + Ce / he,
            et = fe.x - q / Ie,
            Ne = fe.y + z / Ie,
            We = ((et - ke) * q - (Ne - Me) * z) / (Ce * q - X * z);
          (Ee = ke + Ce * We - ie.x), (Se = Me + X * We - ie.y);
          const ot = Ee * Ee + Se * Se;
          if (ot <= 2) return new He(Ee, Se);
          Ue = Math.sqrt(ot / 2);
        } else {
          let he = !1;
          Ce > Number.EPSILON
            ? z > Number.EPSILON && (he = !0)
            : Ce < -Number.EPSILON
            ? z < -Number.EPSILON && (he = !0)
            : Math.sign(X) === Math.sign(q) && (he = !0),
            he
              ? ((Ee = -X), (Se = Ce), (Ue = Math.sqrt(ue)))
              : ((Ee = Ce), (Se = X), (Ue = Math.sqrt(ue / 2)));
        }
        return new He(Ee / Ue, Se / Ue);
      }
      const H = [];
      for (
        let ie = 0, me = B.length, fe = me - 1, Ee = ie + 1;
        ie < me;
        ie++, fe++, Ee++
      )
        fe === me && (fe = 0),
          Ee === me && (Ee = 0),
          (H[ie] = U(B[ie], B[fe], B[Ee]));
      const V = [];
      let k,
        W = H.concat();
      for (let ie = 0, me = L.length; ie < me; ie++) {
        const fe = L[ie];
        k = [];
        for (
          let Ee = 0, Se = fe.length, Ue = Se - 1, Ce = Ee + 1;
          Ee < Se;
          Ee++, Ue++, Ce++
        )
          Ue === Se && (Ue = 0),
            Ce === Se && (Ce = 0),
            (k[Ee] = U(fe[Ee], fe[Ue], fe[Ce]));
        V.push(k), (W = W.concat(k));
      }
      for (let ie = 0; ie < y; ie++) {
        const me = ie / y,
          fe = m * Math.cos((me * Math.PI) / 2),
          Ee = g * Math.sin((me * Math.PI) / 2) + x;
        for (let Se = 0, Ue = B.length; Se < Ue; Se++) {
          const Ce = $(B[Se], H[Se], Ee);
          se(Ce.x, Ce.y, -fe);
        }
        for (let Se = 0, Ue = L.length; Se < Ue; Se++) {
          const Ce = L[Se];
          k = V[Se];
          for (let X = 0, z = Ce.length; X < z; X++) {
            const q = $(Ce[X], k[X], Ee);
            se(q.x, q.y, -fe);
          }
        }
      }
      const ee = g + x;
      for (let ie = 0; ie < G; ie++) {
        const me = h ? $(C[ie], W[ie], ee) : C[ie];
        w
          ? (M.copy(T.normals[0]).multiplyScalar(me.x),
            E.copy(T.binormals[0]).multiplyScalar(me.y),
            N.copy(S[0]).add(M).add(E),
            se(N.x, N.y, N.z))
          : se(me.x, me.y, 0);
      }
      for (let ie = 1; ie <= u; ie++)
        for (let me = 0; me < G; me++) {
          const fe = h ? $(C[me], W[me], ee) : C[me];
          w
            ? (M.copy(T.normals[ie]).multiplyScalar(fe.x),
              E.copy(T.binormals[ie]).multiplyScalar(fe.y),
              N.copy(S[ie]).add(M).add(E),
              se(N.x, N.y, N.z))
            : se(fe.x, fe.y, (d / u) * ie);
        }
      for (let ie = y - 1; ie >= 0; ie--) {
        const me = ie / y,
          fe = m * Math.cos((me * Math.PI) / 2),
          Ee = g * Math.sin((me * Math.PI) / 2) + x;
        for (let Se = 0, Ue = B.length; Se < Ue; Se++) {
          const Ce = $(B[Se], H[Se], Ee);
          se(Ce.x, Ce.y, d + fe);
        }
        for (let Se = 0, Ue = L.length; Se < Ue; Se++) {
          const Ce = L[Se];
          k = V[Se];
          for (let X = 0, z = Ce.length; X < z; X++) {
            const q = $(Ce[X], k[X], Ee);
            w
              ? se(q.x, q.y + S[u - 1].y, S[u - 1].x + fe)
              : se(q.x, q.y, d + fe);
          }
        }
      }
      Y(), K();
      function Y() {
        const ie = i.length / 3;
        if (h) {
          let me = 0,
            fe = G * me;
          for (let Ee = 0; Ee < j; Ee++) {
            const Se = D[Ee];
            we(Se[2] + fe, Se[1] + fe, Se[0] + fe);
          }
          (me = u + y * 2), (fe = G * me);
          for (let Ee = 0; Ee < j; Ee++) {
            const Se = D[Ee];
            we(Se[0] + fe, Se[1] + fe, Se[2] + fe);
          }
        } else {
          for (let me = 0; me < j; me++) {
            const fe = D[me];
            we(fe[2], fe[1], fe[0]);
          }
          for (let me = 0; me < j; me++) {
            const fe = D[me];
            we(fe[0] + G * u, fe[1] + G * u, fe[2] + G * u);
          }
        }
        r.addGroup(ie, i.length / 3 - ie, 0);
      }
      function K() {
        const ie = i.length / 3;
        let me = 0;
        ae(B, me), (me += B.length);
        for (let fe = 0, Ee = L.length; fe < Ee; fe++) {
          const Se = L[fe];
          ae(Se, me), (me += Se.length);
        }
        r.addGroup(ie, i.length / 3 - ie, 1);
      }
      function ae(ie, me) {
        let fe = ie.length;
        for (; --fe >= 0; ) {
          const Ee = fe;
          let Se = fe - 1;
          Se < 0 && (Se = ie.length - 1);
          for (let Ue = 0, Ce = u + y * 2; Ue < Ce; Ue++) {
            const X = G * Ue,
              z = G * (Ue + 1),
              q = me + Ee + X,
              ue = me + Se + X,
              de = me + Se + z,
              he = me + Ee + z;
            Be(q, ue, de, he);
          }
        }
      }
      function se(ie, me, fe) {
        l.push(ie), l.push(me), l.push(fe);
      }
      function we(ie, me, fe) {
        te(ie), te(me), te(fe);
        const Ee = i.length / 3,
          Se = _.generateTopUV(r, i, Ee - 3, Ee - 2, Ee - 1);
        ge(Se[0]), ge(Se[1]), ge(Se[2]);
      }
      function Be(ie, me, fe, Ee) {
        te(ie), te(me), te(Ee), te(me), te(fe), te(Ee);
        const Se = i.length / 3,
          Ue = _.generateSideWallUV(r, i, Se - 6, Se - 3, Se - 2, Se - 1);
        ge(Ue[0]), ge(Ue[1]), ge(Ue[3]), ge(Ue[1]), ge(Ue[2]), ge(Ue[3]);
      }
      function te(ie) {
        i.push(l[ie * 3 + 0]), i.push(l[ie * 3 + 1]), i.push(l[ie * 3 + 2]);
      }
      function ge(ie) {
        s.push(ie.x), s.push(ie.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return LK(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new m1[i.type]().fromJSON(i)),
      new N_(r, e.options)
    );
  }
}
const IK = {
  generateTopUV: function (n, e, t, r, i) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[r * 3],
      l = e[r * 3 + 1],
      c = e[i * 3],
      u = e[i * 3 + 1];
    return [new He(s, o), new He(a, l), new He(c, u)];
  },
  generateSideWallUV: function (n, e, t, r, i, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[r * 3],
      u = e[r * 3 + 1],
      d = e[r * 3 + 2],
      h = e[i * 3],
      m = e[i * 3 + 1],
      g = e[i * 3 + 2],
      x = e[s * 3],
      y = e[s * 3 + 1],
      v = e[s * 3 + 2];
    return Math.abs(a - u) < Math.abs(o - c)
      ? [new He(o, 1 - l), new He(c, 1 - d), new He(h, 1 - g), new He(x, 1 - v)]
      : [
          new He(a, 1 - l),
          new He(u, 1 - d),
          new He(m, 1 - g),
          new He(y, 1 - v),
        ];
  },
};
function LK(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class P_ extends Qc {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new P_(e.radius, e.detail);
  }
}
class x0 extends Qc {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new x0(e.radius, e.detail);
  }
}
class I_ extends qt {
  constructor(e = 0.5, t = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: s,
        thetaLength: o,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      l = [],
      c = [],
      u = [];
    let d = e;
    const h = (t - e) / i,
      m = new Q(),
      g = new He();
    for (let x = 0; x <= i; x++) {
      for (let y = 0; y <= r; y++) {
        const v = s + (y / r) * o;
        (m.x = d * Math.cos(v)),
          (m.y = d * Math.sin(v)),
          l.push(m.x, m.y, m.z),
          c.push(0, 0, 1),
          (g.x = (m.x / t + 1) / 2),
          (g.y = (m.y / t + 1) / 2),
          u.push(g.x, g.y);
      }
      d += h;
    }
    for (let x = 0; x < i; x++) {
      const y = x * (r + 1);
      for (let v = 0; v < r; v++) {
        const _ = v + y,
          S = _,
          w = _ + r + 1,
          T = _ + r + 2,
          E = _ + 1;
        a.push(S, w, E), a.push(w, T, E);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new At(l, 3)),
      this.setAttribute("normal", new At(c, 3)),
      this.setAttribute("uv", new At(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new I_(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class L_ extends qt {
  constructor(
    e = new ld([new He(0, 0.5), new He(-0.5, -0.5), new He(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(a, l, u), (a += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new At(i, 3)),
      this.setAttribute("normal", new At(s, 3)),
      this.setAttribute("uv", new At(o, 2));
    function c(u) {
      const d = i.length / 3,
        h = u.extractPoints(t);
      let m = h.shape;
      const g = h.holes;
      Wa.isClockWise(m) === !1 && (m = m.reverse());
      for (let y = 0, v = g.length; y < v; y++) {
        const _ = g[y];
        Wa.isClockWise(_) === !0 && (g[y] = _.reverse());
      }
      const x = Wa.triangulateShape(m, g);
      for (let y = 0, v = g.length; y < v; y++) {
        const _ = g[y];
        m = m.concat(_);
      }
      for (let y = 0, v = m.length; y < v; y++) {
        const _ = m[y];
        i.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y);
      }
      for (let y = 0, v = x.length; y < v; y++) {
        const _ = x[y],
          S = _[0] + d,
          w = _[1] + d,
          T = _[2] + d;
        r.push(S, w, T), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return OK(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const o = t[e.shapes[i]];
      r.push(o);
    }
    return new L_(r, e.curveSegments);
  }
}
function OK(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class _0 extends qt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const u = [],
      d = new Q(),
      h = new Q(),
      m = [],
      g = [],
      x = [],
      y = [];
    for (let v = 0; v <= r; v++) {
      const _ = [],
        S = v / r;
      let w = 0;
      v === 0 && o === 0
        ? (w = 0.5 / t)
        : v === r && l === Math.PI && (w = -0.5 / t);
      for (let T = 0; T <= t; T++) {
        const E = T / t;
        (d.x = -e * Math.cos(i + E * s) * Math.sin(o + S * a)),
          (d.y = e * Math.cos(o + S * a)),
          (d.z = e * Math.sin(i + E * s) * Math.sin(o + S * a)),
          g.push(d.x, d.y, d.z),
          h.copy(d).normalize(),
          x.push(h.x, h.y, h.z),
          y.push(E + w, 1 - S),
          _.push(c++);
      }
      u.push(_);
    }
    for (let v = 0; v < r; v++)
      for (let _ = 0; _ < t; _++) {
        const S = u[v][_ + 1],
          w = u[v][_],
          T = u[v + 1][_],
          E = u[v + 1][_ + 1];
        (v !== 0 || o > 0) && m.push(S, w, E),
          (v !== r - 1 || l < Math.PI) && m.push(w, T, E);
      }
    this.setIndex(m),
      this.setAttribute("position", new At(g, 3)),
      this.setAttribute("normal", new At(x, 3)),
      this.setAttribute("uv", new At(y, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new _0(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class O_ extends Qc {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new O_(e.radius, e.detail);
  }
}
class D_ extends qt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const o = [],
      a = [],
      l = [],
      c = [],
      u = new Q(),
      d = new Q(),
      h = new Q();
    for (let m = 0; m <= r; m++)
      for (let g = 0; g <= i; g++) {
        const x = (g / i) * s,
          y = (m / r) * Math.PI * 2;
        (d.x = (e + t * Math.cos(y)) * Math.cos(x)),
          (d.y = (e + t * Math.cos(y)) * Math.sin(x)),
          (d.z = t * Math.sin(y)),
          a.push(d.x, d.y, d.z),
          (u.x = e * Math.cos(x)),
          (u.y = e * Math.sin(x)),
          h.subVectors(d, u).normalize(),
          l.push(h.x, h.y, h.z),
          c.push(g / i),
          c.push(m / r);
      }
    for (let m = 1; m <= r; m++)
      for (let g = 1; g <= i; g++) {
        const x = (i + 1) * m + g - 1,
          y = (i + 1) * (m - 1) + g - 1,
          v = (i + 1) * (m - 1) + g,
          _ = (i + 1) * m + g;
        o.push(x, y, _), o.push(y, v, _);
      }
    this.setIndex(o),
      this.setAttribute("position", new At(a, 3)),
      this.setAttribute("normal", new At(l, 3)),
      this.setAttribute("uv", new At(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new D_(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class F_ extends qt {
  constructor(e = 1, t = 0.4, r = 64, i = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: s,
        q: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      c = [],
      u = [],
      d = new Q(),
      h = new Q(),
      m = new Q(),
      g = new Q(),
      x = new Q(),
      y = new Q(),
      v = new Q();
    for (let S = 0; S <= r; ++S) {
      const w = (S / r) * s * Math.PI * 2;
      _(w, s, o, e, m),
        _(w + 0.01, s, o, e, g),
        y.subVectors(g, m),
        v.addVectors(g, m),
        x.crossVectors(y, v),
        v.crossVectors(x, y),
        x.normalize(),
        v.normalize();
      for (let T = 0; T <= i; ++T) {
        const E = (T / i) * Math.PI * 2,
          M = -t * Math.cos(E),
          N = t * Math.sin(E);
        (d.x = m.x + (M * v.x + N * x.x)),
          (d.y = m.y + (M * v.y + N * x.y)),
          (d.z = m.z + (M * v.z + N * x.z)),
          l.push(d.x, d.y, d.z),
          h.subVectors(d, m).normalize(),
          c.push(h.x, h.y, h.z),
          u.push(S / r),
          u.push(T / i);
      }
    }
    for (let S = 1; S <= r; S++)
      for (let w = 1; w <= i; w++) {
        const T = (i + 1) * (S - 1) + (w - 1),
          E = (i + 1) * S + (w - 1),
          M = (i + 1) * S + w,
          N = (i + 1) * (S - 1) + w;
        a.push(T, E, N), a.push(E, M, N);
      }
    this.setIndex(a),
      this.setAttribute("position", new At(l, 3)),
      this.setAttribute("normal", new At(c, 3)),
      this.setAttribute("uv", new At(u, 2));
    function _(S, w, T, E, M) {
      const N = Math.cos(S),
        R = Math.sin(S),
        C = (T / w) * S,
        L = Math.cos(C);
      (M.x = E * (2 + L) * 0.5 * N),
        (M.y = E * (2 + L) * R * 0.5),
        (M.z = E * Math.sin(C) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new F_(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class U_ extends qt {
  constructor(
    e = new y2(new Q(-1, -1, 0), new Q(-1, 1, 0), new Q(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new Q(),
      l = new Q(),
      c = new He();
    let u = new Q();
    const d = [],
      h = [],
      m = [],
      g = [];
    x(),
      this.setIndex(g),
      this.setAttribute("position", new At(d, 3)),
      this.setAttribute("normal", new At(h, 3)),
      this.setAttribute("uv", new At(m, 2));
    function x() {
      for (let S = 0; S < t; S++) y(S);
      y(s === !1 ? t : 0), _(), v();
    }
    function y(S) {
      u = e.getPointAt(S / t, u);
      const w = o.normals[S],
        T = o.binormals[S];
      for (let E = 0; E <= i; E++) {
        const M = (E / i) * Math.PI * 2,
          N = Math.sin(M),
          R = -Math.cos(M);
        (l.x = R * w.x + N * T.x),
          (l.y = R * w.y + N * T.y),
          (l.z = R * w.z + N * T.z),
          l.normalize(),
          h.push(l.x, l.y, l.z),
          (a.x = u.x + r * l.x),
          (a.y = u.y + r * l.y),
          (a.z = u.z + r * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function v() {
      for (let S = 1; S <= t; S++)
        for (let w = 1; w <= i; w++) {
          const T = (i + 1) * (S - 1) + (w - 1),
            E = (i + 1) * S + (w - 1),
            M = (i + 1) * S + w,
            N = (i + 1) * (S - 1) + w;
          g.push(T, E, N), g.push(E, M, N);
        }
    }
    function _() {
      for (let S = 0; S <= t; S++)
        for (let w = 0; w <= i; w++)
          (c.x = S / t), (c.y = w / i), m.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new U_(
      new m1[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class Gk extends qt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new Q(),
        s = new Q();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const d = l[c],
            h = d.start,
            m = d.count;
          for (let g = h, x = h + m; g < x; g += 3)
            for (let y = 0; y < 3; y++) {
              const v = a.getX(g + y),
                _ = a.getX(g + ((y + 1) % 3));
              i.fromBufferAttribute(o, v),
                s.fromBufferAttribute(o, _),
                UI(i, s, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * a + c,
              d = 3 * a + ((c + 1) % 3);
            i.fromBufferAttribute(o, u),
              s.fromBufferAttribute(o, d),
              UI(i, s, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new At(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function UI(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var kI = Object.freeze({
  __proto__: null,
  BoxGeometry: Ld,
  CapsuleGeometry: E_,
  CircleGeometry: M_,
  ConeGeometry: T_,
  CylinderGeometry: ap,
  DodecahedronGeometry: C_,
  EdgesGeometry: zk,
  ExtrudeGeometry: N_,
  IcosahedronGeometry: P_,
  LatheGeometry: y0,
  OctahedronGeometry: x0,
  PlaneGeometry: Gl,
  PolyhedronGeometry: Qc,
  RingGeometry: I_,
  ShapeGeometry: L_,
  SphereGeometry: _0,
  TetrahedronGeometry: O_,
  TorusGeometry: D_,
  TorusKnotGeometry: F_,
  TubeGeometry: U_,
  WireframeGeometry: Gk,
});
class _2 extends oi {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new pt(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class Wk extends Bo {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class k_ extends oi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new pt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ao()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class S2 extends k_ {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new He(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return ur((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new pt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new pt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new pt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class A2 extends oi {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new pt(16777215)),
      (this.specular = new pt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ao()),
      (this.combine = u0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class jk extends oi {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class w2 extends oi {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class b2 extends oi {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new pt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new pt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new ao()),
      (this.combine = u0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class $k extends oi {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new pt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Xa),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class z_ extends Hi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function qu(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function Xk(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Yk(n) {
  function e(i, s) {
    return n[i] - n[s];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function _M(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let s = 0, o = 0; o !== r; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) i[o++] = n[a + l];
  }
  return i;
}
function E2(n, e, t, r) {
  let i = 1,
    s = n[0];
  for (; s !== void 0 && s[r] === void 0; ) s = n[i++];
  if (s === void 0) return;
  let o = s[r];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[i++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[i++]);
      while (s !== void 0);
    else
      do (o = s[r]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[i++]);
      while (s !== void 0);
}
function DK(n, e, t, r, i = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l],
      u = c.getValueSize(),
      d = [],
      h = [];
    for (let m = 0; m < c.times.length; ++m) {
      const g = c.times[m] * i;
      if (!(g < t || g >= r)) {
        d.push(c.times[m]);
        for (let x = 0; x < u; ++x) h.push(c.values[m * u + x]);
      }
    }
    d.length !== 0 &&
      ((c.times = qu(d, c.times.constructor)),
      (c.values = qu(h, c.values.constructor)),
      o.push(c));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function FK(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    s = e / r;
  for (let o = 0; o < i; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = n.tracks.find(function (v) {
      return v.name === a.name && v.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (u = d / 3);
    let h = 0;
    const m = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = m / 3);
    const g = a.times.length - 1;
    let x;
    if (s <= a.times[0]) {
      const v = u,
        _ = d - u;
      x = a.values.slice(v, _);
    } else if (s >= a.times[g]) {
      const v = g * d + u,
        _ = v + d - u;
      x = a.values.slice(v, _);
    } else {
      const v = a.createInterpolant(),
        _ = u,
        S = d - u;
      v.evaluate(s), (x = v.resultBuffer.slice(_, S));
    }
    l === "quaternion" &&
      new ki().fromArray(x).normalize().conjugate().toArray(x);
    const y = c.times.length;
    for (let v = 0; v < y; ++v) {
      const _ = v * m + h;
      if (l === "quaternion")
        ki.multiplyQuaternionsFlat(c.values, _, x, 0, c.values, _);
      else {
        const S = m - h * 2;
        for (let w = 0; w < S; ++w) c.values[_ + w] -= x[w];
      }
    }
  }
  return (n.blendMode = e2), n;
}
const UK = {
  convertArray: qu,
  isTypedArray: Xk,
  getKeyframeOrder: Yk,
  sortedArray: _M,
  flattenJSON: E2,
  subclip: DK,
  makeClipAdditive: FK,
};
class S0 {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      s = t[r - 1];
    e: {
      t: {
        let o;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < s) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((s = i), (i = t[++r]), e < i)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((r = 2), (s = a));
            for (let l = r - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = s), (s = t[--r - 1]), e >= s)) break t;
            }
            (o = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < o; ) {
          const a = (r + o) >>> 1;
          e < t[a] ? (o = a) : (r = a + 1);
        }
        if (((i = t[r]), (s = t[r - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, s, i);
    }
    return this.interpolate_(r, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let o = 0; o !== i; ++o) t[o] = r[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class qk extends S0 {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: $u, endingEnd: $u });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = i[s],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Xu:
          (s = e), (a = 2 * t - r);
          break;
        case Tg:
          (s = i.length - 2), (a = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (a = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Xu:
          (o = e), (l = 2 * r - t);
          break;
        case Tg:
          (o = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (r - t) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - r)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      d = this._offsetNext,
      h = this._weightPrev,
      m = this._weightNext,
      g = (r - t) / (i - t),
      x = g * g,
      y = x * g,
      v = -h * y + 2 * h * x - h * g,
      _ = (1 + h) * y + (-1.5 - 2 * h) * x + (-0.5 + h) * g + 1,
      S = (-1 - m) * y + (1.5 + m) * x + 0.5 * g,
      w = m * y - m * x;
    for (let T = 0; T !== a; ++T)
      s[T] = v * o[u + T] + _ * o[c + T] + S * o[l + T] + w * o[d + T];
    return s;
  }
}
class M2 extends S0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (r - t) / (i - t),
      d = 1 - u;
    for (let h = 0; h !== a; ++h) s[h] = o[c + h] * d + o[l + h] * u;
    return s;
  }
}
class Kk extends S0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class wa {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = qu(t, this.TimeBufferType)),
      (this.values = qu(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: qu(e.times, Array),
        values: qu(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new Kk(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new M2(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new qk(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Eg:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Mg:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case _x:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Eg;
      case this.InterpolantFactoryMethodLinear:
        return Mg;
      case this.InterpolantFactoryMethodSmooth:
        return _x;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let s = 0,
      o = i - 1;
    for (; s !== i && r[s] < e; ) ++s;
    for (; o !== -1 && r[o] > t; ) --o;
    if ((++o, s !== 0 || o !== i)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = r.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      s = r.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = r[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && Xk(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === _x,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const d = a * r,
            h = d - r,
            m = d + r;
          for (let g = 0; g !== r; ++g) {
            const x = t[d + g];
            if (x !== t[h + g] || x !== t[m + g]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * r,
            h = o * r;
          for (let m = 0; m !== r; ++m) t[h + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * r, l = o * r, c = 0; c !== r; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
wa.prototype.TimeBufferType = Float32Array;
wa.prototype.ValueBufferType = Float32Array;
wa.prototype.DefaultInterpolation = Mg;
class Od extends wa {}
Od.prototype.ValueTypeName = "bool";
Od.prototype.ValueBufferType = Array;
Od.prototype.DefaultInterpolation = Eg;
Od.prototype.InterpolantFactoryMethodLinear = void 0;
Od.prototype.InterpolantFactoryMethodSmooth = void 0;
class T2 extends wa {}
T2.prototype.ValueTypeName = "color";
class Fg extends wa {}
Fg.prototype.ValueTypeName = "number";
class Zk extends S0 {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (r - t) / (i - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) ki.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class lp extends wa {
  InterpolantFactoryMethodLinear(e) {
    return new Zk(this.times, this.values, this.getValueSize(), e);
  }
}
lp.prototype.ValueTypeName = "quaternion";
lp.prototype.DefaultInterpolation = Mg;
lp.prototype.InterpolantFactoryMethodSmooth = void 0;
class Dd extends wa {}
Dd.prototype.ValueTypeName = "string";
Dd.prototype.ValueBufferType = Array;
Dd.prototype.DefaultInterpolation = Eg;
Dd.prototype.InterpolantFactoryMethodLinear = void 0;
Dd.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ug extends wa {}
Ug.prototype.ValueTypeName = "vector";
class kg {
  constructor(e = "", t = -1, r = [], i = p_) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = io()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = r.length; o !== a; ++o) t.push(zK(r[o]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = r.length; s !== o; ++s) t.push(wa.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
      const u = Yk(l);
      (l = _M(l, 1, u)),
        (c = _M(c, 1, u)),
        !i && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new Fg(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / r)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const d = u[1];
        let h = i[d];
        h || (i[d] = h = []), h.push(c);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (d, h, m, g, x) {
        if (m.length !== 0) {
          const y = [],
            v = [];
          E2(m, y, v, g), y.length !== 0 && x.push(new d(h, y, v));
        }
      },
      i = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const h = c[d].keys;
      if (!(!h || h.length === 0))
        if (h[0].morphTargets) {
          const m = {};
          let g;
          for (g = 0; g < h.length; g++)
            if (h[g].morphTargets)
              for (let x = 0; x < h[g].morphTargets.length; x++)
                m[h[g].morphTargets[x]] = -1;
          for (const x in m) {
            const y = [],
              v = [];
            for (let _ = 0; _ !== h[g].morphTargets.length; ++_) {
              const S = h[g];
              y.push(S.time), v.push(S.morphTarget === x ? 1 : 0);
            }
            i.push(new Fg(".morphTargetInfluence[" + x + "]", y, v));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          r(Ug, m + ".position", h, "pos", i),
            r(lp, m + ".quaternion", h, "rot", i),
            r(Ug, m + ".scale", h, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function kK(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Fg;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Ug;
    case "color":
      return T2;
    case "quaternion":
      return lp;
    case "bool":
    case "boolean":
      return Od;
    case "string":
      return Dd;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function zK(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = kK(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    E2(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Ml = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
let C2 = class {
  constructor(e, t, r) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (u) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), (s = !0);
      }),
      (this.itemEnd = function (u) {
        o++,
          i.onProgress !== void 0 && i.onProgress(u, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, h = c.length; d < h; d += 2) {
          const m = c[d],
            g = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return g;
        }
        return null;
      });
  }
};
const Qk = new C2();
let Rs = class {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Qk),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, s) {
      r.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
};
Rs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ml = {};
class BK extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ul extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = Ml.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (ml[e] !== void 0) {
      ml[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    (ml[e] = []), ml[e].push({ onLoad: t, onProgress: r, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = ml[e],
            d = c.body.getReader(),
            h = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            m = h ? parseInt(h) : 0,
            g = m !== 0;
          let x = 0;
          const y = new ReadableStream({
            start(v) {
              _();
              function _() {
                d.read().then(({ done: S, value: w }) => {
                  if (S) v.close();
                  else {
                    x += w.byteLength;
                    const T = new ProgressEvent("progress", {
                      lengthComputable: g,
                      loaded: x,
                      total: m,
                    });
                    for (let E = 0, M = u.length; E < M; E++) {
                      const N = u[E];
                      N.onProgress && N.onProgress(T);
                    }
                    v.enqueue(w), _();
                  }
                });
              }
            },
          });
          return new Response(y);
        } else
          throw new BK(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                h = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(h);
              return c.arrayBuffer().then((g) => m.decode(g));
            }
        }
      })
      .then((c) => {
        Ml.add(e, c);
        const u = ml[e];
        delete ml[e];
        for (let d = 0, h = u.length; d < h; d++) {
          const m = u[d];
          m.onLoad && m.onLoad(c);
        }
      })
      .catch((c) => {
        const u = ml[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete ml[e];
        for (let d = 0, h = u.length; d < h; d++) {
          const m = u[d];
          m.onError && m.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class VK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new Ul(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = kg.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class HK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = [],
      a = new w_(),
      l = new Ul(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let c = 0;
    function u(d) {
      l.load(
        e[d],
        function (h) {
          const m = s.parse(h, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = dr),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let d = 0, h = e.length; d < h; ++d) u(d);
    else
      l.load(
        e,
        function (d) {
          const h = s.parse(d, !0);
          if (h.isCubemap) {
            const m = h.mipmaps.length / h.mipmapCount;
            for (let g = 0; g < m; g++) {
              o[g] = { mipmaps: [] };
              for (let x = 0; x < h.mipmapCount; x++)
                o[g].mipmaps.push(h.mipmaps[g * h.mipmapCount + x]),
                  (o[g].format = h.format),
                  (o[g].width = h.width),
                  (o[g].height = h.height);
            }
            a.image = o;
          } else
            (a.image.width = h.width),
              (a.image.height = h.height),
              (a.mipmaps = h.mipmaps);
          h.mipmapCount === 1 && (a.minFilter = dr),
            (a.format = h.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        r,
        i
      );
    return a;
  }
}
let zg = class extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Ml.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = Pg("img");
    function l() {
      u(), Ml.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
};
class GK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new p0();
    s.colorSpace = Xs;
    const o = new zg(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(
        e[c],
        function (u) {
          (s.images[c] = u), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return s;
  }
}
class WK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new Dc(),
      a = new Ul(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = s.parse(l);
          } catch (u) {
            if (i !== void 0) i(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (o.image = c.image)
            : c.data !== void 0 &&
              ((o.image.width = c.width),
              (o.image.height = c.height),
              (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : Oo),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : Oo),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : dr),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : dr),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = ca)),
            c.mipmapCount === 1 && (o.minFilter = dr),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c);
        },
        r,
        i
      ),
      o
    );
  }
}
let jK = class extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new Fr(),
      o = new zg(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        r,
        i
      ),
      s
    );
  }
};
class Jc extends xn {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new pt(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class R2 extends Jc {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new pt(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Pw = new Ut(),
  zI = new Q(),
  BI = new Q();
class N2 {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new He(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Ut()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new m0()),
      (this._frameExtents = new He(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new rn(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    zI.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(zI),
      BI.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(BI),
      t.updateMatrixWorld(),
      Pw.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Pw),
      r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(Pw);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class $K extends N2 {
  constructor() {
    super(new Yn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = Fh * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class B_ extends Jc {
  constructor(e, t, r = 0, i = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new xn()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new $K());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const VI = new Ut(),
  pm = new Q(),
  Iw = new Q();
class XK extends N2 {
  constructor() {
    super(new Yn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new He(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new rn(2, 1, 1, 1),
        new rn(0, 1, 1, 1),
        new rn(3, 1, 1, 1),
        new rn(1, 1, 1, 1),
        new rn(3, 0, 1, 1),
        new rn(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Q(1, 0, 0),
        new Q(-1, 0, 0),
        new Q(0, 0, 1),
        new Q(0, 0, -1),
        new Q(0, 1, 0),
        new Q(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 1, 0),
        new Q(0, 0, 1),
        new Q(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      s = e.distance || r.far;
    s !== r.far && ((r.far = s), r.updateProjectionMatrix()),
      pm.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(pm),
      Iw.copy(r.position),
      Iw.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(Iw),
      r.updateMatrixWorld(),
      i.makeTranslation(-pm.x, -pm.y, -pm.z),
      VI.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(VI);
  }
}
class P2 extends Jc {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new XK());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class YK extends N2 {
  constructor() {
    super(new Fo(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class I2 extends Jc {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(xn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new xn()),
      (this.shadow = new YK());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class L2 extends Jc {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class Jk extends Jc {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class ez {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new Q());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * i),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * r),
      t.addScaledVector(o[4], 1.092548 * (r * i)),
      t.addScaledVector(o[5], 1.092548 * (i * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (r * s)),
      t.addScaledVector(o[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * i),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * r),
      t.addScaledVector(o[4], 2 * 0.429043 * r * i),
      t.addScaledVector(o[5], 2 * 0.429043 * i * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * r * s),
      t.addScaledVector(o[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * r * s),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class tz extends Jc {
  constructor(e = new ez(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class cp extends Rs {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const s = this,
      o = new Ul(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const i = cp.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new pt().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((i.uniforms[s] = {}), o.type)) {
          case "t":
            i.uniforms[s].value = r(o.value);
            break;
          case "c":
            i.uniforms[s].value = new pt().setHex(o.value);
            break;
          case "v2":
            i.uniforms[s].value = new He().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[s].value = new Q().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[s].value = new rn().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[s].value = new Qt().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[s].value = new Ut().fromArray(o.value);
            break;
          default:
            i.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new He().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new He().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: _2,
      SpriteMaterial: S_,
      RawShaderMaterial: Wk,
      ShaderMaterial: Bo,
      PointsMaterial: v0,
      MeshPhysicalMaterial: S2,
      MeshStandardMaterial: k_,
      MeshPhongMaterial: A2,
      MeshToonMaterial: jk,
      MeshNormalMaterial: w2,
      MeshLambertMaterial: b2,
      MeshDepthMaterial: v_,
      MeshDistanceMaterial: y_,
      MeshBasicMaterial: Za,
      MeshMatcapMaterial: $k,
      LineDashedMaterial: z_,
      LineBasicMaterial: Hi,
      Material: oi,
    };
    return new t[e]();
  }
}
class SM {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++) t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class O2 extends qt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class nz extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new Ul(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(m, g) {
      if (t[g] !== void 0) return t[g];
      const y = m.interleavedBuffers[g],
        v = s(m, y.buffer),
        _ = eh(y.type, v),
        S = new g0(_, y.stride);
      return (S.uuid = y.uuid), (t[g] = S), S;
    }
    function s(m, g) {
      if (r[g] !== void 0) return r[g];
      const y = m.arrayBuffers[g],
        v = new Uint32Array(y).buffer;
      return (r[g] = v), v;
    }
    const o = e.isInstancedBufferGeometry ? new O2() : new qt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = eh(a.type, a.array);
      o.setIndex(new Mn(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const g = l[m];
      let x;
      if (g.isInterleavedBufferAttribute) {
        const y = i(e.data, g.data);
        x = new Vc(y, g.itemSize, g.offset, g.normalized);
      } else {
        const y = eh(g.type, g.array),
          v = g.isInstancedBufferAttribute ? Hc : Mn;
        x = new v(y, g.itemSize, g.normalized);
      }
      g.name !== void 0 && (x.name = g.name),
        g.usage !== void 0 && x.setUsage(g.usage),
        o.setAttribute(m, x);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const m in c) {
        const g = c[m],
          x = [];
        for (let y = 0, v = g.length; y < v; y++) {
          const _ = g[y];
          let S;
          if (_.isInterleavedBufferAttribute) {
            const w = i(e.data, _.data);
            S = new Vc(w, _.itemSize, _.offset, _.normalized);
          } else {
            const w = eh(_.type, _.array);
            S = new Mn(w, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (S.name = _.name), x.push(S);
        }
        o.morphAttributes[m] = x;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, g = d.length; m !== g; ++m) {
        const x = d[m];
        o.addGroup(x.start, x.count, x.materialIndex);
      }
    const h = e.data.boundingSphere;
    if (h !== void 0) {
      const m = new Q();
      h.center !== void 0 && m.fromArray(h.center),
        (o.boundingSphere = new mi(m, h.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class qK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = this.path === "" ? SM.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new Ul(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (d) {
            i !== void 0 && i(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const u = c.metadata;
          if (
            u === void 0 ||
            u.type === void 0 ||
            u.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(c, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? SM.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new Ul(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, s, l, a, r),
      u = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, u), t !== void 0)) {
      let d = !1;
      for (const h in o)
        if (o[h].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, i, a, o, t),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const s = new ld().fromJSON(e[r]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new A_().fromJSON(e[s], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new nz();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in kI
              ? (a = kI[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (r[l.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const s = new cp();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          s = kg.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let s;
    function o(l) {
      return (
        r.manager.itemStart(l),
        s.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c;
        return o(u);
      } else
        return l.data
          ? { data: eh(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new C2(t);
      (s = new zg(l)), s.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const d = e[c],
          h = d.url;
        if (Array.isArray(h)) {
          const m = [];
          for (let g = 0, x = h.length; g < x; g++) {
            const y = h[g],
              v = a(y);
            v !== null &&
              (v instanceof HTMLImageElement
                ? m.push(v)
                : m.push(new Dc(v.data, v.width, v.height)));
          }
          i[d.uuid] = new Yu(m);
        } else {
          const m = a(d.url);
          i[d.uuid] = new Yu(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return o.data
          ? { data: eh(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new zg(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let d = 0, h = c.length; d < h; d++) {
            const m = c[d],
              g = await s(m);
            g !== null &&
              (g instanceof HTMLImageElement
                ? u.push(g)
                : u.push(new Dc(g.data, g.width, g.height)));
          }
          r[l.uuid] = new Yu(u);
        } else {
          const u = await s(l.url);
          r[l.uuid] = new Yu(u);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          c = l.data;
        let u;
        Array.isArray(c)
          ? ((u = new p0()), c.length === 6 && (u.needsUpdate = !0))
          : (c && c.data ? (u = new Dc()) : (u = new Fr()),
            c && (u.needsUpdate = !0)),
          (u.source = l),
          (u.uuid = a.uuid),
          a.name !== void 0 && (u.name = a.name),
          a.mapping !== void 0 && (u.mapping = r(a.mapping, KK)),
          a.channel !== void 0 && (u.channel = a.channel),
          a.offset !== void 0 && u.offset.fromArray(a.offset),
          a.repeat !== void 0 && u.repeat.fromArray(a.repeat),
          a.center !== void 0 && u.center.fromArray(a.center),
          a.rotation !== void 0 && (u.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((u.wrapS = r(a.wrap[0], HI)), (u.wrapT = r(a.wrap[1], HI))),
          a.format !== void 0 && (u.format = a.format),
          a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat),
          a.type !== void 0 && (u.type = a.type),
          a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (u.minFilter = r(a.minFilter, GI)),
          a.magFilter !== void 0 && (u.magFilter = r(a.magFilter, GI)),
          a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (u.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (u.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (u.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (u.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (u.compareFunction = a.compareFunction),
          a.userData !== void 0 && (u.userData = a.userData),
          (i[a.uuid] = u);
      }
    return i;
  }
  parseObject(e, t, r, i, s) {
    let o;
    function a(h) {
      return (
        t[h] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", h),
        t[h]
      );
    }
    function l(h) {
      if (h !== void 0) {
        if (Array.isArray(h)) {
          const m = [];
          for (let g = 0, x = h.length; g < x; g++) {
            const y = h[g];
            r[y] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", y),
              m.push(r[y]);
          }
          return m;
        }
        return (
          r[h] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", h),
          r[h]
        );
      }
    }
    function c(h) {
      return (
        i[h] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", h),
        i[h]
      );
    }
    let u, d;
    switch (e.type) {
      case "Scene":
        (o = new f1()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new pt(e.background))
              : (o.background = c(e.background))),
          e.environment !== void 0 && (o.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new __(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new x_(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            o.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (o.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (o = new Yn(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Fo(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new L2(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new I2(e.color, e.intensity);
        break;
      case "PointLight":
        o = new P2(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new Jk(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new B_(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new R2(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new tz().fromJSON(e);
        break;
      case "SkinnedMesh":
        (u = a(e.geometry)),
          (d = l(e.material)),
          (o = new Rk(u, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (u = a(e.geometry)), (d = l(e.material)), (o = new qn(u, d));
        break;
      case "InstancedMesh":
        (u = a(e.geometry)), (d = l(e.material));
        const h = e.count,
          m = e.instanceMatrix,
          g = e.instanceColor;
        (o = new Nk(u, d, h)),
          (o.instanceMatrix = new Hc(new Float32Array(m.array), 16)),
          g !== void 0 &&
            (o.instanceColor = new Hc(new Float32Array(g.array), g.itemSize));
        break;
      case "BatchedMesh":
        (u = a(e.geometry)),
          (d = l(e.material)),
          (o = new Pk(
            e.maxGeometryCount,
            e.maxVertexCount,
            e.maxIndexCount,
            d
          )),
          (o.geometry = u),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._visibility = e.visibility),
          (o._active = e.active),
          (o._bounds = e.bounds.map((x) => {
            const y = new zi();
            y.min.fromArray(x.boxMin), y.max.fromArray(x.boxMax);
            const v = new mi();
            return (
              (v.radius = x.sphereRadius),
              v.center.fromArray(x.sphereCenter),
              {
                boxInitialized: x.boxInitialized,
                box: y,
                sphereInitialized: x.sphereInitialized,
                sphere: v,
              }
            );
          })),
          (o._maxGeometryCount = e.maxGeometryCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._geometryCount = e.geometryCount),
          (o._matricesTexture = c(e.matricesTexture.uuid));
        break;
      case "LOD":
        o = new Ck();
        break;
      case "Line":
        o = new Gc(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new Ik(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new Qa(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new Lk(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new Tk(l(e.material));
        break;
      case "Group":
        o = new nh();
        break;
      case "Bone":
        o = new f2();
        break;
      default:
        o = new xn();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const h = e.children;
      for (let m = 0; m < h.length; m++)
        o.add(this.parseObject(h[m], t, r, i, s));
    }
    if (e.animations !== void 0) {
      const h = e.animations;
      for (let m = 0; m < h.length; m++) {
        const g = h[m];
        o.animations.push(s[g]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const h = e.levels;
      for (let m = 0; m < h.length; m++) {
        const g = h[m],
          x = o.getObjectByProperty("uuid", g.object);
        x !== void 0 && o.addLevel(x, g.distance, g.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
}
const KK = {
    UVMapping: h_,
    CubeReflectionMapping: Dl,
    CubeRefractionMapping: Bc,
    EquirectangularReflectionMapping: Sg,
    EquirectangularRefractionMapping: Ag,
    CubeUVReflectionMapping: np,
  },
  HI = {
    RepeatWrapping: wg,
    ClampToEdgeWrapping: Oo,
    MirroredRepeatWrapping: bg,
  },
  GI = {
    NearestFilter: Dr,
    NearestMipmapNearestFilter: jC,
    NearestMipmapLinearFilter: Jf,
    LinearFilter: dr,
    LinearMipmapNearestFilter: Wm,
    LinearMipmapLinearFilter: ca,
  };
class ZK extends Rs {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = Ml.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((c) => {
          t && t(c), s.manager.itemEnd(e);
        }).catch((c) => {
          i && i(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader);
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(s.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return Ml.add(e, c), t && t(c), s.manager.itemEnd(e), c;
      })
      .catch(function (c) {
        i && i(c), Ml.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
      });
    Ml.add(e, l), s.manager.itemStart(e);
  }
}
let Ey;
class D2 {
  static getContext() {
    return (
      Ey === void 0 &&
        (Ey = new (window.AudioContext || window.webkitAudioContext)()),
      Ey
    );
  }
  static setContext(e) {
    Ey = e;
  }
}
class QK extends Rs {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new Ul(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            D2.getContext()
              .decodeAudioData(c, function (d) {
                t(d);
              })
              .catch(a);
          } catch (c) {
            a(c);
          }
        },
        r,
        i
      );
    function a(l) {
      i ? i(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
const WI = new Ut(),
  jI = new Ut(),
  bu = new Ut();
class JK {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Yn()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Yn()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        bu.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        s = (i * t.near) / t.focus,
        o = (t.near * Math.tan(od * t.fov * 0.5)) / t.zoom;
      let a, l;
      (jI.elements[12] = -i),
        (WI.elements[12] = i),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (bu.elements[0] = (2 * t.near) / (l - a)),
        (bu.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(bu),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (bu.elements[0] = (2 * t.near) / (l - a)),
        (bu.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(bu);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jI),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(WI);
  }
}
class F2 {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = $I()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = $I();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function $I() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Eu = new Q(),
  XI = new ki(),
  eZ = new Q(),
  Mu = new Q();
class tZ extends xn {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = D2.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new F2());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      r = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Eu, XI, eZ),
      Mu.set(0, 0, -1).applyQuaternion(XI),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Eu.x, i),
        t.positionY.linearRampToValueAtTime(Eu.y, i),
        t.positionZ.linearRampToValueAtTime(Eu.z, i),
        t.forwardX.linearRampToValueAtTime(Mu.x, i),
        t.forwardY.linearRampToValueAtTime(Mu.y, i),
        t.forwardZ.linearRampToValueAtTime(Mu.z, i),
        t.upX.linearRampToValueAtTime(r.x, i),
        t.upY.linearRampToValueAtTime(r.y, i),
        t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(Eu.x, Eu.y, Eu.z),
        t.setOrientation(Mu.x, Mu.y, Mu.z, r.x, r.y, r.z);
  }
}
class rz extends xn {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Tu = new Q(),
  YI = new ki(),
  nZ = new Q(),
  Cu = new Q();
class rZ extends rz {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Tu, YI, nZ), Cu.set(0, 0, 1).applyQuaternion(YI);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Tu.x, r),
        t.positionY.linearRampToValueAtTime(Tu.y, r),
        t.positionZ.linearRampToValueAtTime(Tu.z, r),
        t.orientationX.linearRampToValueAtTime(Cu.x, r),
        t.orientationY.linearRampToValueAtTime(Cu.y, r),
        t.orientationZ.linearRampToValueAtTime(Cu.z, r);
    } else t.setPosition(Tu.x, Tu.y, Tu.z), t.setOrientation(Cu.x, Cu.y, Cu.z);
  }
}
class iZ {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class iz {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, s, o;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a) r[s + a] = r[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(r, s, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (r[l] !== r[l + t]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let s = r, o = i; s !== o; ++s) t[s] = t[i + (s % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, s) {
    if (i >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[r + o];
  }
  _slerp(e, t, r, i) {
    ki.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, s) {
    const o = this._workIndex * s;
    ki.multiplyQuaternionsFlat(e, o, e, t, e, r),
      ki.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, r, i, s) {
    const o = 1 - i;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[r + a] * i;
    }
  }
  _lerpAdditive(e, t, r, i, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[r + o] * i;
    }
  }
}
const U2 = "\\[\\]\\.:\\/",
  sZ = new RegExp("[" + U2 + "]", "g"),
  k2 = "[^" + U2 + "]",
  oZ = "[^" + U2.replace("\\.", "") + "]",
  aZ = /((?:WC+[\/:])*)/.source.replace("WC", k2),
  lZ = /(WCOD+)?/.source.replace("WCOD", oZ),
  cZ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", k2),
  uZ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", k2),
  dZ = new RegExp("^" + aZ + lZ + cZ + uZ + "$"),
  fZ = ["material", "materials", "bones", "map"];
class hZ {
  constructor(e, t, r) {
    const i = r || pn.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class pn {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || pn.parseTrackName(t)),
      (this.node = pn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new pn.Composite(e, t, r)
      : new pn(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(sZ, "");
  }
  static parseTrackName(e) {
    const t = dZ.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = r.nodeName.substring(i + 1);
      fZ.indexOf(s) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = s));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = r(a.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = pn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let c = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
pn.Composite = hZ;
pn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
pn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
pn.prototype.GetterByBindingType = [
  pn.prototype._getValue_direct,
  pn.prototype._getValue_array,
  pn.prototype._getValue_arrayElement,
  pn.prototype._getValue_toArray,
];
pn.prototype.SetterByBindingTypeAndVersioning = [
  [
    pn.prototype._setValue_direct,
    pn.prototype._setValue_direct_setNeedsUpdate,
    pn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_array,
    pn.prototype._setValue_array_setNeedsUpdate,
    pn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_arrayElement,
    pn.prototype._setValue_arrayElement_setNeedsUpdate,
    pn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    pn.prototype._setValue_fromArray,
    pn.prototype._setValue_fromArray_setNeedsUpdate,
    pn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class pZ {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = io()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      c = this.nCachedObjects_;
    for (let u = 0, d = arguments.length; u !== d; ++u) {
      const h = arguments[u],
        m = h.uuid;
      let g = t[m];
      if (g === void 0) {
        (g = l++), (t[m] = g), e.push(h);
        for (let x = 0, y = o; x !== y; ++x) s[x].push(new pn(h, r[x], i[x]));
      } else if (g < c) {
        a = e[g];
        const x = --c,
          y = e[x];
        (t[y.uuid] = g), (e[g] = y), (t[m] = x), (e[x] = h);
        for (let v = 0, _ = o; v !== _; ++v) {
          const S = s[v],
            w = S[x];
          let T = S[g];
          (S[g] = w), T === void 0 && (T = new pn(h, r[v], i[v])), (S[x] = T);
        }
      } else
        e[g] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        c = l.uuid,
        u = t[c];
      if (u !== void 0 && u >= s) {
        const d = s++,
          h = e[d];
        (t[h.uuid] = u), (e[u] = h), (t[c] = d), (e[d] = l);
        for (let m = 0, g = i; m !== g; ++m) {
          const x = r[m],
            y = x[d],
            v = x[u];
          (x[u] = y), (x[d] = v);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        u = c.uuid,
        d = t[u];
      if (d !== void 0)
        if ((delete t[u], d < s)) {
          const h = --s,
            m = e[h],
            g = --o,
            x = e[g];
          (t[m.uuid] = d), (e[d] = m), (t[x.uuid] = h), (e[h] = x), e.pop();
          for (let y = 0, v = i; y !== v; ++y) {
            const _ = r[y],
              S = _[h],
              w = _[g];
            (_[d] = S), (_[h] = w), _.pop();
          }
        } else {
          const h = --o,
            m = e[h];
          h > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let g = 0, x = i; g !== x; ++g) {
            const y = r[g];
            (y[d] = y[h]), y.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      c = l.length,
      u = this.nCachedObjects_,
      d = new Array(c);
    (i = s.length), (r[e] = i), o.push(e), a.push(t), s.push(d);
    for (let h = u, m = l.length; h !== m; ++h) {
      const g = l[h];
      d[h] = new pn(g, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        c = e[a];
      (t[c] = r),
        (o[r] = l),
        o.pop(),
        (s[r] = s[a]),
        s.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class sz {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: $u, endingEnd: $u };
    for (let c = 0; c !== o; ++c) {
      const u = s[c].createInterpolant(null);
      (a[c] = u), (u.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = Q4),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if ((e.fadeOut(t), this.fadeIn(t), r)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        o = s / i,
        a = i / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      s = i.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = s), (l[1] = s + r), (c[0] = e / o), (c[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * r;
      l < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case e2:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(o), c[u].accumulateAdditive(a);
          break;
        case p_:
        default:
          for (let u = 0, d = l.length; u !== d; ++u)
            l[u].evaluate(o), c[u].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const o = r === J4;
    if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
    if (r === Z4) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= t || i < 0)
      ) {
        const a = Math.floor(i / t);
        (i -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (o && (s & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = Xu), (i.endingEnd = Xu))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? Xu : $u)
          : (i.endingStart = Tg),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? Xu : $u) : (i.endingEnd = Tg));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      s = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = r), this;
  }
}
const mZ = new Float32Array(1);
class gZ extends Go {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = r.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let d = 0; d !== s; ++d) {
      const h = i[d],
        m = h.name;
      let g = u[m];
      if (g !== void 0) ++g.referenceCount, (o[d] = g);
      else {
        if (((g = o[d]), g !== void 0)) {
          g._cacheIndex === null &&
            (++g.referenceCount, this._addInactiveBinding(g, l, m));
          continue;
        }
        const x = t && t._propertyBindings[d].binding.parsedPath;
        (g = new iz(pn.create(r, m, x), h.ValueTypeName, h.getValueSize())),
          ++g.referenceCount,
          this._addInactiveBinding(g, l, m),
          (o[d] = g);
      }
      a[d].resultBuffer = g.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    (c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      h = (e._localRoot || this._root).uuid;
    delete d[h],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const s = t[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let o = i[t];
    o === void 0 && ((o = {}), (i[t] = o)),
      (o[r] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      s = r.path,
      o = this._bindingsByRootAndName,
      a = o[i],
      l = t[t.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new M2(new Float32Array(2), new Float32Array(2), 1, mZ)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = t[i];
    (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = r), (t[r] = s);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      s = i.uuid;
    let o = typeof e == "string" ? kg.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (r === void 0 && (o !== null ? (r = o.blendMode) : (r = p_)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === r) return d;
      (c = l.knownActions[0]), o === null && (o = c._clip);
    }
    if (o === null) return null;
    const u = new sz(this, o, t, r);
    return this._bindAction(u, c), this._addInactiveAction(u, a, s), u;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      s = typeof e == "string" ? kg.findByName(r, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let c = 0; c !== r; ++c) t[c]._update(i, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      s = i[r];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          d = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (d._cacheIndex = u),
          (t[u] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const o in r) {
      const a = r[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      s = i[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class z2 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new z2(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let vZ = 0;
class yZ extends Go {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: vZ++ }),
      (this.name = ""),
      (this.usage = Dh),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class oz extends g0 {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class xZ {
  constructor(e, t, r, i, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const qI = new Ut();
class az {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Id(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new ad()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      qI.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(qI),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return AM(e, this, r, t), r.sort(KI), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, s = e.length; i < s; i++) AM(e[i], this, r, t);
    return r.sort(KI), r;
  }
}
function KI(n, e) {
  return n.distance - e.distance;
}
function AM(n, e, t, r) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), r === !0)) {
    const i = n.children;
    for (let s = 0, o = i.length; s < o; s++) AM(i[s], e, t, !0);
  }
}
class wM {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(ur(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class _Z {
  constructor(e = 1, t = 0, r = 0) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ZI = new He();
class SZ {
  constructor(e = new He(1 / 0, 1 / 0), t = new He(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ZI.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ZI).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const QI = new Q(),
  My = new Q();
class AZ {
  constructor(e = new Q(), t = new Q()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    QI.subVectors(e, this.start), My.subVectors(this.end, this.start);
    const r = My.dot(My);
    let s = My.dot(QI) / r;
    return t && (s = ur(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const JI = new Q();
class wZ extends xn {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new qt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = (o / l) * Math.PI * 2,
        u = (a / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
    }
    r.setAttribute("position", new At(i, 3));
    const s = new Hi({ fog: !1, toneMapped: !1 });
    (this.cone = new Qa(r, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      JI.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(JI),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const dc = new Q(),
  Ty = new Ut(),
  Lw = new Ut();
class bZ extends Qa {
  constructor(e) {
    const t = lz(e),
      r = new qt(),
      i = [],
      s = [],
      o = new pt(0, 0, 1),
      a = new pt(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent &&
        u.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    r.setAttribute("position", new At(i, 3)),
      r.setAttribute("color", new At(s, 3));
    const l = new Hi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    Lw.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Ty.multiplyMatrices(Lw, a.matrixWorld),
        dc.setFromMatrixPosition(Ty),
        i.setXYZ(o, dc.x, dc.y, dc.z),
        Ty.multiplyMatrices(Lw, a.parent.matrixWorld),
        dc.setFromMatrixPosition(Ty),
        i.setXYZ(o + 1, dc.x, dc.y, dc.z),
        (o += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function lz(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, lz(n.children[t]));
  return e;
}
class EZ extends qn {
  constructor(e, t, r) {
    const i = new _0(t, 4, 2),
      s = new Za({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const MZ = new Q(),
  eL = new pt(),
  tL = new pt();
class TZ extends xn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new x0(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Za({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    i.setAttribute("color", new Mn(o, 3)),
      this.add(new qn(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      eL.copy(this.light.color), tL.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const s = r < i / 2 ? eL : tL;
        t.setXYZ(r, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(MZ.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class CZ extends Qa {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new pt(r)), (i = new pt(i));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      c = [];
    for (let h = 0, m = 0, g = -a; h <= t; h++, g += o) {
      l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
      const x = h === s ? r : i;
      x.toArray(c, m),
        (m += 3),
        x.toArray(c, m),
        (m += 3),
        x.toArray(c, m),
        (m += 3),
        x.toArray(c, m),
        (m += 3);
    }
    const u = new qt();
    u.setAttribute("position", new At(l, 3)),
      u.setAttribute("color", new At(c, 3));
    const d = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(u, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class RZ extends Qa {
  constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
    (s = new pt(s)), (o = new pt(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const h = (d / t) * (Math.PI * 2),
          m = Math.sin(h) * e,
          g = Math.cos(h) * e;
        a.push(0, 0, 0), a.push(m, 0, g);
        const x = d & 1 ? s : o;
        l.push(x.r, x.g, x.b), l.push(x.r, x.g, x.b);
      }
    for (let d = 0; d < r; d++) {
      const h = d & 1 ? s : o,
        m = e - (e / r) * d;
      for (let g = 0; g < i; g++) {
        let x = (g / i) * (Math.PI * 2),
          y = Math.sin(x) * m,
          v = Math.cos(x) * m;
        a.push(y, 0, v),
          l.push(h.r, h.g, h.b),
          (x = ((g + 1) / i) * (Math.PI * 2)),
          (y = Math.sin(x) * m),
          (v = Math.cos(x) * m),
          a.push(y, 0, v),
          l.push(h.r, h.g, h.b);
      }
    }
    const c = new qt();
    c.setAttribute("position", new At(a, 3)),
      c.setAttribute("color", new At(l, 3));
    const u = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(c, u), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const nL = new Q(),
  Cy = new Q(),
  rL = new Q();
class NZ extends xn {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new qt();
    i.setAttribute(
      "position",
      new At([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new Hi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Gc(i, s)),
      this.add(this.lightPlane),
      (i = new qt()),
      i.setAttribute("position", new At([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Gc(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      nL.setFromMatrixPosition(this.light.matrixWorld),
      Cy.setFromMatrixPosition(this.light.target.matrixWorld),
      rL.subVectors(Cy, nL),
      this.lightPlane.lookAt(Cy),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Cy),
      (this.targetLine.scale.z = rL.length());
  }
}
const Ry = new Q(),
  ar = new h0();
class PZ extends Qa {
  constructor(e) {
    const t = new qt(),
      r = new Hi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(g, x) {
      l(g), l(x);
    }
    function l(g) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        o[g] === void 0 && (o[g] = []),
        o[g].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new At(i, 3)),
      t.setAttribute("color", new At(s, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const c = new pt(16755200),
      u = new pt(16711680),
      d = new pt(43775),
      h = new pt(16777215),
      m = new pt(3355443);
    this.setColors(c, u, d, h, m);
  }
  setColors(e, t, r, i, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    ar.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      Ar("c", t, e, ar, 0, 0, -1),
      Ar("t", t, e, ar, 0, 0, 1),
      Ar("n1", t, e, ar, -r, -i, -1),
      Ar("n2", t, e, ar, r, -i, -1),
      Ar("n3", t, e, ar, -r, i, -1),
      Ar("n4", t, e, ar, r, i, -1),
      Ar("f1", t, e, ar, -r, -i, 1),
      Ar("f2", t, e, ar, r, -i, 1),
      Ar("f3", t, e, ar, -r, i, 1),
      Ar("f4", t, e, ar, r, i, 1),
      Ar("u1", t, e, ar, r * 0.7, i * 1.1, -1),
      Ar("u2", t, e, ar, -r * 0.7, i * 1.1, -1),
      Ar("u3", t, e, ar, 0, i * 2, -1),
      Ar("cf1", t, e, ar, -r, 0, 1),
      Ar("cf2", t, e, ar, r, 0, 1),
      Ar("cf3", t, e, ar, 0, -i, 1),
      Ar("cf4", t, e, ar, 0, i, 1),
      Ar("cn1", t, e, ar, -r, 0, -1),
      Ar("cn2", t, e, ar, r, 0, -1),
      Ar("cn3", t, e, ar, 0, -i, -1),
      Ar("cn4", t, e, ar, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Ar(n, e, t, r, i, s, o) {
  Ry.set(i, s, o).unproject(r);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++) l.setXYZ(a[c], Ry.x, Ry.y, Ry.z);
  }
}
const Ny = new zi();
class IZ extends Qa {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new qt();
    s.setIndex(new Mn(r, 1)),
      s.setAttribute("position", new Mn(i, 3)),
      super(s, new Hi({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Ny.setFromObject(this.object),
      Ny.isEmpty())
    )
      return;
    const t = Ny.min,
      r = Ny.max,
      i = this.geometry.attributes.position,
      s = i.array;
    (s[0] = r.x),
      (s[1] = r.y),
      (s[2] = r.z),
      (s[3] = t.x),
      (s[4] = r.y),
      (s[5] = r.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = r.z),
      (s[9] = r.x),
      (s[10] = t.y),
      (s[11] = r.z),
      (s[12] = r.x),
      (s[13] = r.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = r.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = r.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class LZ extends Qa {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new qt();
    s.setIndex(new Mn(r, 1)),
      s.setAttribute("position", new At(i, 3)),
      super(s, new Hi({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class OZ extends Gc {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new qt();
    o.setAttribute("position", new At(s, 3)),
      o.computeBoundingSphere(),
      super(o, new Hi({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new qt();
    l.setAttribute("position", new At(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new qn(
          l,
          new Za({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const iL = new Q();
let Py, Ow;
class DZ extends xn {
  constructor(
    e = new Q(0, 0, 1),
    t = new Q(0, 0, 0),
    r = 1,
    i = 16776960,
    s = r * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Py === void 0 &&
        ((Py = new qt()),
        Py.setAttribute("position", new At([0, 0, 0, 0, 1, 0], 3)),
        (Ow = new ap(0, 0.5, 1, 5, 1)),
        Ow.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Gc(Py, new Hi({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new qn(Ow, new Za({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      iL.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(iL, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class FZ extends Qa {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new qt();
    i.setAttribute("position", new At(t, 3)),
      i.setAttribute("color", new At(r, 3));
    const s = new Hi({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new pt(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(t),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(r),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class UZ {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new pt()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Ig()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    return this.currentPath.bezierCurveTo(e, t, r, i, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(v) {
      const _ = [];
      for (let S = 0, w = v.length; S < w; S++) {
        const T = v[S],
          E = new ld();
        (E.curves = T.curves), _.push(E);
      }
      return _;
    }
    function r(v, _) {
      const S = _.length;
      let w = !1;
      for (let T = S - 1, E = 0; E < S; T = E++) {
        let M = _[T],
          N = _[E],
          R = N.x - M.x,
          C = N.y - M.y;
        if (Math.abs(C) > Number.EPSILON) {
          if (
            (C < 0 && ((M = _[E]), (R = -R), (N = _[T]), (C = -C)),
            v.y < M.y || v.y > N.y)
          )
            continue;
          if (v.y === M.y) {
            if (v.x === M.x) return !0;
          } else {
            const L = C * (v.x - M.x) - R * (v.y - M.y);
            if (L === 0) return !0;
            if (L < 0) continue;
            w = !w;
          }
        } else {
          if (v.y !== M.y) continue;
          if ((N.x <= v.x && v.x <= M.x) || (M.x <= v.x && v.x <= N.x))
            return !0;
        }
      }
      return w;
    }
    const i = Wa.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const c = [];
    if (s.length === 1)
      return (a = s[0]), (l = new ld()), (l.curves = a.curves), c.push(l), c;
    let u = !i(s[0].getPoints());
    u = e ? !u : u;
    const d = [],
      h = [];
    let m = [],
      g = 0,
      x;
    (h[g] = void 0), (m[g] = []);
    for (let v = 0, _ = s.length; v < _; v++)
      (a = s[v]),
        (x = a.getPoints()),
        (o = i(x)),
        (o = e ? !o : o),
        o
          ? (!u && h[g] && g++,
            (h[g] = { s: new ld(), p: x }),
            (h[g].s.curves = a.curves),
            u && g++,
            (m[g] = []))
          : m[g].push({ h: a, p: x[0] });
    if (!h[0]) return t(s);
    if (h.length > 1) {
      let v = !1,
        _ = 0;
      for (let S = 0, w = h.length; S < w; S++) d[S] = [];
      for (let S = 0, w = h.length; S < w; S++) {
        const T = m[S];
        for (let E = 0; E < T.length; E++) {
          const M = T[E];
          let N = !0;
          for (let R = 0; R < h.length; R++)
            r(M.p, h[R].p) &&
              (S !== R && _++, N ? ((N = !1), d[R].push(M)) : (v = !0));
          N && d[S].push(M);
        }
      }
      _ > 0 && v === !1 && (m = d);
    }
    let y;
    for (let v = 0, _ = h.length; v < _; v++) {
      (l = h[v].s), c.push(l), (y = m[v]);
      for (let S = 0, w = y.length; S < w; S++) l.holes.push(y[S].h);
    }
    return c;
  }
}
class kZ extends va {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
    ),
      super(e, t, { ...i, count: r }),
      (this.isWebGLMultipleRenderTargets = !0);
  }
  get texture() {
    return this.textures;
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: u_ } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = u_));
const zZ = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: f_,
      AddEquation: xc,
      AddOperation: k4,
      AdditiveAnimationBlendMode: e2,
      AdditiveBlending: UE,
      AgXToneMapping: WC,
      AlphaFormat: j4,
      AlwaysCompare: ok,
      AlwaysDepth: P4,
      AlwaysStencilFunc: hM,
      AmbientLight: L2,
      AnimationAction: sz,
      AnimationClip: kg,
      AnimationLoader: VK,
      AnimationMixer: gZ,
      AnimationObjectGroup: pZ,
      AnimationUtils: UK,
      ArcCurve: Ok,
      ArrayCamera: bk,
      ArrowHelper: DZ,
      AttachedBindMode: BE,
      Audio: rz,
      AudioAnalyser: iZ,
      AudioContext: D2,
      AudioListener: tZ,
      AudioLoader: QK,
      AxesHelper: FZ,
      BackSide: pi,
      BasicDepthPacking: ek,
      BasicShadowMap: d4,
      BatchedMesh: Pk,
      Bone: f2,
      BooleanKeyframeTrack: Od,
      Box2: SZ,
      Box3: zi,
      Box3Helper: LZ,
      BoxGeometry: Ld,
      BoxHelper: IZ,
      BufferAttribute: Mn,
      BufferGeometry: qt,
      BufferGeometryLoader: nz,
      ByteType: H4,
      Cache: Ml,
      Camera: h0,
      CameraHelper: PZ,
      CanvasTexture: aK,
      CapsuleGeometry: E_,
      CatmullRomCurve3: Dk,
      CineonToneMapping: GC,
      CircleGeometry: M_,
      ClampToEdgeWrapping: Oo,
      Clock: F2,
      Color: pt,
      ColorKeyframeTrack: T2,
      ColorManagement: bn,
      CompressedArrayTexture: sK,
      CompressedCubeTexture: oK,
      CompressedTexture: w_,
      CompressedTextureLoader: HK,
      ConeGeometry: T_,
      ConstantAlphaFactor: C4,
      ConstantColorFactor: M4,
      CubeCamera: mk,
      CubeReflectionMapping: Dl,
      CubeRefractionMapping: Bc,
      CubeTexture: p0,
      CubeTextureLoader: GK,
      CubeUVReflectionMapping: np,
      CubicBezierCurve: m2,
      CubicBezierCurve3: Fk,
      CubicInterpolant: qk,
      CullFaceBack: FE,
      CullFaceFront: u4,
      CullFaceFrontBack: Z9,
      CullFaceNone: c4,
      Curve: Aa,
      CurvePath: kk,
      CustomBlending: f4,
      CustomToneMapping: z4,
      CylinderGeometry: ap,
      Cylindrical: _Z,
      Data3DTexture: a2,
      DataArrayTexture: f0,
      DataTexture: Dc,
      DataTextureLoader: WK,
      DataUtils: i7,
      DecrementStencilOp: lj,
      DecrementWrapStencilOp: uj,
      DefaultLoadingManager: Qk,
      DepthFormat: sd,
      DepthStencilFormat: Oh,
      DepthTexture: sp,
      DetachedBindMode: V4,
      DirectionalLight: I2,
      DirectionalLightHelper: NZ,
      DiscreteInterpolant: Kk,
      DisplayP3ColorSpace: m_,
      DodecahedronGeometry: C_,
      DoubleSide: Ys,
      DstAlphaFactor: S4,
      DstColorFactor: w4,
      DynamicCopyUsage: bj,
      DynamicDrawUsage: d1,
      DynamicReadUsage: Sj,
      EdgesGeometry: zk,
      EllipseCurve: b_,
      EqualCompare: nk,
      EqualDepth: L4,
      EqualStencilFunc: pj,
      EquirectangularReflectionMapping: Sg,
      EquirectangularRefractionMapping: Ag,
      Euler: ao,
      EventDispatcher: Go,
      ExtrudeGeometry: N_,
      FileLoader: Ul,
      Float16BufferAttribute: u7,
      Float32BufferAttribute: At,
      FloatType: Qs,
      Fog: __,
      FogExp2: x_,
      FramebufferTexture: h2,
      FrontSide: ja,
      Frustum: m0,
      GLBufferAttribute: xZ,
      GLSL1: Mj,
      GLSL3: pM,
      GreaterCompare: rk,
      GreaterDepth: D4,
      GreaterEqualCompare: sk,
      GreaterEqualDepth: O4,
      GreaterEqualStencilFunc: yj,
      GreaterStencilFunc: gj,
      GridHelper: CZ,
      Group: nh,
      HalfFloatType: rp,
      HemisphereLight: R2,
      HemisphereLightHelper: TZ,
      IcosahedronGeometry: P_,
      ImageBitmapLoader: ZK,
      ImageLoader: zg,
      ImageUtils: fk,
      IncrementStencilOp: aj,
      IncrementWrapStencilOp: cj,
      InstancedBufferAttribute: Hc,
      InstancedBufferGeometry: O2,
      InstancedInterleavedBuffer: oz,
      InstancedMesh: Nk,
      Int16BufferAttribute: l7,
      Int32BufferAttribute: c7,
      Int8BufferAttribute: s7,
      IntType: XC,
      InterleavedBuffer: g0,
      InterleavedBufferAttribute: Vc,
      Interpolant: S0,
      InterpolateDiscrete: Eg,
      InterpolateLinear: Mg,
      InterpolateSmooth: _x,
      InvertStencilOp: dj,
      KeepStencilOp: Fu,
      KeyframeTrack: wa,
      LOD: Ck,
      LatheGeometry: y0,
      Layers: ad,
      LessCompare: r2,
      LessDepth: I4,
      LessEqualCompare: i2,
      LessEqualDepth: _g,
      LessEqualStencilFunc: mj,
      LessStencilFunc: hj,
      Light: Jc,
      LightProbe: tz,
      Line: Gc,
      Line3: AZ,
      LineBasicMaterial: Hi,
      LineCurve: g2,
      LineCurve3: Uk,
      LineDashedMaterial: z_,
      LineLoop: Ik,
      LineSegments: Qa,
      LinearDisplayP3ColorSpace: d0,
      LinearFilter: dr,
      LinearInterpolant: M2,
      LinearMipMapLinearFilter: tj,
      LinearMipMapNearestFilter: ej,
      LinearMipmapLinearFilter: ca,
      LinearMipmapNearestFilter: Wm,
      LinearSRGBColorSpace: Ho,
      LinearToneMapping: VC,
      LinearTransfer: Cg,
      Loader: Rs,
      LoaderUtils: SM,
      LoadingManager: C2,
      LoopOnce: Z4,
      LoopPingPong: J4,
      LoopRepeat: Q4,
      LuminanceAlphaFormat: Y4,
      LuminanceFormat: X4,
      MOUSE: Ou,
      Material: oi,
      MaterialLoader: cp,
      MathUtils: o2,
      Matrix3: Qt,
      Matrix4: Ut,
      MaxEquation: g4,
      Mesh: qn,
      MeshBasicMaterial: Za,
      MeshDepthMaterial: v_,
      MeshDistanceMaterial: y_,
      MeshLambertMaterial: b2,
      MeshMatcapMaterial: $k,
      MeshNormalMaterial: w2,
      MeshPhongMaterial: A2,
      MeshPhysicalMaterial: S2,
      MeshStandardMaterial: k_,
      MeshToonMaterial: jk,
      MinEquation: m4,
      MirroredRepeatWrapping: bg,
      MixOperation: U4,
      MultiplyBlending: zE,
      MultiplyOperation: u0,
      NearestFilter: Dr,
      NearestMipMapLinearFilter: J9,
      NearestMipMapNearestFilter: Q9,
      NearestMipmapLinearFilter: Jf,
      NearestMipmapNearestFilter: jC,
      NeutralToneMapping: B4,
      NeverCompare: tk,
      NeverDepth: N4,
      NeverStencilFunc: fj,
      NoBlending: Cl,
      NoColorSpace: Al,
      NoToneMapping: ws,
      NormalAnimationBlendMode: p_,
      NormalBlending: id,
      NotEqualCompare: ik,
      NotEqualDepth: F4,
      NotEqualStencilFunc: vj,
      NumberKeyframeTrack: Fg,
      Object3D: xn,
      ObjectLoader: qK,
      ObjectSpaceNormalMap: n2,
      OctahedronGeometry: x0,
      OneFactor: y4,
      OneMinusConstantAlphaFactor: R4,
      OneMinusConstantColorFactor: T4,
      OneMinusDstAlphaFactor: A4,
      OneMinusDstColorFactor: b4,
      OneMinusSrcAlphaFactor: u1,
      OneMinusSrcColorFactor: _4,
      OrthographicCamera: Fo,
      P3Primaries: Ng,
      PCFShadowMap: d_,
      PCFSoftShadowMap: Gm,
      PMREMGenerator: mM,
      Path: Ig,
      PerspectiveCamera: Yn,
      Plane: Fa,
      PlaneGeometry: Gl,
      PlaneHelper: OZ,
      PointLight: P2,
      PointLightHelper: EZ,
      Points: Lk,
      PointsMaterial: v0,
      PolarGridHelper: RZ,
      PolyhedronGeometry: Qc,
      PositionalAudio: rZ,
      PropertyBinding: pn,
      PropertyMixer: iz,
      QuadraticBezierCurve: v2,
      QuadraticBezierCurve3: y2,
      Quaternion: ki,
      QuaternionKeyframeTrack: lp,
      QuaternionLinearInterpolant: Zk,
      RED_GREEN_RGTC2_Format: dM,
      RED_RGTC1_Format: K4,
      REVISION: u_,
      RGBADepthPacking: t2,
      RGBAFormat: ys,
      RGBAIntegerFormat: JC,
      RGBA_ASTC_10x10_Format: sM,
      RGBA_ASTC_10x5_Format: nM,
      RGBA_ASTC_10x6_Format: rM,
      RGBA_ASTC_10x8_Format: iM,
      RGBA_ASTC_12x10_Format: oM,
      RGBA_ASTC_12x12_Format: aM,
      RGBA_ASTC_4x4_Format: YE,
      RGBA_ASTC_5x4_Format: qE,
      RGBA_ASTC_5x5_Format: KE,
      RGBA_ASTC_6x5_Format: ZE,
      RGBA_ASTC_6x6_Format: QE,
      RGBA_ASTC_8x5_Format: JE,
      RGBA_ASTC_8x6_Format: eM,
      RGBA_ASTC_8x8_Format: tM,
      RGBA_BPTC_Format: xx,
      RGBA_ETC2_EAC_Format: XE,
      RGBA_PVRTC_2BPPV1_Format: WE,
      RGBA_PVRTC_4BPPV1_Format: GE,
      RGBA_S3TC_DXT1_Format: gx,
      RGBA_S3TC_DXT3_Format: vx,
      RGBA_S3TC_DXT5_Format: yx,
      RGBFormat: $4,
      RGB_BPTC_SIGNED_Format: lM,
      RGB_BPTC_UNSIGNED_Format: cM,
      RGB_ETC1_Format: jE,
      RGB_ETC2_Format: $E,
      RGB_PVRTC_2BPPV1_Format: HE,
      RGB_PVRTC_4BPPV1_Format: VE,
      RGB_S3TC_DXT1_Format: mx,
      RGFormat: q4,
      RGIntegerFormat: QC,
      RawShaderMaterial: Wk,
      Ray: Id,
      Raycaster: az,
      Rec709Primaries: Rg,
      RectAreaLight: Jk,
      RedFormat: KC,
      RedIntegerFormat: ZC,
      ReinhardToneMapping: HC,
      RenderTarget: Fl,
      RepeatWrapping: wg,
      ReplaceStencilOp: oj,
      ReverseSubtractEquation: p4,
      RingGeometry: I_,
      SIGNED_RED_GREEN_RGTC2_Format: fM,
      SIGNED_RED_RGTC1_Format: uM,
      SRGBColorSpace: Xs,
      SRGBTransfer: kn,
      Scene: f1,
      ShaderChunk: Kt,
      ShaderLib: aa,
      ShaderMaterial: Bo,
      ShadowMaterial: _2,
      Shape: ld,
      ShapeGeometry: L_,
      ShapePath: UZ,
      ShapeUtils: Wa,
      ShortType: G4,
      Skeleton: A_,
      SkeletonHelper: bZ,
      SkinnedMesh: Rk,
      Source: Yu,
      Sphere: mi,
      SphereGeometry: _0,
      Spherical: wM,
      SphericalHarmonics3: ez,
      SplineCurve: x2,
      SpotLight: B_,
      SpotLightHelper: wZ,
      Sprite: Tk,
      SpriteMaterial: S_,
      SrcAlphaFactor: c1,
      SrcAlphaSaturateFactor: E4,
      SrcColorFactor: x4,
      StaticCopyUsage: wj,
      StaticDrawUsage: Dh,
      StaticReadUsage: _j,
      StereoCamera: JK,
      StreamCopyUsage: Ej,
      StreamDrawUsage: xj,
      StreamReadUsage: Aj,
      StringKeyframeTrack: Dd,
      SubtractEquation: h4,
      SubtractiveBlending: kE,
      TOUCH: Du,
      TangentSpaceNormalMap: Xa,
      TetrahedronGeometry: O_,
      Texture: Fr,
      TextureLoader: jK,
      TorusGeometry: D_,
      TorusKnotGeometry: F_,
      Triangle: qs,
      TriangleFanDrawMode: ij,
      TriangleStripDrawMode: rj,
      TrianglesDrawMode: nj,
      TubeGeometry: U_,
      UVMapping: h_,
      Uint16BufferAttribute: l2,
      Uint32BufferAttribute: c2,
      Uint8BufferAttribute: o7,
      Uint8ClampedBufferAttribute: a7,
      Uniform: z2,
      UniformsGroup: yZ,
      UniformsLib: ht,
      UniformsUtils: u2,
      UnsignedByteType: $a,
      UnsignedInt248Type: ip,
      UnsignedInt5999Type: W4,
      UnsignedIntType: xd,
      UnsignedShort4444Type: YC,
      UnsignedShort5551Type: qC,
      UnsignedShortType: $C,
      VSMShadowMap: ta,
      Vector2: He,
      Vector3: Q,
      Vector4: rn,
      VectorKeyframeTrack: Ug,
      VideoTexture: iK,
      WebGL3DRenderTarget: Yj,
      WebGLArrayRenderTarget: Xj,
      WebGLCoordinateSystem: Do,
      WebGLCubeRenderTarget: gk,
      WebGLMultipleRenderTargets: kZ,
      WebGLRenderTarget: va,
      WebGLRenderer: Ek,
      WebGLUtils: wk,
      WebGPUCoordinateSystem: _d,
      WireframeGeometry: Gk,
      WrapAroundEnding: Tg,
      ZeroCurvatureEnding: $u,
      ZeroFactor: v4,
      ZeroSlopeEnding: Xu,
      ZeroStencilOp: sj,
      createCanvasElement: uk,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var cz = { exports: {} },
  Fd = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Fd.ConcurrentRoot = 1;
Fd.ContinuousEventPriority = 4;
Fd.DefaultEventPriority = 16;
Fd.DiscreteEventPriority = 1;
Fd.IdleEventPriority = 536870912;
Fd.LegacyRoot = 0;
cz.exports = Fd;
var ih = cz.exports;
function BZ(n) {
  let e;
  const t = new Set(),
    r = (c, u) => {
      const d = typeof c == "function" ? c(e) : c;
      if (d !== e) {
        const h = e;
        (e = u ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, h));
      }
    },
    i = () => e,
    s = (c, u = i, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let h = u(e);
      function m() {
        const g = u(e);
        if (!d(h, g)) {
          const x = h;
          c((h = g), x);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (c, u, d) =>
        u || d ? s(c, u, d) : (t.add(c), () => t.delete(c)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, l)), l;
}
const VZ =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  sL = VZ ? I.useEffect : I.useLayoutEffect;
function HZ(n) {
  const e = typeof n == "function" ? BZ(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, s] = I.useReducer((y) => y + 1, 0),
        o = e.getState(),
        a = I.useRef(o),
        l = I.useRef(r),
        c = I.useRef(i),
        u = I.useRef(!1),
        d = I.useRef();
      d.current === void 0 && (d.current = r(o));
      let h,
        m = !1;
      (a.current !== o || l.current !== r || c.current !== i || u.current) &&
        ((h = r(o)), (m = !i(d.current, h))),
        sL(() => {
          m && (d.current = h),
            (a.current = o),
            (l.current = r),
            (c.current = i),
            (u.current = !1);
        });
      const g = I.useRef(o);
      sL(() => {
        const y = () => {
            try {
              const _ = e.getState(),
                S = l.current(_);
              c.current(d.current, S) ||
                ((a.current = _), (d.current = S), s());
            } catch {
              (u.current = !0), s();
            }
          },
          v = e.subscribe(y);
        return e.getState() !== g.current && y(), v;
      }, []);
      const x = m ? h : d.current;
      return I.useDebugValue(x), x;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var uz = { exports: {} },
  dz = { exports: {} },
  fz = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(U, H) {
    var V = U.length;
    U.push(H);
    e: for (; 0 < V; ) {
      var k = (V - 1) >>> 1,
        W = U[k];
      if (0 < i(W, H)) (U[k] = H), (U[V] = W), (V = k);
      else break e;
    }
  }
  function t(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var H = U[0],
      V = U.pop();
    if (V !== H) {
      U[0] = V;
      e: for (var k = 0, W = U.length, ee = W >>> 1; k < ee; ) {
        var Y = 2 * (k + 1) - 1,
          K = U[Y],
          ae = Y + 1,
          se = U[ae];
        if (0 > i(K, V))
          ae < W && 0 > i(se, K)
            ? ((U[k] = se), (U[ae] = V), (k = ae))
            : ((U[k] = K), (U[Y] = V), (k = Y));
        else if (ae < W && 0 > i(se, V)) (U[k] = se), (U[ae] = V), (k = ae);
        else break e;
      }
    }
    return H;
  }
  function i(U, H) {
    var V = U.sortIndex - H.sortIndex;
    return V !== 0 ? V : U.id - H.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    h = 3,
    m = !1,
    g = !1,
    x = !1,
    y = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var H = t(c); H !== null; ) {
      if (H.callback === null) r(c);
      else if (H.startTime <= U)
        r(c), (H.sortIndex = H.expirationTime), e(l, H);
      else break;
      H = t(c);
    }
  }
  function w(U) {
    if (((x = !1), S(U), !g))
      if (t(l) !== null) (g = !0), G(T);
      else {
        var H = t(c);
        H !== null && j(w, H.startTime - U);
      }
  }
  function T(U, H) {
    (g = !1), x && ((x = !1), v(N), (N = -1)), (m = !0);
    var V = h;
    try {
      for (
        S(H), d = t(l);
        d !== null && (!(d.expirationTime > H) || (U && !L()));

      ) {
        var k = d.callback;
        if (typeof k == "function") {
          (d.callback = null), (h = d.priorityLevel);
          var W = k(d.expirationTime <= H);
          (H = n.unstable_now()),
            typeof W == "function" ? (d.callback = W) : d === t(l) && r(l),
            S(H);
        } else r(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var Y = t(c);
        Y !== null && j(w, Y.startTime - H), (ee = !1);
      }
      return ee;
    } finally {
      (d = null), (h = V), (m = !1);
    }
  }
  var E = !1,
    M = null,
    N = -1,
    R = 5,
    C = -1;
  function L() {
    return !(n.unstable_now() - C < R);
  }
  function O() {
    if (M !== null) {
      var U = n.unstable_now();
      C = U;
      var H = !0;
      try {
        H = M(!0, U);
      } finally {
        H ? D() : ((E = !1), (M = null));
      }
    } else E = !1;
  }
  var D;
  if (typeof _ == "function")
    D = function () {
      _(O);
    };
  else if (typeof MessageChannel < "u") {
    var B = new MessageChannel(),
      $ = B.port2;
    (B.port1.onmessage = O),
      (D = function () {
        $.postMessage(null);
      });
  } else
    D = function () {
      y(O, 0);
    };
  function G(U) {
    (M = U), E || ((E = !0), D());
  }
  function j(U, H) {
    N = y(function () {
      U(n.unstable_now());
    }, H);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      g || m || ((g = !0), G(T));
    }),
    (n.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (R = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return h;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (U) {
      switch (h) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = h;
      }
      var V = h;
      h = H;
      try {
        return U();
      } finally {
        h = V;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (U, H) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var V = h;
      h = U;
      try {
        return H();
      } finally {
        h = V;
      }
    }),
    (n.unstable_scheduleCallback = function (U, H, V) {
      var k = n.unstable_now();
      switch (
        (typeof V == "object" && V !== null
          ? ((V = V.delay), (V = typeof V == "number" && 0 < V ? k + V : k))
          : (V = k),
        U)
      ) {
        case 1:
          var W = -1;
          break;
        case 2:
          W = 250;
          break;
        case 5:
          W = 1073741823;
          break;
        case 4:
          W = 1e4;
          break;
        default:
          W = 5e3;
      }
      return (
        (W = V + W),
        (U = {
          id: u++,
          callback: H,
          priorityLevel: U,
          startTime: V,
          expirationTime: W,
          sortIndex: -1,
        }),
        V > k
          ? ((U.sortIndex = V),
            e(c, U),
            t(l) === null &&
              U === t(c) &&
              (x ? (v(N), (N = -1)) : (x = !0), j(w, V - k)))
          : ((U.sortIndex = W), e(l, U), g || m || ((g = !0), G(T))),
        U
      );
    }),
    (n.unstable_shouldYield = L),
    (n.unstable_wrapCallback = function (U) {
      var H = h;
      return function () {
        var V = h;
        h = H;
        try {
          return U.apply(this, arguments);
        } finally {
          h = V;
        }
      };
    });
})(fz);
dz.exports = fz;
var bM = dz.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var GZ = function (e) {
  var t = {},
    r = I,
    i = bM,
    s = Object.assign;
  function o(f) {
    for (
      var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + f,
        A = 1;
      A < arguments.length;
      A++
    )
      p += "&args[]=" + encodeURIComponent(arguments[A]);
    return (
      "Minified React error #" +
      f +
      "; visit " +
      p +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    u = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    h = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    g = Symbol.for("react.context"),
    x = Symbol.for("react.forward_ref"),
    y = Symbol.for("react.suspense"),
    v = Symbol.for("react.suspense_list"),
    _ = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    T = Symbol.iterator;
  function E(f) {
    return f === null || typeof f != "object"
      ? null
      : ((f = (T && f[T]) || f["@@iterator"]),
        typeof f == "function" ? f : null);
  }
  function M(f) {
    if (f == null) return null;
    if (typeof f == "function") return f.displayName || f.name || null;
    if (typeof f == "string") return f;
    switch (f) {
      case u:
        return "Fragment";
      case c:
        return "Portal";
      case h:
        return "Profiler";
      case d:
        return "StrictMode";
      case y:
        return "Suspense";
      case v:
        return "SuspenseList";
    }
    if (typeof f == "object")
      switch (f.$$typeof) {
        case g:
          return (f.displayName || "Context") + ".Consumer";
        case m:
          return (f._context.displayName || "Context") + ".Provider";
        case x:
          var p = f.render;
          return (
            (f = f.displayName),
            f ||
              ((f = p.displayName || p.name || ""),
              (f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")),
            f
          );
        case _:
          return (
            (p = f.displayName || null), p !== null ? p : M(f.type) || "Memo"
          );
        case S:
          (p = f._payload), (f = f._init);
          try {
            return M(f(p));
          } catch {}
      }
    return null;
  }
  function N(f) {
    var p = f.type;
    switch (f.tag) {
      case 24:
        return "Cache";
      case 9:
        return (p.displayName || "Context") + ".Consumer";
      case 10:
        return (p._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (f = p.render),
          (f = f.displayName || f.name || ""),
          p.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return p;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return M(p);
      case 8:
        return p === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof p == "function") return p.displayName || p.name || null;
        if (typeof p == "string") return p;
    }
    return null;
  }
  function R(f) {
    var p = f,
      A = f;
    if (f.alternate) for (; p.return; ) p = p.return;
    else {
      f = p;
      do (p = f), p.flags & 4098 && (A = p.return), (f = p.return);
      while (f);
    }
    return p.tag === 3 ? A : null;
  }
  function C(f) {
    if (R(f) !== f) throw Error(o(188));
  }
  function L(f) {
    var p = f.alternate;
    if (!p) {
      if (((p = R(f)), p === null)) throw Error(o(188));
      return p !== f ? null : f;
    }
    for (var A = f, b = p; ; ) {
      var P = A.return;
      if (P === null) break;
      var F = P.alternate;
      if (F === null) {
        if (((b = P.return), b !== null)) {
          A = b;
          continue;
        }
        break;
      }
      if (P.child === F.child) {
        for (F = P.child; F; ) {
          if (F === A) return C(P), f;
          if (F === b) return C(P), p;
          F = F.sibling;
        }
        throw Error(o(188));
      }
      if (A.return !== b.return) (A = P), (b = F);
      else {
        for (var ne = !1, pe = P.child; pe; ) {
          if (pe === A) {
            (ne = !0), (A = P), (b = F);
            break;
          }
          if (pe === b) {
            (ne = !0), (b = P), (A = F);
            break;
          }
          pe = pe.sibling;
        }
        if (!ne) {
          for (pe = F.child; pe; ) {
            if (pe === A) {
              (ne = !0), (A = F), (b = P);
              break;
            }
            if (pe === b) {
              (ne = !0), (b = F), (A = P);
              break;
            }
            pe = pe.sibling;
          }
          if (!ne) throw Error(o(189));
        }
      }
      if (A.alternate !== b) throw Error(o(190));
    }
    if (A.tag !== 3) throw Error(o(188));
    return A.stateNode.current === A ? f : p;
  }
  function O(f) {
    return (f = L(f)), f !== null ? D(f) : null;
  }
  function D(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      var p = D(f);
      if (p !== null) return p;
      f = f.sibling;
    }
    return null;
  }
  function B(f) {
    if (f.tag === 5 || f.tag === 6) return f;
    for (f = f.child; f !== null; ) {
      if (f.tag !== 4) {
        var p = B(f);
        if (p !== null) return p;
      }
      f = f.sibling;
    }
    return null;
  }
  var $ = Array.isArray,
    G = e.getPublicInstance,
    j = e.getRootHostContext,
    U = e.getChildHostContext,
    H = e.prepareForCommit,
    V = e.resetAfterCommit,
    k = e.createInstance,
    W = e.appendInitialChild,
    ee = e.finalizeInitialChildren,
    Y = e.prepareUpdate,
    K = e.shouldSetTextContent,
    ae = e.createTextInstance,
    se = e.scheduleTimeout,
    we = e.cancelTimeout,
    Be = e.noTimeout,
    te = e.isPrimaryRenderer,
    ge = e.supportsMutation,
    ie = e.supportsPersistence,
    me = e.supportsHydration,
    fe = e.getInstanceFromNode,
    Ee = e.preparePortalMount,
    Se = e.getCurrentEventPriority,
    Ue = e.detachDeletedInstance,
    Ce = e.supportsMicrotasks,
    X = e.scheduleMicrotask,
    z = e.supportsTestSelectors,
    q = e.findFiberRoot,
    ue = e.getBoundingRect,
    de = e.getTextContent,
    he = e.isHiddenSubtree,
    Ie = e.matchAccessibilityRole,
    ke = e.setFocusIfFocusable,
    Me = e.setupIntersectionObserver,
    et = e.appendChild,
    Ne = e.appendChildToContainer,
    We = e.commitTextUpdate,
    ot = e.commitMount,
    nt = e.commitUpdate,
    Ke = e.insertBefore,
    it = e.insertInContainerBefore,
    re = e.removeChild,
    ze = e.removeChildFromContainer,
    Xe = e.resetTextContent,
    le = e.hideInstance,
    Re = e.hideTextInstance,
    xe = e.unhideInstance,
    Ye = e.unhideTextInstance,
    at = e.clearContainer,
    vt = e.cloneInstance,
    dt = e.createContainerChildSet,
    mt = e.appendChildToContainerChildSet,
    kt = e.finalizeContainerChildren,
    lt = e.replaceContainerChildren,
    St = e.cloneHiddenInstance,
    Nt = e.cloneHiddenTextInstance,
    gn = e.canHydrateInstance,
    dn = e.canHydrateTextInstance,
    gr = e.canHydrateSuspenseInstance,
    Kr = e.isSuspenseInstancePending,
    Ur = e.isSuspenseInstanceFallback,
    kr = e.registerSuspenseInstanceRetry,
    zr = e.getNextHydratableSibling,
    Ai = e.getFirstHydratableChild,
    vr = e.getFirstHydratableChildWithinContainer,
    Ps = e.getFirstHydratableChildWithinSuspenseInstance,
    wi = e.hydrateInstance,
    Z = e.hydrateTextInstance,
    be = e.hydrateSuspenseInstance,
    Fe = e.getNextHydratableInstanceAfterSuspenseInstance,
    Pe = e.commitHydratedContainer,
    Le = e.commitHydratedSuspenseInstance,
    ft = e.clearSuspenseBoundary,
    wt = e.clearSuspenseBoundaryFromContainer,
    bt = e.shouldDeleteUnhydratedTailInstances,
    Dt = e.didNotMatchHydratedContainerTextInstance,
    Ht = e.didNotMatchHydratedTextInstance,
    tt;
  function Vt(f) {
    if (tt === void 0)
      try {
        throw Error();
      } catch (A) {
        var p = A.stack.trim().match(/\n( *(at )?)/);
        tt = (p && p[1]) || "";
      }
    return (
      `
` +
      tt +
      f
    );
  }
  var Un = !1;
  function Nn(f, p) {
    if (!f || Un) return "";
    Un = !0;
    var A = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (p)
        if (
          ((p = function () {
            throw Error();
          }),
          Object.defineProperty(p.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(p, []);
          } catch (st) {
            var b = st;
          }
          Reflect.construct(f, [], p);
        } else {
          try {
            p.call();
          } catch (st) {
            b = st;
          }
          f.call(p.prototype);
        }
      else {
        try {
          throw Error();
        } catch (st) {
          b = st;
        }
        f();
      }
    } catch (st) {
      if (st && b && typeof st.stack == "string") {
        for (
          var P = st.stack.split(`
`),
            F = b.stack.split(`
`),
            ne = P.length - 1,
            pe = F.length - 1;
          1 <= ne && 0 <= pe && P[ne] !== F[pe];

        )
          pe--;
        for (; 1 <= ne && 0 <= pe; ne--, pe--)
          if (P[ne] !== F[pe]) {
            if (ne !== 1 || pe !== 1)
              do
                if ((ne--, pe--, 0 > pe || P[ne] !== F[pe])) {
                  var Ge =
                    `
` + P[ne].replace(" at new ", " at ");
                  return (
                    f.displayName &&
                      Ge.includes("<anonymous>") &&
                      (Ge = Ge.replace("<anonymous>", f.displayName)),
                    Ge
                  );
                }
              while (1 <= ne && 0 <= pe);
            break;
          }
      }
    } finally {
      (Un = !1), (Error.prepareStackTrace = A);
    }
    return (f = f ? f.displayName || f.name : "") ? Vt(f) : "";
  }
  var Tr = Object.prototype.hasOwnProperty,
    bi = [],
    en = -1;
  function It(f) {
    return { current: f };
  }
  function cn(f) {
    0 > en || ((f.current = bi[en]), (bi[en] = null), en--);
  }
  function Ft(f, p) {
    en++, (bi[en] = f.current), (f.current = p);
  }
  var yr = {},
    sr = It(yr),
    jn = It(!1),
    ls = yr;
  function wn(f, p) {
    var A = f.type.contextTypes;
    if (!A) return yr;
    var b = f.stateNode;
    if (b && b.__reactInternalMemoizedUnmaskedChildContext === p)
      return b.__reactInternalMemoizedMaskedChildContext;
    var P = {},
      F;
    for (F in A) P[F] = p[F];
    return (
      b &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = p),
        (f.__reactInternalMemoizedMaskedChildContext = P)),
      P
    );
  }
  function Pn(f) {
    return (f = f.childContextTypes), f != null;
  }
  function Gi() {
    cn(jn), cn(sr);
  }
  function Br(f, p, A) {
    if (sr.current !== yr) throw Error(o(168));
    Ft(sr, p), Ft(jn, A);
  }
  function ba(f, p, A) {
    var b = f.stateNode;
    if (((p = p.childContextTypes), typeof b.getChildContext != "function"))
      return A;
    b = b.getChildContext();
    for (var P in b) if (!(P in p)) throw Error(o(108, N(f) || "Unknown", P));
    return s({}, A, b);
  }
  function Ea(f) {
    return (
      (f =
        ((f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext) ||
        yr),
      (ls = sr.current),
      Ft(sr, f),
      Ft(jn, jn.current),
      !0
    );
  }
  function Ei(f, p, A) {
    var b = f.stateNode;
    if (!b) throw Error(o(169));
    A
      ? ((f = ba(f, p, ls)),
        (b.__reactInternalMemoizedMergedChildContext = f),
        cn(jn),
        cn(sr),
        Ft(sr, f))
      : cn(jn),
      Ft(jn, A);
  }
  var Is = Math.clz32 ? Math.clz32 : L0,
    Wd = Math.log,
    tu = Math.LN2;
  function L0(f) {
    return (f >>>= 0), f === 0 ? 32 : (31 - ((Wd(f) / tu) | 0)) | 0;
  }
  var el = 64,
    tl = 4194304;
  function nl(f) {
    switch (f & -f) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return f & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return f;
    }
  }
  function nu(f, p) {
    var A = f.pendingLanes;
    if (A === 0) return 0;
    var b = 0,
      P = f.suspendedLanes,
      F = f.pingedLanes,
      ne = A & 268435455;
    if (ne !== 0) {
      var pe = ne & ~P;
      pe !== 0 ? (b = nl(pe)) : ((F &= ne), F !== 0 && (b = nl(F)));
    } else (ne = A & ~P), ne !== 0 ? (b = nl(ne)) : F !== 0 && (b = nl(F));
    if (b === 0) return 0;
    if (
      p !== 0 &&
      p !== b &&
      !(p & P) &&
      ((P = b & -b), (F = p & -p), P >= F || (P === 16 && (F & 4194240) !== 0))
    )
      return p;
    if ((b & 4 && (b |= A & 16), (p = f.entangledLanes), p !== 0))
      for (f = f.entanglements, p &= b; 0 < p; )
        (A = 31 - Is(p)), (P = 1 << A), (b |= f[A]), (p &= ~P);
    return b;
  }
  function O0(f, p) {
    switch (f) {
      case 1:
      case 2:
      case 4:
        return p + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return p + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ep(f, p) {
    for (
      var A = f.suspendedLanes,
        b = f.pingedLanes,
        P = f.expirationTimes,
        F = f.pendingLanes;
      0 < F;

    ) {
      var ne = 31 - Is(F),
        pe = 1 << ne,
        Ge = P[ne];
      Ge === -1
        ? (!(pe & A) || pe & b) && (P[ne] = O0(pe, p))
        : Ge <= p && (f.expiredLanes |= pe),
        (F &= ~pe);
    }
  }
  function rl(f) {
    return (
      (f = f.pendingLanes & -1073741825),
      f !== 0 ? f : f & 1073741824 ? 1073741824 : 0
    );
  }
  function jd(f) {
    for (var p = [], A = 0; 31 > A; A++) p.push(f);
    return p;
  }
  function Ma(f, p, A) {
    (f.pendingLanes |= p),
      p !== 536870912 && ((f.suspendedLanes = 0), (f.pingedLanes = 0)),
      (f = f.eventTimes),
      (p = 31 - Is(p)),
      (f[p] = A);
  }
  function Xl(f, p) {
    var A = f.pendingLanes & ~p;
    (f.pendingLanes = p),
      (f.suspendedLanes = 0),
      (f.pingedLanes = 0),
      (f.expiredLanes &= p),
      (f.mutableReadLanes &= p),
      (f.entangledLanes &= p),
      (p = f.entanglements);
    var b = f.eventTimes;
    for (f = f.expirationTimes; 0 < A; ) {
      var P = 31 - Is(A),
        F = 1 << P;
      (p[P] = 0), (b[P] = -1), (f[P] = -1), (A &= ~F);
    }
  }
  function Ta(f, p) {
    var A = (f.entangledLanes |= p);
    for (f = f.entanglements; A; ) {
      var b = 31 - Is(A),
        P = 1 << b;
      (P & p) | (f[b] & p) && (f[b] |= p), (A &= ~P);
    }
  }
  var sn = 0;
  function Mp(f) {
    return (
      (f &= -f), 1 < f ? (4 < f ? (f & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var il = i.unstable_scheduleCallback,
    $d = i.unstable_cancelCallback,
    Tp = i.unstable_shouldYield,
    D0 = i.unstable_requestPaint,
    Zn = i.unstable_now,
    ru = i.unstable_ImmediatePriority,
    F0 = i.unstable_UserBlockingPriority,
    Wi = i.unstable_NormalPriority,
    Cp = i.unstable_IdlePriority,
    iu = null,
    Ls = null;
  function Rp(f) {
    if (Ls && typeof Ls.onCommitFiberRoot == "function")
      try {
        Ls.onCommitFiberRoot(iu, f, void 0, (f.current.flags & 128) === 128);
      } catch {}
  }
  function U0(f, p) {
    return (f === p && (f !== 0 || 1 / f === 1 / p)) || (f !== f && p !== p);
  }
  var Os = typeof Object.is == "function" ? Object.is : U0,
    ji = null,
    Ca = !1,
    vo = !1;
  function Np(f) {
    ji === null ? (ji = [f]) : ji.push(f);
  }
  function Pp(f) {
    (Ca = !0), Np(f);
  }
  function cs() {
    if (!vo && ji !== null) {
      vo = !0;
      var f = 0,
        p = sn;
      try {
        var A = ji;
        for (sn = 1; f < A.length; f++) {
          var b = A[f];
          do b = b(!0);
          while (b !== null);
        }
        (ji = null), (Ca = !1);
      } catch (P) {
        throw (ji !== null && (ji = ji.slice(f + 1)), il(ru, cs), P);
      } finally {
        (sn = p), (vo = !1);
      }
    }
    return null;
  }
  var su = a.ReactCurrentBatchConfig;
  function ou(f, p) {
    if (Os(f, p)) return !0;
    if (
      typeof f != "object" ||
      f === null ||
      typeof p != "object" ||
      p === null
    )
      return !1;
    var A = Object.keys(f),
      b = Object.keys(p);
    if (A.length !== b.length) return !1;
    for (b = 0; b < A.length; b++) {
      var P = A[b];
      if (!Tr.call(p, P) || !Os(f[P], p[P])) return !1;
    }
    return !0;
  }
  function au(f) {
    switch (f.tag) {
      case 5:
        return Vt(f.type);
      case 16:
        return Vt("Lazy");
      case 13:
        return Vt("Suspense");
      case 19:
        return Vt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (f = Nn(f.type, !1)), f;
      case 11:
        return (f = Nn(f.type.render, !1)), f;
      case 1:
        return (f = Nn(f.type, !0)), f;
      default:
        return "";
    }
  }
  function $i(f, p) {
    if (f && f.defaultProps) {
      (p = s({}, p)), (f = f.defaultProps);
      for (var A in f) p[A] === void 0 && (p[A] = f[A]);
      return p;
    }
    return p;
  }
  var Zr = It(null),
    Xd = null,
    Xo = null,
    Yl = null;
  function Yd() {
    Yl = Xo = Xd = null;
  }
  function k0(f, p, A) {
    te
      ? (Ft(Zr, p._currentValue), (p._currentValue = A))
      : (Ft(Zr, p._currentValue2), (p._currentValue2 = A));
  }
  function Qr(f) {
    var p = Zr.current;
    cn(Zr), te ? (f._currentValue = p) : (f._currentValue2 = p);
  }
  function Xi(f, p, A) {
    for (; f !== null; ) {
      var b = f.alternate;
      if (
        ((f.childLanes & p) !== p
          ? ((f.childLanes |= p), b !== null && (b.childLanes |= p))
          : b !== null && (b.childLanes & p) !== p && (b.childLanes |= p),
        f === A)
      )
        break;
      f = f.return;
    }
  }
  function xr(f, p) {
    (Xd = f),
      (Yl = Xo = null),
      (f = f.dependencies),
      f !== null &&
        f.firstContext !== null &&
        (f.lanes & p && (ks = !0), (f.firstContext = null));
  }
  function _r(f) {
    var p = te ? f._currentValue : f._currentValue2;
    if (Yl !== f)
      if (((f = { context: f, memoizedValue: p, next: null }), Xo === null)) {
        if (Xd === null) throw Error(o(308));
        (Xo = f), (Xd.dependencies = { lanes: 0, firstContext: f });
      } else Xo = Xo.next = f;
    return p;
  }
  var Ds = null,
    ql = !1;
  function PS(f) {
    f.updateQueue = {
      baseState: f.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function HR(f, p) {
    (f = f.updateQueue),
      p.updateQueue === f &&
        (p.updateQueue = {
          baseState: f.baseState,
          firstBaseUpdate: f.firstBaseUpdate,
          lastBaseUpdate: f.lastBaseUpdate,
          shared: f.shared,
          effects: f.effects,
        });
  }
  function sl(f, p) {
    return {
      eventTime: f,
      lane: p,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function Kl(f, p) {
    var A = f.updateQueue;
    A !== null &&
      ((A = A.shared),
      Cr !== null && f.mode & 1 && !(nn & 2)
        ? ((f = A.interleaved),
          f === null
            ? ((p.next = p), Ds === null ? (Ds = [A]) : Ds.push(A))
            : ((p.next = f.next), (f.next = p)),
          (A.interleaved = p))
        : ((f = A.pending),
          f === null ? (p.next = p) : ((p.next = f.next), (f.next = p)),
          (A.pending = p)));
  }
  function z0(f, p, A) {
    if (
      ((p = p.updateQueue), p !== null && ((p = p.shared), (A & 4194240) !== 0))
    ) {
      var b = p.lanes;
      (b &= f.pendingLanes), (A |= b), (p.lanes = A), Ta(f, A);
    }
  }
  function GR(f, p) {
    var A = f.updateQueue,
      b = f.alternate;
    if (b !== null && ((b = b.updateQueue), A === b)) {
      var P = null,
        F = null;
      if (((A = A.firstBaseUpdate), A !== null)) {
        do {
          var ne = {
            eventTime: A.eventTime,
            lane: A.lane,
            tag: A.tag,
            payload: A.payload,
            callback: A.callback,
            next: null,
          };
          F === null ? (P = F = ne) : (F = F.next = ne), (A = A.next);
        } while (A !== null);
        F === null ? (P = F = p) : (F = F.next = p);
      } else P = F = p;
      (A = {
        baseState: b.baseState,
        firstBaseUpdate: P,
        lastBaseUpdate: F,
        shared: b.shared,
        effects: b.effects,
      }),
        (f.updateQueue = A);
      return;
    }
    (f = A.lastBaseUpdate),
      f === null ? (A.firstBaseUpdate = p) : (f.next = p),
      (A.lastBaseUpdate = p);
  }
  function B0(f, p, A, b) {
    var P = f.updateQueue;
    ql = !1;
    var F = P.firstBaseUpdate,
      ne = P.lastBaseUpdate,
      pe = P.shared.pending;
    if (pe !== null) {
      P.shared.pending = null;
      var Ge = pe,
        st = Ge.next;
      (Ge.next = null), ne === null ? (F = st) : (ne.next = st), (ne = Ge);
      var _t = f.alternate;
      _t !== null &&
        ((_t = _t.updateQueue),
        (pe = _t.lastBaseUpdate),
        pe !== ne &&
          (pe === null ? (_t.firstBaseUpdate = st) : (pe.next = st),
          (_t.lastBaseUpdate = Ge)));
    }
    if (F !== null) {
      var Xt = P.baseState;
      (ne = 0), (_t = st = Ge = null), (pe = F);
      do {
        var zt = pe.lane,
          In = pe.eventTime;
        if ((b & zt) === zt) {
          _t !== null &&
            (_t = _t.next =
              {
                eventTime: In,
                lane: 0,
                tag: pe.tag,
                payload: pe.payload,
                callback: pe.callback,
                next: null,
              });
          e: {
            var Pt = f,
              Ri = pe;
            switch (((zt = p), (In = A), Ri.tag)) {
              case 1:
                if (((Pt = Ri.payload), typeof Pt == "function")) {
                  Xt = Pt.call(In, Xt, zt);
                  break e;
                }
                Xt = Pt;
                break e;
              case 3:
                Pt.flags = (Pt.flags & -65537) | 128;
              case 0:
                if (
                  ((Pt = Ri.payload),
                  (zt = typeof Pt == "function" ? Pt.call(In, Xt, zt) : Pt),
                  zt == null)
                )
                  break e;
                Xt = s({}, Xt, zt);
                break e;
              case 2:
                ql = !0;
            }
          }
          pe.callback !== null &&
            pe.lane !== 0 &&
            ((f.flags |= 64),
            (zt = P.effects),
            zt === null ? (P.effects = [pe]) : zt.push(pe));
        } else
          (In = {
            eventTime: In,
            lane: zt,
            tag: pe.tag,
            payload: pe.payload,
            callback: pe.callback,
            next: null,
          }),
            _t === null ? ((st = _t = In), (Ge = Xt)) : (_t = _t.next = In),
            (ne |= zt);
        if (((pe = pe.next), pe === null)) {
          if (((pe = P.shared.pending), pe === null)) break;
          (zt = pe),
            (pe = zt.next),
            (zt.next = null),
            (P.lastBaseUpdate = zt),
            (P.shared.pending = null);
        }
      } while (!0);
      if (
        (_t === null && (Ge = Xt),
        (P.baseState = Ge),
        (P.firstBaseUpdate = st),
        (P.lastBaseUpdate = _t),
        (p = P.shared.interleaved),
        p !== null)
      ) {
        P = p;
        do (ne |= P.lane), (P = P.next);
        while (P !== p);
      } else F === null && (P.shared.lanes = 0);
      (rf |= ne), (f.lanes = ne), (f.memoizedState = Xt);
    }
  }
  function WR(f, p, A) {
    if (((f = p.effects), (p.effects = null), f !== null))
      for (p = 0; p < f.length; p++) {
        var b = f[p],
          P = b.callback;
        if (P !== null) {
          if (((b.callback = null), (b = A), typeof P != "function"))
            throw Error(o(191, P));
          P.call(b);
        }
      }
  }
  var jR = new r.Component().refs;
  function IS(f, p, A, b) {
    (p = f.memoizedState),
      (A = A(b, p)),
      (A = A == null ? p : s({}, p, A)),
      (f.memoizedState = A),
      f.lanes === 0 && (f.updateQueue.baseState = A);
  }
  var V0 = {
    isMounted: function (f) {
      return (f = f._reactInternals) ? R(f) === f : !1;
    },
    enqueueSetState: function (f, p, A) {
      f = f._reactInternals;
      var b = qi(),
        P = Jl(f),
        F = sl(b, P);
      (F.payload = p),
        A != null && (F.callback = A),
        Kl(f, F),
        (p = Ao(f, P, b)),
        p !== null && z0(p, f, P);
    },
    enqueueReplaceState: function (f, p, A) {
      f = f._reactInternals;
      var b = qi(),
        P = Jl(f),
        F = sl(b, P);
      (F.tag = 1),
        (F.payload = p),
        A != null && (F.callback = A),
        Kl(f, F),
        (p = Ao(f, P, b)),
        p !== null && z0(p, f, P);
    },
    enqueueForceUpdate: function (f, p) {
      f = f._reactInternals;
      var A = qi(),
        b = Jl(f),
        P = sl(A, b);
      (P.tag = 2),
        p != null && (P.callback = p),
        Kl(f, P),
        (p = Ao(f, b, A)),
        p !== null && z0(p, f, b);
    },
  };
  function $R(f, p, A, b, P, F, ne) {
    return (
      (f = f.stateNode),
      typeof f.shouldComponentUpdate == "function"
        ? f.shouldComponentUpdate(b, F, ne)
        : p.prototype && p.prototype.isPureReactComponent
        ? !ou(A, b) || !ou(P, F)
        : !0
    );
  }
  function XR(f, p, A) {
    var b = !1,
      P = yr,
      F = p.contextType;
    return (
      typeof F == "object" && F !== null
        ? (F = _r(F))
        : ((P = Pn(p) ? ls : sr.current),
          (b = p.contextTypes),
          (F = (b = b != null) ? wn(f, P) : yr)),
      (p = new p(A, F)),
      (f.memoizedState =
        p.state !== null && p.state !== void 0 ? p.state : null),
      (p.updater = V0),
      (f.stateNode = p),
      (p._reactInternals = f),
      b &&
        ((f = f.stateNode),
        (f.__reactInternalMemoizedUnmaskedChildContext = P),
        (f.__reactInternalMemoizedMaskedChildContext = F)),
      p
    );
  }
  function YR(f, p, A, b) {
    (f = p.state),
      typeof p.componentWillReceiveProps == "function" &&
        p.componentWillReceiveProps(A, b),
      typeof p.UNSAFE_componentWillReceiveProps == "function" &&
        p.UNSAFE_componentWillReceiveProps(A, b),
      p.state !== f && V0.enqueueReplaceState(p, p.state, null);
  }
  function LS(f, p, A, b) {
    var P = f.stateNode;
    (P.props = A), (P.state = f.memoizedState), (P.refs = jR), PS(f);
    var F = p.contextType;
    typeof F == "object" && F !== null
      ? (P.context = _r(F))
      : ((F = Pn(p) ? ls : sr.current), (P.context = wn(f, F))),
      (P.state = f.memoizedState),
      (F = p.getDerivedStateFromProps),
      typeof F == "function" && (IS(f, p, F, A), (P.state = f.memoizedState)),
      typeof p.getDerivedStateFromProps == "function" ||
        typeof P.getSnapshotBeforeUpdate == "function" ||
        (typeof P.UNSAFE_componentWillMount != "function" &&
          typeof P.componentWillMount != "function") ||
        ((p = P.state),
        typeof P.componentWillMount == "function" && P.componentWillMount(),
        typeof P.UNSAFE_componentWillMount == "function" &&
          P.UNSAFE_componentWillMount(),
        p !== P.state && V0.enqueueReplaceState(P, P.state, null),
        B0(f, A, P, b),
        (P.state = f.memoizedState)),
      typeof P.componentDidMount == "function" && (f.flags |= 4194308);
  }
  var qd = [],
    Kd = 0,
    H0 = null,
    G0 = 0,
    yo = [],
    xo = 0,
    lu = null,
    ol = 1,
    al = "";
  function cu(f, p) {
    (qd[Kd++] = G0), (qd[Kd++] = H0), (H0 = f), (G0 = p);
  }
  function qR(f, p, A) {
    (yo[xo++] = ol), (yo[xo++] = al), (yo[xo++] = lu), (lu = f);
    var b = ol;
    f = al;
    var P = 32 - Is(b) - 1;
    (b &= ~(1 << P)), (A += 1);
    var F = 32 - Is(p) + P;
    if (30 < F) {
      var ne = P - (P % 5);
      (F = (b & ((1 << ne) - 1)).toString(32)),
        (b >>= ne),
        (P -= ne),
        (ol = (1 << (32 - Is(p) + P)) | (A << P) | b),
        (al = F + f);
    } else (ol = (1 << F) | (A << P) | b), (al = f);
  }
  function OS(f) {
    f.return !== null && (cu(f, 1), qR(f, 1, 0));
  }
  function DS(f) {
    for (; f === H0; )
      (H0 = qd[--Kd]), (qd[Kd] = null), (G0 = qd[--Kd]), (qd[Kd] = null);
    for (; f === lu; )
      (lu = yo[--xo]),
        (yo[xo] = null),
        (al = yo[--xo]),
        (yo[xo] = null),
        (ol = yo[--xo]),
        (yo[xo] = null);
  }
  var Fs = null,
    Us = null,
    $n = !1,
    Ip = !1,
    Yo = null;
  function KR(f, p) {
    var A = wo(5, null, null, 0);
    (A.elementType = "DELETED"),
      (A.stateNode = p),
      (A.return = f),
      (p = f.deletions),
      p === null ? ((f.deletions = [A]), (f.flags |= 16)) : p.push(A);
  }
  function ZR(f, p) {
    switch (f.tag) {
      case 5:
        return (
          (p = gn(p, f.type, f.pendingProps)),
          p !== null ? ((f.stateNode = p), (Fs = f), (Us = Ai(p)), !0) : !1
        );
      case 6:
        return (
          (p = dn(p, f.pendingProps)),
          p !== null ? ((f.stateNode = p), (Fs = f), (Us = null), !0) : !1
        );
      case 13:
        if (((p = gr(p)), p !== null)) {
          var A = lu !== null ? { id: ol, overflow: al } : null;
          return (
            (f.memoizedState = {
              dehydrated: p,
              treeContext: A,
              retryLane: 1073741824,
            }),
            (A = wo(18, null, null, 0)),
            (A.stateNode = p),
            (A.return = f),
            (f.child = A),
            (Fs = f),
            (Us = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function FS(f) {
    return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
  }
  function US(f) {
    if ($n) {
      var p = Us;
      if (p) {
        var A = p;
        if (!ZR(f, p)) {
          if (FS(f)) throw Error(o(418));
          p = zr(A);
          var b = Fs;
          p && ZR(f, p)
            ? KR(b, A)
            : ((f.flags = (f.flags & -4097) | 2), ($n = !1), (Fs = f));
        }
      } else {
        if (FS(f)) throw Error(o(418));
        (f.flags = (f.flags & -4097) | 2), ($n = !1), (Fs = f);
      }
    }
  }
  function QR(f) {
    for (
      f = f.return;
      f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13;

    )
      f = f.return;
    Fs = f;
  }
  function Lp(f) {
    if (!me || f !== Fs) return !1;
    if (!$n) return QR(f), ($n = !0), !1;
    if (
      f.tag !== 3 &&
      (f.tag !== 5 || (bt(f.type) && !K(f.type, f.memoizedProps)))
    ) {
      var p = Us;
      if (p) {
        if (FS(f)) {
          for (f = Us; f; ) f = zr(f);
          throw Error(o(418));
        }
        for (; p; ) KR(f, p), (p = zr(p));
      }
    }
    if ((QR(f), f.tag === 13)) {
      if (!me) throw Error(o(316));
      if (((f = f.memoizedState), (f = f !== null ? f.dehydrated : null), !f))
        throw Error(o(317));
      Us = Fe(f);
    } else Us = Fs ? zr(f.stateNode) : null;
    return !0;
  }
  function Zd() {
    me && ((Us = Fs = null), (Ip = $n = !1));
  }
  function kS(f) {
    Yo === null ? (Yo = [f]) : Yo.push(f);
  }
  function Op(f, p, A) {
    if (
      ((f = A.ref),
      f !== null && typeof f != "function" && typeof f != "object")
    ) {
      if (A._owner) {
        if (((A = A._owner), A)) {
          if (A.tag !== 1) throw Error(o(309));
          var b = A.stateNode;
        }
        if (!b) throw Error(o(147, f));
        var P = b,
          F = "" + f;
        return p !== null &&
          p.ref !== null &&
          typeof p.ref == "function" &&
          p.ref._stringRef === F
          ? p.ref
          : ((p = function (ne) {
              var pe = P.refs;
              pe === jR && (pe = P.refs = {}),
                ne === null ? delete pe[F] : (pe[F] = ne);
            }),
            (p._stringRef = F),
            p);
      }
      if (typeof f != "string") throw Error(o(284));
      if (!A._owner) throw Error(o(290, f));
    }
    return f;
  }
  function W0(f, p) {
    throw (
      ((f = Object.prototype.toString.call(p)),
      Error(
        o(
          31,
          f === "[object Object]"
            ? "object with keys {" + Object.keys(p).join(", ") + "}"
            : f
        )
      ))
    );
  }
  function JR(f) {
    var p = f._init;
    return p(f._payload);
  }
  function eN(f) {
    function p(Oe, ve) {
      if (f) {
        var Ve = Oe.deletions;
        Ve === null ? ((Oe.deletions = [ve]), (Oe.flags |= 16)) : Ve.push(ve);
      }
    }
    function A(Oe, ve) {
      if (!f) return null;
      for (; ve !== null; ) p(Oe, ve), (ve = ve.sibling);
      return null;
    }
    function b(Oe, ve) {
      for (Oe = new Map(); ve !== null; )
        ve.key !== null ? Oe.set(ve.key, ve) : Oe.set(ve.index, ve),
          (ve = ve.sibling);
      return Oe;
    }
    function P(Oe, ve) {
      return (Oe = tc(Oe, ve)), (Oe.index = 0), (Oe.sibling = null), Oe;
    }
    function F(Oe, ve, Ve) {
      return (
        (Oe.index = Ve),
        f
          ? ((Ve = Oe.alternate),
            Ve !== null
              ? ((Ve = Ve.index), Ve < ve ? ((Oe.flags |= 2), ve) : Ve)
              : ((Oe.flags |= 2), ve))
          : ((Oe.flags |= 1048576), ve)
      );
    }
    function ne(Oe) {
      return f && Oe.alternate === null && (Oe.flags |= 2), Oe;
    }
    function pe(Oe, ve, Ve, yt) {
      return ve === null || ve.tag !== 6
        ? ((ve = SA(Ve, Oe.mode, yt)), (ve.return = Oe), ve)
        : ((ve = P(ve, Ve)), (ve.return = Oe), ve);
    }
    function Ge(Oe, ve, Ve, yt) {
      var Rt = Ve.type;
      return Rt === u
        ? _t(Oe, ve, Ve.props.children, yt, Ve.key)
        : ve !== null &&
          (ve.elementType === Rt ||
            (typeof Rt == "object" &&
              Rt !== null &&
              Rt.$$typeof === S &&
              JR(Rt) === ve.type))
        ? ((yt = P(ve, Ve.props)),
          (yt.ref = Op(Oe, ve, Ve)),
          (yt.return = Oe),
          yt)
        : ((yt = Sv(Ve.type, Ve.key, Ve.props, null, Oe.mode, yt)),
          (yt.ref = Op(Oe, ve, Ve)),
          (yt.return = Oe),
          yt);
    }
    function st(Oe, ve, Ve, yt) {
      return ve === null ||
        ve.tag !== 4 ||
        ve.stateNode.containerInfo !== Ve.containerInfo ||
        ve.stateNode.implementation !== Ve.implementation
        ? ((ve = AA(Ve, Oe.mode, yt)), (ve.return = Oe), ve)
        : ((ve = P(ve, Ve.children || [])), (ve.return = Oe), ve);
    }
    function _t(Oe, ve, Ve, yt, Rt) {
      return ve === null || ve.tag !== 7
        ? ((ve = gu(Ve, Oe.mode, yt, Rt)), (ve.return = Oe), ve)
        : ((ve = P(ve, Ve)), (ve.return = Oe), ve);
    }
    function Xt(Oe, ve, Ve) {
      if ((typeof ve == "string" && ve !== "") || typeof ve == "number")
        return (ve = SA("" + ve, Oe.mode, Ve)), (ve.return = Oe), ve;
      if (typeof ve == "object" && ve !== null) {
        switch (ve.$$typeof) {
          case l:
            return (
              (Ve = Sv(ve.type, ve.key, ve.props, null, Oe.mode, Ve)),
              (Ve.ref = Op(Oe, null, ve)),
              (Ve.return = Oe),
              Ve
            );
          case c:
            return (ve = AA(ve, Oe.mode, Ve)), (ve.return = Oe), ve;
          case S:
            var yt = ve._init;
            return Xt(Oe, yt(ve._payload), Ve);
        }
        if ($(ve) || E(ve))
          return (ve = gu(ve, Oe.mode, Ve, null)), (ve.return = Oe), ve;
        W0(Oe, ve);
      }
      return null;
    }
    function zt(Oe, ve, Ve, yt) {
      var Rt = ve !== null ? ve.key : null;
      if ((typeof Ve == "string" && Ve !== "") || typeof Ve == "number")
        return Rt !== null ? null : pe(Oe, ve, "" + Ve, yt);
      if (typeof Ve == "object" && Ve !== null) {
        switch (Ve.$$typeof) {
          case l:
            return Ve.key === Rt ? Ge(Oe, ve, Ve, yt) : null;
          case c:
            return Ve.key === Rt ? st(Oe, ve, Ve, yt) : null;
          case S:
            return (Rt = Ve._init), zt(Oe, ve, Rt(Ve._payload), yt);
        }
        if ($(Ve) || E(Ve))
          return Rt !== null ? null : _t(Oe, ve, Ve, yt, null);
        W0(Oe, Ve);
      }
      return null;
    }
    function In(Oe, ve, Ve, yt, Rt) {
      if ((typeof yt == "string" && yt !== "") || typeof yt == "number")
        return (Oe = Oe.get(Ve) || null), pe(ve, Oe, "" + yt, Rt);
      if (typeof yt == "object" && yt !== null) {
        switch (yt.$$typeof) {
          case l:
            return (
              (Oe = Oe.get(yt.key === null ? Ve : yt.key) || null),
              Ge(ve, Oe, yt, Rt)
            );
          case c:
            return (
              (Oe = Oe.get(yt.key === null ? Ve : yt.key) || null),
              st(ve, Oe, yt, Rt)
            );
          case S:
            var tn = yt._init;
            return In(Oe, ve, Ve, tn(yt._payload), Rt);
        }
        if ($(yt) || E(yt))
          return (Oe = Oe.get(Ve) || null), _t(ve, Oe, yt, Rt, null);
        W0(ve, yt);
      }
      return null;
    }
    function Pt(Oe, ve, Ve, yt) {
      for (
        var Rt = null, tn = null, Yt = ve, vn = (ve = 0), ei = null;
        Yt !== null && vn < Ve.length;
        vn++
      ) {
        Yt.index > vn ? ((ei = Yt), (Yt = null)) : (ei = Yt.sibling);
        var yn = zt(Oe, Yt, Ve[vn], yt);
        if (yn === null) {
          Yt === null && (Yt = ei);
          break;
        }
        f && Yt && yn.alternate === null && p(Oe, Yt),
          (ve = F(yn, ve, vn)),
          tn === null ? (Rt = yn) : (tn.sibling = yn),
          (tn = yn),
          (Yt = ei);
      }
      if (vn === Ve.length) return A(Oe, Yt), $n && cu(Oe, vn), Rt;
      if (Yt === null) {
        for (; vn < Ve.length; vn++)
          (Yt = Xt(Oe, Ve[vn], yt)),
            Yt !== null &&
              ((ve = F(Yt, ve, vn)),
              tn === null ? (Rt = Yt) : (tn.sibling = Yt),
              (tn = Yt));
        return $n && cu(Oe, vn), Rt;
      }
      for (Yt = b(Oe, Yt); vn < Ve.length; vn++)
        (ei = In(Yt, Oe, vn, Ve[vn], yt)),
          ei !== null &&
            (f &&
              ei.alternate !== null &&
              Yt.delete(ei.key === null ? vn : ei.key),
            (ve = F(ei, ve, vn)),
            tn === null ? (Rt = ei) : (tn.sibling = ei),
            (tn = ei));
      return (
        f &&
          Yt.forEach(function (nc) {
            return p(Oe, nc);
          }),
        $n && cu(Oe, vn),
        Rt
      );
    }
    function Ri(Oe, ve, Ve, yt) {
      var Rt = E(Ve);
      if (typeof Rt != "function") throw Error(o(150));
      if (((Ve = Rt.call(Ve)), Ve == null)) throw Error(o(151));
      for (
        var tn = (Rt = null), Yt = ve, vn = (ve = 0), ei = null, yn = Ve.next();
        Yt !== null && !yn.done;
        vn++, yn = Ve.next()
      ) {
        Yt.index > vn ? ((ei = Yt), (Yt = null)) : (ei = Yt.sibling);
        var nc = zt(Oe, Yt, yn.value, yt);
        if (nc === null) {
          Yt === null && (Yt = ei);
          break;
        }
        f && Yt && nc.alternate === null && p(Oe, Yt),
          (ve = F(nc, ve, vn)),
          tn === null ? (Rt = nc) : (tn.sibling = nc),
          (tn = nc),
          (Yt = ei);
      }
      if (yn.done) return A(Oe, Yt), $n && cu(Oe, vn), Rt;
      if (Yt === null) {
        for (; !yn.done; vn++, yn = Ve.next())
          (yn = Xt(Oe, yn.value, yt)),
            yn !== null &&
              ((ve = F(yn, ve, vn)),
              tn === null ? (Rt = yn) : (tn.sibling = yn),
              (tn = yn));
        return $n && cu(Oe, vn), Rt;
      }
      for (Yt = b(Oe, Yt); !yn.done; vn++, yn = Ve.next())
        (yn = In(Yt, Oe, vn, yn.value, yt)),
          yn !== null &&
            (f &&
              yn.alternate !== null &&
              Yt.delete(yn.key === null ? vn : yn.key),
            (ve = F(yn, ve, vn)),
            tn === null ? (Rt = yn) : (tn.sibling = yn),
            (tn = yn));
      return (
        f &&
          Yt.forEach(function (tG) {
            return p(Oe, tG);
          }),
        $n && cu(Oe, vn),
        Rt
      );
    }
    function bo(Oe, ve, Ve, yt) {
      if (
        (typeof Ve == "object" &&
          Ve !== null &&
          Ve.type === u &&
          Ve.key === null &&
          (Ve = Ve.props.children),
        typeof Ve == "object" && Ve !== null)
      ) {
        switch (Ve.$$typeof) {
          case l:
            e: {
              for (var Rt = Ve.key, tn = ve; tn !== null; ) {
                if (tn.key === Rt) {
                  if (((Rt = Ve.type), Rt === u)) {
                    if (tn.tag === 7) {
                      A(Oe, tn.sibling),
                        (ve = P(tn, Ve.props.children)),
                        (ve.return = Oe),
                        (Oe = ve);
                      break e;
                    }
                  } else if (
                    tn.elementType === Rt ||
                    (typeof Rt == "object" &&
                      Rt !== null &&
                      Rt.$$typeof === S &&
                      JR(Rt) === tn.type)
                  ) {
                    A(Oe, tn.sibling),
                      (ve = P(tn, Ve.props)),
                      (ve.ref = Op(Oe, tn, Ve)),
                      (ve.return = Oe),
                      (Oe = ve);
                    break e;
                  }
                  A(Oe, tn);
                  break;
                } else p(Oe, tn);
                tn = tn.sibling;
              }
              Ve.type === u
                ? ((ve = gu(Ve.props.children, Oe.mode, yt, Ve.key)),
                  (ve.return = Oe),
                  (Oe = ve))
                : ((yt = Sv(Ve.type, Ve.key, Ve.props, null, Oe.mode, yt)),
                  (yt.ref = Op(Oe, ve, Ve)),
                  (yt.return = Oe),
                  (Oe = yt));
            }
            return ne(Oe);
          case c:
            e: {
              for (tn = Ve.key; ve !== null; ) {
                if (ve.key === tn)
                  if (
                    ve.tag === 4 &&
                    ve.stateNode.containerInfo === Ve.containerInfo &&
                    ve.stateNode.implementation === Ve.implementation
                  ) {
                    A(Oe, ve.sibling),
                      (ve = P(ve, Ve.children || [])),
                      (ve.return = Oe),
                      (Oe = ve);
                    break e;
                  } else {
                    A(Oe, ve);
                    break;
                  }
                else p(Oe, ve);
                ve = ve.sibling;
              }
              (ve = AA(Ve, Oe.mode, yt)), (ve.return = Oe), (Oe = ve);
            }
            return ne(Oe);
          case S:
            return (tn = Ve._init), bo(Oe, ve, tn(Ve._payload), yt);
        }
        if ($(Ve)) return Pt(Oe, ve, Ve, yt);
        if (E(Ve)) return Ri(Oe, ve, Ve, yt);
        W0(Oe, Ve);
      }
      return (typeof Ve == "string" && Ve !== "") || typeof Ve == "number"
        ? ((Ve = "" + Ve),
          ve !== null && ve.tag === 6
            ? (A(Oe, ve.sibling), (ve = P(ve, Ve)), (ve.return = Oe), (Oe = ve))
            : (A(Oe, ve),
              (ve = SA(Ve, Oe.mode, yt)),
              (ve.return = Oe),
              (Oe = ve)),
          ne(Oe))
        : A(Oe, ve);
    }
    return bo;
  }
  var Qd = eN(!0),
    tN = eN(!1),
    Dp = {},
    _o = It(Dp),
    Fp = It(Dp),
    Jd = It(Dp);
  function Ra(f) {
    if (f === Dp) throw Error(o(174));
    return f;
  }
  function zS(f, p) {
    Ft(Jd, p), Ft(Fp, f), Ft(_o, Dp), (f = j(p)), cn(_o), Ft(_o, f);
  }
  function ef() {
    cn(_o), cn(Fp), cn(Jd);
  }
  function nN(f) {
    var p = Ra(Jd.current),
      A = Ra(_o.current);
    (p = U(A, f.type, p)), A !== p && (Ft(Fp, f), Ft(_o, p));
  }
  function BS(f) {
    Fp.current === f && (cn(_o), cn(Fp));
  }
  var Qn = It(0);
  function j0(f) {
    for (var p = f; p !== null; ) {
      if (p.tag === 13) {
        var A = p.memoizedState;
        if (A !== null && ((A = A.dehydrated), A === null || Kr(A) || Ur(A)))
          return p;
      } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
        if (p.flags & 128) return p;
      } else if (p.child !== null) {
        (p.child.return = p), (p = p.child);
        continue;
      }
      if (p === f) break;
      for (; p.sibling === null; ) {
        if (p.return === null || p.return === f) return null;
        p = p.return;
      }
      (p.sibling.return = p.return), (p = p.sibling);
    }
    return null;
  }
  var VS = [];
  function HS() {
    for (var f = 0; f < VS.length; f++) {
      var p = VS[f];
      te
        ? (p._workInProgressVersionPrimary = null)
        : (p._workInProgressVersionSecondary = null);
    }
    VS.length = 0;
  }
  var $0 = a.ReactCurrentDispatcher,
    So = a.ReactCurrentBatchConfig,
    tf = 0,
    or = null,
    Mi = null,
    Jr = null,
    X0 = !1,
    Up = !1,
    kp = 0,
    MH = 0;
  function Ti() {
    throw Error(o(321));
  }
  function GS(f, p) {
    if (p === null) return !1;
    for (var A = 0; A < p.length && A < f.length; A++)
      if (!Os(f[A], p[A])) return !1;
    return !0;
  }
  function WS(f, p, A, b, P, F) {
    if (
      ((tf = F),
      (or = p),
      (p.memoizedState = null),
      (p.updateQueue = null),
      (p.lanes = 0),
      ($0.current = f === null || f.memoizedState === null ? NH : PH),
      (f = A(b, P)),
      Up)
    ) {
      F = 0;
      do {
        if (((Up = !1), (kp = 0), 25 <= F)) throw Error(o(301));
        (F += 1),
          (Jr = Mi = null),
          (p.updateQueue = null),
          ($0.current = IH),
          (f = A(b, P));
      } while (Up);
    }
    if (
      (($0.current = Q0),
      (p = Mi !== null && Mi.next !== null),
      (tf = 0),
      (Jr = Mi = or = null),
      (X0 = !1),
      p)
    )
      throw Error(o(300));
    return f;
  }
  function jS() {
    var f = kp !== 0;
    return (kp = 0), f;
  }
  function ll() {
    var f = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Jr === null ? (or.memoizedState = Jr = f) : (Jr = Jr.next = f), Jr;
  }
  function Na() {
    if (Mi === null) {
      var f = or.alternate;
      f = f !== null ? f.memoizedState : null;
    } else f = Mi.next;
    var p = Jr === null ? or.memoizedState : Jr.next;
    if (p !== null) (Jr = p), (Mi = f);
    else {
      if (f === null) throw Error(o(310));
      (Mi = f),
        (f = {
          memoizedState: Mi.memoizedState,
          baseState: Mi.baseState,
          baseQueue: Mi.baseQueue,
          queue: Mi.queue,
          next: null,
        }),
        Jr === null ? (or.memoizedState = Jr = f) : (Jr = Jr.next = f);
    }
    return Jr;
  }
  function uu(f, p) {
    return typeof p == "function" ? p(f) : p;
  }
  function Y0(f) {
    var p = Na(),
      A = p.queue;
    if (A === null) throw Error(o(311));
    A.lastRenderedReducer = f;
    var b = Mi,
      P = b.baseQueue,
      F = A.pending;
    if (F !== null) {
      if (P !== null) {
        var ne = P.next;
        (P.next = F.next), (F.next = ne);
      }
      (b.baseQueue = P = F), (A.pending = null);
    }
    if (P !== null) {
      (F = P.next), (b = b.baseState);
      var pe = (ne = null),
        Ge = null,
        st = F;
      do {
        var _t = st.lane;
        if ((tf & _t) === _t)
          Ge !== null &&
            (Ge = Ge.next =
              {
                lane: 0,
                action: st.action,
                hasEagerState: st.hasEagerState,
                eagerState: st.eagerState,
                next: null,
              }),
            (b = st.hasEagerState ? st.eagerState : f(b, st.action));
        else {
          var Xt = {
            lane: _t,
            action: st.action,
            hasEagerState: st.hasEagerState,
            eagerState: st.eagerState,
            next: null,
          };
          Ge === null ? ((pe = Ge = Xt), (ne = b)) : (Ge = Ge.next = Xt),
            (or.lanes |= _t),
            (rf |= _t);
        }
        st = st.next;
      } while (st !== null && st !== F);
      Ge === null ? (ne = b) : (Ge.next = pe),
        Os(b, p.memoizedState) || (ks = !0),
        (p.memoizedState = b),
        (p.baseState = ne),
        (p.baseQueue = Ge),
        (A.lastRenderedState = b);
    }
    if (((f = A.interleaved), f !== null)) {
      P = f;
      do (F = P.lane), (or.lanes |= F), (rf |= F), (P = P.next);
      while (P !== f);
    } else P === null && (A.lanes = 0);
    return [p.memoizedState, A.dispatch];
  }
  function q0(f) {
    var p = Na(),
      A = p.queue;
    if (A === null) throw Error(o(311));
    A.lastRenderedReducer = f;
    var b = A.dispatch,
      P = A.pending,
      F = p.memoizedState;
    if (P !== null) {
      A.pending = null;
      var ne = (P = P.next);
      do (F = f(F, ne.action)), (ne = ne.next);
      while (ne !== P);
      Os(F, p.memoizedState) || (ks = !0),
        (p.memoizedState = F),
        p.baseQueue === null && (p.baseState = F),
        (A.lastRenderedState = F);
    }
    return [F, b];
  }
  function rN() {}
  function iN(f, p) {
    var A = or,
      b = Na(),
      P = p(),
      F = !Os(b.memoizedState, P);
    if (
      (F && ((b.memoizedState = P), (ks = !0)),
      (b = b.queue),
      Bp(aN.bind(null, A, b, f), [f]),
      b.getSnapshot !== p || F || (Jr !== null && Jr.memoizedState.tag & 1))
    ) {
      if (
        ((A.flags |= 2048),
        zp(9, oN.bind(null, A, b, P, p), void 0, null),
        Cr === null)
      )
        throw Error(o(349));
      tf & 30 || sN(A, p, P);
    }
    return P;
  }
  function sN(f, p, A) {
    (f.flags |= 16384),
      (f = { getSnapshot: p, value: A }),
      (p = or.updateQueue),
      p === null
        ? ((p = { lastEffect: null, stores: null }),
          (or.updateQueue = p),
          (p.stores = [f]))
        : ((A = p.stores), A === null ? (p.stores = [f]) : A.push(f));
  }
  function oN(f, p, A, b) {
    (p.value = A), (p.getSnapshot = b), lN(p) && Ao(f, 1, -1);
  }
  function aN(f, p, A) {
    return A(function () {
      lN(p) && Ao(f, 1, -1);
    });
  }
  function lN(f) {
    var p = f.getSnapshot;
    f = f.value;
    try {
      var A = p();
      return !Os(f, A);
    } catch {
      return !0;
    }
  }
  function $S(f) {
    var p = ll();
    return (
      typeof f == "function" && (f = f()),
      (p.memoizedState = p.baseState = f),
      (f = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: uu,
        lastRenderedState: f,
      }),
      (p.queue = f),
      (f = f.dispatch = RH.bind(null, or, f)),
      [p.memoizedState, f]
    );
  }
  function zp(f, p, A, b) {
    return (
      (f = { tag: f, create: p, destroy: A, deps: b, next: null }),
      (p = or.updateQueue),
      p === null
        ? ((p = { lastEffect: null, stores: null }),
          (or.updateQueue = p),
          (p.lastEffect = f.next = f))
        : ((A = p.lastEffect),
          A === null
            ? (p.lastEffect = f.next = f)
            : ((b = A.next), (A.next = f), (f.next = b), (p.lastEffect = f))),
      f
    );
  }
  function cN() {
    return Na().memoizedState;
  }
  function K0(f, p, A, b) {
    var P = ll();
    (or.flags |= f),
      (P.memoizedState = zp(1 | p, A, void 0, b === void 0 ? null : b));
  }
  function Z0(f, p, A, b) {
    var P = Na();
    b = b === void 0 ? null : b;
    var F = void 0;
    if (Mi !== null) {
      var ne = Mi.memoizedState;
      if (((F = ne.destroy), b !== null && GS(b, ne.deps))) {
        P.memoizedState = zp(p, A, F, b);
        return;
      }
    }
    (or.flags |= f), (P.memoizedState = zp(1 | p, A, F, b));
  }
  function XS(f, p) {
    return K0(8390656, 8, f, p);
  }
  function Bp(f, p) {
    return Z0(2048, 8, f, p);
  }
  function uN(f, p) {
    return Z0(4, 2, f, p);
  }
  function dN(f, p) {
    return Z0(4, 4, f, p);
  }
  function fN(f, p) {
    if (typeof p == "function")
      return (
        (f = f()),
        p(f),
        function () {
          p(null);
        }
      );
    if (p != null)
      return (
        (f = f()),
        (p.current = f),
        function () {
          p.current = null;
        }
      );
  }
  function hN(f, p, A) {
    return (
      (A = A != null ? A.concat([f]) : null), Z0(4, 4, fN.bind(null, p, f), A)
    );
  }
  function YS() {}
  function pN(f, p) {
    var A = Na();
    p = p === void 0 ? null : p;
    var b = A.memoizedState;
    return b !== null && p !== null && GS(p, b[1])
      ? b[0]
      : ((A.memoizedState = [f, p]), f);
  }
  function mN(f, p) {
    var A = Na();
    p = p === void 0 ? null : p;
    var b = A.memoizedState;
    return b !== null && p !== null && GS(p, b[1])
      ? b[0]
      : ((f = f()), (A.memoizedState = [f, p]), f);
  }
  function TH(f, p) {
    var A = sn;
    (sn = A !== 0 && 4 > A ? A : 4), f(!0);
    var b = So.transition;
    So.transition = {};
    try {
      f(!1), p();
    } finally {
      (sn = A), (So.transition = b);
    }
  }
  function gN() {
    return Na().memoizedState;
  }
  function CH(f, p, A) {
    var b = Jl(f);
    (A = {
      lane: b,
      action: A,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      vN(f)
        ? yN(p, A)
        : (xN(f, p, A),
          (A = qi()),
          (f = Ao(f, b, A)),
          f !== null && _N(f, p, b));
  }
  function RH(f, p, A) {
    var b = Jl(f),
      P = {
        lane: b,
        action: A,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (vN(f)) yN(p, P);
    else {
      xN(f, p, P);
      var F = f.alternate;
      if (
        f.lanes === 0 &&
        (F === null || F.lanes === 0) &&
        ((F = p.lastRenderedReducer), F !== null)
      )
        try {
          var ne = p.lastRenderedState,
            pe = F(ne, A);
          if (((P.hasEagerState = !0), (P.eagerState = pe), Os(pe, ne))) return;
        } catch {
        } finally {
        }
      (A = qi()), (f = Ao(f, b, A)), f !== null && _N(f, p, b);
    }
  }
  function vN(f) {
    var p = f.alternate;
    return f === or || (p !== null && p === or);
  }
  function yN(f, p) {
    Up = X0 = !0;
    var A = f.pending;
    A === null ? (p.next = p) : ((p.next = A.next), (A.next = p)),
      (f.pending = p);
  }
  function xN(f, p, A) {
    Cr !== null && f.mode & 1 && !(nn & 2)
      ? ((f = p.interleaved),
        f === null
          ? ((A.next = A), Ds === null ? (Ds = [p]) : Ds.push(p))
          : ((A.next = f.next), (f.next = A)),
        (p.interleaved = A))
      : ((f = p.pending),
        f === null ? (A.next = A) : ((A.next = f.next), (f.next = A)),
        (p.pending = A));
  }
  function _N(f, p, A) {
    if (A & 4194240) {
      var b = p.lanes;
      (b &= f.pendingLanes), (A |= b), (p.lanes = A), Ta(f, A);
    }
  }
  var Q0 = {
      readContext: _r,
      useCallback: Ti,
      useContext: Ti,
      useEffect: Ti,
      useImperativeHandle: Ti,
      useInsertionEffect: Ti,
      useLayoutEffect: Ti,
      useMemo: Ti,
      useReducer: Ti,
      useRef: Ti,
      useState: Ti,
      useDebugValue: Ti,
      useDeferredValue: Ti,
      useTransition: Ti,
      useMutableSource: Ti,
      useSyncExternalStore: Ti,
      useId: Ti,
      unstable_isNewReconciler: !1,
    },
    NH = {
      readContext: _r,
      useCallback: function (f, p) {
        return (ll().memoizedState = [f, p === void 0 ? null : p]), f;
      },
      useContext: _r,
      useEffect: XS,
      useImperativeHandle: function (f, p, A) {
        return (
          (A = A != null ? A.concat([f]) : null),
          K0(4194308, 4, fN.bind(null, p, f), A)
        );
      },
      useLayoutEffect: function (f, p) {
        return K0(4194308, 4, f, p);
      },
      useInsertionEffect: function (f, p) {
        return K0(4, 2, f, p);
      },
      useMemo: function (f, p) {
        var A = ll();
        return (
          (p = p === void 0 ? null : p),
          (f = f()),
          (A.memoizedState = [f, p]),
          f
        );
      },
      useReducer: function (f, p, A) {
        var b = ll();
        return (
          (p = A !== void 0 ? A(p) : p),
          (b.memoizedState = b.baseState = p),
          (f = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: f,
            lastRenderedState: p,
          }),
          (b.queue = f),
          (f = f.dispatch = CH.bind(null, or, f)),
          [b.memoizedState, f]
        );
      },
      useRef: function (f) {
        var p = ll();
        return (f = { current: f }), (p.memoizedState = f);
      },
      useState: $S,
      useDebugValue: YS,
      useDeferredValue: function (f) {
        var p = $S(f),
          A = p[0],
          b = p[1];
        return (
          XS(
            function () {
              var P = So.transition;
              So.transition = {};
              try {
                b(f);
              } finally {
                So.transition = P;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = $S(!1),
          p = f[0];
        return (f = TH.bind(null, f[1])), (ll().memoizedState = f), [p, f];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (f, p, A) {
        var b = or,
          P = ll();
        if ($n) {
          if (A === void 0) throw Error(o(407));
          A = A();
        } else {
          if (((A = p()), Cr === null)) throw Error(o(349));
          tf & 30 || sN(b, p, A);
        }
        P.memoizedState = A;
        var F = { value: A, getSnapshot: p };
        return (
          (P.queue = F),
          XS(aN.bind(null, b, F, f), [f]),
          (b.flags |= 2048),
          zp(9, oN.bind(null, b, F, A, p), void 0, null),
          A
        );
      },
      useId: function () {
        var f = ll(),
          p = Cr.identifierPrefix;
        if ($n) {
          var A = al,
            b = ol;
          (A = (b & ~(1 << (32 - Is(b) - 1))).toString(32) + A),
            (p = ":" + p + "R" + A),
            (A = kp++),
            0 < A && (p += "H" + A.toString(32)),
            (p += ":");
        } else (A = MH++), (p = ":" + p + "r" + A.toString(32) + ":");
        return (f.memoizedState = p);
      },
      unstable_isNewReconciler: !1,
    },
    PH = {
      readContext: _r,
      useCallback: pN,
      useContext: _r,
      useEffect: Bp,
      useImperativeHandle: hN,
      useInsertionEffect: uN,
      useLayoutEffect: dN,
      useMemo: mN,
      useReducer: Y0,
      useRef: cN,
      useState: function () {
        return Y0(uu);
      },
      useDebugValue: YS,
      useDeferredValue: function (f) {
        var p = Y0(uu),
          A = p[0],
          b = p[1];
        return (
          Bp(
            function () {
              var P = So.transition;
              So.transition = {};
              try {
                b(f);
              } finally {
                So.transition = P;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = Y0(uu)[0],
          p = Na().memoizedState;
        return [f, p];
      },
      useMutableSource: rN,
      useSyncExternalStore: iN,
      useId: gN,
      unstable_isNewReconciler: !1,
    },
    IH = {
      readContext: _r,
      useCallback: pN,
      useContext: _r,
      useEffect: Bp,
      useImperativeHandle: hN,
      useInsertionEffect: uN,
      useLayoutEffect: dN,
      useMemo: mN,
      useReducer: q0,
      useRef: cN,
      useState: function () {
        return q0(uu);
      },
      useDebugValue: YS,
      useDeferredValue: function (f) {
        var p = q0(uu),
          A = p[0],
          b = p[1];
        return (
          Bp(
            function () {
              var P = So.transition;
              So.transition = {};
              try {
                b(f);
              } finally {
                So.transition = P;
              }
            },
            [f]
          ),
          A
        );
      },
      useTransition: function () {
        var f = q0(uu)[0],
          p = Na().memoizedState;
        return [f, p];
      },
      useMutableSource: rN,
      useSyncExternalStore: iN,
      useId: gN,
      unstable_isNewReconciler: !1,
    };
  function qS(f, p) {
    try {
      var A = "",
        b = p;
      do (A += au(b)), (b = b.return);
      while (b);
      var P = A;
    } catch (F) {
      P =
        `
Error generating stack: ` +
        F.message +
        `
` +
        F.stack;
    }
    return { value: f, source: p, stack: P };
  }
  function KS(f, p) {
    try {
      console.error(p.value);
    } catch (A) {
      setTimeout(function () {
        throw A;
      });
    }
  }
  var LH = typeof WeakMap == "function" ? WeakMap : Map;
  function SN(f, p, A) {
    (A = sl(-1, A)), (A.tag = 3), (A.payload = { element: null });
    var b = p.value;
    return (
      (A.callback = function () {
        pv || ((pv = !0), (pA = b)), KS(f, p);
      }),
      A
    );
  }
  function AN(f, p, A) {
    (A = sl(-1, A)), (A.tag = 3);
    var b = f.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var P = p.value;
      (A.payload = function () {
        return b(P);
      }),
        (A.callback = function () {
          KS(f, p);
        });
    }
    var F = f.stateNode;
    return (
      F !== null &&
        typeof F.componentDidCatch == "function" &&
        (A.callback = function () {
          KS(f, p),
            typeof b != "function" &&
              (Zl === null ? (Zl = new Set([this])) : Zl.add(this));
          var ne = p.stack;
          this.componentDidCatch(p.value, {
            componentStack: ne !== null ? ne : "",
          });
        }),
      A
    );
  }
  function wN(f, p, A) {
    var b = f.pingCache;
    if (b === null) {
      b = f.pingCache = new LH();
      var P = new Set();
      b.set(p, P);
    } else (P = b.get(p)), P === void 0 && ((P = new Set()), b.set(p, P));
    P.has(A) || (P.add(A), (f = XH.bind(null, f, p, A)), p.then(f, f));
  }
  function bN(f) {
    do {
      var p;
      if (
        ((p = f.tag === 13) &&
          ((p = f.memoizedState),
          (p = p !== null ? p.dehydrated !== null : !0)),
        p)
      )
        return f;
      f = f.return;
    } while (f !== null);
    return null;
  }
  function EN(f, p, A, b, P) {
    return f.mode & 1
      ? ((f.flags |= 65536), (f.lanes = P), f)
      : (f === p
          ? (f.flags |= 65536)
          : ((f.flags |= 128),
            (A.flags |= 131072),
            (A.flags &= -52805),
            A.tag === 1 &&
              (A.alternate === null
                ? (A.tag = 17)
                : ((p = sl(-1, 1)), (p.tag = 2), Kl(A, p))),
            (A.lanes |= 1)),
        f);
  }
  function Pa(f) {
    f.flags |= 4;
  }
  function MN(f, p) {
    if (f !== null && f.child === p.child) return !0;
    if (p.flags & 16) return !1;
    for (f = p.child; f !== null; ) {
      if (f.flags & 12854 || f.subtreeFlags & 12854) return !1;
      f = f.sibling;
    }
    return !0;
  }
  var Vp, Hp, J0, ev;
  if (ge)
    (Vp = function (f, p) {
      for (var A = p.child; A !== null; ) {
        if (A.tag === 5 || A.tag === 6) W(f, A.stateNode);
        else if (A.tag !== 4 && A.child !== null) {
          (A.child.return = A), (A = A.child);
          continue;
        }
        if (A === p) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === p) return;
          A = A.return;
        }
        (A.sibling.return = A.return), (A = A.sibling);
      }
    }),
      (Hp = function () {}),
      (J0 = function (f, p, A, b, P) {
        if (((f = f.memoizedProps), f !== b)) {
          var F = p.stateNode,
            ne = Ra(_o.current);
          (A = Y(F, A, f, b, P, ne)), (p.updateQueue = A) && Pa(p);
        }
      }),
      (ev = function (f, p, A, b) {
        A !== b && Pa(p);
      });
  else if (ie) {
    Vp = function (f, p, A, b) {
      for (var P = p.child; P !== null; ) {
        if (P.tag === 5) {
          var F = P.stateNode;
          A && b && (F = St(F, P.type, P.memoizedProps, P)), W(f, F);
        } else if (P.tag === 6)
          (F = P.stateNode), A && b && (F = Nt(F, P.memoizedProps, P)), W(f, F);
        else if (P.tag !== 4) {
          if (P.tag === 22 && P.memoizedState !== null)
            (F = P.child), F !== null && (F.return = P), Vp(f, P, !0, !0);
          else if (P.child !== null) {
            (P.child.return = P), (P = P.child);
            continue;
          }
        }
        if (P === p) break;
        for (; P.sibling === null; ) {
          if (P.return === null || P.return === p) return;
          P = P.return;
        }
        (P.sibling.return = P.return), (P = P.sibling);
      }
    };
    var TN = function (f, p, A, b) {
      for (var P = p.child; P !== null; ) {
        if (P.tag === 5) {
          var F = P.stateNode;
          A && b && (F = St(F, P.type, P.memoizedProps, P)), mt(f, F);
        } else if (P.tag === 6)
          (F = P.stateNode),
            A && b && (F = Nt(F, P.memoizedProps, P)),
            mt(f, F);
        else if (P.tag !== 4) {
          if (P.tag === 22 && P.memoizedState !== null)
            (F = P.child), F !== null && (F.return = P), TN(f, P, !0, !0);
          else if (P.child !== null) {
            (P.child.return = P), (P = P.child);
            continue;
          }
        }
        if (P === p) break;
        for (; P.sibling === null; ) {
          if (P.return === null || P.return === p) return;
          P = P.return;
        }
        (P.sibling.return = P.return), (P = P.sibling);
      }
    };
    (Hp = function (f, p) {
      var A = p.stateNode;
      if (!MN(f, p)) {
        f = A.containerInfo;
        var b = dt(f);
        TN(b, p, !1, !1), (A.pendingChildren = b), Pa(p), kt(f, b);
      }
    }),
      (J0 = function (f, p, A, b, P) {
        var F = f.stateNode,
          ne = f.memoizedProps;
        if ((f = MN(f, p)) && ne === b) p.stateNode = F;
        else {
          var pe = p.stateNode,
            Ge = Ra(_o.current),
            st = null;
          ne !== b && (st = Y(pe, A, ne, b, P, Ge)),
            f && st === null
              ? (p.stateNode = F)
              : ((F = vt(F, st, A, ne, b, p, f, pe)),
                ee(F, A, b, P, Ge) && Pa(p),
                (p.stateNode = F),
                f ? Pa(p) : Vp(F, p, !1, !1));
        }
      }),
      (ev = function (f, p, A, b) {
        A !== b
          ? ((f = Ra(Jd.current)),
            (A = Ra(_o.current)),
            (p.stateNode = ae(b, f, A, p)),
            Pa(p))
          : (p.stateNode = f.stateNode);
      });
  } else (Hp = function () {}), (J0 = function () {}), (ev = function () {});
  function Gp(f, p) {
    if (!$n)
      switch (f.tailMode) {
        case "hidden":
          p = f.tail;
          for (var A = null; p !== null; )
            p.alternate !== null && (A = p), (p = p.sibling);
          A === null ? (f.tail = null) : (A.sibling = null);
          break;
        case "collapsed":
          A = f.tail;
          for (var b = null; A !== null; )
            A.alternate !== null && (b = A), (A = A.sibling);
          b === null
            ? p || f.tail === null
              ? (f.tail = null)
              : (f.tail.sibling = null)
            : (b.sibling = null);
      }
  }
  function Ci(f) {
    var p = f.alternate !== null && f.alternate.child === f.child,
      A = 0,
      b = 0;
    if (p)
      for (var P = f.child; P !== null; )
        (A |= P.lanes | P.childLanes),
          (b |= P.subtreeFlags & 14680064),
          (b |= P.flags & 14680064),
          (P.return = f),
          (P = P.sibling);
    else
      for (P = f.child; P !== null; )
        (A |= P.lanes | P.childLanes),
          (b |= P.subtreeFlags),
          (b |= P.flags),
          (P.return = f),
          (P = P.sibling);
    return (f.subtreeFlags |= b), (f.childLanes = A), p;
  }
  function OH(f, p, A) {
    var b = p.pendingProps;
    switch ((DS(p), p.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Ci(p), null;
      case 1:
        return Pn(p.type) && Gi(), Ci(p), null;
      case 3:
        return (
          (b = p.stateNode),
          ef(),
          cn(jn),
          cn(sr),
          HS(),
          b.pendingContext &&
            ((b.context = b.pendingContext), (b.pendingContext = null)),
          (f === null || f.child === null) &&
            (Lp(p)
              ? Pa(p)
              : f === null ||
                (f.memoizedState.isDehydrated && !(p.flags & 256)) ||
                ((p.flags |= 1024), Yo !== null && (vA(Yo), (Yo = null)))),
          Hp(f, p),
          Ci(p),
          null
        );
      case 5:
        BS(p), (A = Ra(Jd.current));
        var P = p.type;
        if (f !== null && p.stateNode != null)
          J0(f, p, P, b, A),
            f.ref !== p.ref && ((p.flags |= 512), (p.flags |= 2097152));
        else {
          if (!b) {
            if (p.stateNode === null) throw Error(o(166));
            return Ci(p), null;
          }
          if (((f = Ra(_o.current)), Lp(p))) {
            if (!me) throw Error(o(175));
            (f = wi(p.stateNode, p.type, p.memoizedProps, A, f, p, !Ip)),
              (p.updateQueue = f),
              f !== null && Pa(p);
          } else {
            var F = k(P, b, A, f, p);
            Vp(F, p, !1, !1), (p.stateNode = F), ee(F, P, b, A, f) && Pa(p);
          }
          p.ref !== null && ((p.flags |= 512), (p.flags |= 2097152));
        }
        return Ci(p), null;
      case 6:
        if (f && p.stateNode != null) ev(f, p, f.memoizedProps, b);
        else {
          if (typeof b != "string" && p.stateNode === null) throw Error(o(166));
          if (((f = Ra(Jd.current)), (A = Ra(_o.current)), Lp(p))) {
            if (!me) throw Error(o(176));
            if (
              ((f = p.stateNode),
              (b = p.memoizedProps),
              (A = Z(f, b, p, !Ip)) && ((P = Fs), P !== null))
            )
              switch (((F = (P.mode & 1) !== 0), P.tag)) {
                case 3:
                  Dt(P.stateNode.containerInfo, f, b, F);
                  break;
                case 5:
                  Ht(P.type, P.memoizedProps, P.stateNode, f, b, F);
              }
            A && Pa(p);
          } else p.stateNode = ae(b, f, A, p);
        }
        return Ci(p), null;
      case 13:
        if (
          (cn(Qn),
          (b = p.memoizedState),
          $n && Us !== null && p.mode & 1 && !(p.flags & 128))
        ) {
          for (f = Us; f; ) f = zr(f);
          return Zd(), (p.flags |= 98560), p;
        }
        if (b !== null && b.dehydrated !== null) {
          if (((b = Lp(p)), f === null)) {
            if (!b) throw Error(o(318));
            if (!me) throw Error(o(344));
            if (
              ((f = p.memoizedState),
              (f = f !== null ? f.dehydrated : null),
              !f)
            )
              throw Error(o(317));
            be(f, p);
          } else
            Zd(), !(p.flags & 128) && (p.memoizedState = null), (p.flags |= 4);
          return Ci(p), null;
        }
        return (
          Yo !== null && (vA(Yo), (Yo = null)),
          p.flags & 128
            ? ((p.lanes = A), p)
            : ((b = b !== null),
              (A = !1),
              f === null ? Lp(p) : (A = f.memoizedState !== null),
              b &&
                !A &&
                ((p.child.flags |= 8192),
                p.mode & 1 &&
                  (f === null || Qn.current & 1 ? Vr === 0 && (Vr = 3) : xA())),
              p.updateQueue !== null && (p.flags |= 4),
              Ci(p),
              null)
        );
      case 4:
        return (
          ef(),
          Hp(f, p),
          f === null && Ee(p.stateNode.containerInfo),
          Ci(p),
          null
        );
      case 10:
        return Qr(p.type._context), Ci(p), null;
      case 17:
        return Pn(p.type) && Gi(), Ci(p), null;
      case 19:
        if ((cn(Qn), (P = p.memoizedState), P === null)) return Ci(p), null;
        if (((b = (p.flags & 128) !== 0), (F = P.rendering), F === null))
          if (b) Gp(P, !1);
          else {
            if (Vr !== 0 || (f !== null && f.flags & 128))
              for (f = p.child; f !== null; ) {
                if (((F = j0(f)), F !== null)) {
                  for (
                    p.flags |= 128,
                      Gp(P, !1),
                      f = F.updateQueue,
                      f !== null && ((p.updateQueue = f), (p.flags |= 4)),
                      p.subtreeFlags = 0,
                      f = A,
                      b = p.child;
                    b !== null;

                  )
                    (A = b),
                      (P = f),
                      (A.flags &= 14680066),
                      (F = A.alternate),
                      F === null
                        ? ((A.childLanes = 0),
                          (A.lanes = P),
                          (A.child = null),
                          (A.subtreeFlags = 0),
                          (A.memoizedProps = null),
                          (A.memoizedState = null),
                          (A.updateQueue = null),
                          (A.dependencies = null),
                          (A.stateNode = null))
                        : ((A.childLanes = F.childLanes),
                          (A.lanes = F.lanes),
                          (A.child = F.child),
                          (A.subtreeFlags = 0),
                          (A.deletions = null),
                          (A.memoizedProps = F.memoizedProps),
                          (A.memoizedState = F.memoizedState),
                          (A.updateQueue = F.updateQueue),
                          (A.type = F.type),
                          (P = F.dependencies),
                          (A.dependencies =
                            P === null
                              ? null
                              : {
                                  lanes: P.lanes,
                                  firstContext: P.firstContext,
                                })),
                      (b = b.sibling);
                  return Ft(Qn, (Qn.current & 1) | 2), p.child;
                }
                f = f.sibling;
              }
            P.tail !== null &&
              Zn() > hA &&
              ((p.flags |= 128), (b = !0), Gp(P, !1), (p.lanes = 4194304));
          }
        else {
          if (!b)
            if (((f = j0(F)), f !== null)) {
              if (
                ((p.flags |= 128),
                (b = !0),
                (f = f.updateQueue),
                f !== null && ((p.updateQueue = f), (p.flags |= 4)),
                Gp(P, !0),
                P.tail === null &&
                  P.tailMode === "hidden" &&
                  !F.alternate &&
                  !$n)
              )
                return Ci(p), null;
            } else
              2 * Zn() - P.renderingStartTime > hA &&
                A !== 1073741824 &&
                ((p.flags |= 128), (b = !0), Gp(P, !1), (p.lanes = 4194304));
          P.isBackwards
            ? ((F.sibling = p.child), (p.child = F))
            : ((f = P.last),
              f !== null ? (f.sibling = F) : (p.child = F),
              (P.last = F));
        }
        return P.tail !== null
          ? ((p = P.tail),
            (P.rendering = p),
            (P.tail = p.sibling),
            (P.renderingStartTime = Zn()),
            (p.sibling = null),
            (f = Qn.current),
            Ft(Qn, b ? (f & 1) | 2 : f & 1),
            p)
          : (Ci(p), null);
      case 22:
      case 23:
        return (
          yA(),
          (b = p.memoizedState !== null),
          f !== null && (f.memoizedState !== null) !== b && (p.flags |= 8192),
          b && p.mode & 1
            ? zs & 1073741824 &&
              (Ci(p), ge && p.subtreeFlags & 6 && (p.flags |= 8192))
            : Ci(p),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, p.tag));
  }
  var DH = a.ReactCurrentOwner,
    ks = !1;
  function Yi(f, p, A, b) {
    p.child = f === null ? tN(p, null, A, b) : Qd(p, f.child, A, b);
  }
  function CN(f, p, A, b, P) {
    A = A.render;
    var F = p.ref;
    return (
      xr(p, P),
      (b = WS(f, p, A, b, F, P)),
      (A = jS()),
      f !== null && !ks
        ? ((p.updateQueue = f.updateQueue),
          (p.flags &= -2053),
          (f.lanes &= ~P),
          cl(f, p, P))
        : ($n && A && OS(p), (p.flags |= 1), Yi(f, p, b, P), p.child)
    );
  }
  function RN(f, p, A, b, P) {
    if (f === null) {
      var F = A.type;
      return typeof F == "function" &&
        !_A(F) &&
        F.defaultProps === void 0 &&
        A.compare === null &&
        A.defaultProps === void 0
        ? ((p.tag = 15), (p.type = F), NN(f, p, F, b, P))
        : ((f = Sv(A.type, null, b, p, p.mode, P)),
          (f.ref = p.ref),
          (f.return = p),
          (p.child = f));
    }
    if (((F = f.child), !(f.lanes & P))) {
      var ne = F.memoizedProps;
      if (
        ((A = A.compare),
        (A = A !== null ? A : ou),
        A(ne, b) && f.ref === p.ref)
      )
        return cl(f, p, P);
    }
    return (
      (p.flags |= 1),
      (f = tc(F, b)),
      (f.ref = p.ref),
      (f.return = p),
      (p.child = f)
    );
  }
  function NN(f, p, A, b, P) {
    if (f !== null && ou(f.memoizedProps, b) && f.ref === p.ref)
      if (((ks = !1), (f.lanes & P) !== 0)) f.flags & 131072 && (ks = !0);
      else return (p.lanes = f.lanes), cl(f, p, P);
    return ZS(f, p, A, b, P);
  }
  function PN(f, p, A) {
    var b = p.pendingProps,
      P = b.children,
      F = f !== null ? f.memoizedState : null;
    if (b.mode === "hidden")
      if (!(p.mode & 1))
        (p.memoizedState = { baseLanes: 0, cachePool: null }),
          Ft(nf, zs),
          (zs |= A);
      else if (A & 1073741824)
        (p.memoizedState = { baseLanes: 0, cachePool: null }),
          (b = F !== null ? F.baseLanes : A),
          Ft(nf, zs),
          (zs |= b);
      else
        return (
          (f = F !== null ? F.baseLanes | A : A),
          (p.lanes = p.childLanes = 1073741824),
          (p.memoizedState = { baseLanes: f, cachePool: null }),
          (p.updateQueue = null),
          Ft(nf, zs),
          (zs |= f),
          null
        );
    else
      F !== null ? ((b = F.baseLanes | A), (p.memoizedState = null)) : (b = A),
        Ft(nf, zs),
        (zs |= b);
    return Yi(f, p, P, A), p.child;
  }
  function IN(f, p) {
    var A = p.ref;
    ((f === null && A !== null) || (f !== null && f.ref !== A)) &&
      ((p.flags |= 512), (p.flags |= 2097152));
  }
  function ZS(f, p, A, b, P) {
    var F = Pn(A) ? ls : sr.current;
    return (
      (F = wn(p, F)),
      xr(p, P),
      (A = WS(f, p, A, b, F, P)),
      (b = jS()),
      f !== null && !ks
        ? ((p.updateQueue = f.updateQueue),
          (p.flags &= -2053),
          (f.lanes &= ~P),
          cl(f, p, P))
        : ($n && b && OS(p), (p.flags |= 1), Yi(f, p, A, P), p.child)
    );
  }
  function LN(f, p, A, b, P) {
    if (Pn(A)) {
      var F = !0;
      Ea(p);
    } else F = !1;
    if ((xr(p, P), p.stateNode === null))
      f !== null &&
        ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
        XR(p, A, b),
        LS(p, A, b, P),
        (b = !0);
    else if (f === null) {
      var ne = p.stateNode,
        pe = p.memoizedProps;
      ne.props = pe;
      var Ge = ne.context,
        st = A.contextType;
      typeof st == "object" && st !== null
        ? (st = _r(st))
        : ((st = Pn(A) ? ls : sr.current), (st = wn(p, st)));
      var _t = A.getDerivedStateFromProps,
        Xt =
          typeof _t == "function" ||
          typeof ne.getSnapshotBeforeUpdate == "function";
      Xt ||
        (typeof ne.UNSAFE_componentWillReceiveProps != "function" &&
          typeof ne.componentWillReceiveProps != "function") ||
        ((pe !== b || Ge !== st) && YR(p, ne, b, st)),
        (ql = !1);
      var zt = p.memoizedState;
      (ne.state = zt),
        B0(p, b, ne, P),
        (Ge = p.memoizedState),
        pe !== b || zt !== Ge || jn.current || ql
          ? (typeof _t == "function" &&
              (IS(p, A, _t, b), (Ge = p.memoizedState)),
            (pe = ql || $R(p, A, pe, b, zt, Ge, st))
              ? (Xt ||
                  (typeof ne.UNSAFE_componentWillMount != "function" &&
                    typeof ne.componentWillMount != "function") ||
                  (typeof ne.componentWillMount == "function" &&
                    ne.componentWillMount(),
                  typeof ne.UNSAFE_componentWillMount == "function" &&
                    ne.UNSAFE_componentWillMount()),
                typeof ne.componentDidMount == "function" &&
                  (p.flags |= 4194308))
              : (typeof ne.componentDidMount == "function" &&
                  (p.flags |= 4194308),
                (p.memoizedProps = b),
                (p.memoizedState = Ge)),
            (ne.props = b),
            (ne.state = Ge),
            (ne.context = st),
            (b = pe))
          : (typeof ne.componentDidMount == "function" && (p.flags |= 4194308),
            (b = !1));
    } else {
      (ne = p.stateNode),
        HR(f, p),
        (pe = p.memoizedProps),
        (st = p.type === p.elementType ? pe : $i(p.type, pe)),
        (ne.props = st),
        (Xt = p.pendingProps),
        (zt = ne.context),
        (Ge = A.contextType),
        typeof Ge == "object" && Ge !== null
          ? (Ge = _r(Ge))
          : ((Ge = Pn(A) ? ls : sr.current), (Ge = wn(p, Ge)));
      var In = A.getDerivedStateFromProps;
      (_t =
        typeof In == "function" ||
        typeof ne.getSnapshotBeforeUpdate == "function") ||
        (typeof ne.UNSAFE_componentWillReceiveProps != "function" &&
          typeof ne.componentWillReceiveProps != "function") ||
        ((pe !== Xt || zt !== Ge) && YR(p, ne, b, Ge)),
        (ql = !1),
        (zt = p.memoizedState),
        (ne.state = zt),
        B0(p, b, ne, P);
      var Pt = p.memoizedState;
      pe !== Xt || zt !== Pt || jn.current || ql
        ? (typeof In == "function" && (IS(p, A, In, b), (Pt = p.memoizedState)),
          (st = ql || $R(p, A, st, b, zt, Pt, Ge) || !1)
            ? (_t ||
                (typeof ne.UNSAFE_componentWillUpdate != "function" &&
                  typeof ne.componentWillUpdate != "function") ||
                (typeof ne.componentWillUpdate == "function" &&
                  ne.componentWillUpdate(b, Pt, Ge),
                typeof ne.UNSAFE_componentWillUpdate == "function" &&
                  ne.UNSAFE_componentWillUpdate(b, Pt, Ge)),
              typeof ne.componentDidUpdate == "function" && (p.flags |= 4),
              typeof ne.getSnapshotBeforeUpdate == "function" &&
                (p.flags |= 1024))
            : (typeof ne.componentDidUpdate != "function" ||
                (pe === f.memoizedProps && zt === f.memoizedState) ||
                (p.flags |= 4),
              typeof ne.getSnapshotBeforeUpdate != "function" ||
                (pe === f.memoizedProps && zt === f.memoizedState) ||
                (p.flags |= 1024),
              (p.memoizedProps = b),
              (p.memoizedState = Pt)),
          (ne.props = b),
          (ne.state = Pt),
          (ne.context = Ge),
          (b = st))
        : (typeof ne.componentDidUpdate != "function" ||
            (pe === f.memoizedProps && zt === f.memoizedState) ||
            (p.flags |= 4),
          typeof ne.getSnapshotBeforeUpdate != "function" ||
            (pe === f.memoizedProps && zt === f.memoizedState) ||
            (p.flags |= 1024),
          (b = !1));
    }
    return QS(f, p, A, b, F, P);
  }
  function QS(f, p, A, b, P, F) {
    IN(f, p);
    var ne = (p.flags & 128) !== 0;
    if (!b && !ne) return P && Ei(p, A, !1), cl(f, p, F);
    (b = p.stateNode), (DH.current = p);
    var pe =
      ne && typeof A.getDerivedStateFromError != "function" ? null : b.render();
    return (
      (p.flags |= 1),
      f !== null && ne
        ? ((p.child = Qd(p, f.child, null, F)), (p.child = Qd(p, null, pe, F)))
        : Yi(f, p, pe, F),
      (p.memoizedState = b.state),
      P && Ei(p, A, !0),
      p.child
    );
  }
  function ON(f) {
    var p = f.stateNode;
    p.pendingContext
      ? Br(f, p.pendingContext, p.pendingContext !== p.context)
      : p.context && Br(f, p.context, !1),
      zS(f, p.containerInfo);
  }
  function DN(f, p, A, b, P) {
    return Zd(), kS(P), (p.flags |= 256), Yi(f, p, A, b), p.child;
  }
  var tv = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nv(f) {
    return { baseLanes: f, cachePool: null };
  }
  function FN(f, p, A) {
    var b = p.pendingProps,
      P = Qn.current,
      F = !1,
      ne = (p.flags & 128) !== 0,
      pe;
    if (
      ((pe = ne) ||
        (pe = f !== null && f.memoizedState === null ? !1 : (P & 2) !== 0),
      pe
        ? ((F = !0), (p.flags &= -129))
        : (f === null || f.memoizedState !== null) && (P |= 1),
      Ft(Qn, P & 1),
      f === null)
    )
      return (
        US(p),
        (f = p.memoizedState),
        f !== null && ((f = f.dehydrated), f !== null)
          ? (p.mode & 1
              ? Ur(f)
                ? (p.lanes = 8)
                : (p.lanes = 1073741824)
              : (p.lanes = 1),
            null)
          : ((P = b.children),
            (f = b.fallback),
            F
              ? ((b = p.mode),
                (F = p.child),
                (P = { mode: "hidden", children: P }),
                !(b & 1) && F !== null
                  ? ((F.childLanes = 0), (F.pendingProps = P))
                  : (F = Av(P, b, 0, null)),
                (f = gu(f, b, A, null)),
                (F.return = p),
                (f.return = p),
                (F.sibling = f),
                (p.child = F),
                (p.child.memoizedState = nv(A)),
                (p.memoizedState = tv),
                f)
              : JS(p, P))
      );
    if (((P = f.memoizedState), P !== null)) {
      if (((pe = P.dehydrated), pe !== null)) {
        if (ne)
          return p.flags & 256
            ? ((p.flags &= -257), rv(f, p, A, Error(o(422))))
            : p.memoizedState !== null
            ? ((p.child = f.child), (p.flags |= 128), null)
            : ((F = b.fallback),
              (P = p.mode),
              (b = Av({ mode: "visible", children: b.children }, P, 0, null)),
              (F = gu(F, P, A, null)),
              (F.flags |= 2),
              (b.return = p),
              (F.return = p),
              (b.sibling = F),
              (p.child = b),
              p.mode & 1 && Qd(p, f.child, null, A),
              (p.child.memoizedState = nv(A)),
              (p.memoizedState = tv),
              F);
        if (!(p.mode & 1)) p = rv(f, p, A, null);
        else if (Ur(pe)) p = rv(f, p, A, Error(o(419)));
        else if (((b = (A & f.childLanes) !== 0), ks || b)) {
          if (((b = Cr), b !== null)) {
            switch (A & -A) {
              case 4:
                F = 2;
                break;
              case 16:
                F = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                F = 32;
                break;
              case 536870912:
                F = 268435456;
                break;
              default:
                F = 0;
            }
            (b = F & (b.suspendedLanes | A) ? 0 : F),
              b !== 0 && b !== P.retryLane && ((P.retryLane = b), Ao(f, b, -1));
          }
          xA(), (p = rv(f, p, A, Error(o(421))));
        } else
          Kr(pe)
            ? ((p.flags |= 128),
              (p.child = f.child),
              (p = YH.bind(null, f)),
              kr(pe, p),
              (p = null))
            : ((A = P.treeContext),
              me &&
                ((Us = Ps(pe)),
                (Fs = p),
                ($n = !0),
                (Yo = null),
                (Ip = !1),
                A !== null &&
                  ((yo[xo++] = ol),
                  (yo[xo++] = al),
                  (yo[xo++] = lu),
                  (ol = A.id),
                  (al = A.overflow),
                  (lu = p))),
              (p = JS(p, p.pendingProps.children)),
              (p.flags |= 4096));
        return p;
      }
      return F
        ? ((b = kN(f, p, b.children, b.fallback, A)),
          (F = p.child),
          (P = f.child.memoizedState),
          (F.memoizedState =
            P === null
              ? nv(A)
              : { baseLanes: P.baseLanes | A, cachePool: null }),
          (F.childLanes = f.childLanes & ~A),
          (p.memoizedState = tv),
          b)
        : ((A = UN(f, p, b.children, A)), (p.memoizedState = null), A);
    }
    return F
      ? ((b = kN(f, p, b.children, b.fallback, A)),
        (F = p.child),
        (P = f.child.memoizedState),
        (F.memoizedState =
          P === null ? nv(A) : { baseLanes: P.baseLanes | A, cachePool: null }),
        (F.childLanes = f.childLanes & ~A),
        (p.memoizedState = tv),
        b)
      : ((A = UN(f, p, b.children, A)), (p.memoizedState = null), A);
  }
  function JS(f, p) {
    return (
      (p = Av({ mode: "visible", children: p }, f.mode, 0, null)),
      (p.return = f),
      (f.child = p)
    );
  }
  function UN(f, p, A, b) {
    var P = f.child;
    return (
      (f = P.sibling),
      (A = tc(P, { mode: "visible", children: A })),
      !(p.mode & 1) && (A.lanes = b),
      (A.return = p),
      (A.sibling = null),
      f !== null &&
        ((b = p.deletions),
        b === null ? ((p.deletions = [f]), (p.flags |= 16)) : b.push(f)),
      (p.child = A)
    );
  }
  function kN(f, p, A, b, P) {
    var F = p.mode;
    f = f.child;
    var ne = f.sibling,
      pe = { mode: "hidden", children: A };
    return (
      !(F & 1) && p.child !== f
        ? ((A = p.child),
          (A.childLanes = 0),
          (A.pendingProps = pe),
          (p.deletions = null))
        : ((A = tc(f, pe)), (A.subtreeFlags = f.subtreeFlags & 14680064)),
      ne !== null ? (b = tc(ne, b)) : ((b = gu(b, F, P, null)), (b.flags |= 2)),
      (b.return = p),
      (A.return = p),
      (A.sibling = b),
      (p.child = A),
      b
    );
  }
  function rv(f, p, A, b) {
    return (
      b !== null && kS(b),
      Qd(p, f.child, null, A),
      (f = JS(p, p.pendingProps.children)),
      (f.flags |= 2),
      (p.memoizedState = null),
      f
    );
  }
  function zN(f, p, A) {
    f.lanes |= p;
    var b = f.alternate;
    b !== null && (b.lanes |= p), Xi(f.return, p, A);
  }
  function eA(f, p, A, b, P) {
    var F = f.memoizedState;
    F === null
      ? (f.memoizedState = {
          isBackwards: p,
          rendering: null,
          renderingStartTime: 0,
          last: b,
          tail: A,
          tailMode: P,
        })
      : ((F.isBackwards = p),
        (F.rendering = null),
        (F.renderingStartTime = 0),
        (F.last = b),
        (F.tail = A),
        (F.tailMode = P));
  }
  function BN(f, p, A) {
    var b = p.pendingProps,
      P = b.revealOrder,
      F = b.tail;
    if ((Yi(f, p, b.children, A), (b = Qn.current), b & 2))
      (b = (b & 1) | 2), (p.flags |= 128);
    else {
      if (f !== null && f.flags & 128)
        e: for (f = p.child; f !== null; ) {
          if (f.tag === 13) f.memoizedState !== null && zN(f, A, p);
          else if (f.tag === 19) zN(f, A, p);
          else if (f.child !== null) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === p) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === p) break e;
            f = f.return;
          }
          (f.sibling.return = f.return), (f = f.sibling);
        }
      b &= 1;
    }
    if ((Ft(Qn, b), !(p.mode & 1))) p.memoizedState = null;
    else
      switch (P) {
        case "forwards":
          for (A = p.child, P = null; A !== null; )
            (f = A.alternate),
              f !== null && j0(f) === null && (P = A),
              (A = A.sibling);
          (A = P),
            A === null
              ? ((P = p.child), (p.child = null))
              : ((P = A.sibling), (A.sibling = null)),
            eA(p, !1, P, A, F);
          break;
        case "backwards":
          for (A = null, P = p.child, p.child = null; P !== null; ) {
            if (((f = P.alternate), f !== null && j0(f) === null)) {
              p.child = P;
              break;
            }
            (f = P.sibling), (P.sibling = A), (A = P), (P = f);
          }
          eA(p, !0, A, null, F);
          break;
        case "together":
          eA(p, !1, null, null, void 0);
          break;
        default:
          p.memoizedState = null;
      }
    return p.child;
  }
  function cl(f, p, A) {
    if (
      (f !== null && (p.dependencies = f.dependencies),
      (rf |= p.lanes),
      !(A & p.childLanes))
    )
      return null;
    if (f !== null && p.child !== f.child) throw Error(o(153));
    if (p.child !== null) {
      for (
        f = p.child, A = tc(f, f.pendingProps), p.child = A, A.return = p;
        f.sibling !== null;

      )
        (f = f.sibling),
          (A = A.sibling = tc(f, f.pendingProps)),
          (A.return = p);
      A.sibling = null;
    }
    return p.child;
  }
  function FH(f, p, A) {
    switch (p.tag) {
      case 3:
        ON(p), Zd();
        break;
      case 5:
        nN(p);
        break;
      case 1:
        Pn(p.type) && Ea(p);
        break;
      case 4:
        zS(p, p.stateNode.containerInfo);
        break;
      case 10:
        k0(p, p.type._context, p.memoizedProps.value);
        break;
      case 13:
        var b = p.memoizedState;
        if (b !== null)
          return b.dehydrated !== null
            ? (Ft(Qn, Qn.current & 1), (p.flags |= 128), null)
            : A & p.child.childLanes
            ? FN(f, p, A)
            : (Ft(Qn, Qn.current & 1),
              (f = cl(f, p, A)),
              f !== null ? f.sibling : null);
        Ft(Qn, Qn.current & 1);
        break;
      case 19:
        if (((b = (A & p.childLanes) !== 0), f.flags & 128)) {
          if (b) return BN(f, p, A);
          p.flags |= 128;
        }
        var P = p.memoizedState;
        if (
          (P !== null &&
            ((P.rendering = null), (P.tail = null), (P.lastEffect = null)),
          Ft(Qn, Qn.current),
          b)
        )
          break;
        return null;
      case 22:
      case 23:
        return (p.lanes = 0), PN(f, p, A);
    }
    return cl(f, p, A);
  }
  function UH(f, p) {
    switch ((DS(p), p.tag)) {
      case 1:
        return (
          Pn(p.type) && Gi(),
          (f = p.flags),
          f & 65536 ? ((p.flags = (f & -65537) | 128), p) : null
        );
      case 3:
        return (
          ef(),
          cn(jn),
          cn(sr),
          HS(),
          (f = p.flags),
          f & 65536 && !(f & 128) ? ((p.flags = (f & -65537) | 128), p) : null
        );
      case 5:
        return BS(p), null;
      case 13:
        if (
          (cn(Qn), (f = p.memoizedState), f !== null && f.dehydrated !== null)
        ) {
          if (p.alternate === null) throw Error(o(340));
          Zd();
        }
        return (
          (f = p.flags), f & 65536 ? ((p.flags = (f & -65537) | 128), p) : null
        );
      case 19:
        return cn(Qn), null;
      case 4:
        return ef(), null;
      case 10:
        return Qr(p.type._context), null;
      case 22:
      case 23:
        return yA(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var iv = !1,
    du = !1,
    kH = typeof WeakSet == "function" ? WeakSet : Set,
    gt = null;
  function sv(f, p) {
    var A = f.ref;
    if (A !== null)
      if (typeof A == "function")
        try {
          A(null);
        } catch (b) {
          fs(f, p, b);
        }
      else A.current = null;
  }
  function tA(f, p, A) {
    try {
      A();
    } catch (b) {
      fs(f, p, b);
    }
  }
  var VN = !1;
  function zH(f, p) {
    for (H(f.containerInfo), gt = p; gt !== null; )
      if (
        ((f = gt), (p = f.child), (f.subtreeFlags & 1028) !== 0 && p !== null)
      )
        (p.return = f), (gt = p);
      else
        for (; gt !== null; ) {
          f = gt;
          try {
            var A = f.alternate;
            if (f.flags & 1024)
              switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (A !== null) {
                    var b = A.memoizedProps,
                      P = A.memoizedState,
                      F = f.stateNode,
                      ne = F.getSnapshotBeforeUpdate(
                        f.elementType === f.type ? b : $i(f.type, b),
                        P
                      );
                    F.__reactInternalSnapshotBeforeUpdate = ne;
                  }
                  break;
                case 3:
                  ge && at(f.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (pe) {
            fs(f, f.return, pe);
          }
          if (((p = f.sibling), p !== null)) {
            (p.return = f.return), (gt = p);
            break;
          }
          gt = f.return;
        }
    return (A = VN), (VN = !1), A;
  }
  function fu(f, p, A) {
    var b = p.updateQueue;
    if (((b = b !== null ? b.lastEffect : null), b !== null)) {
      var P = (b = b.next);
      do {
        if ((P.tag & f) === f) {
          var F = P.destroy;
          (P.destroy = void 0), F !== void 0 && tA(p, A, F);
        }
        P = P.next;
      } while (P !== b);
    }
  }
  function Wp(f, p) {
    if (
      ((p = p.updateQueue), (p = p !== null ? p.lastEffect : null), p !== null)
    ) {
      var A = (p = p.next);
      do {
        if ((A.tag & f) === f) {
          var b = A.create;
          A.destroy = b();
        }
        A = A.next;
      } while (A !== p);
    }
  }
  function nA(f) {
    var p = f.ref;
    if (p !== null) {
      var A = f.stateNode;
      switch (f.tag) {
        case 5:
          f = G(A);
          break;
        default:
          f = A;
      }
      typeof p == "function" ? p(f) : (p.current = f);
    }
  }
  function HN(f, p, A) {
    if (Ls && typeof Ls.onCommitFiberUnmount == "function")
      try {
        Ls.onCommitFiberUnmount(iu, p);
      } catch {}
    switch (p.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((f = p.updateQueue), f !== null && ((f = f.lastEffect), f !== null))
        ) {
          var b = (f = f.next);
          do {
            var P = b,
              F = P.destroy;
            (P = P.tag),
              F !== void 0 && (P & 2 || P & 4) && tA(p, A, F),
              (b = b.next);
          } while (b !== f);
        }
        break;
      case 1:
        if (
          (sv(p, A),
          (f = p.stateNode),
          typeof f.componentWillUnmount == "function")
        )
          try {
            (f.props = p.memoizedProps),
              (f.state = p.memoizedState),
              f.componentWillUnmount();
          } catch (ne) {
            fs(p, A, ne);
          }
        break;
      case 5:
        sv(p, A);
        break;
      case 4:
        ge
          ? YN(f, p, A)
          : ie &&
            ie &&
            ((p = p.stateNode.containerInfo), (A = dt(p)), lt(p, A));
    }
  }
  function GN(f, p, A) {
    for (var b = p; ; )
      if ((HN(f, b, A), b.child === null || (ge && b.tag === 4))) {
        if (b === p) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === p) return;
          b = b.return;
        }
        (b.sibling.return = b.return), (b = b.sibling);
      } else (b.child.return = b), (b = b.child);
  }
  function WN(f) {
    var p = f.alternate;
    p !== null && ((f.alternate = null), WN(p)),
      (f.child = null),
      (f.deletions = null),
      (f.sibling = null),
      f.tag === 5 && ((p = f.stateNode), p !== null && Ue(p)),
      (f.stateNode = null),
      (f.return = null),
      (f.dependencies = null),
      (f.memoizedProps = null),
      (f.memoizedState = null),
      (f.pendingProps = null),
      (f.stateNode = null),
      (f.updateQueue = null);
  }
  function jN(f) {
    return f.tag === 5 || f.tag === 3 || f.tag === 4;
  }
  function $N(f) {
    e: for (;;) {
      for (; f.sibling === null; ) {
        if (f.return === null || jN(f.return)) return null;
        f = f.return;
      }
      for (
        f.sibling.return = f.return, f = f.sibling;
        f.tag !== 5 && f.tag !== 6 && f.tag !== 18;

      ) {
        if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
        (f.child.return = f), (f = f.child);
      }
      if (!(f.flags & 2)) return f.stateNode;
    }
  }
  function XN(f) {
    if (ge) {
      e: {
        for (var p = f.return; p !== null; ) {
          if (jN(p)) break e;
          p = p.return;
        }
        throw Error(o(160));
      }
      var A = p;
      switch (A.tag) {
        case 5:
          (p = A.stateNode),
            A.flags & 32 && (Xe(p), (A.flags &= -33)),
            (A = $N(f)),
            iA(f, A, p);
          break;
        case 3:
        case 4:
          (p = A.stateNode.containerInfo), (A = $N(f)), rA(f, A, p);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function rA(f, p, A) {
    var b = f.tag;
    if (b === 5 || b === 6) (f = f.stateNode), p ? it(A, f, p) : Ne(A, f);
    else if (b !== 4 && ((f = f.child), f !== null))
      for (rA(f, p, A), f = f.sibling; f !== null; )
        rA(f, p, A), (f = f.sibling);
  }
  function iA(f, p, A) {
    var b = f.tag;
    if (b === 5 || b === 6) (f = f.stateNode), p ? Ke(A, f, p) : et(A, f);
    else if (b !== 4 && ((f = f.child), f !== null))
      for (iA(f, p, A), f = f.sibling; f !== null; )
        iA(f, p, A), (f = f.sibling);
  }
  function YN(f, p, A) {
    for (var b = p, P = !1, F, ne; ; ) {
      if (!P) {
        P = b.return;
        e: for (;;) {
          if (P === null) throw Error(o(160));
          switch (((F = P.stateNode), P.tag)) {
            case 5:
              ne = !1;
              break e;
            case 3:
              (F = F.containerInfo), (ne = !0);
              break e;
            case 4:
              (F = F.containerInfo), (ne = !0);
              break e;
          }
          P = P.return;
        }
        P = !0;
      }
      if (b.tag === 5 || b.tag === 6)
        GN(f, b, A), ne ? ze(F, b.stateNode) : re(F, b.stateNode);
      else if (b.tag === 18) ne ? wt(F, b.stateNode) : ft(F, b.stateNode);
      else if (b.tag === 4) {
        if (b.child !== null) {
          (F = b.stateNode.containerInfo),
            (ne = !0),
            (b.child.return = b),
            (b = b.child);
          continue;
        }
      } else if ((HN(f, b, A), b.child !== null)) {
        (b.child.return = b), (b = b.child);
        continue;
      }
      if (b === p) break;
      for (; b.sibling === null; ) {
        if (b.return === null || b.return === p) return;
        (b = b.return), b.tag === 4 && (P = !1);
      }
      (b.sibling.return = b.return), (b = b.sibling);
    }
  }
  function sA(f, p) {
    if (ge) {
      switch (p.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          fu(3, p, p.return), Wp(3, p), fu(5, p, p.return);
          return;
        case 1:
          return;
        case 5:
          var A = p.stateNode;
          if (A != null) {
            var b = p.memoizedProps;
            f = f !== null ? f.memoizedProps : b;
            var P = p.type,
              F = p.updateQueue;
            (p.updateQueue = null), F !== null && nt(A, F, P, f, b, p);
          }
          return;
        case 6:
          if (p.stateNode === null) throw Error(o(162));
          (A = p.memoizedProps),
            We(p.stateNode, f !== null ? f.memoizedProps : A, A);
          return;
        case 3:
          me &&
            f !== null &&
            f.memoizedState.isDehydrated &&
            Pe(p.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          ov(p);
          return;
        case 19:
          ov(p);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (p.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        fu(3, p, p.return), Wp(3, p), fu(5, p, p.return);
        return;
      case 12:
        return;
      case 13:
        ov(p);
        return;
      case 19:
        ov(p);
        return;
      case 3:
        me &&
          f !== null &&
          f.memoizedState.isDehydrated &&
          Pe(p.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (ie) {
      switch (p.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (p = p.stateNode), lt(p.containerInfo, p.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function ov(f) {
    var p = f.updateQueue;
    if (p !== null) {
      f.updateQueue = null;
      var A = f.stateNode;
      A === null && (A = f.stateNode = new kH()),
        p.forEach(function (b) {
          var P = qH.bind(null, f, b);
          A.has(b) || (A.add(b), b.then(P, P));
        });
    }
  }
  function BH(f, p) {
    for (gt = p; gt !== null; ) {
      p = gt;
      var A = p.deletions;
      if (A !== null)
        for (var b = 0; b < A.length; b++) {
          var P = A[b];
          try {
            var F = f;
            ge ? YN(F, P, p) : GN(F, P, p);
            var ne = P.alternate;
            ne !== null && (ne.return = null), (P.return = null);
          } catch (Rt) {
            fs(P, p, Rt);
          }
        }
      if (((A = p.child), p.subtreeFlags & 12854 && A !== null))
        (A.return = p), (gt = A);
      else
        for (; gt !== null; ) {
          p = gt;
          try {
            var pe = p.flags;
            if ((pe & 32 && ge && Xe(p.stateNode), pe & 512)) {
              var Ge = p.alternate;
              if (Ge !== null) {
                var st = Ge.ref;
                st !== null &&
                  (typeof st == "function" ? st(null) : (st.current = null));
              }
            }
            if (pe & 8192)
              switch (p.tag) {
                case 13:
                  if (p.memoizedState !== null) {
                    var _t = p.alternate;
                    (_t === null || _t.memoizedState === null) && (fA = Zn());
                  }
                  break;
                case 22:
                  var Xt = p.memoizedState !== null,
                    zt = p.alternate,
                    In = zt !== null && zt.memoizedState !== null;
                  if (((A = p), ge)) {
                    e: if (((b = A), (P = Xt), (F = null), ge))
                      for (var Pt = b; ; ) {
                        if (Pt.tag === 5) {
                          if (F === null) {
                            F = Pt;
                            var Ri = Pt.stateNode;
                            P ? le(Ri) : xe(Pt.stateNode, Pt.memoizedProps);
                          }
                        } else if (Pt.tag === 6) {
                          if (F === null) {
                            var bo = Pt.stateNode;
                            P ? Re(bo) : Ye(bo, Pt.memoizedProps);
                          }
                        } else if (
                          ((Pt.tag !== 22 && Pt.tag !== 23) ||
                            Pt.memoizedState === null ||
                            Pt === b) &&
                          Pt.child !== null
                        ) {
                          (Pt.child.return = Pt), (Pt = Pt.child);
                          continue;
                        }
                        if (Pt === b) break;
                        for (; Pt.sibling === null; ) {
                          if (Pt.return === null || Pt.return === b) break e;
                          F === Pt && (F = null), (Pt = Pt.return);
                        }
                        F === Pt && (F = null),
                          (Pt.sibling.return = Pt.return),
                          (Pt = Pt.sibling);
                      }
                  }
                  if (Xt && !In && A.mode & 1) {
                    gt = A;
                    for (var Oe = A.child; Oe !== null; ) {
                      for (A = gt = Oe; gt !== null; ) {
                        b = gt;
                        var ve = b.child;
                        switch (b.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            fu(4, b, b.return);
                            break;
                          case 1:
                            sv(b, b.return);
                            var Ve = b.stateNode;
                            if (typeof Ve.componentWillUnmount == "function") {
                              var yt = b.return;
                              try {
                                (Ve.props = b.memoizedProps),
                                  (Ve.state = b.memoizedState),
                                  Ve.componentWillUnmount();
                              } catch (Rt) {
                                fs(b, yt, Rt);
                              }
                            }
                            break;
                          case 5:
                            sv(b, b.return);
                            break;
                          case 22:
                            if (b.memoizedState !== null) {
                              ZN(A);
                              continue;
                            }
                        }
                        ve !== null ? ((ve.return = b), (gt = ve)) : ZN(A);
                      }
                      Oe = Oe.sibling;
                    }
                  }
              }
            switch (pe & 4102) {
              case 2:
                XN(p), (p.flags &= -3);
                break;
              case 6:
                XN(p), (p.flags &= -3), sA(p.alternate, p);
                break;
              case 4096:
                p.flags &= -4097;
                break;
              case 4100:
                (p.flags &= -4097), sA(p.alternate, p);
                break;
              case 4:
                sA(p.alternate, p);
            }
          } catch (Rt) {
            fs(p, p.return, Rt);
          }
          if (((A = p.sibling), A !== null)) {
            (A.return = p.return), (gt = A);
            break;
          }
          gt = p.return;
        }
    }
  }
  function VH(f, p, A) {
    (gt = f), qN(f);
  }
  function qN(f, p, A) {
    for (var b = (f.mode & 1) !== 0; gt !== null; ) {
      var P = gt,
        F = P.child;
      if (P.tag === 22 && b) {
        var ne = P.memoizedState !== null || iv;
        if (!ne) {
          var pe = P.alternate,
            Ge = (pe !== null && pe.memoizedState !== null) || du;
          pe = iv;
          var st = du;
          if (((iv = ne), (du = Ge) && !st))
            for (gt = P; gt !== null; )
              (ne = gt),
                (Ge = ne.child),
                ne.tag === 22 && ne.memoizedState !== null
                  ? QN(P)
                  : Ge !== null
                  ? ((Ge.return = ne), (gt = Ge))
                  : QN(P);
          for (; F !== null; ) (gt = F), qN(F), (F = F.sibling);
          (gt = P), (iv = pe), (du = st);
        }
        KN(f);
      } else
        P.subtreeFlags & 8772 && F !== null
          ? ((F.return = P), (gt = F))
          : KN(f);
    }
  }
  function KN(f) {
    for (; gt !== null; ) {
      var p = gt;
      if (p.flags & 8772) {
        var A = p.alternate;
        try {
          if (p.flags & 8772)
            switch (p.tag) {
              case 0:
              case 11:
              case 15:
                du || Wp(5, p);
                break;
              case 1:
                var b = p.stateNode;
                if (p.flags & 4 && !du)
                  if (A === null) b.componentDidMount();
                  else {
                    var P =
                      p.elementType === p.type
                        ? A.memoizedProps
                        : $i(p.type, A.memoizedProps);
                    b.componentDidUpdate(
                      P,
                      A.memoizedState,
                      b.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var F = p.updateQueue;
                F !== null && WR(p, F, b);
                break;
              case 3:
                var ne = p.updateQueue;
                if (ne !== null) {
                  if (((A = null), p.child !== null))
                    switch (p.child.tag) {
                      case 5:
                        A = G(p.child.stateNode);
                        break;
                      case 1:
                        A = p.child.stateNode;
                    }
                  WR(p, ne, A);
                }
                break;
              case 5:
                var pe = p.stateNode;
                A === null && p.flags & 4 && ot(pe, p.type, p.memoizedProps, p);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (me && p.memoizedState === null) {
                  var Ge = p.alternate;
                  if (Ge !== null) {
                    var st = Ge.memoizedState;
                    if (st !== null) {
                      var _t = st.dehydrated;
                      _t !== null && Le(_t);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          du || (p.flags & 512 && nA(p));
        } catch (Xt) {
          fs(p, p.return, Xt);
        }
      }
      if (p === f) {
        gt = null;
        break;
      }
      if (((A = p.sibling), A !== null)) {
        (A.return = p.return), (gt = A);
        break;
      }
      gt = p.return;
    }
  }
  function ZN(f) {
    for (; gt !== null; ) {
      var p = gt;
      if (p === f) {
        gt = null;
        break;
      }
      var A = p.sibling;
      if (A !== null) {
        (A.return = p.return), (gt = A);
        break;
      }
      gt = p.return;
    }
  }
  function QN(f) {
    for (; gt !== null; ) {
      var p = gt;
      try {
        switch (p.tag) {
          case 0:
          case 11:
          case 15:
            var A = p.return;
            try {
              Wp(4, p);
            } catch (Ge) {
              fs(p, A, Ge);
            }
            break;
          case 1:
            var b = p.stateNode;
            if (typeof b.componentDidMount == "function") {
              var P = p.return;
              try {
                b.componentDidMount();
              } catch (Ge) {
                fs(p, P, Ge);
              }
            }
            var F = p.return;
            try {
              nA(p);
            } catch (Ge) {
              fs(p, F, Ge);
            }
            break;
          case 5:
            var ne = p.return;
            try {
              nA(p);
            } catch (Ge) {
              fs(p, ne, Ge);
            }
        }
      } catch (Ge) {
        fs(p, p.return, Ge);
      }
      if (p === f) {
        gt = null;
        break;
      }
      var pe = p.sibling;
      if (pe !== null) {
        (pe.return = p.return), (gt = pe);
        break;
      }
      gt = p.return;
    }
  }
  var av = 0,
    lv = 1,
    cv = 2,
    uv = 3,
    dv = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var jp = Symbol.for;
    (av = jp("selector.component")),
      (lv = jp("selector.has_pseudo_class")),
      (cv = jp("selector.role")),
      (uv = jp("selector.test_id")),
      (dv = jp("selector.text"));
  }
  function oA(f) {
    var p = fe(f);
    if (p != null) {
      if (typeof p.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return p;
    }
    if (((f = q(f)), f === null)) throw Error(o(362));
    return f.stateNode.current;
  }
  function aA(f, p) {
    switch (p.$$typeof) {
      case av:
        if (f.type === p.value) return !0;
        break;
      case lv:
        e: {
          (p = p.value), (f = [f, 0]);
          for (var A = 0; A < f.length; ) {
            var b = f[A++],
              P = f[A++],
              F = p[P];
            if (b.tag !== 5 || !he(b)) {
              for (; F != null && aA(b, F); ) P++, (F = p[P]);
              if (P === p.length) {
                p = !0;
                break e;
              } else
                for (b = b.child; b !== null; ) f.push(b, P), (b = b.sibling);
            }
          }
          p = !1;
        }
        return p;
      case cv:
        if (f.tag === 5 && Ie(f.stateNode, p.value)) return !0;
        break;
      case dv:
        if (
          (f.tag === 5 || f.tag === 6) &&
          ((f = de(f)), f !== null && 0 <= f.indexOf(p.value))
        )
          return !0;
        break;
      case uv:
        if (
          f.tag === 5 &&
          ((f = f.memoizedProps["data-testname"]),
          typeof f == "string" && f.toLowerCase() === p.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function lA(f) {
    switch (f.$$typeof) {
      case av:
        return "<" + (M(f.value) || "Unknown") + ">";
      case lv:
        return ":has(" + (lA(f) || "") + ")";
      case cv:
        return '[role="' + f.value + '"]';
      case dv:
        return '"' + f.value + '"';
      case uv:
        return '[data-testname="' + f.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function JN(f, p) {
    var A = [];
    f = [f, 0];
    for (var b = 0; b < f.length; ) {
      var P = f[b++],
        F = f[b++],
        ne = p[F];
      if (P.tag !== 5 || !he(P)) {
        for (; ne != null && aA(P, ne); ) F++, (ne = p[F]);
        if (F === p.length) A.push(P);
        else for (P = P.child; P !== null; ) f.push(P, F), (P = P.sibling);
      }
    }
    return A;
  }
  function cA(f, p) {
    if (!z) throw Error(o(363));
    (f = oA(f)), (f = JN(f, p)), (p = []), (f = Array.from(f));
    for (var A = 0; A < f.length; ) {
      var b = f[A++];
      if (b.tag === 5) he(b) || p.push(b.stateNode);
      else for (b = b.child; b !== null; ) f.push(b), (b = b.sibling);
    }
    return p;
  }
  var HH = Math.ceil,
    fv = a.ReactCurrentDispatcher,
    uA = a.ReactCurrentOwner,
    Sr = a.ReactCurrentBatchConfig,
    nn = 0,
    Cr = null,
    Rr = null,
    ai = 0,
    zs = 0,
    nf = It(0),
    Vr = 0,
    $p = null,
    rf = 0,
    hv = 0,
    dA = 0,
    Xp = null,
    us = null,
    fA = 0,
    hA = 1 / 0;
  function sf() {
    hA = Zn() + 500;
  }
  var pv = !1,
    pA = null,
    Zl = null,
    mv = !1,
    Ql = null,
    gv = 0,
    Yp = 0,
    mA = null,
    vv = -1,
    yv = 0;
  function qi() {
    return nn & 6 ? Zn() : vv !== -1 ? vv : (vv = Zn());
  }
  function Jl(f) {
    return f.mode & 1
      ? nn & 2 && ai !== 0
        ? ai & -ai
        : su.transition !== null
        ? (yv === 0 &&
            ((f = el), (el <<= 1), !(el & 4194240) && (el = 64), (yv = f)),
          yv)
        : ((f = sn), f !== 0 ? f : Se())
      : 1;
  }
  function Ao(f, p, A) {
    if (50 < Yp) throw ((Yp = 0), (mA = null), Error(o(185)));
    var b = xv(f, p);
    return b === null
      ? null
      : (Ma(b, p, A),
        (!(nn & 2) || b !== Cr) &&
          (b === Cr && (!(nn & 2) && (hv |= p), Vr === 4 && ec(b, ai)),
          ds(b, A),
          p === 1 && nn === 0 && !(f.mode & 1) && (sf(), Ca && cs())),
        b);
  }
  function xv(f, p) {
    f.lanes |= p;
    var A = f.alternate;
    for (A !== null && (A.lanes |= p), A = f, f = f.return; f !== null; )
      (f.childLanes |= p),
        (A = f.alternate),
        A !== null && (A.childLanes |= p),
        (A = f),
        (f = f.return);
    return A.tag === 3 ? A.stateNode : null;
  }
  function ds(f, p) {
    var A = f.callbackNode;
    Ep(f, p);
    var b = nu(f, f === Cr ? ai : 0);
    if (b === 0)
      A !== null && $d(A), (f.callbackNode = null), (f.callbackPriority = 0);
    else if (((p = b & -b), f.callbackPriority !== p)) {
      if ((A != null && $d(A), p === 1))
        f.tag === 0 ? Pp(tP.bind(null, f)) : Np(tP.bind(null, f)),
          Ce
            ? X(function () {
                nn === 0 && cs();
              })
            : il(ru, cs),
          (A = null);
      else {
        switch (Mp(b)) {
          case 1:
            A = ru;
            break;
          case 4:
            A = F0;
            break;
          case 16:
            A = Wi;
            break;
          case 536870912:
            A = Cp;
            break;
          default:
            A = Wi;
        }
        A = uP(A, eP.bind(null, f));
      }
      (f.callbackPriority = p), (f.callbackNode = A);
    }
  }
  function eP(f, p) {
    if (((vv = -1), (yv = 0), nn & 6)) throw Error(o(327));
    var A = f.callbackNode;
    if (mu() && f.callbackNode !== A) return null;
    var b = nu(f, f === Cr ? ai : 0);
    if (b === 0) return null;
    if (b & 30 || b & f.expiredLanes || p) p = _v(f, b);
    else {
      p = b;
      var P = nn;
      nn |= 2;
      var F = iP();
      (Cr !== f || ai !== p) && (sf(), hu(f, p));
      do
        try {
          jH();
          break;
        } catch (pe) {
          rP(f, pe);
        }
      while (!0);
      Yd(),
        (fv.current = F),
        (nn = P),
        Rr !== null ? (p = 0) : ((Cr = null), (ai = 0), (p = Vr));
    }
    if (p !== 0) {
      if (
        (p === 2 && ((P = rl(f)), P !== 0 && ((b = P), (p = gA(f, P)))),
        p === 1)
      )
        throw ((A = $p), hu(f, 0), ec(f, b), ds(f, Zn()), A);
      if (p === 6) ec(f, b);
      else {
        if (
          ((P = f.current.alternate),
          !(b & 30) &&
            !GH(P) &&
            ((p = _v(f, b)),
            p === 2 && ((F = rl(f)), F !== 0 && ((b = F), (p = gA(f, F)))),
            p === 1))
        )
          throw ((A = $p), hu(f, 0), ec(f, b), ds(f, Zn()), A);
        switch (((f.finishedWork = P), (f.finishedLanes = b), p)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            pu(f, us);
            break;
          case 3:
            if (
              (ec(f, b),
              (b & 130023424) === b && ((p = fA + 500 - Zn()), 10 < p))
            ) {
              if (nu(f, 0) !== 0) break;
              if (((P = f.suspendedLanes), (P & b) !== b)) {
                qi(), (f.pingedLanes |= f.suspendedLanes & P);
                break;
              }
              f.timeoutHandle = se(pu.bind(null, f, us), p);
              break;
            }
            pu(f, us);
            break;
          case 4:
            if ((ec(f, b), (b & 4194240) === b)) break;
            for (p = f.eventTimes, P = -1; 0 < b; ) {
              var ne = 31 - Is(b);
              (F = 1 << ne), (ne = p[ne]), ne > P && (P = ne), (b &= ~F);
            }
            if (
              ((b = P),
              (b = Zn() - b),
              (b =
                (120 > b
                  ? 120
                  : 480 > b
                  ? 480
                  : 1080 > b
                  ? 1080
                  : 1920 > b
                  ? 1920
                  : 3e3 > b
                  ? 3e3
                  : 4320 > b
                  ? 4320
                  : 1960 * HH(b / 1960)) - b),
              10 < b)
            ) {
              f.timeoutHandle = se(pu.bind(null, f, us), b);
              break;
            }
            pu(f, us);
            break;
          case 5:
            pu(f, us);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return ds(f, Zn()), f.callbackNode === A ? eP.bind(null, f) : null;
  }
  function gA(f, p) {
    var A = Xp;
    return (
      f.current.memoizedState.isDehydrated && (hu(f, p).flags |= 256),
      (f = _v(f, p)),
      f !== 2 && ((p = us), (us = A), p !== null && vA(p)),
      f
    );
  }
  function vA(f) {
    us === null ? (us = f) : us.push.apply(us, f);
  }
  function GH(f) {
    for (var p = f; ; ) {
      if (p.flags & 16384) {
        var A = p.updateQueue;
        if (A !== null && ((A = A.stores), A !== null))
          for (var b = 0; b < A.length; b++) {
            var P = A[b],
              F = P.getSnapshot;
            P = P.value;
            try {
              if (!Os(F(), P)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((A = p.child), p.subtreeFlags & 16384 && A !== null))
        (A.return = p), (p = A);
      else {
        if (p === f) break;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === f) return !0;
          p = p.return;
        }
        (p.sibling.return = p.return), (p = p.sibling);
      }
    }
    return !0;
  }
  function ec(f, p) {
    for (
      p &= ~dA,
        p &= ~hv,
        f.suspendedLanes |= p,
        f.pingedLanes &= ~p,
        f = f.expirationTimes;
      0 < p;

    ) {
      var A = 31 - Is(p),
        b = 1 << A;
      (f[A] = -1), (p &= ~b);
    }
  }
  function tP(f) {
    if (nn & 6) throw Error(o(327));
    mu();
    var p = nu(f, 0);
    if (!(p & 1)) return ds(f, Zn()), null;
    var A = _v(f, p);
    if (f.tag !== 0 && A === 2) {
      var b = rl(f);
      b !== 0 && ((p = b), (A = gA(f, b)));
    }
    if (A === 1) throw ((A = $p), hu(f, 0), ec(f, p), ds(f, Zn()), A);
    if (A === 6) throw Error(o(345));
    return (
      (f.finishedWork = f.current.alternate),
      (f.finishedLanes = p),
      pu(f, us),
      ds(f, Zn()),
      null
    );
  }
  function nP(f) {
    Ql !== null && Ql.tag === 0 && !(nn & 6) && mu();
    var p = nn;
    nn |= 1;
    var A = Sr.transition,
      b = sn;
    try {
      if (((Sr.transition = null), (sn = 1), f)) return f();
    } finally {
      (sn = b), (Sr.transition = A), (nn = p), !(nn & 6) && cs();
    }
  }
  function yA() {
    (zs = nf.current), cn(nf);
  }
  function hu(f, p) {
    (f.finishedWork = null), (f.finishedLanes = 0);
    var A = f.timeoutHandle;
    if ((A !== Be && ((f.timeoutHandle = Be), we(A)), Rr !== null))
      for (A = Rr.return; A !== null; ) {
        var b = A;
        switch ((DS(b), b.tag)) {
          case 1:
            (b = b.type.childContextTypes), b != null && Gi();
            break;
          case 3:
            ef(), cn(jn), cn(sr), HS();
            break;
          case 5:
            BS(b);
            break;
          case 4:
            ef();
            break;
          case 13:
            cn(Qn);
            break;
          case 19:
            cn(Qn);
            break;
          case 10:
            Qr(b.type._context);
            break;
          case 22:
          case 23:
            yA();
        }
        A = A.return;
      }
    if (
      ((Cr = f),
      (Rr = f = tc(f.current, null)),
      (ai = zs = p),
      (Vr = 0),
      ($p = null),
      (dA = hv = rf = 0),
      (us = Xp = null),
      Ds !== null)
    ) {
      for (p = 0; p < Ds.length; p++)
        if (((A = Ds[p]), (b = A.interleaved), b !== null)) {
          A.interleaved = null;
          var P = b.next,
            F = A.pending;
          if (F !== null) {
            var ne = F.next;
            (F.next = P), (b.next = ne);
          }
          A.pending = b;
        }
      Ds = null;
    }
    return f;
  }
  function rP(f, p) {
    do {
      var A = Rr;
      try {
        if ((Yd(), ($0.current = Q0), X0)) {
          for (var b = or.memoizedState; b !== null; ) {
            var P = b.queue;
            P !== null && (P.pending = null), (b = b.next);
          }
          X0 = !1;
        }
        if (
          ((tf = 0),
          (Jr = Mi = or = null),
          (Up = !1),
          (kp = 0),
          (uA.current = null),
          A === null || A.return === null)
        ) {
          (Vr = 1), ($p = p), (Rr = null);
          break;
        }
        e: {
          var F = f,
            ne = A.return,
            pe = A,
            Ge = p;
          if (
            ((p = ai),
            (pe.flags |= 32768),
            Ge !== null &&
              typeof Ge == "object" &&
              typeof Ge.then == "function")
          ) {
            var st = Ge,
              _t = pe,
              Xt = _t.tag;
            if (!(_t.mode & 1) && (Xt === 0 || Xt === 11 || Xt === 15)) {
              var zt = _t.alternate;
              zt
                ? ((_t.updateQueue = zt.updateQueue),
                  (_t.memoizedState = zt.memoizedState),
                  (_t.lanes = zt.lanes))
                : ((_t.updateQueue = null), (_t.memoizedState = null));
            }
            var In = bN(ne);
            if (In !== null) {
              (In.flags &= -257),
                EN(In, ne, pe, F, p),
                In.mode & 1 && wN(F, st, p),
                (p = In),
                (Ge = st);
              var Pt = p.updateQueue;
              if (Pt === null) {
                var Ri = new Set();
                Ri.add(Ge), (p.updateQueue = Ri);
              } else Pt.add(Ge);
              break e;
            } else {
              if (!(p & 1)) {
                wN(F, st, p), xA();
                break e;
              }
              Ge = Error(o(426));
            }
          } else if ($n && pe.mode & 1) {
            var bo = bN(ne);
            if (bo !== null) {
              !(bo.flags & 65536) && (bo.flags |= 256),
                EN(bo, ne, pe, F, p),
                kS(Ge);
              break e;
            }
          }
          (F = Ge),
            Vr !== 4 && (Vr = 2),
            Xp === null ? (Xp = [F]) : Xp.push(F),
            (Ge = qS(Ge, pe)),
            (pe = ne);
          do {
            switch (pe.tag) {
              case 3:
                (pe.flags |= 65536), (p &= -p), (pe.lanes |= p);
                var Oe = SN(pe, Ge, p);
                GR(pe, Oe);
                break e;
              case 1:
                F = Ge;
                var ve = pe.type,
                  Ve = pe.stateNode;
                if (
                  !(pe.flags & 128) &&
                  (typeof ve.getDerivedStateFromError == "function" ||
                    (Ve !== null &&
                      typeof Ve.componentDidCatch == "function" &&
                      (Zl === null || !Zl.has(Ve))))
                ) {
                  (pe.flags |= 65536), (p &= -p), (pe.lanes |= p);
                  var yt = AN(pe, F, p);
                  GR(pe, yt);
                  break e;
                }
            }
            pe = pe.return;
          } while (pe !== null);
        }
        oP(A);
      } catch (Rt) {
        (p = Rt), Rr === A && A !== null && (Rr = A = A.return);
        continue;
      }
      break;
    } while (!0);
  }
  function iP() {
    var f = fv.current;
    return (fv.current = Q0), f === null ? Q0 : f;
  }
  function xA() {
    (Vr === 0 || Vr === 3 || Vr === 2) && (Vr = 4),
      Cr === null || (!(rf & 268435455) && !(hv & 268435455)) || ec(Cr, ai);
  }
  function _v(f, p) {
    var A = nn;
    nn |= 2;
    var b = iP();
    (Cr === f && ai === p) || hu(f, p);
    do
      try {
        WH();
        break;
      } catch (P) {
        rP(f, P);
      }
    while (!0);
    if ((Yd(), (nn = A), (fv.current = b), Rr !== null)) throw Error(o(261));
    return (Cr = null), (ai = 0), Vr;
  }
  function WH() {
    for (; Rr !== null; ) sP(Rr);
  }
  function jH() {
    for (; Rr !== null && !Tp(); ) sP(Rr);
  }
  function sP(f) {
    var p = cP(f.alternate, f, zs);
    (f.memoizedProps = f.pendingProps),
      p === null ? oP(f) : (Rr = p),
      (uA.current = null);
  }
  function oP(f) {
    var p = f;
    do {
      var A = p.alternate;
      if (((f = p.return), p.flags & 32768)) {
        if (((A = UH(A, p)), A !== null)) {
          (A.flags &= 32767), (Rr = A);
          return;
        }
        if (f !== null)
          (f.flags |= 32768), (f.subtreeFlags = 0), (f.deletions = null);
        else {
          (Vr = 6), (Rr = null);
          return;
        }
      } else if (((A = OH(A, p, zs)), A !== null)) {
        Rr = A;
        return;
      }
      if (((p = p.sibling), p !== null)) {
        Rr = p;
        return;
      }
      Rr = p = f;
    } while (p !== null);
    Vr === 0 && (Vr = 5);
  }
  function pu(f, p) {
    var A = sn,
      b = Sr.transition;
    try {
      (Sr.transition = null), (sn = 1), $H(f, p, A);
    } finally {
      (Sr.transition = b), (sn = A);
    }
    return null;
  }
  function $H(f, p, A) {
    do mu();
    while (Ql !== null);
    if (nn & 6) throw Error(o(327));
    var b = f.finishedWork,
      P = f.finishedLanes;
    if (b === null) return null;
    if (((f.finishedWork = null), (f.finishedLanes = 0), b === f.current))
      throw Error(o(177));
    (f.callbackNode = null), (f.callbackPriority = 0);
    var F = b.lanes | b.childLanes;
    if (
      (Xl(f, F),
      f === Cr && ((Rr = Cr = null), (ai = 0)),
      (!(b.subtreeFlags & 2064) && !(b.flags & 2064)) ||
        mv ||
        ((mv = !0),
        uP(Wi, function () {
          return mu(), null;
        })),
      (F = (b.flags & 15990) !== 0),
      b.subtreeFlags & 15990 || F)
    ) {
      (F = Sr.transition), (Sr.transition = null);
      var ne = sn;
      sn = 1;
      var pe = nn;
      (nn |= 4),
        (uA.current = null),
        zH(f, b),
        BH(f, b),
        V(f.containerInfo),
        (f.current = b),
        VH(b),
        D0(),
        (nn = pe),
        (sn = ne),
        (Sr.transition = F);
    } else f.current = b;
    if (
      (mv && ((mv = !1), (Ql = f), (gv = P)),
      (F = f.pendingLanes),
      F === 0 && (Zl = null),
      Rp(b.stateNode),
      ds(f, Zn()),
      p !== null)
    )
      for (A = f.onRecoverableError, b = 0; b < p.length; b++) A(p[b]);
    if (pv) throw ((pv = !1), (f = pA), (pA = null), f);
    return (
      gv & 1 && f.tag !== 0 && mu(),
      (F = f.pendingLanes),
      F & 1 ? (f === mA ? Yp++ : ((Yp = 0), (mA = f))) : (Yp = 0),
      cs(),
      null
    );
  }
  function mu() {
    if (Ql !== null) {
      var f = Mp(gv),
        p = Sr.transition,
        A = sn;
      try {
        if (((Sr.transition = null), (sn = 16 > f ? 16 : f), Ql === null))
          var b = !1;
        else {
          if (((f = Ql), (Ql = null), (gv = 0), nn & 6)) throw Error(o(331));
          var P = nn;
          for (nn |= 4, gt = f.current; gt !== null; ) {
            var F = gt,
              ne = F.child;
            if (gt.flags & 16) {
              var pe = F.deletions;
              if (pe !== null) {
                for (var Ge = 0; Ge < pe.length; Ge++) {
                  var st = pe[Ge];
                  for (gt = st; gt !== null; ) {
                    var _t = gt;
                    switch (_t.tag) {
                      case 0:
                      case 11:
                      case 15:
                        fu(8, _t, F);
                    }
                    var Xt = _t.child;
                    if (Xt !== null) (Xt.return = _t), (gt = Xt);
                    else
                      for (; gt !== null; ) {
                        _t = gt;
                        var zt = _t.sibling,
                          In = _t.return;
                        if ((WN(_t), _t === st)) {
                          gt = null;
                          break;
                        }
                        if (zt !== null) {
                          (zt.return = In), (gt = zt);
                          break;
                        }
                        gt = In;
                      }
                  }
                }
                var Pt = F.alternate;
                if (Pt !== null) {
                  var Ri = Pt.child;
                  if (Ri !== null) {
                    Pt.child = null;
                    do {
                      var bo = Ri.sibling;
                      (Ri.sibling = null), (Ri = bo);
                    } while (Ri !== null);
                  }
                }
                gt = F;
              }
            }
            if (F.subtreeFlags & 2064 && ne !== null)
              (ne.return = F), (gt = ne);
            else
              e: for (; gt !== null; ) {
                if (((F = gt), F.flags & 2048))
                  switch (F.tag) {
                    case 0:
                    case 11:
                    case 15:
                      fu(9, F, F.return);
                  }
                var Oe = F.sibling;
                if (Oe !== null) {
                  (Oe.return = F.return), (gt = Oe);
                  break e;
                }
                gt = F.return;
              }
          }
          var ve = f.current;
          for (gt = ve; gt !== null; ) {
            ne = gt;
            var Ve = ne.child;
            if (ne.subtreeFlags & 2064 && Ve !== null)
              (Ve.return = ne), (gt = Ve);
            else
              e: for (ne = ve; gt !== null; ) {
                if (((pe = gt), pe.flags & 2048))
                  try {
                    switch (pe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Wp(9, pe);
                    }
                  } catch (Rt) {
                    fs(pe, pe.return, Rt);
                  }
                if (pe === ne) {
                  gt = null;
                  break e;
                }
                var yt = pe.sibling;
                if (yt !== null) {
                  (yt.return = pe.return), (gt = yt);
                  break e;
                }
                gt = pe.return;
              }
          }
          if (
            ((nn = P),
            cs(),
            Ls && typeof Ls.onPostCommitFiberRoot == "function")
          )
            try {
              Ls.onPostCommitFiberRoot(iu, f);
            } catch {}
          b = !0;
        }
        return b;
      } finally {
        (sn = A), (Sr.transition = p);
      }
    }
    return !1;
  }
  function aP(f, p, A) {
    (p = qS(A, p)),
      (p = SN(f, p, 1)),
      Kl(f, p),
      (p = qi()),
      (f = xv(f, 1)),
      f !== null && (Ma(f, 1, p), ds(f, p));
  }
  function fs(f, p, A) {
    if (f.tag === 3) aP(f, f, A);
    else
      for (; p !== null; ) {
        if (p.tag === 3) {
          aP(p, f, A);
          break;
        } else if (p.tag === 1) {
          var b = p.stateNode;
          if (
            typeof p.type.getDerivedStateFromError == "function" ||
            (typeof b.componentDidCatch == "function" &&
              (Zl === null || !Zl.has(b)))
          ) {
            (f = qS(A, f)),
              (f = AN(p, f, 1)),
              Kl(p, f),
              (f = qi()),
              (p = xv(p, 1)),
              p !== null && (Ma(p, 1, f), ds(p, f));
            break;
          }
        }
        p = p.return;
      }
  }
  function XH(f, p, A) {
    var b = f.pingCache;
    b !== null && b.delete(p),
      (p = qi()),
      (f.pingedLanes |= f.suspendedLanes & A),
      Cr === f &&
        (ai & A) === A &&
        (Vr === 4 || (Vr === 3 && (ai & 130023424) === ai && 500 > Zn() - fA)
          ? hu(f, 0)
          : (dA |= A)),
      ds(f, p);
  }
  function lP(f, p) {
    p === 0 &&
      (f.mode & 1
        ? ((p = tl), (tl <<= 1), !(tl & 130023424) && (tl = 4194304))
        : (p = 1));
    var A = qi();
    (f = xv(f, p)), f !== null && (Ma(f, p, A), ds(f, A));
  }
  function YH(f) {
    var p = f.memoizedState,
      A = 0;
    p !== null && (A = p.retryLane), lP(f, A);
  }
  function qH(f, p) {
    var A = 0;
    switch (f.tag) {
      case 13:
        var b = f.stateNode,
          P = f.memoizedState;
        P !== null && (A = P.retryLane);
        break;
      case 19:
        b = f.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    b !== null && b.delete(p), lP(f, A);
  }
  var cP;
  cP = function (f, p, A) {
    if (f !== null)
      if (f.memoizedProps !== p.pendingProps || jn.current) ks = !0;
      else {
        if (!(f.lanes & A) && !(p.flags & 128)) return (ks = !1), FH(f, p, A);
        ks = !!(f.flags & 131072);
      }
    else (ks = !1), $n && p.flags & 1048576 && qR(p, G0, p.index);
    switch (((p.lanes = 0), p.tag)) {
      case 2:
        var b = p.type;
        f !== null &&
          ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
          (f = p.pendingProps);
        var P = wn(p, sr.current);
        xr(p, A), (P = WS(null, p, b, f, P, A));
        var F = jS();
        return (
          (p.flags |= 1),
          typeof P == "object" &&
          P !== null &&
          typeof P.render == "function" &&
          P.$$typeof === void 0
            ? ((p.tag = 1),
              (p.memoizedState = null),
              (p.updateQueue = null),
              Pn(b) ? ((F = !0), Ea(p)) : (F = !1),
              (p.memoizedState =
                P.state !== null && P.state !== void 0 ? P.state : null),
              PS(p),
              (P.updater = V0),
              (p.stateNode = P),
              (P._reactInternals = p),
              LS(p, b, f, A),
              (p = QS(null, p, b, !0, F, A)))
            : ((p.tag = 0), $n && F && OS(p), Yi(null, p, P, A), (p = p.child)),
          p
        );
      case 16:
        b = p.elementType;
        e: {
          switch (
            (f !== null &&
              ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
            (f = p.pendingProps),
            (P = b._init),
            (b = P(b._payload)),
            (p.type = b),
            (P = p.tag = ZH(b)),
            (f = $i(b, f)),
            P)
          ) {
            case 0:
              p = ZS(null, p, b, f, A);
              break e;
            case 1:
              p = LN(null, p, b, f, A);
              break e;
            case 11:
              p = CN(null, p, b, f, A);
              break e;
            case 14:
              p = RN(null, p, b, $i(b.type, f), A);
              break e;
          }
          throw Error(o(306, b, ""));
        }
        return p;
      case 0:
        return (
          (b = p.type),
          (P = p.pendingProps),
          (P = p.elementType === b ? P : $i(b, P)),
          ZS(f, p, b, P, A)
        );
      case 1:
        return (
          (b = p.type),
          (P = p.pendingProps),
          (P = p.elementType === b ? P : $i(b, P)),
          LN(f, p, b, P, A)
        );
      case 3:
        e: {
          if ((ON(p), f === null)) throw Error(o(387));
          (b = p.pendingProps),
            (F = p.memoizedState),
            (P = F.element),
            HR(f, p),
            B0(p, b, null, A);
          var ne = p.memoizedState;
          if (((b = ne.element), me && F.isDehydrated))
            if (
              ((F = {
                element: b,
                isDehydrated: !1,
                cache: ne.cache,
                transitions: ne.transitions,
              }),
              (p.updateQueue.baseState = F),
              (p.memoizedState = F),
              p.flags & 256)
            ) {
              (P = Error(o(423))), (p = DN(f, p, b, A, P));
              break e;
            } else if (b !== P) {
              (P = Error(o(424))), (p = DN(f, p, b, A, P));
              break e;
            } else
              for (
                me &&
                  ((Us = vr(p.stateNode.containerInfo)),
                  (Fs = p),
                  ($n = !0),
                  (Yo = null),
                  (Ip = !1)),
                  A = tN(p, null, b, A),
                  p.child = A;
                A;

              )
                (A.flags = (A.flags & -3) | 4096), (A = A.sibling);
          else {
            if ((Zd(), b === P)) {
              p = cl(f, p, A);
              break e;
            }
            Yi(f, p, b, A);
          }
          p = p.child;
        }
        return p;
      case 5:
        return (
          nN(p),
          f === null && US(p),
          (b = p.type),
          (P = p.pendingProps),
          (F = f !== null ? f.memoizedProps : null),
          (ne = P.children),
          K(b, P) ? (ne = null) : F !== null && K(b, F) && (p.flags |= 32),
          IN(f, p),
          Yi(f, p, ne, A),
          p.child
        );
      case 6:
        return f === null && US(p), null;
      case 13:
        return FN(f, p, A);
      case 4:
        return (
          zS(p, p.stateNode.containerInfo),
          (b = p.pendingProps),
          f === null ? (p.child = Qd(p, null, b, A)) : Yi(f, p, b, A),
          p.child
        );
      case 11:
        return (
          (b = p.type),
          (P = p.pendingProps),
          (P = p.elementType === b ? P : $i(b, P)),
          CN(f, p, b, P, A)
        );
      case 7:
        return Yi(f, p, p.pendingProps, A), p.child;
      case 8:
        return Yi(f, p, p.pendingProps.children, A), p.child;
      case 12:
        return Yi(f, p, p.pendingProps.children, A), p.child;
      case 10:
        e: {
          if (
            ((b = p.type._context),
            (P = p.pendingProps),
            (F = p.memoizedProps),
            (ne = P.value),
            k0(p, b, ne),
            F !== null)
          )
            if (Os(F.value, ne)) {
              if (F.children === P.children && !jn.current) {
                p = cl(f, p, A);
                break e;
              }
            } else
              for (F = p.child, F !== null && (F.return = p); F !== null; ) {
                var pe = F.dependencies;
                if (pe !== null) {
                  ne = F.child;
                  for (var Ge = pe.firstContext; Ge !== null; ) {
                    if (Ge.context === b) {
                      if (F.tag === 1) {
                        (Ge = sl(-1, A & -A)), (Ge.tag = 2);
                        var st = F.updateQueue;
                        if (st !== null) {
                          st = st.shared;
                          var _t = st.pending;
                          _t === null
                            ? (Ge.next = Ge)
                            : ((Ge.next = _t.next), (_t.next = Ge)),
                            (st.pending = Ge);
                        }
                      }
                      (F.lanes |= A),
                        (Ge = F.alternate),
                        Ge !== null && (Ge.lanes |= A),
                        Xi(F.return, A, p),
                        (pe.lanes |= A);
                      break;
                    }
                    Ge = Ge.next;
                  }
                } else if (F.tag === 10)
                  ne = F.type === p.type ? null : F.child;
                else if (F.tag === 18) {
                  if (((ne = F.return), ne === null)) throw Error(o(341));
                  (ne.lanes |= A),
                    (pe = ne.alternate),
                    pe !== null && (pe.lanes |= A),
                    Xi(ne, A, p),
                    (ne = F.sibling);
                } else ne = F.child;
                if (ne !== null) ne.return = F;
                else
                  for (ne = F; ne !== null; ) {
                    if (ne === p) {
                      ne = null;
                      break;
                    }
                    if (((F = ne.sibling), F !== null)) {
                      (F.return = ne.return), (ne = F);
                      break;
                    }
                    ne = ne.return;
                  }
                F = ne;
              }
          Yi(f, p, P.children, A), (p = p.child);
        }
        return p;
      case 9:
        return (
          (P = p.type),
          (b = p.pendingProps.children),
          xr(p, A),
          (P = _r(P)),
          (b = b(P)),
          (p.flags |= 1),
          Yi(f, p, b, A),
          p.child
        );
      case 14:
        return (
          (b = p.type),
          (P = $i(b, p.pendingProps)),
          (P = $i(b.type, P)),
          RN(f, p, b, P, A)
        );
      case 15:
        return NN(f, p, p.type, p.pendingProps, A);
      case 17:
        return (
          (b = p.type),
          (P = p.pendingProps),
          (P = p.elementType === b ? P : $i(b, P)),
          f !== null &&
            ((f.alternate = null), (p.alternate = null), (p.flags |= 2)),
          (p.tag = 1),
          Pn(b) ? ((f = !0), Ea(p)) : (f = !1),
          xr(p, A),
          XR(p, b, P),
          LS(p, b, P, A),
          QS(null, p, b, !0, f, A)
        );
      case 19:
        return BN(f, p, A);
      case 22:
        return PN(f, p, A);
    }
    throw Error(o(156, p.tag));
  };
  function uP(f, p) {
    return il(f, p);
  }
  function KH(f, p, A, b) {
    (this.tag = f),
      (this.key = A),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = p),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = b),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function wo(f, p, A, b) {
    return new KH(f, p, A, b);
  }
  function _A(f) {
    return (f = f.prototype), !(!f || !f.isReactComponent);
  }
  function ZH(f) {
    if (typeof f == "function") return _A(f) ? 1 : 0;
    if (f != null) {
      if (((f = f.$$typeof), f === x)) return 11;
      if (f === _) return 14;
    }
    return 2;
  }
  function tc(f, p) {
    var A = f.alternate;
    return (
      A === null
        ? ((A = wo(f.tag, p, f.key, f.mode)),
          (A.elementType = f.elementType),
          (A.type = f.type),
          (A.stateNode = f.stateNode),
          (A.alternate = f),
          (f.alternate = A))
        : ((A.pendingProps = p),
          (A.type = f.type),
          (A.flags = 0),
          (A.subtreeFlags = 0),
          (A.deletions = null)),
      (A.flags = f.flags & 14680064),
      (A.childLanes = f.childLanes),
      (A.lanes = f.lanes),
      (A.child = f.child),
      (A.memoizedProps = f.memoizedProps),
      (A.memoizedState = f.memoizedState),
      (A.updateQueue = f.updateQueue),
      (p = f.dependencies),
      (A.dependencies =
        p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }),
      (A.sibling = f.sibling),
      (A.index = f.index),
      (A.ref = f.ref),
      A
    );
  }
  function Sv(f, p, A, b, P, F) {
    var ne = 2;
    if (((b = f), typeof f == "function")) _A(f) && (ne = 1);
    else if (typeof f == "string") ne = 5;
    else
      e: switch (f) {
        case u:
          return gu(A.children, P, F, p);
        case d:
          (ne = 8), (P |= 8);
          break;
        case h:
          return (
            (f = wo(12, A, p, P | 2)), (f.elementType = h), (f.lanes = F), f
          );
        case y:
          return (f = wo(13, A, p, P)), (f.elementType = y), (f.lanes = F), f;
        case v:
          return (f = wo(19, A, p, P)), (f.elementType = v), (f.lanes = F), f;
        case w:
          return Av(A, P, F, p);
        default:
          if (typeof f == "object" && f !== null)
            switch (f.$$typeof) {
              case m:
                ne = 10;
                break e;
              case g:
                ne = 9;
                break e;
              case x:
                ne = 11;
                break e;
              case _:
                ne = 14;
                break e;
              case S:
                (ne = 16), (b = null);
                break e;
            }
          throw Error(o(130, f == null ? f : typeof f, ""));
      }
    return (
      (p = wo(ne, A, p, P)), (p.elementType = f), (p.type = b), (p.lanes = F), p
    );
  }
  function gu(f, p, A, b) {
    return (f = wo(7, f, b, p)), (f.lanes = A), f;
  }
  function Av(f, p, A, b) {
    return (
      (f = wo(22, f, b, p)),
      (f.elementType = w),
      (f.lanes = A),
      (f.stateNode = {}),
      f
    );
  }
  function SA(f, p, A) {
    return (f = wo(6, f, null, p)), (f.lanes = A), f;
  }
  function AA(f, p, A) {
    return (
      (p = wo(4, f.children !== null ? f.children : [], f.key, p)),
      (p.lanes = A),
      (p.stateNode = {
        containerInfo: f.containerInfo,
        pendingChildren: null,
        implementation: f.implementation,
      }),
      p
    );
  }
  function QH(f, p, A, b, P) {
    (this.tag = p),
      (this.containerInfo = f),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Be),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = jd(0)),
      (this.expirationTimes = jd(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = jd(0)),
      (this.identifierPrefix = b),
      (this.onRecoverableError = P),
      me && (this.mutableSourceEagerHydrationData = null);
  }
  function dP(f, p, A, b, P, F, ne, pe, Ge) {
    return (
      (f = new QH(f, p, A, pe, Ge)),
      p === 1 ? ((p = 1), F === !0 && (p |= 8)) : (p = 0),
      (F = wo(3, null, null, p)),
      (f.current = F),
      (F.stateNode = f),
      (F.memoizedState = {
        element: b,
        isDehydrated: A,
        cache: null,
        transitions: null,
      }),
      PS(F),
      f
    );
  }
  function fP(f) {
    if (!f) return yr;
    f = f._reactInternals;
    e: {
      if (R(f) !== f || f.tag !== 1) throw Error(o(170));
      var p = f;
      do {
        switch (p.tag) {
          case 3:
            p = p.stateNode.context;
            break e;
          case 1:
            if (Pn(p.type)) {
              p = p.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        p = p.return;
      } while (p !== null);
      throw Error(o(171));
    }
    if (f.tag === 1) {
      var A = f.type;
      if (Pn(A)) return ba(f, A, p);
    }
    return p;
  }
  function hP(f) {
    var p = f._reactInternals;
    if (p === void 0)
      throw typeof f.render == "function"
        ? Error(o(188))
        : ((f = Object.keys(f).join(",")), Error(o(268, f)));
    return (f = O(p)), f === null ? null : f.stateNode;
  }
  function pP(f, p) {
    if (((f = f.memoizedState), f !== null && f.dehydrated !== null)) {
      var A = f.retryLane;
      f.retryLane = A !== 0 && A < p ? A : p;
    }
  }
  function wA(f, p) {
    pP(f, p), (f = f.alternate) && pP(f, p);
  }
  function JH(f) {
    return (f = O(f)), f === null ? null : f.stateNode;
  }
  function eG() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (f) {
      if (f.tag === 13) {
        var p = qi();
        Ao(f, 134217728, p), wA(f, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (f) {
      if (f.tag === 13) {
        var p = qi(),
          A = Jl(f);
        Ao(f, A, p), wA(f, A);
      }
    }),
    (t.attemptSynchronousHydration = function (f) {
      switch (f.tag) {
        case 3:
          var p = f.stateNode;
          if (p.current.memoizedState.isDehydrated) {
            var A = nl(p.pendingLanes);
            A !== 0 && (Ta(p, A | 1), ds(p, Zn()), !(nn & 6) && (sf(), cs()));
          }
          break;
        case 13:
          var b = qi();
          nP(function () {
            return Ao(f, 1, b);
          }),
            wA(f, 1);
      }
    }),
    (t.batchedUpdates = function (f, p) {
      var A = nn;
      nn |= 1;
      try {
        return f(p);
      } finally {
        (nn = A), nn === 0 && (sf(), Ca && cs());
      }
    }),
    (t.createComponentSelector = function (f) {
      return { $$typeof: av, value: f };
    }),
    (t.createContainer = function (f, p, A, b, P, F, ne) {
      return dP(f, p, !1, null, A, b, P, F, ne);
    }),
    (t.createHasPseudoClassSelector = function (f) {
      return { $$typeof: lv, value: f };
    }),
    (t.createHydrationContainer = function (f, p, A, b, P, F, ne, pe, Ge) {
      return (
        (f = dP(A, b, !0, f, P, F, ne, pe, Ge)),
        (f.context = fP(null)),
        (A = f.current),
        (b = qi()),
        (P = Jl(A)),
        (F = sl(b, P)),
        (F.callback = p ?? null),
        Kl(A, F),
        (f.current.lanes = P),
        Ma(f, P, b),
        ds(f, b),
        f
      );
    }),
    (t.createPortal = function (f, p, A) {
      var b =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: c,
        key: b == null ? null : "" + b,
        children: f,
        containerInfo: p,
        implementation: A,
      };
    }),
    (t.createRoleSelector = function (f) {
      return { $$typeof: cv, value: f };
    }),
    (t.createTestNameSelector = function (f) {
      return { $$typeof: uv, value: f };
    }),
    (t.createTextSelector = function (f) {
      return { $$typeof: dv, value: f };
    }),
    (t.deferredUpdates = function (f) {
      var p = sn,
        A = Sr.transition;
      try {
        return (Sr.transition = null), (sn = 16), f();
      } finally {
        (sn = p), (Sr.transition = A);
      }
    }),
    (t.discreteUpdates = function (f, p, A, b, P) {
      var F = sn,
        ne = Sr.transition;
      try {
        return (Sr.transition = null), (sn = 1), f(p, A, b, P);
      } finally {
        (sn = F), (Sr.transition = ne), nn === 0 && sf();
      }
    }),
    (t.findAllNodes = cA),
    (t.findBoundingRects = function (f, p) {
      if (!z) throw Error(o(363));
      (p = cA(f, p)), (f = []);
      for (var A = 0; A < p.length; A++) f.push(ue(p[A]));
      for (p = f.length - 1; 0 < p; p--) {
        A = f[p];
        for (
          var b = A.x, P = b + A.width, F = A.y, ne = F + A.height, pe = p - 1;
          0 <= pe;
          pe--
        )
          if (p !== pe) {
            var Ge = f[pe],
              st = Ge.x,
              _t = st + Ge.width,
              Xt = Ge.y,
              zt = Xt + Ge.height;
            if (b >= st && F >= Xt && P <= _t && ne <= zt) {
              f.splice(p, 1);
              break;
            } else if (b !== st || A.width !== Ge.width || zt < F || Xt > ne) {
              if (!(F !== Xt || A.height !== Ge.height || _t < b || st > P)) {
                st > b && ((Ge.width += st - b), (Ge.x = b)),
                  _t < P && (Ge.width = P - st),
                  f.splice(p, 1);
                break;
              }
            } else {
              Xt > F && ((Ge.height += Xt - F), (Ge.y = F)),
                zt < ne && (Ge.height = ne - Xt),
                f.splice(p, 1);
              break;
            }
          }
      }
      return f;
    }),
    (t.findHostInstance = hP),
    (t.findHostInstanceWithNoPortals = function (f) {
      return (
        (f = L(f)),
        (f = f !== null ? B(f) : null),
        f === null ? null : f.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (f) {
      return hP(f);
    }),
    (t.flushControlled = function (f) {
      var p = nn;
      nn |= 1;
      var A = Sr.transition,
        b = sn;
      try {
        (Sr.transition = null), (sn = 1), f();
      } finally {
        (sn = b), (Sr.transition = A), (nn = p), nn === 0 && (sf(), cs());
      }
    }),
    (t.flushPassiveEffects = mu),
    (t.flushSync = nP),
    (t.focusWithin = function (f, p) {
      if (!z) throw Error(o(363));
      for (f = oA(f), p = JN(f, p), p = Array.from(p), f = 0; f < p.length; ) {
        var A = p[f++];
        if (!he(A)) {
          if (A.tag === 5 && ke(A.stateNode)) return !0;
          for (A = A.child; A !== null; ) p.push(A), (A = A.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return sn;
    }),
    (t.getFindAllNodesFailureDescription = function (f, p) {
      if (!z) throw Error(o(363));
      var A = 0,
        b = [];
      f = [oA(f), 0];
      for (var P = 0; P < f.length; ) {
        var F = f[P++],
          ne = f[P++],
          pe = p[ne];
        if (
          (F.tag !== 5 || !he(F)) &&
          (aA(F, pe) && (b.push(lA(pe)), ne++, ne > A && (A = ne)),
          ne < p.length)
        )
          for (F = F.child; F !== null; ) f.push(F, ne), (F = F.sibling);
      }
      if (A < p.length) {
        for (f = []; A < p.length; A++) f.push(lA(p[A]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (b.join(" > ") +
            `

No matching component was found for:
  `) +
          f.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (f) {
      if (((f = f.current), !f.child)) return null;
      switch (f.child.tag) {
        case 5:
          return G(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (f) {
      if (
        ((f = {
          bundleType: f.bundleType,
          version: f.version,
          rendererPackageName: f.rendererPackageName,
          rendererConfig: f.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: JH,
          findFiberByHostInstance: f.findFiberByHostInstance || eG,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        f = !1;
      else {
        var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (p.isDisabled || !p.supportsFiber) f = !0;
        else {
          try {
            (iu = p.inject(f)), (Ls = p);
          } catch {}
          f = !!p.checkDCE;
        }
      }
      return f;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (f, p, A, b) {
      if (!z) throw Error(o(363));
      f = cA(f, p);
      var P = Me(f, A, b).disconnect;
      return {
        disconnect: function () {
          P();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (f, p) {
      var A = p._getVersion;
      (A = A(p._source)),
        f.mutableSourceEagerHydrationData == null
          ? (f.mutableSourceEagerHydrationData = [p, A])
          : f.mutableSourceEagerHydrationData.push(p, A);
    }),
    (t.runWithPriority = function (f, p) {
      var A = sn;
      try {
        return (sn = f), p();
      } finally {
        sn = A;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (f, p, A, b) {
      var P = p.current,
        F = qi(),
        ne = Jl(P);
      return (
        (A = fP(A)),
        p.context === null ? (p.context = A) : (p.pendingContext = A),
        (p = sl(F, ne)),
        (p.payload = { element: f }),
        (b = b === void 0 ? null : b),
        b !== null && (p.callback = b),
        Kl(P, p),
        (f = Ao(P, ne, F)),
        f !== null && z0(f, P, ne),
        ne
      );
    }),
    t
  );
};
uz.exports = GZ;
var WZ = uz.exports;
const jZ = Qh(WZ),
  $Z = (n) => typeof n == "object" && typeof n.then == "function",
  Ku = [];
function hz(n, e, t = (r, i) => r === i) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const r = n.length;
  if (e.length !== r) return !1;
  for (let i = 0; i < r; i++) if (!t(n[i], e[i])) return !1;
  return !0;
}
function pz(n, e = null, t = !1, r = {}) {
  e === null && (e = [n]);
  for (const s of Ku)
    if (hz(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return (
          r.lifespan &&
            r.lifespan > 0 &&
            (s.timeout && clearTimeout(s.timeout),
            (s.timeout = setTimeout(s.remove, r.lifespan))),
          s.response
        );
      if (!t) throw s.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    remove: () => {
      const s = Ku.indexOf(i);
      s !== -1 && Ku.splice(s, 1);
    },
    promise: ($Z(n) ? n : n(...e))
      .then((s) => {
        (i.response = s),
          r.lifespan &&
            r.lifespan > 0 &&
            (i.timeout = setTimeout(i.remove, r.lifespan));
      })
      .catch((s) => (i.error = s)),
  };
  if ((Ku.push(i), !t)) throw i.promise;
}
const mz = (n, e, t) => pz(n, e, !1, t),
  XZ = (n, e, t) => void pz(n, e, !0, t),
  YZ = (n) => {
    if (n === void 0 || n.length === 0) Ku.splice(0, Ku.length);
    else {
      const e = Ku.find((t) => hz(n, t.keys, t.equal));
      e && e.remove();
    }
  },
  B2 = {},
  qZ = (n) => void Object.assign(B2, n);
function KZ(n, e) {
  function t(u, { args: d = [], attach: h, ...m }, g) {
    let x = `${u[0].toUpperCase()}${u.slice(1)}`,
      y;
    if (u === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const v = m.object;
      y = Uf(v, { type: u, root: g, attach: h, primitive: !0 });
    } else {
      const v = B2[x];
      if (!v)
        throw new Error(
          `R3F: ${x} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      y = Uf(new v(...d), {
        type: u,
        root: g,
        attach: h,
        memoizedProps: { args: d },
      });
    }
    return (
      y.__r3f.attach === void 0 &&
        (y instanceof qt
          ? (y.__r3f.attach = "geometry")
          : y instanceof oi && (y.__r3f.attach = "material")),
      x !== "inject" && Uw(y, m),
      y
    );
  }
  function r(u, d) {
    let h = !1;
    if (d) {
      var m, g;
      (m = d.__r3f) != null && m.attach
        ? Fw(u, d, d.__r3f.attach)
        : d.isObject3D && u.isObject3D && (u.add(d), (h = !0)),
        h || (g = u.__r3f) == null || g.objects.push(d),
        d.__r3f || Uf(d, {}),
        (d.__r3f.parent = u),
        MM(d),
        kf(d);
    }
  }
  function i(u, d, h) {
    let m = !1;
    if (d) {
      var g, x;
      if ((g = d.__r3f) != null && g.attach) Fw(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        (d.parent = u),
          d.dispatchEvent({ type: "added" }),
          u.dispatchEvent({ type: "childadded", child: d });
        const y = u.children.filter((_) => _ !== d),
          v = y.indexOf(h);
        (u.children = [...y.slice(0, v), d, ...y.slice(v)]), (m = !0);
      }
      m || (x = u.__r3f) == null || x.objects.push(d),
        d.__r3f || Uf(d, {}),
        (d.__r3f.parent = u),
        MM(d),
        kf(d);
    }
  }
  function s(u, d, h = !1) {
    u && [...u].forEach((m) => o(d, m, h));
  }
  function o(u, d, h) {
    if (d) {
      var m, g, x;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = u.__r3f) != null &&
          m.objects &&
          (u.__r3f.objects = u.__r3f.objects.filter((w) => w !== d)),
        (g = d.__r3f) != null && g.attach)
      )
        uL(u, d, d.__r3f.attach);
      else if (d.isObject3D && u.isObject3D) {
        var y;
        u.remove(d), (y = d.__r3f) != null && y.root && sQ(wx(d), d);
      }
      const _ = (x = d.__r3f) == null ? void 0 : x.primitive,
        S = !_ && (h === void 0 ? d.dispose !== null : h);
      if (!_) {
        var v;
        s((v = d.__r3f) == null ? void 0 : v.objects, d, S),
          s(d.children, d, S);
      }
      if ((delete d.__r3f, S && d.dispose && d.type !== "Scene")) {
        const w = () => {
          try {
            d.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? bM.unstable_scheduleCallback(bM.unstable_IdlePriority, w)
          : w();
      }
      kf(u);
    }
  }
  function a(u, d, h, m) {
    var g;
    const x = (g = u.__r3f) == null ? void 0 : g.parent;
    if (!x) return;
    const y = t(d, h, u.__r3f.root);
    if (u.children) {
      for (const v of u.children) v.__r3f && r(y, v);
      u.children = u.children.filter((v) => !v.__r3f);
    }
    u.__r3f.objects.forEach((v) => r(y, v)),
      (u.__r3f.objects = []),
      u.__r3f.autoRemovedBeforeAppend || o(x, u),
      y.parent && (y.__r3f.autoRemovedBeforeAppend = !0),
      r(x, y),
      y.raycast &&
        y.__r3f.eventCount &&
        wx(y).getState().internal.interaction.push(y),
      [m, m.alternate].forEach((v) => {
        v !== null &&
          ((v.stateNode = y),
          v.ref &&
            (typeof v.ref == "function" ? v.ref(y) : (v.ref.current = y)));
      });
  }
  const l = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: jZ({
      createInstance: t,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (u, d) => {
        if (!d) return;
        const h = u.getState().scene;
        h.__r3f && ((h.__r3f.root = u), r(h, d));
      },
      removeChildFromContainer: (u, d) => {
        d && o(u.getState().scene, d);
      },
      insertInContainerBefore: (u, d, h) => {
        if (!d || !h) return;
        const m = u.getState().scene;
        m.__r3f && i(m, d, h);
      },
      getRootHostContext: () => null,
      getChildHostContext: (u) => u,
      finalizeInitialChildren(u) {
        var d;
        return !!((d = u == null ? void 0 : u.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(u, d, h, m) {
        var g;
        if (
          ((g = u == null ? void 0 : u.__r3f) != null ? g : {}).primitive &&
          m.object &&
          m.object !== u
        )
          return [!0];
        {
          const { args: y = [], children: v, ..._ } = m,
            { args: S = [], children: w, ...T } = h;
          if (!Array.isArray(y))
            throw new Error("R3F: the args prop must be an array!");
          if (y.some((M, N) => M !== S[N])) return [!0];
          const E = Az(u, _, T, !0);
          return E.changes.length ? [!1, E] : null;
        }
      },
      commitUpdate(u, [d, h], m, g, x, y) {
        d ? a(u, m, x, y) : Uw(u, h);
      },
      commitMount(u, d, h, m) {
        var g;
        const x = (g = u.__r3f) != null ? g : {};
        u.raycast &&
          x.handlers &&
          x.eventCount &&
          wx(u).getState().internal.interaction.push(u);
      },
      getPublicInstance: (u) => u,
      prepareForCommit: () => null,
      preparePortalMount: (u) => Uf(u.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(u) {
        var d;
        const { attach: h, parent: m } = (d = u.__r3f) != null ? d : {};
        h && m && uL(m, u, h), u.isObject3D && (u.visible = !1), kf(u);
      },
      unhideInstance(u, d) {
        var h;
        const { attach: m, parent: g } = (h = u.__r3f) != null ? h : {};
        m && g && Fw(g, u, m),
          ((u.isObject3D && d.visible == null) || d.visible) &&
            (u.visible = !0),
          kf(u);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : ih.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Hn.fun(performance.now)
          ? performance.now
          : Hn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Hn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Hn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: Uw,
  };
}
var oL, aL;
const Dw = (n) => "colorSpace" in n || "outputColorSpace" in n,
  gz = () => {
    var n;
    return (n = B2.ColorManagement) != null ? n : null;
  },
  vz = (n) => n && n.isOrthographicCamera,
  ZZ = (n) => n && n.hasOwnProperty("current"),
  A0 =
    typeof window < "u" &&
    (((oL = window.document) != null && oL.createElement) ||
      ((aL = window.navigator) == null ? void 0 : aL.product) === "ReactNative")
      ? I.useLayoutEffect
      : I.useEffect;
function yz(n) {
  const e = I.useRef(n);
  return A0(() => void (e.current = n), [n]), e;
}
function QZ({ set: n }) {
  return A0(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class xz extends I.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
xz.getDerivedStateFromError = () => ({ error: !0 });
const _z = "__default",
  lL = new Map(),
  JZ = (n) => n && !!n.memoized && !!n.changes;
function Sz(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const mm = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function wx(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Hn = {
  obj: (n) => n === Object(n) && !Hn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (Hn.str(n) || Hn.num(n)) return n === e;
    const s = Hn.obj(n);
    if (s && r === "reference") return n === e;
    const o = Hn.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || s) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (s && t === "shallow" && r === "shallow") {
      for (a in i ? e : n)
        if (!Hn.equ(n[a], e[a], { strict: i, objects: "reference" })) return !1;
    } else for (a in i ? e : n) if (n[a] !== e[a]) return !1;
    if (Hn.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function eQ(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function tQ(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Uf(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function EM(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((s, o) => s[o], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const cL = /-\d+$/;
function Fw(n, e, t) {
  if (Hn.str(t)) {
    if (cL.test(t)) {
      const s = t.replace(cL, ""),
        { target: o, key: a } = EM(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: r, key: i } = EM(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function uL(n, e, t) {
  var r, i;
  if (Hn.str(t)) {
    const { target: s, key: o } = EM(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function Az(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: s, key: o, ref: a, ...l } = {},
  c = !1
) {
  const u = n.__r3f,
    d = Object.entries(i),
    h = [];
  if (c) {
    const g = Object.keys(l);
    for (let x = 0; x < g.length; x++)
      i.hasOwnProperty(g[x]) || d.unshift([g[x], _z + "remove"]);
  }
  d.forEach(([g, x]) => {
    var y;
    if (
      ((y = n.__r3f) != null && y.primitive && g === "object") ||
      Hn.equ(x, l[g])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(g))
      return h.push([g, x, !0, []]);
    let v = [];
    g.includes("-") && (v = g.split("-")), h.push([g, x, !1, v]);
    for (const _ in i) {
      const S = i[_];
      _.startsWith(`${g}-`) && h.push([_, S, !1, _.split("-")]);
    }
  });
  const m = { ...i };
  return (
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.args &&
      (m.args = u.memoizedProps.args),
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.attach &&
      (m.attach = u.memoizedProps.attach),
    { memoized: m, changes: h }
  );
}
const nQ = typeof process < "u" && !1;
function Uw(n, e) {
  var t;
  const r = n.__r3f,
    i = r == null ? void 0 : r.root,
    s = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: o, changes: a } = JZ(e) ? e : Az(n, e),
    l = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let u = 0; u < a.length; u++) {
    let [d, h, m, g] = a[u];
    if (Dw(n)) {
      const _ = "srgb",
        S = "srgb-linear";
      d === "encoding"
        ? ((d = "colorSpace"), (h = h === 3001 ? _ : S))
        : d === "outputEncoding" &&
          ((d = "outputColorSpace"), (h = h === 3001 ? _ : S));
    }
    let x = n,
      y = x[d];
    if (g.length && ((y = g.reduce((v, _) => v[_], n)), !(y && y.set))) {
      const [v, ..._] = g.reverse();
      (x = _.reverse().reduce((S, w) => S[w], n)), (d = v);
    }
    if (h === _z + "remove")
      if (x.constructor) {
        let v = lL.get(x.constructor);
        v || ((v = new x.constructor()), lL.set(x.constructor, v)), (h = v[d]);
      } else h = 0;
    if (m && r)
      h ? (r.handlers[d] = h) : delete r.handlers[d],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (y && y.set && (y.copy || y instanceof ad)) {
      if (Array.isArray(h)) y.fromArray ? y.fromArray(h) : y.set(...h);
      else if (
        y.copy &&
        h &&
        h.constructor &&
        (nQ
          ? y.constructor.name === h.constructor.name
          : y.constructor === h.constructor)
      )
        y.copy(h);
      else if (h !== void 0) {
        const v = y instanceof pt;
        !v && y.setScalar
          ? y.setScalar(h)
          : y instanceof ad && h instanceof ad
          ? (y.mask = h.mask)
          : y.set(h),
          !gz() && s && !s.linear && v && y.convertSRGBToLinear();
      }
    } else if (
      ((x[d] = h),
      x[d] instanceof Fr && x[d].format === ys && x[d].type === $a && s)
    ) {
      const v = x[d];
      Dw(v) && Dw(s.gl)
        ? (v.colorSpace = s.gl.outputColorSpace)
        : (v.encoding = s.gl.outputEncoding);
    }
    kf(n);
  }
  if (r && r.parent && n.raycast && l !== r.eventCount) {
    const u = wx(n).getState().internal,
      d = u.interaction.indexOf(n);
    d > -1 && u.interaction.splice(d, 1), r.eventCount && u.interaction.push(n);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      MM(n),
    n
  );
}
function kf(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function MM(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function rQ(n, e) {
  n.manual ||
    (vz(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function Iy(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function iQ() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return ih.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return ih.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return ih.ContinuousEventPriority;
    default:
      return ih.DefaultEventPriority;
  }
}
function wz(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function sQ(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      wz(t.capturedMap, e, r, i);
    });
}
function oQ(n) {
  function e(l) {
    const { internal: c } = n.getState(),
      u = l.offsetX - c.initialClick[0],
      d = l.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(u * u + d * d));
  }
  function t(l) {
    return l.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((u) => {
        var d;
        return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + u];
      })
    );
  }
  function r(l, c) {
    const u = n.getState(),
      d = new Set(),
      h = [],
      m = c ? c(u.internal.interaction) : u.internal.interaction;
    for (let v = 0; v < m.length; v++) {
      const _ = mm(m[v]);
      _ && (_.raycaster.camera = void 0);
    }
    u.previousRoot || u.events.compute == null || u.events.compute(l, u);
    function g(v) {
      const _ = mm(v);
      if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
      if (_.raycaster.camera === void 0) {
        var S;
        _.events.compute == null ||
          _.events.compute(
            l,
            _,
            (S = _.previousRoot) == null ? void 0 : S.getState()
          ),
          _.raycaster.camera === void 0 && (_.raycaster.camera = null);
      }
      return _.raycaster.camera ? _.raycaster.intersectObject(v, !0) : [];
    }
    let x = m
      .flatMap(g)
      .sort((v, _) => {
        const S = mm(v.object),
          w = mm(_.object);
        return !S || !w
          ? v.distance - _.distance
          : w.events.priority - S.events.priority || v.distance - _.distance;
      })
      .filter((v) => {
        const _ = Iy(v);
        return d.has(_) ? !1 : (d.add(_), !0);
      });
    u.events.filter && (x = u.events.filter(x, u));
    for (const v of x) {
      let _ = v.object;
      for (; _; ) {
        var y;
        (y = _.__r3f) != null &&
          y.eventCount &&
          h.push({ ...v, eventObject: _ }),
          (_ = _.parent);
      }
    }
    if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId))
      for (let v of u.internal.capturedMap.get(l.pointerId).values())
        d.has(Iy(v.intersection)) || h.push(v.intersection);
    return h;
  }
  function i(l, c, u, d) {
    const h = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const g of l) {
        const x = mm(g.object) || h,
          { raycaster: y, pointer: v, camera: _, internal: S } = x,
          w = new Q(v.x, v.y, 0).unproject(_),
          T = (C) => {
            var L, O;
            return (L =
              (O = S.capturedMap.get(C)) == null
                ? void 0
                : O.has(g.eventObject)) != null
              ? L
              : !1;
          },
          E = (C) => {
            const L = { intersection: g, target: c.target };
            S.capturedMap.has(C)
              ? S.capturedMap.get(C).set(g.eventObject, L)
              : S.capturedMap.set(C, new Map([[g.eventObject, L]])),
              c.target.setPointerCapture(C);
          },
          M = (C) => {
            const L = S.capturedMap.get(C);
            L && wz(S.capturedMap, g.eventObject, L, C);
          };
        let N = {};
        for (let C in c) {
          let L = c[C];
          typeof L != "function" && (N[C] = L);
        }
        let R = {
          ...g,
          ...N,
          pointer: v,
          intersections: l,
          stopped: m.stopped,
          delta: u,
          unprojectedPoint: w,
          ray: y.ray,
          camera: _,
          stopPropagation() {
            const C = "pointerId" in c && S.capturedMap.get(c.pointerId);
            if (
              (!C || C.has(g.eventObject)) &&
              ((R.stopped = m.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (L) => L.eventObject === g.eventObject
                ))
            ) {
              const L = l.slice(0, l.indexOf(g));
              s([...L, g]);
            }
          },
          target: {
            hasPointerCapture: T,
            setPointerCapture: E,
            releasePointerCapture: M,
          },
          currentTarget: {
            hasPointerCapture: T,
            setPointerCapture: E,
            releasePointerCapture: M,
          },
          nativeEvent: c,
        };
        if ((d(R), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: c } = n.getState();
    for (const u of c.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === u.object &&
            d.index === u.index &&
            d.instanceId === u.instanceId
        )
      ) {
        const h = u.eventObject.__r3f,
          m = h == null ? void 0 : h.handlers;
        if ((c.hovered.delete(Iy(u)), h != null && h.eventCount)) {
          const g = { ...u, intersections: l };
          m.onPointerOut == null || m.onPointerOut(g),
            m.onPointerLeave == null || m.onPointerLeave(g);
        }
      }
  }
  function o(l, c) {
    for (let u = 0; u < c.length; u++) {
      const d = c[u].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: u } = n.getState();
          "pointerId" in c &&
            u.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              u.capturedMap.has(c.pointerId) &&
                (u.capturedMap.delete(c.pointerId), s([]));
            });
        };
    }
    return function (u) {
      const { onPointerMissed: d, internal: h } = n.getState();
      h.lastEvent.current = u;
      const m = l === "onPointerMove",
        g = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        y = r(u, m ? t : void 0),
        v = g ? e(u) : 0;
      l === "onPointerDown" &&
        ((h.initialClick = [u.offsetX, u.offsetY]),
        (h.initialHits = y.map((S) => S.eventObject))),
        g && !y.length && v <= 2 && (o(u, h.interaction), d && d(u)),
        m && s(y);
      function _(S) {
        const w = S.eventObject,
          T = w.__r3f,
          E = T == null ? void 0 : T.handlers;
        if (T != null && T.eventCount)
          if (m) {
            if (
              E.onPointerOver ||
              E.onPointerEnter ||
              E.onPointerOut ||
              E.onPointerLeave
            ) {
              const M = Iy(S),
                N = h.hovered.get(M);
              N
                ? N.stopped && S.stopPropagation()
                : (h.hovered.set(M, S),
                  E.onPointerOver == null || E.onPointerOver(S),
                  E.onPointerEnter == null || E.onPointerEnter(S));
            }
            E.onPointerMove == null || E.onPointerMove(S);
          } else {
            const M = E[l];
            M
              ? (!g || h.initialHits.includes(w)) &&
                (o(
                  u,
                  h.interaction.filter((N) => !h.initialHits.includes(N))
                ),
                M(S))
              : g &&
                h.initialHits.includes(w) &&
                o(
                  u,
                  h.interaction.filter((N) => !h.initialHits.includes(N))
                );
          }
      }
      i(y, u, v, _);
    };
  }
  return { handlePointer: a };
}
const bz = (n) => !!(n != null && n.render),
  Ez = I.createContext(null),
  aQ = (n, e) => {
    const t = HZ((a, l) => {
        const c = new Q(),
          u = new Q(),
          d = new Q();
        function h(v = l().camera, _ = u, S = l().size) {
          const { width: w, height: T, top: E, left: M } = S,
            N = w / T;
          _ instanceof Q ? d.copy(_) : d.set(..._);
          const R = v.getWorldPosition(c).distanceTo(d);
          if (vz(v))
            return {
              width: w / v.zoom,
              height: T / v.zoom,
              top: E,
              left: M,
              factor: 1,
              distance: R,
              aspect: N,
            };
          {
            const C = (v.fov * Math.PI) / 180,
              L = 2 * Math.tan(C / 2) * R,
              O = L * (w / T);
            return {
              width: O,
              height: L,
              top: E,
              left: M,
              factor: w / O,
              distance: R,
              aspect: N,
            };
          }
        }
        let m;
        const g = (v) =>
            a((_) => ({ performance: { ..._.performance, current: v } })),
          x = new He();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (v = 1) => n(l(), v),
          advance: (v, _) => e(v, _, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new F2(),
          pointer: x,
          mouse: x,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const v = l();
              m && clearTimeout(m),
                v.performance.current !== v.performance.min &&
                  g(v.performance.min),
                (m = setTimeout(
                  () => g(l().performance.max),
                  v.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: h,
          },
          setEvents: (v) => a((_) => ({ ..._, events: { ..._.events, ...v } })),
          setSize: (v, _, S, w, T) => {
            const E = l().camera,
              M = {
                width: v,
                height: _,
                top: w || 0,
                left: T || 0,
                updateStyle: S,
              };
            a((N) => ({ size: M, viewport: { ...N.viewport, ...h(E, u, M) } }));
          },
          setDpr: (v) =>
            a((_) => {
              const S = Sz(v);
              return {
                viewport: {
                  ..._.viewport,
                  dpr: S,
                  initialDpr: _.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (v = "always") => {
            const _ = l().clock;
            _.stop(),
              (_.elapsedTime = 0),
              v !== "never" && (_.start(), (_.elapsedTime = 0)),
              a(() => ({ frameloop: v }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: I.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (v, _, S) => {
              const w = l().internal;
              return (
                (w.priority = w.priority + (_ > 0 ? 1 : 0)),
                w.subscribers.push({ ref: v, priority: _, store: S }),
                (w.subscribers = w.subscribers.sort(
                  (T, E) => T.priority - E.priority
                )),
                () => {
                  const T = l().internal;
                  T != null &&
                    T.subscribers &&
                    ((T.priority = T.priority - (_ > 0 ? 1 : 0)),
                    (T.subscribers = T.subscribers.filter((E) => E.ref !== v)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      s = r.viewport.dpr,
      o = r.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: c, gl: u, set: d } = t.getState();
        if (l.width !== i.width || l.height !== i.height || c.dpr !== s) {
          var h;
          (i = l), (s = c.dpr), rQ(a, l), u.setPixelRatio(c.dpr);
          const m =
            (h = l.updateStyle) != null
              ? h
              : typeof HTMLCanvasElement < "u" &&
                u.domElement instanceof HTMLCanvasElement;
          u.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Ly,
  lQ = new Set(),
  cQ = new Set(),
  uQ = new Set();
function kw(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function gm(n, e) {
  switch (n) {
    case "before":
      return kw(lQ, e);
    case "after":
      return kw(cQ, e);
    case "tail":
      return kw(uQ, e);
  }
}
let zw, Bw;
function Vw(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      zw = e.internal.subscribers,
      Ly = 0;
    Ly < zw.length;
    Ly++
  )
    (Bw = zw[Ly]), Bw.ref.current(Bw.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function dQ(n) {
  let e = !1,
    t = !1,
    r,
    i,
    s;
  function o(c) {
    (i = requestAnimationFrame(o)),
      (e = !0),
      (r = 0),
      gm("before", c),
      (t = !0);
    for (const d of n.values()) {
      var u;
      (s = d.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((u = s.gl.xr) != null && u.isPresenting) &&
          (r += Vw(c, s));
    }
    if (((t = !1), gm("after", c), r === 0))
      return gm("tail", c), (e = !1), cancelAnimationFrame(i);
  }
  function a(c, u = 1) {
    var d;
    if (!c) return n.forEach((h) => a(h.store.getState(), u));
    ((d = c.gl.xr) != null && d.isPresenting) ||
      !c.internal.active ||
      c.frameloop === "never" ||
      (u > 1
        ? (c.internal.frames = Math.min(60, c.internal.frames + u))
        : t
        ? (c.internal.frames = 2)
        : (c.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)));
  }
  function l(c, u = !0, d, h) {
    if ((u && gm("before", c), d)) Vw(c, d, h);
    else for (const m of n.values()) Vw(c, m.store.getState());
    u && gm("after", c);
  }
  return { loop: o, invalidate: a, advance: l };
}
function Mz() {
  const n = I.useContext(Ez);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Oa(n = (t) => t, e) {
  return Mz()(n, e);
}
function V2(n, e = 0) {
  const t = Mz(),
    r = t.getState().internal.subscribe,
    i = yz(n);
  return A0(() => r(i, e, t), [e, r, t]), null;
}
const dL = new WeakMap();
function Tz(n, e) {
  return function (t, ...r) {
    let i = dL.get(t);
    return (
      i || ((i = new t()), dL.set(t, i)),
      n && n(i),
      Promise.all(
        r.map(
          (s) =>
            new Promise((o, a) =>
              i.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, eQ(l.scene)), o(l);
                },
                e,
                (l) =>
                  a(
                    new Error(
                      `Could not load ${s}: ${l == null ? void 0 : l.message}`
                    )
                  )
              )
            )
        )
      )
    );
  };
}
function Zu(n, e, t, r) {
  const i = Array.isArray(e) ? e : [e],
    s = mz(Tz(t, r), [n, ...i], { equal: Hn.equ });
  return Array.isArray(e) ? s : s[0];
}
Zu.preload = function (n, e, t) {
  const r = Array.isArray(e) ? e : [e];
  return XZ(Tz(t), [n, ...r]);
};
Zu.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return YZ([n, ...t]);
};
const kh = new Map(),
  { invalidate: fL, advance: hL } = dQ(kh),
  { reconciler: g1, applyProps: Rf } = KZ(kh, iQ),
  Nf = { objects: "shallow", strict: !1 },
  fQ = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return bz(t)
      ? t
      : new Ek({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function hQ(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: s, left: o, updateStyle: a = t } = e;
    return { width: r, height: i, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function pQ(n) {
  const e = kh.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    s = r || aQ(fL, hL),
    o =
      t ||
      g1.createContainer(s, ih.ConcurrentRoot, null, !1, null, "", i, null);
  e || kh.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    c;
  return {
    configure(u = {}) {
      let {
          gl: d,
          size: h,
          scene: m,
          events: g,
          onCreated: x,
          shadows: y = !1,
          linear: v = !1,
          flat: _ = !1,
          legacy: S = !1,
          orthographic: w = !1,
          frameloop: T = "always",
          dpr: E = [1, 2],
          performance: M,
          raycaster: N,
          camera: R,
          onPointerMissed: C,
        } = u,
        L = s.getState(),
        O = L.gl;
      L.gl || L.set({ gl: (O = fQ(d, n)) });
      let D = L.raycaster;
      D || L.set({ raycaster: (D = new az()) });
      const { params: B, ...$ } = N || {};
      if (
        (Hn.equ($, D, Nf) || Rf(D, { ...$ }),
        Hn.equ(B, D.params, Nf) || Rf(D, { params: { ...D.params, ...B } }),
        !L.camera || (L.camera === c && !Hn.equ(c, R, Nf)))
      ) {
        c = R;
        const V = R instanceof h0,
          k = V
            ? R
            : w
            ? new Fo(0, 0, 0, 0, 0.1, 1e3)
            : new Yn(75, 0, 0.1, 1e3);
        V ||
          ((k.position.z = 5),
          R &&
            (Rf(k, R),
            ("aspect" in R ||
              "left" in R ||
              "right" in R ||
              "bottom" in R ||
              "top" in R) &&
              ((k.manual = !0), k.updateProjectionMatrix())),
          !L.camera && !(R != null && R.rotation) && k.lookAt(0, 0, 0)),
          L.set({ camera: k }),
          (D.camera = k);
      }
      if (!L.scene) {
        let V;
        m instanceof f1 ? (V = m) : ((V = new f1()), m && Rf(V, m)),
          L.set({ scene: Uf(V) });
      }
      if (!L.xr) {
        var G;
        const V = (ee, Y) => {
            const K = s.getState();
            K.frameloop !== "never" && hL(ee, !0, K, Y);
          },
          k = () => {
            const ee = s.getState();
            (ee.gl.xr.enabled = ee.gl.xr.isPresenting),
              ee.gl.xr.setAnimationLoop(ee.gl.xr.isPresenting ? V : null),
              ee.gl.xr.isPresenting || fL(ee);
          },
          W = {
            connect() {
              const ee = s.getState().gl;
              ee.xr.addEventListener("sessionstart", k),
                ee.xr.addEventListener("sessionend", k);
            },
            disconnect() {
              const ee = s.getState().gl;
              ee.xr.removeEventListener("sessionstart", k),
                ee.xr.removeEventListener("sessionend", k);
            },
          };
        typeof ((G = O.xr) == null ? void 0 : G.addEventListener) ==
          "function" && W.connect(),
          L.set({ xr: W });
      }
      if (O.shadowMap) {
        const V = O.shadowMap.enabled,
          k = O.shadowMap.type;
        if (((O.shadowMap.enabled = !!y), Hn.boo(y))) O.shadowMap.type = Gm;
        else if (Hn.str(y)) {
          var j;
          const W = { basic: d4, percentage: d_, soft: Gm, variance: ta };
          O.shadowMap.type = (j = W[y]) != null ? j : Gm;
        } else Hn.obj(y) && Object.assign(O.shadowMap, y);
        (V !== O.shadowMap.enabled || k !== O.shadowMap.type) &&
          (O.shadowMap.needsUpdate = !0);
      }
      const U = gz();
      U &&
        ("enabled" in U
          ? (U.enabled = !S)
          : "legacyMode" in U && (U.legacyMode = S)),
        l ||
          Rf(O, { outputEncoding: v ? 3e3 : 3001, toneMapping: _ ? ws : f_ }),
        L.legacy !== S && L.set(() => ({ legacy: S })),
        L.linear !== v && L.set(() => ({ linear: v })),
        L.flat !== _ && L.set(() => ({ flat: _ })),
        d && !Hn.fun(d) && !bz(d) && !Hn.equ(d, O, Nf) && Rf(O, d),
        g && !L.events.handlers && L.set({ events: g(s) });
      const H = hQ(n, h);
      return (
        Hn.equ(H, L.size, Nf) ||
          L.setSize(H.width, H.height, H.updateStyle, H.top, H.left),
        E && L.viewport.dpr !== Sz(E) && L.setDpr(E),
        L.frameloop !== T && L.setFrameloop(T),
        L.onPointerMissed || L.set({ onPointerMissed: C }),
        M &&
          !Hn.equ(M, L.performance, Nf) &&
          L.set((V) => ({ performance: { ...V.performance, ...M } })),
        (a = x),
        (l = !0),
        this
      );
    },
    render(u) {
      return (
        l || this.configure(),
        g1.updateContainer(
          J.jsx(mQ, { store: s, children: u, onCreated: a, rootElement: n }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      Cz(n);
    },
  };
}
function mQ({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    A0(() => {
      const i = n.getState();
      i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    J.jsx(Ez.Provider, { value: n, children: e })
  );
}
function Cz(n, e) {
  const t = kh.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      g1.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              i.events.disconnect == null || i.events.disconnect(),
                (s = i.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                tQ(i),
                kh.delete(n);
            } catch {}
          }, 500);
      });
  }
}
g1.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: I.version,
});
function TM(n, e, t) {
  var r, i, s, o, a;
  e == null && (e = 100);
  function l() {
    var u = Date.now() - o;
    u < e && u >= 0
      ? (r = setTimeout(l, e - u))
      : ((r = null), t || ((a = n.apply(s, i)), (s = i = null)));
  }
  var c = function () {
    (s = this), (i = arguments), (o = Date.now());
    var u = t && !r;
    return (
      r || (r = setTimeout(l, e)), u && ((a = n.apply(s, i)), (s = i = null)), a
    );
  };
  return (
    (c.clear = function () {
      r && (clearTimeout(r), (r = null));
    }),
    (c.flush = function () {
      r && ((a = n.apply(s, i)), (s = i = null), clearTimeout(r), (r = null));
    }),
    c
  );
}
TM.debounce = TM;
var gQ = TM;
const pL = Qh(gQ);
function vQ(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = r || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = I.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = I.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    c = e ? (typeof e == "number" ? e : e.scroll) : null,
    u = e ? (typeof e == "number" ? e : e.resize) : null,
    d = I.useRef(!1);
  I.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [h, m, g] = I.useMemo(() => {
    const _ = () => {
      if (!l.current.element) return;
      const {
          left: S,
          top: w,
          width: T,
          height: E,
          bottom: M,
          right: N,
          x: R,
          y: C,
        } = l.current.element.getBoundingClientRect(),
        L = {
          left: S,
          top: w,
          width: T,
          height: E,
          bottom: M,
          right: N,
          x: R,
          y: C,
        };
      l.current.element instanceof HTMLElement &&
        i &&
        ((L.height = l.current.element.offsetHeight),
        (L.width = l.current.element.offsetWidth)),
        Object.freeze(L),
        d.current &&
          !SQ(l.current.lastBounds, L) &&
          a((l.current.lastBounds = L));
    };
    return [_, u ? pL(_, u) : _, c ? pL(_, c) : _];
  }, [a, i, c, u]);
  function x() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((_) =>
        _.removeEventListener("scroll", g, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null));
  }
  function y() {
    l.current.element &&
      ((l.current.resizeObserver = new s(g)),
      l.current.resizeObserver.observe(l.current.element),
      t &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((_) =>
          _.addEventListener("scroll", g, { capture: !0, passive: !0 })
        ));
  }
  const v = (_) => {
    !_ ||
      _ === l.current.element ||
      (x(), (l.current.element = _), (l.current.scrollContainers = Rz(_)), y());
  };
  return (
    xQ(g, !!t),
    yQ(m),
    I.useEffect(() => {
      x(), y();
    }, [t, g, m]),
    I.useEffect(() => x, []),
    [v, o, h]
  );
}
function yQ(n) {
  I.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function xQ(n, e) {
  I.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function Rz(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...Rz(n.parentElement)]
  );
}
const _Q = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  SQ = (n, e) => _Q.every((t) => n[t] === e[t]);
var AQ = Object.defineProperty,
  wQ = Object.defineProperties,
  bQ = Object.getOwnPropertyDescriptors,
  mL = Object.getOwnPropertySymbols,
  EQ = Object.prototype.hasOwnProperty,
  MQ = Object.prototype.propertyIsEnumerable,
  gL = (n, e, t) =>
    e in n
      ? AQ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  vL = (n, e) => {
    for (var t in e || (e = {})) EQ.call(e, t) && gL(n, t, e[t]);
    if (mL) for (var t of mL(e)) MQ.call(e, t) && gL(n, t, e[t]);
    return n;
  },
  TQ = (n, e) => wQ(n, bQ(e)),
  yL,
  xL;
typeof window < "u" &&
(((yL = window.document) != null && yL.createElement) ||
  ((xL = window.navigator) == null ? void 0 : xL.product) === "ReactNative")
  ? I.useLayoutEffect
  : I.useEffect;
function Nz(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const i = Nz(r, e, t);
    if (i) return i;
    r = r.sibling;
  }
}
function Pz(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const _L = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = _L;
    return;
  }
  return _L.apply(this, arguments);
};
const H2 = Pz(I.createContext(null));
class Iz extends I.Component {
  render() {
    return I.createElement(
      H2.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function CQ() {
  const n = I.useContext(H2);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = I.useId();
  return I.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const i = Nz(r, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function RQ() {
  const n = CQ(),
    [e] = I.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      i && i !== H2 && !e.has(i) && e.set(i, I.useContext(Pz(i)));
    }
    t = t.return;
  }
  return e;
}
function NQ() {
  const n = RQ();
  return I.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          I.createElement(
            e,
            null,
            I.createElement(t.Provider, TQ(vL({}, r), { value: n.get(t) }))
          ),
        (e) => I.createElement(Iz, vL({}, e))
      ),
    [n]
  );
}
const Hw = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function PQ(n) {
  const { handlePointer: e } = oQ(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(Hw).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        i((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
          const [l, c] = Hw[o];
          t.addEventListener(l, a, { passive: c });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = Hw[s];
            r.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
const IQ = I.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: s,
      events: o = PQ,
      eventSource: a,
      eventPrefix: l,
      shadows: c,
      linear: u,
      flat: d,
      legacy: h,
      orthographic: m,
      frameloop: g,
      dpr: x,
      performance: y,
      raycaster: v,
      camera: _,
      scene: S,
      onPointerMissed: w,
      onCreated: T,
      ...E
    },
    M
  ) {
    I.useMemo(() => qZ(zZ), []);
    const N = NQ(),
      [R, C] = vQ({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      L = I.useRef(null),
      O = I.useRef(null);
    I.useImperativeHandle(M, () => L.current);
    const D = yz(w),
      [B, $] = I.useState(!1),
      [G, j] = I.useState(!1);
    if (B) throw B;
    if (G) throw G;
    const U = I.useRef(null);
    A0(() => {
      const V = L.current;
      C.width > 0 &&
        C.height > 0 &&
        V &&
        (U.current || (U.current = pQ(V)),
        U.current.configure({
          gl: s,
          events: o,
          shadows: c,
          linear: u,
          flat: d,
          legacy: h,
          orthographic: m,
          frameloop: g,
          dpr: x,
          performance: y,
          raycaster: v,
          camera: _,
          scene: S,
          size: C,
          onPointerMissed: (...k) =>
            D.current == null ? void 0 : D.current(...k),
          onCreated: (k) => {
            k.events.connect == null ||
              k.events.connect(a ? (ZZ(a) ? a.current : a) : O.current),
              l &&
                k.setEvents({
                  compute: (W, ee) => {
                    const Y = W[l + "X"],
                      K = W[l + "Y"];
                    ee.pointer.set(
                      (Y / ee.size.width) * 2 - 1,
                      -(K / ee.size.height) * 2 + 1
                    ),
                      ee.raycaster.setFromCamera(ee.pointer, ee.camera);
                  },
                }),
              T == null || T(k);
          },
        }),
        U.current.render(
          J.jsx(N, {
            children: J.jsx(xz, {
              set: j,
              children: J.jsx(I.Suspense, {
                fallback: J.jsx(QZ, { set: $ }),
                children: e,
              }),
            }),
          })
        ));
    }),
      I.useEffect(() => {
        const V = L.current;
        if (V) return () => Cz(V);
      }, []);
    const H = a ? "none" : "auto";
    return J.jsx("div", {
      ref: O,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: H,
        ...i,
      },
      ...E,
      children: J.jsx("div", {
        ref: R,
        style: { width: "100%", height: "100%" },
        children: J.jsx("canvas", {
          ref: L,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  LQ = I.forwardRef(function (e, t) {
    return J.jsx(Iz, { children: J.jsx(IQ, { ...e, ref: t }) });
  });
function an() {
  return (
    (an = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    an.apply(null, arguments)
  );
}
const w0 = new Q(),
  G2 = new Q(),
  OQ = new Q(),
  SL = new He();
function DQ(n, e, t) {
  const r = w0.setFromMatrixPosition(n.matrixWorld);
  r.project(e);
  const i = t.width / 2,
    s = t.height / 2;
  return [r.x * i + i, -(r.y * s) + s];
}
function FQ(n, e) {
  const t = w0.setFromMatrixPosition(n.matrixWorld),
    r = G2.setFromMatrixPosition(e.matrixWorld),
    i = t.sub(r),
    s = e.getWorldDirection(OQ);
  return i.angleTo(s) > Math.PI / 2;
}
function UQ(n, e, t, r) {
  const i = w0.setFromMatrixPosition(n.matrixWorld),
    s = i.clone();
  s.project(e), SL.set(s.x, s.y), t.setFromCamera(SL, e);
  const o = t.intersectObjects(r, !0);
  if (o.length) {
    const a = o[0].distance;
    return i.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function kQ(n, e) {
  if (e instanceof Fo) return e.zoom;
  if (e instanceof Yn) {
    const t = w0.setFromMatrixPosition(n.matrixWorld),
      r = G2.setFromMatrixPosition(e.matrixWorld),
      i = (e.fov * Math.PI) / 180,
      s = t.distanceTo(r);
    return 1 / (2 * Math.tan(i / 2) * s);
  } else return 1;
}
function zQ(n, e, t) {
  if (e instanceof Yn || e instanceof Fo) {
    const r = w0.setFromMatrixPosition(n.matrixWorld),
      i = G2.setFromMatrixPosition(e.matrixWorld),
      s = r.distanceTo(i),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const CM = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function Lz(n, e, t = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += CM(e[i] * n.elements[i]) + (i !== 15 ? "," : ")");
  return t + r;
}
const BQ = (
    (n) => (e) =>
      Lz(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  VQ = (
    (n) => (e, t) =>
      Lz(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function HQ(n) {
  return n && typeof n == "object" && "current" in n;
}
const vm = I.forwardRef(
  (
    {
      children: n,
      eps: e = 0.001,
      style: t,
      className: r,
      prepend: i,
      center: s,
      fullscreen: o,
      portal: a,
      distanceFactor: l,
      sprite: c = !1,
      transform: u = !1,
      occlude: d,
      onOcclude: h,
      castShadow: m,
      receiveShadow: g,
      material: x,
      geometry: y,
      zIndexRange: v = [16777271, 0],
      calculatePosition: _ = DQ,
      as: S = "div",
      wrapperClass: w,
      pointerEvents: T = "auto",
      ...E
    },
    M
  ) => {
    const {
        gl: N,
        camera: R,
        scene: C,
        size: L,
        raycaster: O,
        events: D,
        viewport: B,
      } = Oa(),
      [$] = I.useState(() => document.createElement(S)),
      G = I.useRef(),
      j = I.useRef(null),
      U = I.useRef(0),
      H = I.useRef([0, 0]),
      V = I.useRef(null),
      k = I.useRef(null),
      W =
        (a == null ? void 0 : a.current) ||
        D.connected ||
        N.domElement.parentNode,
      ee = I.useRef(null),
      Y = I.useRef(!1),
      K = I.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && HQ(d[0])),
        [d]
      );
    I.useLayoutEffect(() => {
      const te = N.domElement;
      d && d === "blending"
        ? ((te.style.zIndex = `${Math.floor(v[0] / 2)}`),
          (te.style.position = "absolute"),
          (te.style.pointerEvents = "none"))
        : ((te.style.zIndex = null),
          (te.style.position = null),
          (te.style.pointerEvents = null));
    }, [d]),
      I.useLayoutEffect(() => {
        if (j.current) {
          const te = (G.current = r4($));
          if ((C.updateMatrixWorld(), u))
            $.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const ge = _(j.current, R, L);
            $.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${ge[0]}px,${ge[1]}px,0);transform-origin:0 0;`;
          }
          return (
            W && (i ? W.prepend($) : W.appendChild($)),
            () => {
              W && W.removeChild($), te.unmount();
            }
          );
        }
      }, [W, u]),
      I.useLayoutEffect(() => {
        w && ($.className = w);
      }, [w]);
    const ae = I.useMemo(
        () =>
          u
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: L.width,
                height: L.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...(o && {
                  top: -L.height / 2,
                  left: -L.width / 2,
                  width: L.width,
                  height: L.height,
                }),
                ...t,
              },
        [t, s, o, L, u]
      ),
      se = I.useMemo(() => ({ position: "absolute", pointerEvents: T }), [T]);
    I.useLayoutEffect(() => {
      if (((Y.current = !1), u)) {
        var te;
        (te = G.current) == null ||
          te.render(
            I.createElement(
              "div",
              { ref: V, style: ae },
              I.createElement(
                "div",
                { ref: k, style: se },
                I.createElement("div", {
                  ref: M,
                  className: r,
                  style: t,
                  children: n,
                })
              )
            )
          );
      } else {
        var ge;
        (ge = G.current) == null ||
          ge.render(
            I.createElement("div", {
              ref: M,
              style: ae,
              className: r,
              children: n,
            })
          );
      }
    });
    const we = I.useRef(!0);
    V2((te) => {
      if (j.current) {
        R.updateMatrixWorld(), j.current.updateWorldMatrix(!0, !1);
        const ge = u ? H.current : _(j.current, R, L);
        if (
          u ||
          Math.abs(U.current - R.zoom) > e ||
          Math.abs(H.current[0] - ge[0]) > e ||
          Math.abs(H.current[1] - ge[1]) > e
        ) {
          const ie = FQ(j.current, R);
          let me = !1;
          K &&
            (Array.isArray(d)
              ? (me = d.map((Ue) => Ue.current))
              : d !== "blending" && (me = [C]));
          const fe = we.current;
          if (me) {
            const Ue = UQ(j.current, R, O, me);
            we.current = Ue && !ie;
          } else we.current = !ie;
          fe !== we.current &&
            (h
              ? h(!we.current)
              : ($.style.display = we.current ? "block" : "none"));
          const Ee = Math.floor(v[0] / 2),
            Se = d ? (K ? [v[0], Ee] : [Ee - 1, 0]) : v;
          if ((($.style.zIndex = `${zQ(j.current, R, Se)}`), u)) {
            const [Ue, Ce] = [L.width / 2, L.height / 2],
              X = R.projectionMatrix.elements[5] * Ce,
              {
                isOrthographicCamera: z,
                top: q,
                left: ue,
                bottom: de,
                right: he,
              } = R,
              Ie = BQ(R.matrixWorldInverse),
              ke = z
                ? `scale(${X})translate(${CM(-(he + ue) / 2)}px,${CM(
                    (q + de) / 2
                  )}px)`
                : `translateZ(${X}px)`;
            let Me = j.current.matrixWorld;
            c &&
              ((Me = R.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Me)
                .scale(j.current.scale)),
              (Me.elements[3] = Me.elements[7] = Me.elements[11] = 0),
              (Me.elements[15] = 1)),
              ($.style.width = L.width + "px"),
              ($.style.height = L.height + "px"),
              ($.style.perspective = z ? "" : `${X}px`),
              V.current &&
                k.current &&
                ((V.current.style.transform = `${ke}${Ie}translate(${Ue}px,${Ce}px)`),
                (k.current.style.transform = VQ(Me, 1 / ((l || 10) / 400))));
          } else {
            const Ue = l === void 0 ? 1 : kQ(j.current, R) * l;
            $.style.transform = `translate3d(${ge[0]}px,${ge[1]}px,0) scale(${Ue})`;
          }
          (H.current = ge), (U.current = R.zoom);
        }
      }
      if (!K && ee.current && !Y.current)
        if (u) {
          if (V.current) {
            const ge = V.current.children[0];
            if (ge != null && ge.clientWidth && ge != null && ge.clientHeight) {
              const { isOrthographicCamera: ie } = R;
              if (ie || y)
                E.scale &&
                  (Array.isArray(E.scale)
                    ? E.scale instanceof Q
                      ? ee.current.scale.copy(E.scale.clone().divideScalar(1))
                      : ee.current.scale.set(
                          1 / E.scale[0],
                          1 / E.scale[1],
                          1 / E.scale[2]
                        )
                    : ee.current.scale.setScalar(1 / E.scale));
              else {
                const me = (l || 10) / 400,
                  fe = ge.clientWidth * me,
                  Ee = ge.clientHeight * me;
                ee.current.scale.set(fe, Ee, 1);
              }
              Y.current = !0;
            }
          }
        } else {
          const ge = $.children[0];
          if (ge != null && ge.clientWidth && ge != null && ge.clientHeight) {
            const ie = 1 / B.factor,
              me = ge.clientWidth * ie,
              fe = ge.clientHeight * ie;
            ee.current.scale.set(me, fe, 1), (Y.current = !0);
          }
          ee.current.lookAt(te.camera.position);
        }
    });
    const Be = I.useMemo(
      () => ({
        vertexShader: u
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [u]
    );
    return I.createElement(
      "group",
      an({}, E, { ref: j }),
      d &&
        !K &&
        I.createElement(
          "mesh",
          { castShadow: m, receiveShadow: g, ref: ee },
          y || I.createElement("planeGeometry", null),
          x ||
            I.createElement("shaderMaterial", {
              side: Ys,
              vertexShader: Be.vertexShader,
              fragmentShader: Be.fragmentShader,
            })
        )
    );
  }
);
var GQ = Object.defineProperty,
  WQ = (n, e, t) =>
    e in n
      ? GQ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Gt = (n, e, t) => (WQ(n, typeof e != "symbol" ? e + "" : e, t), t);
const Oy = new Id(),
  AL = new Fa(),
  jQ = Math.cos(70 * (Math.PI / 180)),
  wL = (n, e) => ((n % e) + e) % e;
let $Q = class extends Go {
  constructor(e, t) {
    super(),
      Gt(this, "object"),
      Gt(this, "domElement"),
      Gt(this, "enabled", !0),
      Gt(this, "target", new Q()),
      Gt(this, "minDistance", 0),
      Gt(this, "maxDistance", 1 / 0),
      Gt(this, "minZoom", 0),
      Gt(this, "maxZoom", 1 / 0),
      Gt(this, "minPolarAngle", 0),
      Gt(this, "maxPolarAngle", Math.PI),
      Gt(this, "minAzimuthAngle", -1 / 0),
      Gt(this, "maxAzimuthAngle", 1 / 0),
      Gt(this, "enableDamping", !1),
      Gt(this, "dampingFactor", 0.05),
      Gt(this, "enableZoom", !0),
      Gt(this, "zoomSpeed", 1),
      Gt(this, "enableRotate", !0),
      Gt(this, "rotateSpeed", 1),
      Gt(this, "enablePan", !0),
      Gt(this, "panSpeed", 1),
      Gt(this, "screenSpacePanning", !0),
      Gt(this, "keyPanSpeed", 7),
      Gt(this, "zoomToCursor", !1),
      Gt(this, "autoRotate", !1),
      Gt(this, "autoRotateSpeed", 2),
      Gt(this, "reverseOrbit", !1),
      Gt(this, "reverseHorizontalOrbit", !1),
      Gt(this, "reverseVerticalOrbit", !1),
      Gt(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      Gt(this, "mouseButtons", {
        LEFT: Ou.ROTATE,
        MIDDLE: Ou.DOLLY,
        RIGHT: Ou.PAN,
      }),
      Gt(this, "touches", { ONE: Du.ROTATE, TWO: Du.DOLLY_PAN }),
      Gt(this, "target0"),
      Gt(this, "position0"),
      Gt(this, "zoom0"),
      Gt(this, "_domElementKeyEvents", null),
      Gt(this, "getPolarAngle"),
      Gt(this, "getAzimuthalAngle"),
      Gt(this, "setPolarAngle"),
      Gt(this, "setAzimuthalAngle"),
      Gt(this, "getDistance"),
      Gt(this, "listenToKeyEvents"),
      Gt(this, "stopListenToKeyEvents"),
      Gt(this, "saveState"),
      Gt(this, "reset"),
      Gt(this, "update"),
      Gt(this, "connect"),
      Gt(this, "dispose"),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => u.phi),
      (this.getAzimuthalAngle = () => u.theta),
      (this.setPolarAngle = (re) => {
        let ze = wL(re, 2 * Math.PI),
          Xe = u.phi;
        Xe < 0 && (Xe += 2 * Math.PI), ze < 0 && (ze += 2 * Math.PI);
        let le = Math.abs(ze - Xe);
        2 * Math.PI - le < le &&
          (ze < Xe ? (ze += 2 * Math.PI) : (Xe += 2 * Math.PI)),
          (d.phi = ze - Xe),
          r.update();
      }),
      (this.setAzimuthalAngle = (re) => {
        let ze = wL(re, 2 * Math.PI),
          Xe = u.theta;
        Xe < 0 && (Xe += 2 * Math.PI), ze < 0 && (ze += 2 * Math.PI);
        let le = Math.abs(ze - Xe);
        2 * Math.PI - le < le &&
          (ze < Xe ? (ze += 2 * Math.PI) : (Xe += 2 * Math.PI)),
          (d.theta = ze - Xe),
          r.update();
      }),
      (this.getDistance = () => r.object.position.distanceTo(r.target)),
      (this.listenToKeyEvents = (re) => {
        re.addEventListener("keydown", Me), (this._domElementKeyEvents = re);
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", Me),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = () => {
        r.target0.copy(r.target),
          r.position0.copy(r.object.position),
          (r.zoom0 = r.object.zoom);
      }),
      (this.reset = () => {
        r.target.copy(r.target0),
          r.object.position.copy(r.position0),
          (r.object.zoom = r.zoom0),
          r.object.updateProjectionMatrix(),
          r.dispatchEvent(i),
          r.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const re = new Q(),
          ze = new Q(0, 1, 0),
          Xe = new ki().setFromUnitVectors(e.up, ze),
          le = Xe.clone().invert(),
          Re = new Q(),
          xe = new ki(),
          Ye = 2 * Math.PI;
        return function () {
          const vt = r.object.position;
          Xe.setFromUnitVectors(e.up, ze),
            le.copy(Xe).invert(),
            re.copy(vt).sub(r.target),
            re.applyQuaternion(Xe),
            u.setFromVector3(re),
            r.autoRotate && l === a.NONE && B(O()),
            r.enableDamping
              ? ((u.theta += d.theta * r.dampingFactor),
                (u.phi += d.phi * r.dampingFactor))
              : ((u.theta += d.theta), (u.phi += d.phi));
          let dt = r.minAzimuthAngle,
            mt = r.maxAzimuthAngle;
          isFinite(dt) &&
            isFinite(mt) &&
            (dt < -Math.PI ? (dt += Ye) : dt > Math.PI && (dt -= Ye),
            mt < -Math.PI ? (mt += Ye) : mt > Math.PI && (mt -= Ye),
            dt <= mt
              ? (u.theta = Math.max(dt, Math.min(mt, u.theta)))
              : (u.theta =
                  u.theta > (dt + mt) / 2
                    ? Math.max(dt, u.theta)
                    : Math.min(mt, u.theta))),
            (u.phi = Math.max(
              r.minPolarAngle,
              Math.min(r.maxPolarAngle, u.phi)
            )),
            u.makeSafe(),
            r.enableDamping === !0
              ? r.target.addScaledVector(m, r.dampingFactor)
              : r.target.add(m),
            (r.zoomToCursor && R) || r.object.isOrthographicCamera
              ? (u.radius = W(u.radius))
              : (u.radius = W(u.radius * h)),
            re.setFromSpherical(u),
            re.applyQuaternion(le),
            vt.copy(r.target).add(re),
            r.object.matrixAutoUpdate || r.object.updateMatrix(),
            r.object.lookAt(r.target),
            r.enableDamping === !0
              ? ((d.theta *= 1 - r.dampingFactor),
                (d.phi *= 1 - r.dampingFactor),
                m.multiplyScalar(1 - r.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0));
          let kt = !1;
          if (r.zoomToCursor && R) {
            let lt = null;
            if (r.object instanceof Yn && r.object.isPerspectiveCamera) {
              const St = re.length();
              lt = W(St * h);
              const Nt = St - lt;
              r.object.position.addScaledVector(M, Nt),
                r.object.updateMatrixWorld();
            } else if (r.object.isOrthographicCamera) {
              const St = new Q(N.x, N.y, 0);
              St.unproject(r.object),
                (r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / h)
                )),
                r.object.updateProjectionMatrix(),
                (kt = !0);
              const Nt = new Q(N.x, N.y, 0);
              Nt.unproject(r.object),
                r.object.position.sub(Nt).add(St),
                r.object.updateMatrixWorld(),
                (lt = re.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (r.zoomToCursor = !1);
            lt !== null &&
              (r.screenSpacePanning
                ? r.target
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix)
                    .multiplyScalar(lt)
                    .add(r.object.position)
                : (Oy.origin.copy(r.object.position),
                  Oy.direction
                    .set(0, 0, -1)
                    .transformDirection(r.object.matrix),
                  Math.abs(r.object.up.dot(Oy.direction)) < jQ
                    ? e.lookAt(r.target)
                    : (AL.setFromNormalAndCoplanarPoint(r.object.up, r.target),
                      Oy.intersectPlane(AL, r.target))));
          } else
            r.object instanceof Fo &&
              r.object.isOrthographicCamera &&
              ((kt = h !== 1),
              kt &&
                ((r.object.zoom = Math.max(
                  r.minZoom,
                  Math.min(r.maxZoom, r.object.zoom / h)
                )),
                r.object.updateProjectionMatrix()));
          return (
            (h = 1),
            (R = !1),
            kt ||
            Re.distanceToSquared(r.object.position) > c ||
            8 * (1 - xe.dot(r.object.quaternion)) > c
              ? (r.dispatchEvent(i),
                Re.copy(r.object.position),
                xe.copy(r.object.quaternion),
                (kt = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (re) => {
        re === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (r.domElement = re),
          (r.domElement.style.touchAction = "none"),
          r.domElement.addEventListener("contextmenu", We),
          r.domElement.addEventListener("pointerdown", q),
          r.domElement.addEventListener("pointercancel", de),
          r.domElement.addEventListener("wheel", ke);
      }),
      (this.dispose = () => {
        var re, ze, Xe, le, Re, xe;
        r.domElement && (r.domElement.style.touchAction = "auto"),
          (re = r.domElement) == null ||
            re.removeEventListener("contextmenu", We),
          (ze = r.domElement) == null ||
            ze.removeEventListener("pointerdown", q),
          (Xe = r.domElement) == null ||
            Xe.removeEventListener("pointercancel", de),
          (le = r.domElement) == null || le.removeEventListener("wheel", ke),
          (Re = r.domElement) == null ||
            Re.ownerDocument.removeEventListener("pointermove", ue),
          (xe = r.domElement) == null ||
            xe.ownerDocument.removeEventListener("pointerup", de),
          r._domElementKeyEvents !== null &&
            r._domElementKeyEvents.removeEventListener("keydown", Me);
      });
    const r = this,
      i = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const c = 1e-6,
      u = new wM(),
      d = new wM();
    let h = 1;
    const m = new Q(),
      g = new He(),
      x = new He(),
      y = new He(),
      v = new He(),
      _ = new He(),
      S = new He(),
      w = new He(),
      T = new He(),
      E = new He(),
      M = new Q(),
      N = new He();
    let R = !1;
    const C = [],
      L = {};
    function O() {
      return ((2 * Math.PI) / 60 / 60) * r.autoRotateSpeed;
    }
    function D() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function B(re) {
      r.reverseOrbit || r.reverseHorizontalOrbit
        ? (d.theta += re)
        : (d.theta -= re);
    }
    function $(re) {
      r.reverseOrbit || r.reverseVerticalOrbit ? (d.phi += re) : (d.phi -= re);
    }
    const G = (() => {
        const re = new Q();
        return function (Xe, le) {
          re.setFromMatrixColumn(le, 0), re.multiplyScalar(-Xe), m.add(re);
        };
      })(),
      j = (() => {
        const re = new Q();
        return function (Xe, le) {
          r.screenSpacePanning === !0
            ? re.setFromMatrixColumn(le, 1)
            : (re.setFromMatrixColumn(le, 0), re.crossVectors(r.object.up, re)),
            re.multiplyScalar(Xe),
            m.add(re);
        };
      })(),
      U = (() => {
        const re = new Q();
        return function (Xe, le) {
          const Re = r.domElement;
          if (Re && r.object instanceof Yn && r.object.isPerspectiveCamera) {
            const xe = r.object.position;
            re.copy(xe).sub(r.target);
            let Ye = re.length();
            (Ye *= Math.tan(((r.object.fov / 2) * Math.PI) / 180)),
              G((2 * Xe * Ye) / Re.clientHeight, r.object.matrix),
              j((2 * le * Ye) / Re.clientHeight, r.object.matrix);
          } else
            Re && r.object instanceof Fo && r.object.isOrthographicCamera
              ? (G(
                  (Xe * (r.object.right - r.object.left)) /
                    r.object.zoom /
                    Re.clientWidth,
                  r.object.matrix
                ),
                j(
                  (le * (r.object.top - r.object.bottom)) /
                    r.object.zoom /
                    Re.clientHeight,
                  r.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (r.enablePan = !1));
        };
      })();
    function H(re) {
      (r.object instanceof Yn && r.object.isPerspectiveCamera) ||
      (r.object instanceof Fo && r.object.isOrthographicCamera)
        ? (h /= re)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function V(re) {
      (r.object instanceof Yn && r.object.isPerspectiveCamera) ||
      (r.object instanceof Fo && r.object.isOrthographicCamera)
        ? (h *= re)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (r.enableZoom = !1));
    }
    function k(re) {
      if (!r.zoomToCursor || !r.domElement) return;
      R = !0;
      const ze = r.domElement.getBoundingClientRect(),
        Xe = re.clientX - ze.left,
        le = re.clientY - ze.top,
        Re = ze.width,
        xe = ze.height;
      (N.x = (Xe / Re) * 2 - 1),
        (N.y = -(le / xe) * 2 + 1),
        M.set(N.x, N.y, 1)
          .unproject(r.object)
          .sub(r.object.position)
          .normalize();
    }
    function W(re) {
      return Math.max(r.minDistance, Math.min(r.maxDistance, re));
    }
    function ee(re) {
      g.set(re.clientX, re.clientY);
    }
    function Y(re) {
      k(re), w.set(re.clientX, re.clientY);
    }
    function K(re) {
      v.set(re.clientX, re.clientY);
    }
    function ae(re) {
      x.set(re.clientX, re.clientY),
        y.subVectors(x, g).multiplyScalar(r.rotateSpeed);
      const ze = r.domElement;
      ze &&
        (B((2 * Math.PI * y.x) / ze.clientHeight),
        $((2 * Math.PI * y.y) / ze.clientHeight)),
        g.copy(x),
        r.update();
    }
    function se(re) {
      T.set(re.clientX, re.clientY),
        E.subVectors(T, w),
        E.y > 0 ? H(D()) : E.y < 0 && V(D()),
        w.copy(T),
        r.update();
    }
    function we(re) {
      _.set(re.clientX, re.clientY),
        S.subVectors(_, v).multiplyScalar(r.panSpeed),
        U(S.x, S.y),
        v.copy(_),
        r.update();
    }
    function Be(re) {
      k(re), re.deltaY < 0 ? V(D()) : re.deltaY > 0 && H(D()), r.update();
    }
    function te(re) {
      let ze = !1;
      switch (re.code) {
        case r.keys.UP:
          U(0, r.keyPanSpeed), (ze = !0);
          break;
        case r.keys.BOTTOM:
          U(0, -r.keyPanSpeed), (ze = !0);
          break;
        case r.keys.LEFT:
          U(r.keyPanSpeed, 0), (ze = !0);
          break;
        case r.keys.RIGHT:
          U(-r.keyPanSpeed, 0), (ze = !0);
          break;
      }
      ze && (re.preventDefault(), r.update());
    }
    function ge() {
      if (C.length == 1) g.set(C[0].pageX, C[0].pageY);
      else {
        const re = 0.5 * (C[0].pageX + C[1].pageX),
          ze = 0.5 * (C[0].pageY + C[1].pageY);
        g.set(re, ze);
      }
    }
    function ie() {
      if (C.length == 1) v.set(C[0].pageX, C[0].pageY);
      else {
        const re = 0.5 * (C[0].pageX + C[1].pageX),
          ze = 0.5 * (C[0].pageY + C[1].pageY);
        v.set(re, ze);
      }
    }
    function me() {
      const re = C[0].pageX - C[1].pageX,
        ze = C[0].pageY - C[1].pageY,
        Xe = Math.sqrt(re * re + ze * ze);
      w.set(0, Xe);
    }
    function fe() {
      r.enableZoom && me(), r.enablePan && ie();
    }
    function Ee() {
      r.enableZoom && me(), r.enableRotate && ge();
    }
    function Se(re) {
      if (C.length == 1) x.set(re.pageX, re.pageY);
      else {
        const Xe = it(re),
          le = 0.5 * (re.pageX + Xe.x),
          Re = 0.5 * (re.pageY + Xe.y);
        x.set(le, Re);
      }
      y.subVectors(x, g).multiplyScalar(r.rotateSpeed);
      const ze = r.domElement;
      ze &&
        (B((2 * Math.PI * y.x) / ze.clientHeight),
        $((2 * Math.PI * y.y) / ze.clientHeight)),
        g.copy(x);
    }
    function Ue(re) {
      if (C.length == 1) _.set(re.pageX, re.pageY);
      else {
        const ze = it(re),
          Xe = 0.5 * (re.pageX + ze.x),
          le = 0.5 * (re.pageY + ze.y);
        _.set(Xe, le);
      }
      S.subVectors(_, v).multiplyScalar(r.panSpeed), U(S.x, S.y), v.copy(_);
    }
    function Ce(re) {
      const ze = it(re),
        Xe = re.pageX - ze.x,
        le = re.pageY - ze.y,
        Re = Math.sqrt(Xe * Xe + le * le);
      T.set(0, Re),
        E.set(0, Math.pow(T.y / w.y, r.zoomSpeed)),
        H(E.y),
        w.copy(T);
    }
    function X(re) {
      r.enableZoom && Ce(re), r.enablePan && Ue(re);
    }
    function z(re) {
      r.enableZoom && Ce(re), r.enableRotate && Se(re);
    }
    function q(re) {
      var ze, Xe;
      r.enabled !== !1 &&
        (C.length === 0 &&
          ((ze = r.domElement) == null ||
            ze.ownerDocument.addEventListener("pointermove", ue),
          (Xe = r.domElement) == null ||
            Xe.ownerDocument.addEventListener("pointerup", de)),
        ot(re),
        re.pointerType === "touch" ? et(re) : he(re));
    }
    function ue(re) {
      r.enabled !== !1 && (re.pointerType === "touch" ? Ne(re) : Ie(re));
    }
    function de(re) {
      var ze, Xe, le;
      nt(re),
        C.length === 0 &&
          ((ze = r.domElement) == null ||
            ze.releasePointerCapture(re.pointerId),
          (Xe = r.domElement) == null ||
            Xe.ownerDocument.removeEventListener("pointermove", ue),
          (le = r.domElement) == null ||
            le.ownerDocument.removeEventListener("pointerup", de)),
        r.dispatchEvent(o),
        (l = a.NONE);
    }
    function he(re) {
      let ze;
      switch (re.button) {
        case 0:
          ze = r.mouseButtons.LEFT;
          break;
        case 1:
          ze = r.mouseButtons.MIDDLE;
          break;
        case 2:
          ze = r.mouseButtons.RIGHT;
          break;
        default:
          ze = -1;
      }
      switch (ze) {
        case Ou.DOLLY:
          if (r.enableZoom === !1) return;
          Y(re), (l = a.DOLLY);
          break;
        case Ou.ROTATE:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (r.enablePan === !1) return;
            K(re), (l = a.PAN);
          } else {
            if (r.enableRotate === !1) return;
            ee(re), (l = a.ROTATE);
          }
          break;
        case Ou.PAN:
          if (re.ctrlKey || re.metaKey || re.shiftKey) {
            if (r.enableRotate === !1) return;
            ee(re), (l = a.ROTATE);
          } else {
            if (r.enablePan === !1) return;
            K(re), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(s);
    }
    function Ie(re) {
      if (r.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (r.enableRotate === !1) return;
            ae(re);
            break;
          case a.DOLLY:
            if (r.enableZoom === !1) return;
            se(re);
            break;
          case a.PAN:
            if (r.enablePan === !1) return;
            we(re);
            break;
        }
    }
    function ke(re) {
      r.enabled === !1 ||
        r.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (re.preventDefault(), r.dispatchEvent(s), Be(re), r.dispatchEvent(o));
    }
    function Me(re) {
      r.enabled === !1 || r.enablePan === !1 || te(re);
    }
    function et(re) {
      switch ((Ke(re), C.length)) {
        case 1:
          switch (r.touches.ONE) {
            case Du.ROTATE:
              if (r.enableRotate === !1) return;
              ge(), (l = a.TOUCH_ROTATE);
              break;
            case Du.PAN:
              if (r.enablePan === !1) return;
              ie(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case Du.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1) return;
              fe(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case Du.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1) return;
              Ee(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && r.dispatchEvent(s);
    }
    function Ne(re) {
      switch ((Ke(re), l)) {
        case a.TOUCH_ROTATE:
          if (r.enableRotate === !1) return;
          Se(re), r.update();
          break;
        case a.TOUCH_PAN:
          if (r.enablePan === !1) return;
          Ue(re), r.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1) return;
          X(re), r.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1) return;
          z(re), r.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function We(re) {
      r.enabled !== !1 && re.preventDefault();
    }
    function ot(re) {
      C.push(re);
    }
    function nt(re) {
      delete L[re.pointerId];
      for (let ze = 0; ze < C.length; ze++)
        if (C[ze].pointerId == re.pointerId) {
          C.splice(ze, 1);
          return;
        }
    }
    function Ke(re) {
      let ze = L[re.pointerId];
      ze === void 0 && ((ze = new He()), (L[re.pointerId] = ze)),
        ze.set(re.pageX, re.pageY);
    }
    function it(re) {
      const ze = re.pointerId === C[0].pointerId ? C[1] : C[0];
      return L[ze.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
function XQ() {
  var n = Object.create(null);
  function e(i, s) {
    var o = i.id,
      a = i.name,
      l = i.dependencies;
    l === void 0 && (l = []);
    var c = i.init;
    c === void 0 && (c = function () {});
    var u = i.getTransferables;
    if ((u === void 0 && (u = null), !n[o]))
      try {
        (l = l.map(function (h) {
          return (
            h &&
              h.isWorkerModule &&
              (e(h, function (m) {
                if (m instanceof Error) throw m;
              }),
              (h = n[h.id].value)),
            h
          );
        })),
          (c = r("<" + a + ">.init", c)),
          u && (u = r("<" + a + ">.getTransferables", u));
        var d = null;
        typeof c == "function"
          ? (d = c.apply(void 0, l))
          : console.error("worker module init function failed to rehydrate"),
          (n[o] = { id: o, value: d, getTransferables: u }),
          s(d);
      } catch (h) {
        (h && h.noLog) || console.error(h), s(h);
      }
  }
  function t(i, s) {
    var o,
      a = i.id,
      l = i.args;
    (!n[a] || typeof n[a].value != "function") &&
      s(
        new Error(
          "Worker module " +
            a +
            ": not found or its 'init' did not return a function"
        )
      );
    try {
      var c = (o = n[a]).value.apply(o, l);
      c && typeof c.then == "function"
        ? c.then(u, function (d) {
            return s(d instanceof Error ? d : new Error("" + d));
          })
        : u(c);
    } catch (d) {
      s(d);
    }
    function u(d) {
      try {
        var h = n[a].getTransferables && n[a].getTransferables(d);
        (!h || !Array.isArray(h) || !h.length) && (h = void 0), s(d, h);
      } catch (m) {
        console.error(m), s(m);
      }
    }
  }
  function r(i, s) {
    var o = void 0;
    self.troikaDefine = function (l) {
      return (o = l);
    };
    var a = URL.createObjectURL(
      new Blob(
        [
          "/** " +
            i.replace(/\*/g, "") +
            ` **/

troikaDefine(
` +
            s +
            `
)`,
        ],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(a);
    } catch (l) {
      console.error(l);
    }
    return URL.revokeObjectURL(a), delete self.troikaDefine, o;
  }
  self.addEventListener("message", function (i) {
    var s = i.data,
      o = s.messageId,
      a = s.action,
      l = s.data;
    try {
      a === "registerModule" &&
        e(l, function (c) {
          c instanceof Error
            ? postMessage({ messageId: o, success: !1, error: c.message })
            : postMessage({
                messageId: o,
                success: !0,
                result: { isCallable: typeof c == "function" },
              });
        }),
        a === "callModule" &&
          t(l, function (c, u) {
            c instanceof Error
              ? postMessage({ messageId: o, success: !1, error: c.message })
              : postMessage(
                  { messageId: o, success: !0, result: c },
                  u || void 0
                );
          });
    } catch (c) {
      postMessage({ messageId: o, success: !1, error: c.stack });
    }
  });
}
function YQ(n) {
  var e = function () {
    for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
    return e._getInitResult().then(function (i) {
      if (typeof i == "function") return i.apply(void 0, t);
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  };
  return (
    (e._getInitResult = function () {
      var t = n.dependencies,
        r = n.init;
      t = Array.isArray(t)
        ? t.map(function (s) {
            return s && s._getInitResult ? s._getInitResult() : s;
          })
        : [];
      var i = Promise.all(t).then(function (s) {
        return r.apply(null, s);
      });
      return (
        (e._getInitResult = function () {
          return i;
        }),
        i
      );
    }),
    e
  );
}
var Oz = function () {
    var n = !1;
    if (typeof window < "u" && typeof window.document < "u")
      try {
        var e = new Worker(
          URL.createObjectURL(
            new Blob([""], { type: "application/javascript" })
          )
        );
        e.terminate(), (n = !0);
      } catch (t) {
        typeof process < "u",
          console.log(
            "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" +
              t.message +
              "]"
          );
      }
    return (
      (Oz = function () {
        return n;
      }),
      n
    );
  },
  qQ = 0,
  KQ = 0,
  Gw = !1,
  Ym = Object.create(null),
  qm = Object.create(null),
  RM = Object.create(null);
function up(n) {
  if ((!n || typeof n.init != "function") && !Gw)
    throw new Error("requires `options.init` function");
  var e = n.dependencies,
    t = n.init,
    r = n.getTransferables,
    i = n.workerId;
  if (!Oz()) return YQ(n);
  i == null && (i = "#default");
  var s = "workerModule" + ++qQ,
    o = n.name || s,
    a = null;
  e =
    e &&
    e.map(function (c) {
      return (
        typeof c == "function" &&
          !c.workerModuleData &&
          ((Gw = !0),
          (c = up({
            workerId: i,
            name: "<" + o + "> function dependency: " + c.name,
            init:
              `function(){return (
` +
              bx(c) +
              `
)}`,
          })),
          (Gw = !1)),
        c && c.workerModuleData && (c = c.workerModuleData),
        c
      );
    });
  function l() {
    for (var c = [], u = arguments.length; u--; ) c[u] = arguments[u];
    if (!a) {
      a = bL(i, "registerModule", l.workerModuleData);
      var d = function () {
        (a = null), qm[i].delete(d);
      };
      (qm[i] || (qm[i] = new Set())).add(d);
    }
    return a.then(function (h) {
      var m = h.isCallable;
      if (m) return bL(i, "callModule", { id: s, args: c });
      throw new Error(
        "Worker module function was called but `init` did not return a callable function"
      );
    });
  }
  return (
    (l.workerModuleData = {
      isWorkerModule: !0,
      id: s,
      name: o,
      dependencies: e,
      init: bx(t),
      getTransferables: r && bx(r),
    }),
    l
  );
}
function ZQ(n) {
  qm[n] &&
    qm[n].forEach(function (e) {
      e();
    }),
    Ym[n] && (Ym[n].terminate(), delete Ym[n]);
}
function bx(n) {
  var e = n.toString();
  return (
    !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
  );
}
function QQ(n) {
  var e = Ym[n];
  if (!e) {
    var t = bx(XQ);
    (e = Ym[n] =
      new Worker(
        URL.createObjectURL(
          new Blob(
            [
              "/** Worker Module Bootstrap: " +
                n.replace(/\*/g, "") +
                ` **/

;(` +
                t +
                ")()",
            ],
            { type: "application/javascript" }
          )
        )
      )),
      (e.onmessage = function (r) {
        var i = r.data,
          s = i.messageId,
          o = RM[s];
        if (!o)
          throw new Error(
            "WorkerModule response with empty or unknown messageId"
          );
        delete RM[s], o(i);
      });
  }
  return e;
}
function bL(n, e, t) {
  return new Promise(function (r, i) {
    var s = ++KQ;
    (RM[s] = function (o) {
      o.success
        ? r(o.result)
        : i(new Error("Error in worker " + e + " call: " + o.error));
    }),
      QQ(n).postMessage({ messageId: s, action: e, data: t });
  });
}
function Dz() {
  var n = (function (e) {
    function t(H, V, k, W, ee, Y, K, ae) {
      var se = 1 - K;
      (ae.x = se * se * H + 2 * se * K * k + K * K * ee),
        (ae.y = se * se * V + 2 * se * K * W + K * K * Y);
    }
    function r(H, V, k, W, ee, Y, K, ae, se, we) {
      var Be = 1 - se;
      (we.x =
        Be * Be * Be * H +
        3 * Be * Be * se * k +
        3 * Be * se * se * ee +
        se * se * se * K),
        (we.y =
          Be * Be * Be * V +
          3 * Be * Be * se * W +
          3 * Be * se * se * Y +
          se * se * se * ae);
    }
    function i(H, V) {
      for (
        var k = /([MLQCZ])([^MLQCZ]*)/g, W, ee, Y, K, ae;
        (W = k.exec(H));

      ) {
        var se = W[2]
          .replace(/^\s*|\s*$/g, "")
          .split(/[,\s]+/)
          .map(function (we) {
            return parseFloat(we);
          });
        switch (W[1]) {
          case "M":
            (K = ee = se[0]), (ae = Y = se[1]);
            break;
          case "L":
            (se[0] !== K || se[1] !== ae) &&
              V("L", K, ae, (K = se[0]), (ae = se[1]));
            break;
          case "Q": {
            V("Q", K, ae, (K = se[2]), (ae = se[3]), se[0], se[1]);
            break;
          }
          case "C": {
            V(
              "C",
              K,
              ae,
              (K = se[4]),
              (ae = se[5]),
              se[0],
              se[1],
              se[2],
              se[3]
            );
            break;
          }
          case "Z":
            (K !== ee || ae !== Y) && V("L", K, ae, ee, Y);
            break;
        }
      }
    }
    function s(H, V, k) {
      k === void 0 && (k = 16);
      var W = { x: 0, y: 0 };
      i(H, function (ee, Y, K, ae, se, we, Be, te, ge) {
        switch (ee) {
          case "L":
            V(Y, K, ae, se);
            break;
          case "Q": {
            for (var ie = Y, me = K, fe = 1; fe < k; fe++)
              t(Y, K, we, Be, ae, se, fe / (k - 1), W),
                V(ie, me, W.x, W.y),
                (ie = W.x),
                (me = W.y);
            break;
          }
          case "C": {
            for (var Ee = Y, Se = K, Ue = 1; Ue < k; Ue++)
              r(Y, K, we, Be, te, ge, ae, se, Ue / (k - 1), W),
                V(Ee, Se, W.x, W.y),
                (Ee = W.x),
                (Se = W.y);
            break;
          }
        }
      });
    }
    var o =
        "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      a =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
      l = new WeakMap(),
      c = {
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !0,
        antialias: !1,
        depth: !1,
      };
    function u(H, V) {
      var k = H.getContext ? H.getContext("webgl", c) : H,
        W = l.get(k);
      if (!W) {
        let Ee = function (q) {
            var ue = Y[q];
            if (!ue && ((ue = Y[q] = k.getExtension(q)), !ue))
              throw new Error(q + " not supported");
            return ue;
          },
          Se = function (q, ue) {
            var de = k.createShader(ue);
            return k.shaderSource(de, q), k.compileShader(de), de;
          },
          Ue = function (q, ue, de, he) {
            if (!K[q]) {
              var Ie = {},
                ke = {},
                Me = k.createProgram();
              k.attachShader(Me, Se(ue, k.VERTEX_SHADER)),
                k.attachShader(Me, Se(de, k.FRAGMENT_SHADER)),
                k.linkProgram(Me),
                (K[q] = {
                  program: Me,
                  transaction: function (Ne) {
                    k.useProgram(Me),
                      Ne({
                        setUniform: function (ot, nt) {
                          for (
                            var Ke = [], it = arguments.length - 2;
                            it-- > 0;

                          )
                            Ke[it] = arguments[it + 2];
                          var re =
                            ke[nt] || (ke[nt] = k.getUniformLocation(Me, nt));
                          k["uniform" + ot].apply(k, [re].concat(Ke));
                        },
                        setAttribute: function (ot, nt, Ke, it, re) {
                          var ze = Ie[ot];
                          ze ||
                            (ze = Ie[ot] =
                              {
                                buf: k.createBuffer(),
                                loc: k.getAttribLocation(Me, ot),
                                data: null,
                              }),
                            k.bindBuffer(k.ARRAY_BUFFER, ze.buf),
                            k.vertexAttribPointer(
                              ze.loc,
                              nt,
                              k.FLOAT,
                              !1,
                              0,
                              0
                            ),
                            k.enableVertexAttribArray(ze.loc),
                            ee
                              ? k.vertexAttribDivisor(ze.loc, it)
                              : Ee(
                                  "ANGLE_instanced_arrays"
                                ).vertexAttribDivisorANGLE(ze.loc, it),
                            re !== ze.data &&
                              (k.bufferData(k.ARRAY_BUFFER, re, Ke),
                              (ze.data = re));
                        },
                      });
                  },
                });
            }
            K[q].transaction(he);
          },
          Ce = function (q, ue) {
            se++;
            try {
              k.activeTexture(k.TEXTURE0 + se);
              var de = ae[q];
              de ||
                ((de = ae[q] = k.createTexture()),
                k.bindTexture(k.TEXTURE_2D, de),
                k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MIN_FILTER, k.NEAREST),
                k.texParameteri(k.TEXTURE_2D, k.TEXTURE_MAG_FILTER, k.NEAREST)),
                k.bindTexture(k.TEXTURE_2D, de),
                ue(de, se);
            } finally {
              se--;
            }
          },
          X = function (q, ue, de) {
            var he = k.createFramebuffer();
            we.push(he),
              k.bindFramebuffer(k.FRAMEBUFFER, he),
              k.activeTexture(k.TEXTURE0 + ue),
              k.bindTexture(k.TEXTURE_2D, q),
              k.framebufferTexture2D(
                k.FRAMEBUFFER,
                k.COLOR_ATTACHMENT0,
                k.TEXTURE_2D,
                q,
                0
              );
            try {
              de(he);
            } finally {
              k.deleteFramebuffer(he),
                k.bindFramebuffer(k.FRAMEBUFFER, we[--we.length - 1] || null);
            }
          },
          z = function () {
            (Y = {}), (K = {}), (ae = {}), (se = -1), (we.length = 0);
          };
        var Be = Ee,
          te = Se,
          ge = Ue,
          ie = Ce,
          me = X,
          fe = z,
          ee =
            typeof WebGL2RenderingContext < "u" &&
            k instanceof WebGL2RenderingContext,
          Y = {},
          K = {},
          ae = {},
          se = -1,
          we = [];
        k.canvas.addEventListener(
          "webglcontextlost",
          function (q) {
            z(), q.preventDefault();
          },
          !1
        ),
          l.set(
            k,
            (W = {
              gl: k,
              isWebGL2: ee,
              getExtension: Ee,
              withProgram: Ue,
              withTexture: Ce,
              withTextureFramebuffer: X,
              handleContextLoss: z,
            })
          );
      }
      V(W);
    }
    function d(H, V, k, W, ee, Y, K, ae) {
      K === void 0 && (K = 15),
        ae === void 0 && (ae = null),
        u(H, function (se) {
          var we = se.gl,
            Be = se.withProgram,
            te = se.withTexture;
          te("copy", function (ge, ie) {
            we.texImage2D(
              we.TEXTURE_2D,
              0,
              we.RGBA,
              ee,
              Y,
              0,
              we.RGBA,
              we.UNSIGNED_BYTE,
              V
            ),
              Be("copy", o, a, function (me) {
                var fe = me.setUniform,
                  Ee = me.setAttribute;
                Ee(
                  "aUV",
                  2,
                  we.STATIC_DRAW,
                  0,
                  new Float32Array([0, 0, 2, 0, 0, 2])
                ),
                  fe("1i", "image", ie),
                  we.bindFramebuffer(we.FRAMEBUFFER, ae || null),
                  we.disable(we.BLEND),
                  we.colorMask(K & 8, K & 4, K & 2, K & 1),
                  we.viewport(k, W, ee, Y),
                  we.scissor(k, W, ee, Y),
                  we.drawArrays(we.TRIANGLES, 0, 3);
              });
          });
        });
    }
    function h(H, V, k) {
      var W = H.width,
        ee = H.height;
      u(H, function (Y) {
        var K = Y.gl,
          ae = new Uint8Array(W * ee * 4);
        K.readPixels(0, 0, W, ee, K.RGBA, K.UNSIGNED_BYTE, ae),
          (H.width = V),
          (H.height = k),
          d(K, ae, 0, 0, W, ee);
      });
    }
    var m = Object.freeze({
      __proto__: null,
      withWebGLContext: u,
      renderImageData: d,
      resizeWebGLCanvasWithoutClearing: h,
    });
    function g(H, V, k, W, ee, Y) {
      Y === void 0 && (Y = 1);
      var K = new Uint8Array(H * V),
        ae = W[2] - W[0],
        se = W[3] - W[1],
        we = [];
      s(k, function (Ee, Se, Ue, Ce) {
        we.push({
          x1: Ee,
          y1: Se,
          x2: Ue,
          y2: Ce,
          minX: Math.min(Ee, Ue),
          minY: Math.min(Se, Ce),
          maxX: Math.max(Ee, Ue),
          maxY: Math.max(Se, Ce),
        });
      }),
        we.sort(function (Ee, Se) {
          return Ee.maxX - Se.maxX;
        });
      for (var Be = 0; Be < H; Be++)
        for (var te = 0; te < V; te++) {
          var ge = me(
              W[0] + (ae * (Be + 0.5)) / H,
              W[1] + (se * (te + 0.5)) / V
            ),
            ie = Math.pow(1 - Math.abs(ge) / ee, Y) / 2;
          ge < 0 && (ie = 1 - ie),
            (ie = Math.max(0, Math.min(255, Math.round(ie * 255)))),
            (K[te * H + Be] = ie);
        }
      return K;
      function me(Ee, Se) {
        for (var Ue = 1 / 0, Ce = 1 / 0, X = we.length; X--; ) {
          var z = we[X];
          if (z.maxX + Ce <= Ee) break;
          if (Ee + Ce > z.minX && Se - Ce < z.maxY && Se + Ce > z.minY) {
            var q = v(Ee, Se, z.x1, z.y1, z.x2, z.y2);
            q < Ue && ((Ue = q), (Ce = Math.sqrt(Ue)));
          }
        }
        return fe(Ee, Se) && (Ce = -Ce), Ce;
      }
      function fe(Ee, Se) {
        for (var Ue = 0, Ce = we.length; Ce--; ) {
          var X = we[Ce];
          if (X.maxX <= Ee) break;
          var z =
            X.y1 > Se != X.y2 > Se &&
            Ee < ((X.x2 - X.x1) * (Se - X.y1)) / (X.y2 - X.y1) + X.x1;
          z && (Ue += X.y1 < X.y2 ? 1 : -1);
        }
        return Ue !== 0;
      }
    }
    function x(H, V, k, W, ee, Y, K, ae, se, we) {
      Y === void 0 && (Y = 1),
        ae === void 0 && (ae = 0),
        se === void 0 && (se = 0),
        we === void 0 && (we = 0),
        y(H, V, k, W, ee, Y, K, null, ae, se, we);
    }
    function y(H, V, k, W, ee, Y, K, ae, se, we, Be) {
      Y === void 0 && (Y = 1),
        se === void 0 && (se = 0),
        we === void 0 && (we = 0),
        Be === void 0 && (Be = 0);
      for (
        var te = g(H, V, k, W, ee, Y),
          ge = new Uint8Array(te.length * 4),
          ie = 0;
        ie < te.length;
        ie++
      )
        ge[ie * 4 + Be] = te[ie];
      d(K, ge, se, we, H, V, 1 << (3 - Be), ae);
    }
    function v(H, V, k, W, ee, Y) {
      var K = ee - k,
        ae = Y - W,
        se = K * K + ae * ae,
        we = se
          ? Math.max(0, Math.min(1, ((H - k) * K + (V - W) * ae) / se))
          : 0,
        Be = H - (k + we * K),
        te = V - (W + we * ae);
      return Be * Be + te * te;
    }
    var _ = Object.freeze({
        __proto__: null,
        generate: g,
        generateIntoCanvas: x,
        generateIntoFramebuffer: y,
      }),
      S =
        "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
      w =
        "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
      T =
        "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
      E = new Float32Array([0, 0, 2, 0, 0, 2]),
      M = null,
      N = !1,
      R = {},
      C = new WeakMap();
    function L(H) {
      if (!N && !$(H)) throw new Error("WebGL generation not supported");
    }
    function O(H, V, k, W, ee, Y, K) {
      if (
        (Y === void 0 && (Y = 1),
        K === void 0 && (K = null),
        !K && ((K = M), !K))
      ) {
        var ae =
          typeof OffscreenCanvas == "function"
            ? new OffscreenCanvas(1, 1)
            : typeof document < "u"
            ? document.createElement("canvas")
            : null;
        if (!ae) throw new Error("OffscreenCanvas or DOM canvas not supported");
        K = M = ae.getContext("webgl", { depth: !1 });
      }
      L(K);
      var se = new Uint8Array(H * V * 4);
      u(K, function (ge) {
        var ie = ge.gl,
          me = ge.withTexture,
          fe = ge.withTextureFramebuffer;
        me("readable", function (Ee, Se) {
          ie.texImage2D(
            ie.TEXTURE_2D,
            0,
            ie.RGBA,
            H,
            V,
            0,
            ie.RGBA,
            ie.UNSIGNED_BYTE,
            null
          ),
            fe(Ee, Se, function (Ue) {
              B(H, V, k, W, ee, Y, ie, Ue, 0, 0, 0),
                ie.readPixels(0, 0, H, V, ie.RGBA, ie.UNSIGNED_BYTE, se);
            });
        });
      });
      for (
        var we = new Uint8Array(H * V), Be = 0, te = 0;
        Be < se.length;
        Be += 4
      )
        we[te++] = se[Be];
      return we;
    }
    function D(H, V, k, W, ee, Y, K, ae, se, we) {
      Y === void 0 && (Y = 1),
        ae === void 0 && (ae = 0),
        se === void 0 && (se = 0),
        we === void 0 && (we = 0),
        B(H, V, k, W, ee, Y, K, null, ae, se, we);
    }
    function B(H, V, k, W, ee, Y, K, ae, se, we, Be) {
      Y === void 0 && (Y = 1),
        se === void 0 && (se = 0),
        we === void 0 && (we = 0),
        Be === void 0 && (Be = 0),
        L(K);
      var te = [];
      s(k, function (ge, ie, me, fe) {
        te.push(ge, ie, me, fe);
      }),
        (te = new Float32Array(te)),
        u(K, function (ge) {
          var ie = ge.gl,
            me = ge.isWebGL2,
            fe = ge.getExtension,
            Ee = ge.withProgram,
            Se = ge.withTexture,
            Ue = ge.withTextureFramebuffer,
            Ce = ge.handleContextLoss;
          if (
            (Se("rawDistances", function (X, z) {
              (H !== X._lastWidth || V !== X._lastHeight) &&
                ie.texImage2D(
                  ie.TEXTURE_2D,
                  0,
                  ie.RGBA,
                  (X._lastWidth = H),
                  (X._lastHeight = V),
                  0,
                  ie.RGBA,
                  ie.UNSIGNED_BYTE,
                  null
                ),
                Ee("main", S, w, function (q) {
                  var ue = q.setAttribute,
                    de = q.setUniform,
                    he = !me && fe("ANGLE_instanced_arrays"),
                    Ie = !me && fe("EXT_blend_minmax");
                  ue("aUV", 2, ie.STATIC_DRAW, 0, E),
                    ue("aLineSegment", 4, ie.DYNAMIC_DRAW, 1, te),
                    de.apply(void 0, ["4f", "uGlyphBounds"].concat(W)),
                    de("1f", "uMaxDistance", ee),
                    de("1f", "uExponent", Y),
                    Ue(X, z, function (ke) {
                      ie.enable(ie.BLEND),
                        ie.colorMask(!0, !0, !0, !0),
                        ie.viewport(0, 0, H, V),
                        ie.scissor(0, 0, H, V),
                        ie.blendFunc(ie.ONE, ie.ONE),
                        ie.blendEquationSeparate(
                          ie.FUNC_ADD,
                          me ? ie.MAX : Ie.MAX_EXT
                        ),
                        ie.clear(ie.COLOR_BUFFER_BIT),
                        me
                          ? ie.drawArraysInstanced(
                              ie.TRIANGLES,
                              0,
                              3,
                              te.length / 4
                            )
                          : he.drawArraysInstancedANGLE(
                              ie.TRIANGLES,
                              0,
                              3,
                              te.length / 4
                            );
                    });
                }),
                Ee("post", o, T, function (q) {
                  q.setAttribute("aUV", 2, ie.STATIC_DRAW, 0, E),
                    q.setUniform("1i", "tex", z),
                    ie.bindFramebuffer(ie.FRAMEBUFFER, ae),
                    ie.disable(ie.BLEND),
                    ie.colorMask(Be === 0, Be === 1, Be === 2, Be === 3),
                    ie.viewport(se, we, H, V),
                    ie.scissor(se, we, H, V),
                    ie.drawArrays(ie.TRIANGLES, 0, 3);
                });
            }),
            ie.isContextLost())
          )
            throw (Ce(), new Error("webgl context lost"));
        });
    }
    function $(H) {
      var V = !H || H === M ? R : H.canvas || H,
        k = C.get(V);
      if (k === void 0) {
        N = !0;
        var W = null;
        try {
          var ee = [
              97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106,
              97,
            ],
            Y = O(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, H);
          (k =
            Y &&
            ee.length === Y.length &&
            Y.every(function (K, ae) {
              return K === ee[ae];
            })),
            k || ((W = "bad trial run results"), console.info(ee, Y));
        } catch (K) {
          (k = !1), (W = K.message);
        }
        W && console.warn("WebGL SDF generation not supported:", W),
          (N = !1),
          C.set(V, k);
      }
      return k;
    }
    var G = Object.freeze({
      __proto__: null,
      generate: O,
      generateIntoCanvas: D,
      generateIntoFramebuffer: B,
      isSupported: $,
    });
    function j(H, V, k, W, ee, Y) {
      ee === void 0 && (ee = Math.max(W[2] - W[0], W[3] - W[1]) / 2),
        Y === void 0 && (Y = 1);
      try {
        return O.apply(G, arguments);
      } catch (K) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", K),
          g.apply(_, arguments)
        );
      }
    }
    function U(H, V, k, W, ee, Y, K, ae, se, we) {
      ee === void 0 && (ee = Math.max(W[2] - W[0], W[3] - W[1]) / 2),
        Y === void 0 && (Y = 1),
        ae === void 0 && (ae = 0),
        se === void 0 && (se = 0),
        we === void 0 && (we = 0);
      try {
        return D.apply(G, arguments);
      } catch (Be) {
        return (
          console.info("WebGL SDF generation failed, falling back to JS", Be),
          x.apply(_, arguments)
        );
      }
    }
    return (
      (e.forEachPathCommand = i),
      (e.generate = j),
      (e.generateIntoCanvas = U),
      (e.javascript = _),
      (e.pathToLineSegments = s),
      (e.webgl = G),
      (e.webglUtils = m),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
function JQ() {
  var n = (function (e) {
    var t = {
        R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
        EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
        ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
        ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
        AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
        CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
        B: "a,3,f+2,2v,690",
        S: "9,2,k",
        WS: "c,k,4f4,1vk+a,u,1j,335",
        ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
        BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
        NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
        AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
        LRO: "6ct",
        RLO: "6cu",
        LRE: "6cq",
        RLE: "6cr",
        PDF: "6cs",
        LRI: "6ee",
        RLI: "6ef",
        FSI: "6eg",
        PDI: "6eh",
      },
      r = {},
      i = {};
    (r.L = 1),
      (i[1] = "L"),
      Object.keys(t).forEach(function (Ce, X) {
        (r[Ce] = 1 << (X + 1)), (i[r[Ce]] = Ce);
      }),
      Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI,
      o = r.L | r.R | r.AL,
      a = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI,
      l = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF,
      c = r.S | r.WS | r.B | s | r.PDI | l,
      u = null;
    function d() {
      if (!u) {
        u = new Map();
        var Ce = function (z) {
          if (t.hasOwnProperty(z)) {
            var q = 0;
            t[z].split(",").forEach(function (ue) {
              var de = ue.split("+"),
                he = de[0],
                Ie = de[1];
              (he = parseInt(he, 36)),
                (Ie = Ie ? parseInt(Ie, 36) : 0),
                u.set((q += he), r[z]);
              for (var ke = 0; ke < Ie; ke++) u.set(++q, r[z]);
            });
          }
        };
        for (var X in t) Ce(X);
      }
    }
    function h(Ce) {
      return d(), u.get(Ce.codePointAt(0)) || r.L;
    }
    function m(Ce) {
      return i[h(Ce)];
    }
    var g = {
      pairs:
        "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical:
        "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye",
    };
    function x(Ce, X) {
      var z = 36,
        q = 0,
        ue = new Map(),
        de = X && new Map(),
        he;
      return (
        Ce.split(",").forEach(function Ie(ke) {
          if (ke.indexOf("+") !== -1) for (var Me = +ke; Me--; ) Ie(he);
          else {
            he = ke;
            var et = ke.split(">"),
              Ne = et[0],
              We = et[1];
            (Ne = String.fromCodePoint((q += parseInt(Ne, z)))),
              (We = String.fromCodePoint((q += parseInt(We, z)))),
              ue.set(Ne, We),
              X && de.set(We, Ne);
          }
        }),
        { map: ue, reverseMap: de }
      );
    }
    var y, v, _;
    function S() {
      if (!y) {
        var Ce = x(g.pairs, !0),
          X = Ce.map,
          z = Ce.reverseMap;
        (y = X), (v = z), (_ = x(g.canonical, !1).map);
      }
    }
    function w(Ce) {
      return S(), y.get(Ce) || null;
    }
    function T(Ce) {
      return S(), v.get(Ce) || null;
    }
    function E(Ce) {
      return S(), _.get(Ce) || null;
    }
    var M = r.L,
      N = r.R,
      R = r.EN,
      C = r.ES,
      L = r.ET,
      O = r.AN,
      D = r.CS,
      B = r.B,
      $ = r.S,
      G = r.ON,
      j = r.BN,
      U = r.NSM,
      H = r.AL,
      V = r.LRO,
      k = r.RLO,
      W = r.LRE,
      ee = r.RLE,
      Y = r.PDF,
      K = r.LRI,
      ae = r.RLI,
      se = r.FSI,
      we = r.PDI;
    function Be(Ce, X) {
      for (
        var z = 125, q = new Uint32Array(Ce.length), ue = 0;
        ue < Ce.length;
        ue++
      )
        q[ue] = h(Ce[ue]);
      var de = new Map();
      function he(Qr, Xi) {
        var xr = q[Qr];
        (q[Qr] = Xi),
          de.set(xr, de.get(xr) - 1),
          xr & a && de.set(a, de.get(a) - 1),
          de.set(Xi, (de.get(Xi) || 0) + 1),
          Xi & a && de.set(a, (de.get(a) || 0) + 1);
      }
      for (
        var Ie = new Uint8Array(Ce.length),
          ke = new Map(),
          Me = [],
          et = null,
          Ne = 0;
        Ne < Ce.length;
        Ne++
      )
        et ||
          Me.push(
            (et = {
              start: Ne,
              end: Ce.length - 1,
              level: X === "rtl" ? 1 : X === "ltr" ? 0 : Yd(Ne, !1),
            })
          ),
          q[Ne] & B && ((et.end = Ne), (et = null));
      for (
        var We = ee | W | k | V | s | we | Y | B,
          ot = function (Qr) {
            return Qr + (Qr & 1 ? 1 : 2);
          },
          nt = function (Qr) {
            return Qr + (Qr & 1 ? 2 : 1);
          },
          Ke = 0;
        Ke < Me.length;
        Ke++
      ) {
        et = Me[Ke];
        var it = [{ _level: et.level, _override: 0, _isolate: 0 }],
          re = void 0,
          ze = 0,
          Xe = 0,
          le = 0;
        de.clear();
        for (var Re = et.start; Re <= et.end; Re++) {
          var xe = q[Re];
          if (
            ((re = it[it.length - 1]),
            de.set(xe, (de.get(xe) || 0) + 1),
            xe & a && de.set(a, (de.get(a) || 0) + 1),
            xe & We)
          )
            if (xe & (ee | W)) {
              Ie[Re] = re._level;
              var Ye = (xe === ee ? nt : ot)(re._level);
              Ye <= z && !ze && !Xe
                ? it.push({ _level: Ye, _override: 0, _isolate: 0 })
                : ze || Xe++;
            } else if (xe & (k | V)) {
              Ie[Re] = re._level;
              var at = (xe === k ? nt : ot)(re._level);
              at <= z && !ze && !Xe
                ? it.push({
                    _level: at,
                    _override: xe & k ? N : M,
                    _isolate: 0,
                  })
                : ze || Xe++;
            } else if (xe & s) {
              xe & se && (xe = Yd(Re + 1, !0) === 1 ? ae : K),
                (Ie[Re] = re._level),
                re._override && he(Re, re._override);
              var vt = (xe === ae ? nt : ot)(re._level);
              vt <= z && ze === 0 && Xe === 0
                ? (le++,
                  it.push({
                    _level: vt,
                    _override: 0,
                    _isolate: 1,
                    _isolInitIndex: Re,
                  }))
                : ze++;
            } else if (xe & we) {
              if (ze > 0) ze--;
              else if (le > 0) {
                for (Xe = 0; !it[it.length - 1]._isolate; ) it.pop();
                var dt = it[it.length - 1]._isolInitIndex;
                dt != null && (ke.set(dt, Re), ke.set(Re, dt)), it.pop(), le--;
              }
              (re = it[it.length - 1]),
                (Ie[Re] = re._level),
                re._override && he(Re, re._override);
            } else
              xe & Y
                ? (ze === 0 &&
                    (Xe > 0
                      ? Xe--
                      : !re._isolate &&
                        it.length > 1 &&
                        (it.pop(), (re = it[it.length - 1]))),
                  (Ie[Re] = re._level))
                : xe & B && (Ie[Re] = et.level);
          else
            (Ie[Re] = re._level),
              re._override && xe !== j && he(Re, re._override);
        }
        for (var mt = [], kt = null, lt = et.start; lt <= et.end; lt++) {
          var St = q[lt];
          if (!(St & l)) {
            var Nt = Ie[lt],
              gn = St & s,
              dn = St === we;
            kt && Nt === kt._level
              ? ((kt._end = lt), (kt._endsWithIsolInit = gn))
              : mt.push(
                  (kt = {
                    _start: lt,
                    _end: lt,
                    _level: Nt,
                    _startsWithPDI: dn,
                    _endsWithIsolInit: gn,
                  })
                );
          }
        }
        for (var gr = [], Kr = 0; Kr < mt.length; Kr++) {
          var Ur = mt[Kr];
          if (!Ur._startsWithPDI || (Ur._startsWithPDI && !ke.has(Ur._start))) {
            for (
              var kr = [(kt = Ur)], zr = void 0;
              kt && kt._endsWithIsolInit && (zr = ke.get(kt._end)) != null;

            )
              for (var Ai = Kr + 1; Ai < mt.length; Ai++)
                if (mt[Ai]._start === zr) {
                  kr.push((kt = mt[Ai]));
                  break;
                }
            for (var vr = [], Ps = 0; Ps < kr.length; Ps++)
              for (var wi = kr[Ps], Z = wi._start; Z <= wi._end; Z++)
                vr.push(Z);
            for (
              var be = Ie[vr[0]], Fe = et.level, Pe = vr[0] - 1;
              Pe >= 0;
              Pe--
            )
              if (!(q[Pe] & l)) {
                Fe = Ie[Pe];
                break;
              }
            var Le = vr[vr.length - 1],
              ft = Ie[Le],
              wt = et.level;
            if (!(q[Le] & s)) {
              for (var bt = Le + 1; bt <= et.end; bt++)
                if (!(q[bt] & l)) {
                  wt = Ie[bt];
                  break;
                }
            }
            gr.push({
              _seqIndices: vr,
              _sosType: Math.max(Fe, be) % 2 ? N : M,
              _eosType: Math.max(wt, ft) % 2 ? N : M,
            });
          }
        }
        for (var Dt = 0; Dt < gr.length; Dt++) {
          var Ht = gr[Dt],
            tt = Ht._seqIndices,
            Vt = Ht._sosType,
            Un = Ht._eosType,
            Nn = Ie[tt[0]] & 1 ? N : M;
          if (de.get(U))
            for (var Tr = 0; Tr < tt.length; Tr++) {
              var bi = tt[Tr];
              if (q[bi] & U) {
                for (var en = Vt, It = Tr - 1; It >= 0; It--)
                  if (!(q[tt[It]] & l)) {
                    en = q[tt[It]];
                    break;
                  }
                he(bi, en & (s | we) ? G : en);
              }
            }
          if (de.get(R))
            for (var cn = 0; cn < tt.length; cn++) {
              var Ft = tt[cn];
              if (q[Ft] & R)
                for (var yr = cn - 1; yr >= -1; yr--) {
                  var sr = yr === -1 ? Vt : q[tt[yr]];
                  if (sr & o) {
                    sr === H && he(Ft, O);
                    break;
                  }
                }
            }
          if (de.get(H))
            for (var jn = 0; jn < tt.length; jn++) {
              var ls = tt[jn];
              q[ls] & H && he(ls, N);
            }
          if (de.get(C) || de.get(D))
            for (var wn = 1; wn < tt.length - 1; wn++) {
              var Pn = tt[wn];
              if (q[Pn] & (C | D)) {
                for (
                  var Gi = 0, Br = 0, ba = wn - 1;
                  ba >= 0 && ((Gi = q[tt[ba]]), !!(Gi & l));
                  ba--
                );
                for (
                  var Ea = wn + 1;
                  Ea < tt.length && ((Br = q[tt[Ea]]), !!(Br & l));
                  Ea++
                );
                Gi === Br &&
                  (q[Pn] === C ? Gi === R : Gi & (R | O)) &&
                  he(Pn, Gi);
              }
            }
          if (de.get(R))
            for (var Ei = 0; Ei < tt.length; Ei++) {
              var Is = tt[Ei];
              if (q[Is] & R) {
                for (var Wd = Ei - 1; Wd >= 0 && q[tt[Wd]] & (L | l); Wd--)
                  he(tt[Wd], R);
                for (Ei++; Ei < tt.length && q[tt[Ei]] & (L | l | R); Ei++)
                  q[tt[Ei]] !== R && he(tt[Ei], R);
              }
            }
          if (de.get(L) || de.get(C) || de.get(D))
            for (var tu = 0; tu < tt.length; tu++) {
              var L0 = tt[tu];
              if (q[L0] & (L | C | D)) {
                he(L0, G);
                for (var el = tu - 1; el >= 0 && q[tt[el]] & l; el--)
                  he(tt[el], G);
                for (var tl = tu + 1; tl < tt.length && q[tt[tl]] & l; tl++)
                  he(tt[tl], G);
              }
            }
          if (de.get(R))
            for (var nl = 0, nu = Vt; nl < tt.length; nl++) {
              var O0 = tt[nl],
                Ep = q[O0];
              Ep & R ? nu === M && he(O0, M) : Ep & o && (nu = Ep);
            }
          if (de.get(a)) {
            var rl = N | R | O,
              jd = rl | M,
              Ma = [];
            {
              for (var Xl = [], Ta = 0; Ta < tt.length; Ta++)
                if (q[tt[Ta]] & a) {
                  var sn = Ce[tt[Ta]],
                    Mp = void 0;
                  if (w(sn) !== null)
                    if (Xl.length < 63) Xl.push({ char: sn, seqIndex: Ta });
                    else break;
                  else if ((Mp = T(sn)) !== null)
                    for (var il = Xl.length - 1; il >= 0; il--) {
                      var $d = Xl[il].char;
                      if ($d === Mp || $d === T(E(sn)) || w(E($d)) === sn) {
                        Ma.push([Xl[il].seqIndex, Ta]), (Xl.length = il);
                        break;
                      }
                    }
                }
              Ma.sort(function (Qr, Xi) {
                return Qr[0] - Xi[0];
              });
            }
            for (var Tp = 0; Tp < Ma.length; Tp++) {
              for (
                var D0 = Ma[Tp],
                  Zn = D0[0],
                  ru = D0[1],
                  F0 = !1,
                  Wi = 0,
                  Cp = Zn + 1;
                Cp < ru;
                Cp++
              ) {
                var iu = tt[Cp];
                if (q[iu] & jd) {
                  F0 = !0;
                  var Ls = q[iu] & rl ? N : M;
                  if (Ls === Nn) {
                    Wi = Ls;
                    break;
                  }
                }
              }
              if (F0 && !Wi) {
                Wi = Vt;
                for (var Rp = Zn - 1; Rp >= 0; Rp--) {
                  var U0 = tt[Rp];
                  if (q[U0] & jd) {
                    var Os = q[U0] & rl ? N : M;
                    Os !== Nn ? (Wi = Os) : (Wi = Nn);
                    break;
                  }
                }
              }
              if (Wi) {
                if (((q[tt[Zn]] = q[tt[ru]] = Wi), Wi !== Nn)) {
                  for (var ji = Zn + 1; ji < tt.length; ji++)
                    if (!(q[tt[ji]] & l)) {
                      h(Ce[tt[ji]]) & U && (q[tt[ji]] = Wi);
                      break;
                    }
                }
                if (Wi !== Nn) {
                  for (var Ca = ru + 1; Ca < tt.length; Ca++)
                    if (!(q[tt[Ca]] & l)) {
                      h(Ce[tt[Ca]]) & U && (q[tt[Ca]] = Wi);
                      break;
                    }
                }
              }
            }
            for (var vo = 0; vo < tt.length; vo++)
              if (q[tt[vo]] & a) {
                for (var Np = vo, Pp = vo, cs = Vt, su = vo - 1; su >= 0; su--)
                  if (q[tt[su]] & l) Np = su;
                  else {
                    cs = q[tt[su]] & rl ? N : M;
                    break;
                  }
                for (var ou = Un, au = vo + 1; au < tt.length; au++)
                  if (q[tt[au]] & (a | l)) Pp = au;
                  else {
                    ou = q[tt[au]] & rl ? N : M;
                    break;
                  }
                for (var $i = Np; $i <= Pp; $i++)
                  q[tt[$i]] = cs === ou ? cs : Nn;
                vo = Pp;
              }
          }
        }
        for (var Zr = et.start; Zr <= et.end; Zr++) {
          var Xd = Ie[Zr],
            Xo = q[Zr];
          if (
            (Xd & 1
              ? Xo & (M | R | O) && Ie[Zr]++
              : Xo & N
              ? Ie[Zr]++
              : Xo & (O | R) && (Ie[Zr] += 2),
            Xo & l && (Ie[Zr] = Zr === 0 ? et.level : Ie[Zr - 1]),
            Zr === et.end || h(Ce[Zr]) & ($ | B))
          )
            for (var Yl = Zr; Yl >= 0 && h(Ce[Yl]) & c; Yl--) Ie[Yl] = et.level;
        }
      }
      return { levels: Ie, paragraphs: Me };
      function Yd(Qr, Xi) {
        for (var xr = Qr; xr < Ce.length; xr++) {
          var _r = q[xr];
          if (_r & (N | H)) return 1;
          if (_r & (B | M) || (Xi && _r === we)) return 0;
          if (_r & s) {
            var Ds = k0(xr);
            xr = Ds === -1 ? Ce.length : Ds;
          }
        }
        return 0;
      }
      function k0(Qr) {
        for (var Xi = 1, xr = Qr + 1; xr < Ce.length; xr++) {
          var _r = q[xr];
          if (_r & B) break;
          if (_r & we) {
            if (--Xi === 0) return xr;
          } else _r & s && Xi++;
        }
        return -1;
      }
    }
    var te =
        "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
      ge;
    function ie() {
      if (!ge) {
        var Ce = x(te, !0),
          X = Ce.map,
          z = Ce.reverseMap;
        z.forEach(function (q, ue) {
          X.set(ue, q);
        }),
          (ge = X);
      }
    }
    function me(Ce) {
      return ie(), ge.get(Ce) || null;
    }
    function fe(Ce, X, z, q) {
      var ue = Ce.length;
      (z = Math.max(0, z == null ? 0 : +z)),
        (q = Math.min(ue - 1, q == null ? ue - 1 : +q));
      for (var de = new Map(), he = z; he <= q; he++)
        if (X[he] & 1) {
          var Ie = me(Ce[he]);
          Ie !== null && de.set(he, Ie);
        }
      return de;
    }
    function Ee(Ce, X, z, q) {
      var ue = Ce.length;
      (z = Math.max(0, z == null ? 0 : +z)),
        (q = Math.min(ue - 1, q == null ? ue - 1 : +q));
      var de = [];
      return (
        X.paragraphs.forEach(function (he) {
          var Ie = Math.max(z, he.start),
            ke = Math.min(q, he.end);
          if (Ie < ke) {
            for (
              var Me = X.levels.slice(Ie, ke + 1), et = ke;
              et >= Ie && h(Ce[et]) & c;
              et--
            )
              Me[et] = he.level;
            for (var Ne = he.level, We = 1 / 0, ot = 0; ot < Me.length; ot++) {
              var nt = Me[ot];
              nt > Ne && (Ne = nt), nt < We && (We = nt | 1);
            }
            for (var Ke = Ne; Ke >= We; Ke--)
              for (var it = 0; it < Me.length; it++)
                if (Me[it] >= Ke) {
                  for (var re = it; it + 1 < Me.length && Me[it + 1] >= Ke; )
                    it++;
                  it > re && de.push([re + Ie, it + Ie]);
                }
          }
        }),
        de
      );
    }
    function Se(Ce, X, z, q) {
      var ue = Ue(Ce, X, z, q),
        de = [].concat(Ce);
      return (
        ue.forEach(function (he, Ie) {
          de[Ie] = (X.levels[he] & 1 ? me(Ce[he]) : null) || Ce[he];
        }),
        de.join("")
      );
    }
    function Ue(Ce, X, z, q) {
      for (var ue = Ee(Ce, X, z, q), de = [], he = 0; he < Ce.length; he++)
        de[he] = he;
      return (
        ue.forEach(function (Ie) {
          for (
            var ke = Ie[0],
              Me = Ie[1],
              et = de.slice(ke, Me + 1),
              Ne = et.length;
            Ne--;

          )
            de[Me - Ne] = et[Ne];
        }),
        de
      );
    }
    return (
      (e.closingToOpeningBracket = T),
      (e.getBidiCharType = h),
      (e.getBidiCharTypeName = m),
      (e.getCanonicalBracket = E),
      (e.getEmbeddingLevels = Be),
      (e.getMirroredCharacter = me),
      (e.getMirroredCharactersMap = fe),
      (e.getReorderSegments = Ee),
      (e.getReorderedIndices = Ue),
      (e.getReorderedString = Se),
      (e.openingToClosingBracket = w),
      Object.defineProperty(e, "__esModule", { value: !0 }),
      e
    );
  })({});
  return n;
}
const Fz = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function NM(n) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let s = Kt[i];
    return s ? NM(s) : r;
  }
  return n.replace(e, t);
}
const li = [];
for (let n = 0; n < 256; n++) li[n] = (n < 16 ? "0" : "") + n.toString(16);
function eJ() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    li[n & 255] +
    li[(n >> 8) & 255] +
    li[(n >> 16) & 255] +
    li[(n >> 24) & 255] +
    "-" +
    li[e & 255] +
    li[(e >> 8) & 255] +
    "-" +
    li[((e >> 16) & 15) | 64] +
    li[(e >> 24) & 255] +
    "-" +
    li[(t & 63) | 128] +
    li[(t >> 8) & 255] +
    "-" +
    li[(t >> 16) & 255] +
    li[(t >> 24) & 255] +
    li[r & 255] +
    li[(r >> 8) & 255] +
    li[(r >> 16) & 255] +
    li[(r >> 24) & 255]
  ).toUpperCase();
}
const Ru =
    Object.assign ||
    function () {
      let n = arguments[0];
      for (let e = 1, t = arguments.length; e < t; e++) {
        let r = arguments[e];
        if (r)
          for (let i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i]);
      }
      return n;
    },
  tJ = Date.now(),
  EL = new WeakMap(),
  ML = new Map();
let nJ = 1e10;
function PM(n, e) {
  const t = oJ(e);
  let r = EL.get(n);
  if ((r || EL.set(n, (r = Object.create(null))), r[t])) return new r[t]();
  const i = `_onBeforeCompile${t}`,
    s = function (c, u) {
      n.onBeforeCompile.call(this, c, u);
      const d =
        this.customProgramCacheKey() +
        "|" +
        c.vertexShader +
        "|" +
        c.fragmentShader;
      let h = ML[d];
      if (!h) {
        const m = rJ(this, c, e, t);
        h = ML[d] = m;
      }
      (c.vertexShader = h.vertexShader),
        (c.fragmentShader = h.fragmentShader),
        Ru(c.uniforms, this.uniforms),
        e.timeUniform &&
          (c.uniforms[e.timeUniform] = {
            get value() {
              return Date.now() - tJ;
            },
          }),
        this[i] && this[i](c);
    },
    o = function () {
      return a(e.chained ? n : n.clone());
    },
    a = function (c) {
      const u = Object.create(c, l);
      return (
        Object.defineProperty(u, "baseMaterial", { value: n }),
        Object.defineProperty(u, "id", { value: nJ++ }),
        (u.uuid = eJ()),
        (u.uniforms = Ru({}, c.uniforms, e.uniforms)),
        (u.defines = Ru({}, c.defines, e.defines)),
        (u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = ""),
        (u.extensions = Ru({}, c.extensions, e.extensions)),
        (u._listeners = void 0),
        u
      );
    },
    l = {
      constructor: { value: o },
      isDerivedMaterial: { value: !0 },
      customProgramCacheKey: {
        writable: !0,
        configurable: !0,
        value: function () {
          return n.customProgramCacheKey() + "|" + t;
        },
      },
      onBeforeCompile: {
        get() {
          return s;
        },
        set(c) {
          this[i] = c;
        },
      },
      copy: {
        writable: !0,
        configurable: !0,
        value: function (c) {
          return (
            n.copy.call(this, c),
            !n.isShaderMaterial &&
              !n.isDerivedMaterial &&
              (Ru(this.extensions, c.extensions),
              Ru(this.defines, c.defines),
              Ru(this.uniforms, u2.clone(c.uniforms))),
            this
          );
        },
      },
      clone: {
        writable: !0,
        configurable: !0,
        value: function () {
          const c = new n.constructor();
          return a(c).copy(this);
        },
      },
      getDepthMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._depthMaterial;
          return (
            c ||
              ((c = this._depthMaterial =
                PM(
                  n.isDerivedMaterial
                    ? n.getDepthMaterial()
                    : new v_({ depthPacking: t2 }),
                  e
                )),
              (c.defines.IS_DEPTH_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      getDistanceMaterial: {
        writable: !0,
        configurable: !0,
        value: function () {
          let c = this._distanceMaterial;
          return (
            c ||
              ((c = this._distanceMaterial =
                PM(
                  n.isDerivedMaterial ? n.getDistanceMaterial() : new y_(),
                  e
                )),
              (c.defines.IS_DISTANCE_MATERIAL = ""),
              (c.uniforms = this.uniforms)),
            c
          );
        },
      },
      dispose: {
        writable: !0,
        configurable: !0,
        value() {
          const { _depthMaterial: c, _distanceMaterial: u } = this;
          c && c.dispose(), u && u.dispose(), n.dispose.call(this);
        },
      },
    };
  return (r[t] = o), new o();
}
function rJ(n, { vertexShader: e, fragmentShader: t }, r, i) {
  let {
    vertexDefs: s,
    vertexMainIntro: o,
    vertexMainOutro: a,
    vertexTransform: l,
    fragmentDefs: c,
    fragmentMainIntro: u,
    fragmentMainOutro: d,
    fragmentColorTransform: h,
    customRewriter: m,
    timeUniform: g,
  } = r;
  if (
    ((s = s || ""),
    (o = o || ""),
    (a = a || ""),
    (c = c || ""),
    (u = u || ""),
    (d = d || ""),
    (l || m) && (e = NM(e)),
    (h || m) &&
      ((t = t.replace(
        /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
        `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
      )),
      (t = NM(t))),
    m)
  ) {
    let x = m({ vertexShader: e, fragmentShader: t });
    (e = x.vertexShader), (t = x.fragmentShader);
  }
  if (h) {
    let x = [];
    (t = t.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (y) => (x.push(y), "")
    )),
      (d = `${h}
${x.join(`
`)}
${d}`);
  }
  if (g) {
    const x = `
uniform float ${g};
`;
    (s = x + s), (c = x + c);
  }
  return (
    l &&
      ((e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`),
      (s = `${s}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`),
      (o = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${o}
`),
      (e = e.replace(/\b(position|normal|uv)\b/g, (x, y, v, _) =>
        /\battribute\s+vec[23]\s+$/.test(_.substr(0, v))
          ? y
          : `troika_${y}_${i}`
      )),
      (n.map && n.map.channel > 0) ||
        (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))),
    (e = TL(e, i, s, o, a)),
    (t = TL(t, i, c, u, d)),
    { vertexShader: e, fragmentShader: t }
  );
}
function TL(n, e, t, r, i) {
  return (
    (r || i || t) &&
      ((n = n.replace(
        Fz,
        `
${t}
void troikaOrigMain${e}() {`
      )),
      (n += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`)),
    n
  );
}
function iJ(n, e) {
  return n === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let sJ = 0;
const CL = new Map();
function oJ(n) {
  const e = JSON.stringify(n, iJ);
  let t = CL.get(e);
  return t == null && CL.set(e, (t = ++sJ)), t;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/ function aJ() {
  return (
    typeof window > "u" && (self.window = self),
    (function (n) {
      var e = {
        parse: function (i) {
          var s = e._bin,
            o = new Uint8Array(i);
          if (s.readASCII(o, 0, 4) == "ttcf") {
            var a = 4;
            s.readUshort(o, a), (a += 2), s.readUshort(o, a), (a += 2);
            var l = s.readUint(o, a);
            a += 4;
            for (var c = [], u = 0; u < l; u++) {
              var d = s.readUint(o, a);
              (a += 4), c.push(e._readFont(o, d));
            }
            return c;
          }
          return [e._readFont(o, 0)];
        },
        _readFont: function (i, s) {
          var o = e._bin,
            a = s;
          o.readFixed(i, s), (s += 4);
          var l = o.readUshort(i, s);
          (s += 2),
            o.readUshort(i, s),
            (s += 2),
            o.readUshort(i, s),
            (s += 2),
            o.readUshort(i, s),
            (s += 2);
          for (
            var c = [
                "cmap",
                "head",
                "hhea",
                "maxp",
                "hmtx",
                "name",
                "OS/2",
                "post",
                "loca",
                "glyf",
                "kern",
                "CFF ",
                "GDEF",
                "GPOS",
                "GSUB",
                "SVG ",
              ],
              u = { _data: i, _offset: a },
              d = {},
              h = 0;
            h < l;
            h++
          ) {
            var m = o.readASCII(i, s, 4);
            (s += 4), o.readUint(i, s), (s += 4);
            var g = o.readUint(i, s);
            s += 4;
            var x = o.readUint(i, s);
            (s += 4), (d[m] = { offset: g, length: x });
          }
          for (h = 0; h < c.length; h++) {
            var y = c[h];
            d[y] &&
              (u[y.trim()] = e[y.trim()].parse(i, d[y].offset, d[y].length, u));
          }
          return u;
        },
        _tabOffset: function (i, s, o) {
          for (
            var a = e._bin, l = a.readUshort(i, o + 4), c = o + 12, u = 0;
            u < l;
            u++
          ) {
            var d = a.readASCII(i, c, 4);
            (c += 4), a.readUint(i, c), (c += 4);
            var h = a.readUint(i, c);
            if (((c += 4), a.readUint(i, c), (c += 4), d == s)) return h;
          }
          return 0;
        },
      };
      (e._bin = {
        readFixed: function (i, s) {
          return (
            ((i[s] << 8) | i[s + 1]) + ((i[s + 2] << 8) | i[s + 3]) / 65540
          );
        },
        readF2dot14: function (i, s) {
          return e._bin.readShort(i, s) / 16384;
        },
        readInt: function (i, s) {
          return e._bin._view(i).getInt32(s);
        },
        readInt8: function (i, s) {
          return e._bin._view(i).getInt8(s);
        },
        readShort: function (i, s) {
          return e._bin._view(i).getInt16(s);
        },
        readUshort: function (i, s) {
          return e._bin._view(i).getUint16(s);
        },
        readUshorts: function (i, s, o) {
          for (var a = [], l = 0; l < o; l++)
            a.push(e._bin.readUshort(i, s + 2 * l));
          return a;
        },
        readUint: function (i, s) {
          return e._bin._view(i).getUint32(s);
        },
        readUint64: function (i, s) {
          return 4294967296 * e._bin.readUint(i, s) + e._bin.readUint(i, s + 4);
        },
        readASCII: function (i, s, o) {
          for (var a = "", l = 0; l < o; l++)
            a += String.fromCharCode(i[s + l]);
          return a;
        },
        readUnicode: function (i, s, o) {
          for (var a = "", l = 0; l < o; l++) {
            var c = (i[s++] << 8) | i[s++];
            a += String.fromCharCode(c);
          }
          return a;
        },
        _tdec:
          typeof window < "u" && window.TextDecoder
            ? new window.TextDecoder()
            : null,
        readUTF8: function (i, s, o) {
          var a = e._bin._tdec;
          return a && s == 0 && o == i.length
            ? a.decode(i)
            : e._bin.readASCII(i, s, o);
        },
        readBytes: function (i, s, o) {
          for (var a = [], l = 0; l < o; l++) a.push(i[s + l]);
          return a;
        },
        readASCIIArray: function (i, s, o) {
          for (var a = [], l = 0; l < o; l++)
            a.push(String.fromCharCode(i[s + l]));
          return a;
        },
        _view: function (i) {
          return (
            i._dataView ||
            (i._dataView = i.buffer
              ? new DataView(i.buffer, i.byteOffset, i.byteLength)
              : new DataView(new Uint8Array(i).buffer))
          );
        },
      }),
        (e._lctf = {}),
        (e._lctf.parse = function (i, s, o, a, l) {
          var c = e._bin,
            u = {},
            d = s;
          c.readFixed(i, s), (s += 4);
          var h = c.readUshort(i, s);
          s += 2;
          var m = c.readUshort(i, s);
          s += 2;
          var g = c.readUshort(i, s);
          return (
            (s += 2),
            (u.scriptList = e._lctf.readScriptList(i, d + h)),
            (u.featureList = e._lctf.readFeatureList(i, d + m)),
            (u.lookupList = e._lctf.readLookupList(i, d + g, l)),
            u
          );
        }),
        (e._lctf.readLookupList = function (i, s, o) {
          var a = e._bin,
            l = s,
            c = [],
            u = a.readUshort(i, s);
          s += 2;
          for (var d = 0; d < u; d++) {
            var h = a.readUshort(i, s);
            s += 2;
            var m = e._lctf.readLookupTable(i, l + h, o);
            c.push(m);
          }
          return c;
        }),
        (e._lctf.readLookupTable = function (i, s, o) {
          var a = e._bin,
            l = s,
            c = { tabs: [] };
          (c.ltype = a.readUshort(i, s)),
            (s += 2),
            (c.flag = a.readUshort(i, s)),
            (s += 2);
          var u = a.readUshort(i, s);
          s += 2;
          for (var d = c.ltype, h = 0; h < u; h++) {
            var m = a.readUshort(i, s);
            s += 2;
            var g = o(i, d, l + m, c);
            c.tabs.push(g);
          }
          return c;
        }),
        (e._lctf.numOfOnes = function (i) {
          for (var s = 0, o = 0; o < 32; o++) (i >>> o) & 1 && s++;
          return s;
        }),
        (e._lctf.readClassDef = function (i, s) {
          var o = e._bin,
            a = [],
            l = o.readUshort(i, s);
          if (((s += 2), l == 1)) {
            var c = o.readUshort(i, s);
            s += 2;
            var u = o.readUshort(i, s);
            s += 2;
            for (var d = 0; d < u; d++)
              a.push(c + d),
                a.push(c + d),
                a.push(o.readUshort(i, s)),
                (s += 2);
          }
          if (l == 2) {
            var h = o.readUshort(i, s);
            for (s += 2, d = 0; d < h; d++)
              a.push(o.readUshort(i, s)),
                (s += 2),
                a.push(o.readUshort(i, s)),
                (s += 2),
                a.push(o.readUshort(i, s)),
                (s += 2);
          }
          return a;
        }),
        (e._lctf.getInterval = function (i, s) {
          for (var o = 0; o < i.length; o += 3) {
            var a = i[o],
              l = i[o + 1];
            if ((i[o + 2], a <= s && s <= l)) return o;
          }
          return -1;
        }),
        (e._lctf.readCoverage = function (i, s) {
          var o = e._bin,
            a = {};
          (a.fmt = o.readUshort(i, s)), (s += 2);
          var l = o.readUshort(i, s);
          return (
            (s += 2),
            a.fmt == 1 && (a.tab = o.readUshorts(i, s, l)),
            a.fmt == 2 && (a.tab = o.readUshorts(i, s, 3 * l)),
            a
          );
        }),
        (e._lctf.coverageIndex = function (i, s) {
          var o = i.tab;
          if (i.fmt == 1) return o.indexOf(s);
          if (i.fmt == 2) {
            var a = e._lctf.getInterval(o, s);
            if (a != -1) return o[a + 2] + (s - o[a]);
          }
          return -1;
        }),
        (e._lctf.readFeatureList = function (i, s) {
          var o = e._bin,
            a = s,
            l = [],
            c = o.readUshort(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = o.readASCII(i, s, 4);
            s += 4;
            var h = o.readUshort(i, s);
            s += 2;
            var m = e._lctf.readFeatureTable(i, a + h);
            (m.tag = d.trim()), l.push(m);
          }
          return l;
        }),
        (e._lctf.readFeatureTable = function (i, s) {
          var o = e._bin,
            a = s,
            l = {},
            c = o.readUshort(i, s);
          (s += 2), c > 0 && (l.featureParams = a + c);
          var u = o.readUshort(i, s);
          (s += 2), (l.tab = []);
          for (var d = 0; d < u; d++) l.tab.push(o.readUshort(i, s + 2 * d));
          return l;
        }),
        (e._lctf.readScriptList = function (i, s) {
          var o = e._bin,
            a = s,
            l = {},
            c = o.readUshort(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = o.readASCII(i, s, 4);
            s += 4;
            var h = o.readUshort(i, s);
            (s += 2), (l[d.trim()] = e._lctf.readScriptTable(i, a + h));
          }
          return l;
        }),
        (e._lctf.readScriptTable = function (i, s) {
          var o = e._bin,
            a = s,
            l = {},
            c = o.readUshort(i, s);
          (s += 2), c > 0 && (l.default = e._lctf.readLangSysTable(i, a + c));
          var u = o.readUshort(i, s);
          s += 2;
          for (var d = 0; d < u; d++) {
            var h = o.readASCII(i, s, 4);
            s += 4;
            var m = o.readUshort(i, s);
            (s += 2), (l[h.trim()] = e._lctf.readLangSysTable(i, a + m));
          }
          return l;
        }),
        (e._lctf.readLangSysTable = function (i, s) {
          var o = e._bin,
            a = {};
          o.readUshort(i, s),
            (s += 2),
            (a.reqFeature = o.readUshort(i, s)),
            (s += 2);
          var l = o.readUshort(i, s);
          return (s += 2), (a.features = o.readUshorts(i, s, l)), a;
        }),
        (e.CFF = {}),
        (e.CFF.parse = function (i, s, o) {
          var a = e._bin;
          (i = new Uint8Array(i.buffer, s, o))[(s = 0)],
            i[++s],
            i[++s],
            i[++s],
            s++;
          var l = [];
          s = e.CFF.readIndex(i, s, l);
          for (var c = [], u = 0; u < l.length - 1; u++)
            c.push(a.readASCII(i, s + l[u], l[u + 1] - l[u]));
          s += l[l.length - 1];
          var d = [];
          s = e.CFF.readIndex(i, s, d);
          var h = [];
          for (u = 0; u < d.length - 1; u++)
            h.push(e.CFF.readDict(i, s + d[u], s + d[u + 1]));
          s += d[d.length - 1];
          var m = h[0],
            g = [];
          s = e.CFF.readIndex(i, s, g);
          var x = [];
          for (u = 0; u < g.length - 1; u++)
            x.push(a.readASCII(i, s + g[u], g[u + 1] - g[u]));
          if (
            ((s += g[g.length - 1]), e.CFF.readSubrs(i, s, m), m.CharStrings)
          ) {
            (s = m.CharStrings), (g = []), (s = e.CFF.readIndex(i, s, g));
            var y = [];
            for (u = 0; u < g.length - 1; u++)
              y.push(a.readBytes(i, s + g[u], g[u + 1] - g[u]));
            m.CharStrings = y;
          }
          if (m.ROS) {
            s = m.FDArray;
            var v = [];
            for (
              s = e.CFF.readIndex(i, s, v), m.FDArray = [], u = 0;
              u < v.length - 1;
              u++
            ) {
              var _ = e.CFF.readDict(i, s + v[u], s + v[u + 1]);
              e.CFF._readFDict(i, _, x), m.FDArray.push(_);
            }
            (s += v[v.length - 1]), (s = m.FDSelect), (m.FDSelect = []);
            var S = i[s];
            if ((s++, S != 3)) throw S;
            var w = a.readUshort(i, s);
            for (s += 2, u = 0; u < w + 1; u++)
              m.FDSelect.push(a.readUshort(i, s), i[s + 2]), (s += 3);
          }
          return (
            m.Encoding &&
              (m.Encoding = e.CFF.readEncoding(
                i,
                m.Encoding,
                m.CharStrings.length
              )),
            m.charset &&
              (m.charset = e.CFF.readCharset(
                i,
                m.charset,
                m.CharStrings.length
              )),
            e.CFF._readFDict(i, m, x),
            m
          );
        }),
        (e.CFF._readFDict = function (i, s, o) {
          var a;
          for (var l in (s.Private &&
            ((a = s.Private[1]),
            (s.Private = e.CFF.readDict(i, a, a + s.Private[0])),
            s.Private.Subrs &&
              e.CFF.readSubrs(i, a + s.Private.Subrs, s.Private)),
          s))
            [
              "FamilyName",
              "FontName",
              "FullName",
              "Notice",
              "version",
              "Copyright",
            ].indexOf(l) != -1 && (s[l] = o[s[l] - 426 + 35]);
        }),
        (e.CFF.readSubrs = function (i, s, o) {
          var a = e._bin,
            l = [];
          s = e.CFF.readIndex(i, s, l);
          var c,
            u = l.length;
          (c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768),
            (o.Bias = c),
            (o.Subrs = []);
          for (var d = 0; d < l.length - 1; d++)
            o.Subrs.push(a.readBytes(i, s + l[d], l[d + 1] - l[d]));
        }),
        (e.CFF.tableSE = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
          14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
          31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
          48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
          65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
          82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,
          107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119,
          120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0,
          132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0,
          0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0,
        ]),
        (e.CFF.glyphByUnicode = function (i, s) {
          for (var o = 0; o < i.charset.length; o++)
            if (i.charset[o] == s) return o;
          return -1;
        }),
        (e.CFF.glyphBySE = function (i, s) {
          return s < 0 || s > 255
            ? -1
            : e.CFF.glyphByUnicode(i, e.CFF.tableSE[s]);
        }),
        (e.CFF.readEncoding = function (i, s, o) {
          e._bin;
          var a = [".notdef"],
            l = i[s];
          if ((s++, l != 0)) throw "error: unknown encoding format: " + l;
          var c = i[s];
          s++;
          for (var u = 0; u < c; u++) a.push(i[s + u]);
          return a;
        }),
        (e.CFF.readCharset = function (i, s, o) {
          var a = e._bin,
            l = [".notdef"],
            c = i[s];
          if ((s++, c == 0))
            for (var u = 0; u < o; u++) {
              var d = a.readUshort(i, s);
              (s += 2), l.push(d);
            }
          else {
            if (c != 1 && c != 2) throw "error: format: " + c;
            for (; l.length < o; ) {
              (d = a.readUshort(i, s)), (s += 2);
              var h = 0;
              for (
                c == 1
                  ? ((h = i[s]), s++)
                  : ((h = a.readUshort(i, s)), (s += 2)),
                  u = 0;
                u <= h;
                u++
              )
                l.push(d), d++;
            }
          }
          return l;
        }),
        (e.CFF.readIndex = function (i, s, o) {
          var a = e._bin,
            l = a.readUshort(i, s) + 1,
            c = i[(s += 2)];
          if ((s++, c == 1)) for (var u = 0; u < l; u++) o.push(i[s + u]);
          else if (c == 2)
            for (u = 0; u < l; u++) o.push(a.readUshort(i, s + 2 * u));
          else if (c == 3)
            for (u = 0; u < l; u++)
              o.push(16777215 & a.readUint(i, s + 3 * u - 1));
          else if (l != 1)
            throw "unsupported offset size: " + c + ", count: " + l;
          return (s += l * c) - 1;
        }),
        (e.CFF.getCharString = function (i, s, o) {
          var a = e._bin,
            l = i[s],
            c = i[s + 1];
          i[s + 2], i[s + 3], i[s + 4];
          var u = 1,
            d = null,
            h = null;
          l <= 20 && ((d = l), (u = 1)),
            l == 12 && ((d = 100 * l + c), (u = 2)),
            21 <= l && l <= 27 && ((d = l), (u = 1)),
            l == 28 && ((h = a.readShort(i, s + 1)), (u = 3)),
            29 <= l && l <= 31 && ((d = l), (u = 1)),
            32 <= l && l <= 246 && ((h = l - 139), (u = 1)),
            247 <= l && l <= 250 && ((h = 256 * (l - 247) + c + 108), (u = 2)),
            251 <= l && l <= 254 && ((h = 256 * -(l - 251) - c - 108), (u = 2)),
            l == 255 && ((h = a.readInt(i, s + 1) / 65535), (u = 5)),
            (o.val = h ?? "o" + d),
            (o.size = u);
        }),
        (e.CFF.readCharString = function (i, s, o) {
          for (var a = s + o, l = e._bin, c = []; s < a; ) {
            var u = i[s],
              d = i[s + 1];
            i[s + 2], i[s + 3], i[s + 4];
            var h = 1,
              m = null,
              g = null;
            u <= 20 && ((m = u), (h = 1)),
              u == 12 && ((m = 100 * u + d), (h = 2)),
              (u != 19 && u != 20) || ((m = u), (h = 2)),
              21 <= u && u <= 27 && ((m = u), (h = 1)),
              u == 28 && ((g = l.readShort(i, s + 1)), (h = 3)),
              29 <= u && u <= 31 && ((m = u), (h = 1)),
              32 <= u && u <= 246 && ((g = u - 139), (h = 1)),
              247 <= u &&
                u <= 250 &&
                ((g = 256 * (u - 247) + d + 108), (h = 2)),
              251 <= u &&
                u <= 254 &&
                ((g = 256 * -(u - 251) - d - 108), (h = 2)),
              u == 255 && ((g = l.readInt(i, s + 1) / 65535), (h = 5)),
              c.push(g ?? "o" + m),
              (s += h);
          }
          return c;
        }),
        (e.CFF.readDict = function (i, s, o) {
          for (var a = e._bin, l = {}, c = []; s < o; ) {
            var u = i[s],
              d = i[s + 1];
            i[s + 2], i[s + 3], i[s + 4];
            var h = 1,
              m = null,
              g = null;
            if (
              (u == 28 && ((g = a.readShort(i, s + 1)), (h = 3)),
              u == 29 && ((g = a.readInt(i, s + 1)), (h = 5)),
              32 <= u && u <= 246 && ((g = u - 139), (h = 1)),
              247 <= u &&
                u <= 250 &&
                ((g = 256 * (u - 247) + d + 108), (h = 2)),
              251 <= u &&
                u <= 254 &&
                ((g = 256 * -(u - 251) - d - 108), (h = 2)),
              u == 255)
            )
              throw (
                ((g = a.readInt(i, s + 1) / 65535), (h = 5), "unknown number")
              );
            if (u == 30) {
              var x = [];
              for (h = 1; ; ) {
                var y = i[s + h];
                h++;
                var v = y >> 4,
                  _ = 15 & y;
                if ((v != 15 && x.push(v), _ != 15 && x.push(_), _ == 15))
                  break;
              }
              for (
                var S = "",
                  w = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber",
                  ],
                  T = 0;
                T < x.length;
                T++
              )
                S += w[x[T]];
              g = parseFloat(S);
            }
            u <= 21 &&
              ((m = [
                "version",
                "Notice",
                "FullName",
                "FamilyName",
                "Weight",
                "FontBBox",
                "BlueValues",
                "OtherBlues",
                "FamilyBlues",
                "FamilyOtherBlues",
                "StdHW",
                "StdVW",
                "escape",
                "UniqueID",
                "XUID",
                "charset",
                "Encoding",
                "CharStrings",
                "Private",
                "Subrs",
                "defaultWidthX",
                "nominalWidthX",
              ][u]),
              (h = 1),
              u == 12 &&
                ((m = [
                  "Copyright",
                  "isFixedPitch",
                  "ItalicAngle",
                  "UnderlinePosition",
                  "UnderlineThickness",
                  "PaintType",
                  "CharstringType",
                  "FontMatrix",
                  "StrokeWidth",
                  "BlueScale",
                  "BlueShift",
                  "BlueFuzz",
                  "StemSnapH",
                  "StemSnapV",
                  "ForceBold",
                  0,
                  0,
                  "LanguageGroup",
                  "ExpansionFactor",
                  "initialRandomSeed",
                  "SyntheticBase",
                  "PostScript",
                  "BaseFontName",
                  "BaseFontBlend",
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  "ROS",
                  "CIDFontVersion",
                  "CIDFontRevision",
                  "CIDFontType",
                  "CIDCount",
                  "UIDBase",
                  "FDArray",
                  "FDSelect",
                  "FontName",
                ][d]),
                (h = 2))),
              m != null
                ? ((l[m] = c.length == 1 ? c[0] : c), (c = []))
                : c.push(g),
              (s += h);
          }
          return l;
        }),
        (e.cmap = {}),
        (e.cmap.parse = function (i, s, o) {
          (i = new Uint8Array(i.buffer, s, o)), (s = 0);
          var a = e._bin,
            l = {};
          a.readUshort(i, s), (s += 2);
          var c = a.readUshort(i, s);
          s += 2;
          var u = [];
          l.tables = [];
          for (var d = 0; d < c; d++) {
            var h = a.readUshort(i, s);
            s += 2;
            var m = a.readUshort(i, s);
            s += 2;
            var g = a.readUint(i, s);
            s += 4;
            var x = "p" + h + "e" + m,
              y = u.indexOf(g);
            if (y == -1) {
              var v;
              (y = l.tables.length), u.push(g);
              var _ = a.readUshort(i, g);
              _ == 0
                ? (v = e.cmap.parse0(i, g))
                : _ == 4
                ? (v = e.cmap.parse4(i, g))
                : _ == 6
                ? (v = e.cmap.parse6(i, g))
                : _ == 12
                ? (v = e.cmap.parse12(i, g))
                : console.debug("unknown format: " + _, h, m, g),
                l.tables.push(v);
            }
            if (l[x] != null) throw "multiple tables for one platform+encoding";
            l[x] = y;
          }
          return l;
        }),
        (e.cmap.parse0 = function (i, s) {
          var o = e._bin,
            a = {};
          (a.format = o.readUshort(i, s)), (s += 2);
          var l = o.readUshort(i, s);
          (s += 2), o.readUshort(i, s), (s += 2), (a.map = []);
          for (var c = 0; c < l - 6; c++) a.map.push(i[s + c]);
          return a;
        }),
        (e.cmap.parse4 = function (i, s) {
          var o = e._bin,
            a = s,
            l = {};
          (l.format = o.readUshort(i, s)), (s += 2);
          var c = o.readUshort(i, s);
          (s += 2), o.readUshort(i, s), (s += 2);
          var u = o.readUshort(i, s);
          s += 2;
          var d = u / 2;
          (l.searchRange = o.readUshort(i, s)),
            (s += 2),
            (l.entrySelector = o.readUshort(i, s)),
            (s += 2),
            (l.rangeShift = o.readUshort(i, s)),
            (s += 2),
            (l.endCount = o.readUshorts(i, s, d)),
            (s += 2 * d),
            (s += 2),
            (l.startCount = o.readUshorts(i, s, d)),
            (s += 2 * d),
            (l.idDelta = []);
          for (var h = 0; h < d; h++)
            l.idDelta.push(o.readShort(i, s)), (s += 2);
          for (
            l.idRangeOffset = o.readUshorts(i, s, d),
              s += 2 * d,
              l.glyphIdArray = [];
            s < a + c;

          )
            l.glyphIdArray.push(o.readUshort(i, s)), (s += 2);
          return l;
        }),
        (e.cmap.parse6 = function (i, s) {
          var o = e._bin,
            a = {};
          (a.format = o.readUshort(i, s)),
            (s += 2),
            o.readUshort(i, s),
            (s += 2),
            o.readUshort(i, s),
            (s += 2),
            (a.firstCode = o.readUshort(i, s)),
            (s += 2);
          var l = o.readUshort(i, s);
          (s += 2), (a.glyphIdArray = []);
          for (var c = 0; c < l; c++)
            a.glyphIdArray.push(o.readUshort(i, s)), (s += 2);
          return a;
        }),
        (e.cmap.parse12 = function (i, s) {
          var o = e._bin,
            a = {};
          (a.format = o.readUshort(i, s)),
            (s += 2),
            (s += 2),
            o.readUint(i, s),
            (s += 4),
            o.readUint(i, s),
            (s += 4);
          var l = o.readUint(i, s);
          (s += 4), (a.groups = []);
          for (var c = 0; c < l; c++) {
            var u = s + 12 * c,
              d = o.readUint(i, u + 0),
              h = o.readUint(i, u + 4),
              m = o.readUint(i, u + 8);
            a.groups.push([d, h, m]);
          }
          return a;
        }),
        (e.glyf = {}),
        (e.glyf.parse = function (i, s, o, a) {
          for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
          return l;
        }),
        (e.glyf._parseGlyf = function (i, s) {
          var o = e._bin,
            a = i._data,
            l = e._tabOffset(a, "glyf", i._offset) + i.loca[s];
          if (i.loca[s] == i.loca[s + 1]) return null;
          var c = {};
          if (
            ((c.noc = o.readShort(a, l)),
            (l += 2),
            (c.xMin = o.readShort(a, l)),
            (l += 2),
            (c.yMin = o.readShort(a, l)),
            (l += 2),
            (c.xMax = o.readShort(a, l)),
            (l += 2),
            (c.yMax = o.readShort(a, l)),
            (l += 2),
            c.xMin >= c.xMax || c.yMin >= c.yMax)
          )
            return null;
          if (c.noc > 0) {
            c.endPts = [];
            for (var u = 0; u < c.noc; u++)
              c.endPts.push(o.readUshort(a, l)), (l += 2);
            var d = o.readUshort(a, l);
            if (((l += 2), a.length - l < d)) return null;
            (c.instructions = o.readBytes(a, l, d)), (l += d);
            var h = c.endPts[c.noc - 1] + 1;
            for (c.flags = [], u = 0; u < h; u++) {
              var m = a[l];
              if ((l++, c.flags.push(m), (8 & m) != 0)) {
                var g = a[l];
                l++;
                for (var x = 0; x < g; x++) c.flags.push(m), u++;
              }
            }
            for (c.xs = [], u = 0; u < h; u++) {
              var y = (2 & c.flags[u]) != 0,
                v = (16 & c.flags[u]) != 0;
              y
                ? (c.xs.push(v ? a[l] : -a[l]), l++)
                : v
                ? c.xs.push(0)
                : (c.xs.push(o.readShort(a, l)), (l += 2));
            }
            for (c.ys = [], u = 0; u < h; u++)
              (y = (4 & c.flags[u]) != 0),
                (v = (32 & c.flags[u]) != 0),
                y
                  ? (c.ys.push(v ? a[l] : -a[l]), l++)
                  : v
                  ? c.ys.push(0)
                  : (c.ys.push(o.readShort(a, l)), (l += 2));
            var _ = 0,
              S = 0;
            for (u = 0; u < h; u++)
              (_ += c.xs[u]), (S += c.ys[u]), (c.xs[u] = _), (c.ys[u] = S);
          } else {
            var w;
            c.parts = [];
            do {
              (w = o.readUshort(a, l)), (l += 2);
              var T = {
                m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
                p1: -1,
                p2: -1,
              };
              if (
                (c.parts.push(T),
                (T.glyphIndex = o.readUshort(a, l)),
                (l += 2),
                1 & w)
              ) {
                var E = o.readShort(a, l);
                l += 2;
                var M = o.readShort(a, l);
                l += 2;
              } else (E = o.readInt8(a, l)), l++, (M = o.readInt8(a, l)), l++;
              2 & w ? ((T.m.tx = E), (T.m.ty = M)) : ((T.p1 = E), (T.p2 = M)),
                8 & w
                  ? ((T.m.a = T.m.d = o.readF2dot14(a, l)), (l += 2))
                  : 64 & w
                  ? ((T.m.a = o.readF2dot14(a, l)),
                    (l += 2),
                    (T.m.d = o.readF2dot14(a, l)),
                    (l += 2))
                  : 128 & w &&
                    ((T.m.a = o.readF2dot14(a, l)),
                    (l += 2),
                    (T.m.b = o.readF2dot14(a, l)),
                    (l += 2),
                    (T.m.c = o.readF2dot14(a, l)),
                    (l += 2),
                    (T.m.d = o.readF2dot14(a, l)),
                    (l += 2));
            } while (32 & w);
            if (256 & w) {
              var N = o.readUshort(a, l);
              for (l += 2, c.instr = [], u = 0; u < N; u++)
                c.instr.push(a[l]), l++;
            }
          }
          return c;
        }),
        (e.GDEF = {}),
        (e.GDEF.parse = function (i, s, o, a) {
          var l = s;
          s += 4;
          var c = e._bin.readUshort(i, s);
          return {
            glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, l + c),
          };
        }),
        (e.GPOS = {}),
        (e.GPOS.parse = function (i, s, o, a) {
          return e._lctf.parse(i, s, o, a, e.GPOS.subt);
        }),
        (e.GPOS.subt = function (i, s, o, a) {
          var l = e._bin,
            c = o,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, o)),
            (o += 2),
            s == 1 || s == 2 || s == 3 || s == 7 || (s == 8 && u.fmt <= 2))
          ) {
            var d = l.readUshort(i, o);
            (o += 2), (u.coverage = e._lctf.readCoverage(i, d + c));
          }
          if (s == 1 && u.fmt == 1) {
            var h = l.readUshort(i, o);
            (o += 2), h != 0 && (u.pos = e.GPOS.readValueRecord(i, o, h));
          } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
            (h = l.readUshort(i, o)), (o += 2);
            var m = l.readUshort(i, o);
            o += 2;
            var g = e._lctf.numOfOnes(h),
              x = e._lctf.numOfOnes(m);
            if (u.fmt == 1) {
              u.pairsets = [];
              var y = l.readUshort(i, o);
              o += 2;
              for (var v = 0; v < y; v++) {
                var _ = c + l.readUshort(i, o);
                o += 2;
                var S = l.readUshort(i, _);
                _ += 2;
                for (var w = [], T = 0; T < S; T++) {
                  var E = l.readUshort(i, _);
                  (_ += 2),
                    h != 0 &&
                      ((O = e.GPOS.readValueRecord(i, _, h)), (_ += 2 * g)),
                    m != 0 &&
                      ((D = e.GPOS.readValueRecord(i, _, m)), (_ += 2 * x)),
                    w.push({ gid2: E, val1: O, val2: D });
                }
                u.pairsets.push(w);
              }
            }
            if (u.fmt == 2) {
              var M = l.readUshort(i, o);
              o += 2;
              var N = l.readUshort(i, o);
              o += 2;
              var R = l.readUshort(i, o);
              o += 2;
              var C = l.readUshort(i, o);
              for (
                o += 2,
                  u.classDef1 = e._lctf.readClassDef(i, c + M),
                  u.classDef2 = e._lctf.readClassDef(i, c + N),
                  u.matrix = [],
                  v = 0;
                v < R;
                v++
              ) {
                var L = [];
                for (T = 0; T < C; T++) {
                  var O = null,
                    D = null;
                  h != 0 &&
                    ((O = e.GPOS.readValueRecord(i, o, h)), (o += 2 * g)),
                    m != 0 &&
                      ((D = e.GPOS.readValueRecord(i, o, m)), (o += 2 * x)),
                    L.push({ val1: O, val2: D });
                }
                u.matrix.push(L);
              }
            }
          } else if (s == 4 && u.fmt == 1)
            (u.markCoverage = e._lctf.readCoverage(i, l.readUshort(i, o) + c)),
              (u.baseCoverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, o + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, o + 4)),
              (u.markArray = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, o + 6) + c
              )),
              (u.baseArray = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, o + 8) + c,
                u.markClassCount
              ));
          else if (s == 6 && u.fmt == 1)
            (u.mark1Coverage = e._lctf.readCoverage(i, l.readUshort(i, o) + c)),
              (u.mark2Coverage = e._lctf.readCoverage(
                i,
                l.readUshort(i, o + 2) + c
              )),
              (u.markClassCount = l.readUshort(i, o + 4)),
              (u.mark1Array = e.GPOS.readMarkArray(
                i,
                l.readUshort(i, o + 6) + c
              )),
              (u.mark2Array = e.GPOS.readBaseArray(
                i,
                l.readUshort(i, o + 8) + c,
                u.markClassCount
              ));
          else {
            if (s == 9 && u.fmt == 1) {
              var B = l.readUshort(i, o);
              o += 2;
              var $ = l.readUint(i, o);
              if (((o += 4), a.ltype == 9)) a.ltype = B;
              else if (a.ltype != B) throw "invalid extension substitution";
              return e.GPOS.subt(i, a.ltype, c + $);
            }
            console.debug(
              "unsupported GPOS table LookupType",
              s,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GPOS.readValueRecord = function (i, s, o) {
          var a = e._bin,
            l = [];
          return (
            l.push(1 & o ? a.readShort(i, s) : 0),
            (s += 1 & o ? 2 : 0),
            l.push(2 & o ? a.readShort(i, s) : 0),
            (s += 2 & o ? 2 : 0),
            l.push(4 & o ? a.readShort(i, s) : 0),
            (s += 4 & o ? 2 : 0),
            l.push(8 & o ? a.readShort(i, s) : 0),
            (s += 8 & o ? 2 : 0),
            l
          );
        }),
        (e.GPOS.readBaseArray = function (i, s, o) {
          var a = e._bin,
            l = [],
            c = s,
            u = a.readUshort(i, s);
          s += 2;
          for (var d = 0; d < u; d++) {
            for (var h = [], m = 0; m < o; m++)
              h.push(e.GPOS.readAnchorRecord(i, c + a.readUshort(i, s))),
                (s += 2);
            l.push(h);
          }
          return l;
        }),
        (e.GPOS.readMarkArray = function (i, s) {
          var o = e._bin,
            a = [],
            l = s,
            c = o.readUshort(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = e.GPOS.readAnchorRecord(i, o.readUshort(i, s + 2) + l);
            (d.markClass = o.readUshort(i, s)), a.push(d), (s += 4);
          }
          return a;
        }),
        (e.GPOS.readAnchorRecord = function (i, s) {
          var o = e._bin,
            a = {};
          return (
            (a.fmt = o.readUshort(i, s)),
            (a.x = o.readShort(i, s + 2)),
            (a.y = o.readShort(i, s + 4)),
            a
          );
        }),
        (e.GSUB = {}),
        (e.GSUB.parse = function (i, s, o, a) {
          return e._lctf.parse(i, s, o, a, e.GSUB.subt);
        }),
        (e.GSUB.subt = function (i, s, o, a) {
          var l = e._bin,
            c = o,
            u = {};
          if (
            ((u.fmt = l.readUshort(i, o)),
            (o += 2),
            s != 1 && s != 2 && s != 4 && s != 5 && s != 6)
          )
            return null;
          if (
            s == 1 ||
            s == 2 ||
            s == 4 ||
            (s == 5 && u.fmt <= 2) ||
            (s == 6 && u.fmt <= 2)
          ) {
            var d = l.readUshort(i, o);
            (o += 2), (u.coverage = e._lctf.readCoverage(i, c + d));
          }
          if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
            if (u.fmt == 1) (u.delta = l.readShort(i, o)), (o += 2);
            else if (u.fmt == 2) {
              var h = l.readUshort(i, o);
              (o += 2),
                (u.newg = l.readUshorts(i, o, h)),
                (o += 2 * u.newg.length);
            }
          } else if (s == 2 && u.fmt == 1) {
            (h = l.readUshort(i, o)), (o += 2), (u.seqs = []);
            for (var m = 0; m < h; m++) {
              var g = l.readUshort(i, o) + c;
              o += 2;
              var x = l.readUshort(i, g);
              u.seqs.push(l.readUshorts(i, g + 2, x));
            }
          } else if (s == 4)
            for (
              u.vals = [], h = l.readUshort(i, o), o += 2, m = 0;
              m < h;
              m++
            ) {
              var y = l.readUshort(i, o);
              (o += 2), u.vals.push(e.GSUB.readLigatureSet(i, c + y));
            }
          else if (s == 5 && u.fmt == 2) {
            if (u.fmt == 2) {
              var v = l.readUshort(i, o);
              (o += 2),
                (u.cDef = e._lctf.readClassDef(i, c + v)),
                (u.scset = []);
              var _ = l.readUshort(i, o);
              for (o += 2, m = 0; m < _; m++) {
                var S = l.readUshort(i, o);
                (o += 2),
                  u.scset.push(
                    S == 0 ? null : e.GSUB.readSubClassSet(i, c + S)
                  );
              }
            }
          } else if (s == 6 && u.fmt == 3) {
            if (u.fmt == 3) {
              for (m = 0; m < 3; m++) {
                (h = l.readUshort(i, o)), (o += 2);
                for (var w = [], T = 0; T < h; T++)
                  w.push(
                    e._lctf.readCoverage(i, c + l.readUshort(i, o + 2 * T))
                  );
                (o += 2 * h),
                  m == 0 && (u.backCvg = w),
                  m == 1 && (u.inptCvg = w),
                  m == 2 && (u.ahedCvg = w);
              }
              (h = l.readUshort(i, o)),
                (o += 2),
                (u.lookupRec = e.GSUB.readSubstLookupRecords(i, o, h));
            }
          } else {
            if (s == 7 && u.fmt == 1) {
              var E = l.readUshort(i, o);
              o += 2;
              var M = l.readUint(i, o);
              if (((o += 4), a.ltype == 9)) a.ltype = E;
              else if (a.ltype != E) throw "invalid extension substitution";
              return e.GSUB.subt(i, a.ltype, c + M);
            }
            console.debug(
              "unsupported GSUB table LookupType",
              s,
              "format",
              u.fmt
            );
          }
          return u;
        }),
        (e.GSUB.readSubClassSet = function (i, s) {
          var o = e._bin.readUshort,
            a = s,
            l = [],
            c = o(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = o(i, s);
            (s += 2), l.push(e.GSUB.readSubClassRule(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readSubClassRule = function (i, s) {
          var o = e._bin.readUshort,
            a = {},
            l = o(i, s),
            c = o(i, (s += 2));
          (s += 2), (a.input = []);
          for (var u = 0; u < l - 1; u++) a.input.push(o(i, s)), (s += 2);
          return (
            (a.substLookupRecords = e.GSUB.readSubstLookupRecords(i, s, c)), a
          );
        }),
        (e.GSUB.readSubstLookupRecords = function (i, s, o) {
          for (var a = e._bin.readUshort, l = [], c = 0; c < o; c++)
            l.push(a(i, s), a(i, s + 2)), (s += 4);
          return l;
        }),
        (e.GSUB.readChainSubClassSet = function (i, s) {
          var o = e._bin,
            a = s,
            l = [],
            c = o.readUshort(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = o.readUshort(i, s);
            (s += 2), l.push(e.GSUB.readChainSubClassRule(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readChainSubClassRule = function (i, s) {
          for (
            var o = e._bin,
              a = {},
              l = ["backtrack", "input", "lookahead"],
              c = 0;
            c < l.length;
            c++
          ) {
            var u = o.readUshort(i, s);
            (s += 2),
              c == 1 && u--,
              (a[l[c]] = o.readUshorts(i, s, u)),
              (s += 2 * a[l[c]].length);
          }
          return (
            (u = o.readUshort(i, s)),
            (s += 2),
            (a.subst = o.readUshorts(i, s, 2 * u)),
            (s += 2 * a.subst.length),
            a
          );
        }),
        (e.GSUB.readLigatureSet = function (i, s) {
          var o = e._bin,
            a = s,
            l = [],
            c = o.readUshort(i, s);
          s += 2;
          for (var u = 0; u < c; u++) {
            var d = o.readUshort(i, s);
            (s += 2), l.push(e.GSUB.readLigature(i, a + d));
          }
          return l;
        }),
        (e.GSUB.readLigature = function (i, s) {
          var o = e._bin,
            a = { chain: [] };
          (a.nglyph = o.readUshort(i, s)), (s += 2);
          var l = o.readUshort(i, s);
          s += 2;
          for (var c = 0; c < l - 1; c++)
            a.chain.push(o.readUshort(i, s)), (s += 2);
          return a;
        }),
        (e.head = {}),
        (e.head.parse = function (i, s, o) {
          var a = e._bin,
            l = {};
          return (
            a.readFixed(i, s),
            (s += 4),
            (l.fontRevision = a.readFixed(i, s)),
            (s += 4),
            a.readUint(i, s),
            (s += 4),
            a.readUint(i, s),
            (s += 4),
            (l.flags = a.readUshort(i, s)),
            (s += 2),
            (l.unitsPerEm = a.readUshort(i, s)),
            (s += 2),
            (l.created = a.readUint64(i, s)),
            (s += 8),
            (l.modified = a.readUint64(i, s)),
            (s += 8),
            (l.xMin = a.readShort(i, s)),
            (s += 2),
            (l.yMin = a.readShort(i, s)),
            (s += 2),
            (l.xMax = a.readShort(i, s)),
            (s += 2),
            (l.yMax = a.readShort(i, s)),
            (s += 2),
            (l.macStyle = a.readUshort(i, s)),
            (s += 2),
            (l.lowestRecPPEM = a.readUshort(i, s)),
            (s += 2),
            (l.fontDirectionHint = a.readShort(i, s)),
            (s += 2),
            (l.indexToLocFormat = a.readShort(i, s)),
            (s += 2),
            (l.glyphDataFormat = a.readShort(i, s)),
            (s += 2),
            l
          );
        }),
        (e.hhea = {}),
        (e.hhea.parse = function (i, s, o) {
          var a = e._bin,
            l = {};
          return (
            a.readFixed(i, s),
            (s += 4),
            (l.ascender = a.readShort(i, s)),
            (s += 2),
            (l.descender = a.readShort(i, s)),
            (s += 2),
            (l.lineGap = a.readShort(i, s)),
            (s += 2),
            (l.advanceWidthMax = a.readUshort(i, s)),
            (s += 2),
            (l.minLeftSideBearing = a.readShort(i, s)),
            (s += 2),
            (l.minRightSideBearing = a.readShort(i, s)),
            (s += 2),
            (l.xMaxExtent = a.readShort(i, s)),
            (s += 2),
            (l.caretSlopeRise = a.readShort(i, s)),
            (s += 2),
            (l.caretSlopeRun = a.readShort(i, s)),
            (s += 2),
            (l.caretOffset = a.readShort(i, s)),
            (s += 2),
            (s += 8),
            (l.metricDataFormat = a.readShort(i, s)),
            (s += 2),
            (l.numberOfHMetrics = a.readUshort(i, s)),
            (s += 2),
            l
          );
        }),
        (e.hmtx = {}),
        (e.hmtx.parse = function (i, s, o, a) {
          for (
            var l = e._bin,
              c = { aWidth: [], lsBearing: [] },
              u = 0,
              d = 0,
              h = 0;
            h < a.maxp.numGlyphs;
            h++
          )
            h < a.hhea.numberOfHMetrics &&
              ((u = l.readUshort(i, s)),
              (s += 2),
              (d = l.readShort(i, s)),
              (s += 2)),
              c.aWidth.push(u),
              c.lsBearing.push(d);
          return c;
        }),
        (e.kern = {}),
        (e.kern.parse = function (i, s, o, a) {
          var l = e._bin,
            c = l.readUshort(i, s);
          if (((s += 2), c == 1)) return e.kern.parseV1(i, s - 2, o, a);
          var u = l.readUshort(i, s);
          s += 2;
          for (var d = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
            (s += 2), (o = l.readUshort(i, s)), (s += 2);
            var m = l.readUshort(i, s);
            s += 2;
            var g = m >>> 8;
            if ((g &= 15) != 0) throw "unknown kern table format: " + g;
            s = e.kern.readFormat0(i, s, d);
          }
          return d;
        }),
        (e.kern.parseV1 = function (i, s, o, a) {
          var l = e._bin;
          l.readFixed(i, s), (s += 4);
          var c = l.readUint(i, s);
          s += 4;
          for (var u = { glyph1: [], rval: [] }, d = 0; d < c; d++) {
            l.readUint(i, s), (s += 4);
            var h = l.readUshort(i, s);
            (s += 2), l.readUshort(i, s), (s += 2);
            var m = h >>> 8;
            if ((m &= 15) != 0) throw "unknown kern table format: " + m;
            s = e.kern.readFormat0(i, s, u);
          }
          return u;
        }),
        (e.kern.readFormat0 = function (i, s, o) {
          var a = e._bin,
            l = -1,
            c = a.readUshort(i, s);
          (s += 2),
            a.readUshort(i, s),
            (s += 2),
            a.readUshort(i, s),
            (s += 2),
            a.readUshort(i, s),
            (s += 2);
          for (var u = 0; u < c; u++) {
            var d = a.readUshort(i, s);
            s += 2;
            var h = a.readUshort(i, s);
            s += 2;
            var m = a.readShort(i, s);
            (s += 2),
              d != l &&
                (o.glyph1.push(d), o.rval.push({ glyph2: [], vals: [] }));
            var g = o.rval[o.rval.length - 1];
            g.glyph2.push(h), g.vals.push(m), (l = d);
          }
          return s;
        }),
        (e.loca = {}),
        (e.loca.parse = function (i, s, o, a) {
          var l = e._bin,
            c = [],
            u = a.head.indexToLocFormat,
            d = a.maxp.numGlyphs + 1;
          if (u == 0)
            for (var h = 0; h < d; h++)
              c.push(l.readUshort(i, s + (h << 1)) << 1);
          if (u == 1)
            for (h = 0; h < d; h++) c.push(l.readUint(i, s + (h << 2)));
          return c;
        }),
        (e.maxp = {}),
        (e.maxp.parse = function (i, s, o) {
          var a = e._bin,
            l = {},
            c = a.readUint(i, s);
          return (
            (s += 4),
            (l.numGlyphs = a.readUshort(i, s)),
            (s += 2),
            c == 65536 &&
              ((l.maxPoints = a.readUshort(i, s)),
              (s += 2),
              (l.maxContours = a.readUshort(i, s)),
              (s += 2),
              (l.maxCompositePoints = a.readUshort(i, s)),
              (s += 2),
              (l.maxCompositeContours = a.readUshort(i, s)),
              (s += 2),
              (l.maxZones = a.readUshort(i, s)),
              (s += 2),
              (l.maxTwilightPoints = a.readUshort(i, s)),
              (s += 2),
              (l.maxStorage = a.readUshort(i, s)),
              (s += 2),
              (l.maxFunctionDefs = a.readUshort(i, s)),
              (s += 2),
              (l.maxInstructionDefs = a.readUshort(i, s)),
              (s += 2),
              (l.maxStackElements = a.readUshort(i, s)),
              (s += 2),
              (l.maxSizeOfInstructions = a.readUshort(i, s)),
              (s += 2),
              (l.maxComponentElements = a.readUshort(i, s)),
              (s += 2),
              (l.maxComponentDepth = a.readUshort(i, s)),
              (s += 2)),
            l
          );
        }),
        (e.name = {}),
        (e.name.parse = function (i, s, o) {
          var a = e._bin,
            l = {};
          a.readUshort(i, s), (s += 2);
          var c = a.readUshort(i, s);
          (s += 2), a.readUshort(i, s);
          for (
            var u,
              d = [
                "copyright",
                "fontFamily",
                "fontSubfamily",
                "ID",
                "fullName",
                "version",
                "postScriptName",
                "trademark",
                "manufacturer",
                "designer",
                "description",
                "urlVendor",
                "urlDesigner",
                "licence",
                "licenceURL",
                "---",
                "typoFamilyName",
                "typoSubfamilyName",
                "compatibleFull",
                "sampleText",
                "postScriptCID",
                "wwsFamilyName",
                "wwsSubfamilyName",
                "lightPalette",
                "darkPalette",
              ],
              h = (s += 2),
              m = 0;
            m < c;
            m++
          ) {
            var g = a.readUshort(i, s);
            s += 2;
            var x = a.readUshort(i, s);
            s += 2;
            var y = a.readUshort(i, s);
            s += 2;
            var v = a.readUshort(i, s);
            s += 2;
            var _ = a.readUshort(i, s);
            s += 2;
            var S = a.readUshort(i, s);
            s += 2;
            var w,
              T = d[v],
              E = h + 12 * c + S;
            if (g == 0) w = a.readUnicode(i, E, _ / 2);
            else if (g == 3 && x == 0) w = a.readUnicode(i, E, _ / 2);
            else if (x == 0) w = a.readASCII(i, E, _);
            else if (x == 1) w = a.readUnicode(i, E, _ / 2);
            else if (x == 3) w = a.readUnicode(i, E, _ / 2);
            else {
              if (g != 1) throw "unknown encoding " + x + ", platformID: " + g;
              (w = a.readASCII(i, E, _)),
                console.debug(
                  "reading unknown MAC encoding " + x + " as ASCII"
                );
            }
            var M = "p" + g + "," + y.toString(16);
            l[M] == null && (l[M] = {}),
              (l[M][T !== void 0 ? T : v] = w),
              (l[M]._lang = y);
          }
          for (var N in l)
            if (l[N].postScriptName != null && l[N]._lang == 1033) return l[N];
          for (var N in l)
            if (l[N].postScriptName != null && l[N]._lang == 0) return l[N];
          for (var N in l)
            if (l[N].postScriptName != null && l[N]._lang == 3084) return l[N];
          for (var N in l) if (l[N].postScriptName != null) return l[N];
          for (var N in l) {
            u = N;
            break;
          }
          return (
            console.debug("returning name table with languageID " + l[u]._lang),
            l[u]
          );
        }),
        (e["OS/2"] = {}),
        (e["OS/2"].parse = function (i, s, o) {
          var a = e._bin.readUshort(i, s);
          s += 2;
          var l = {};
          if (a == 0) e["OS/2"].version0(i, s, l);
          else if (a == 1) e["OS/2"].version1(i, s, l);
          else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(i, s, l);
          else {
            if (a != 5) throw "unknown OS/2 table version: " + a;
            e["OS/2"].version5(i, s, l);
          }
          return l;
        }),
        (e["OS/2"].version0 = function (i, s, o) {
          var a = e._bin;
          return (
            (o.xAvgCharWidth = a.readShort(i, s)),
            (s += 2),
            (o.usWeightClass = a.readUshort(i, s)),
            (s += 2),
            (o.usWidthClass = a.readUshort(i, s)),
            (s += 2),
            (o.fsType = a.readUshort(i, s)),
            (s += 2),
            (o.ySubscriptXSize = a.readShort(i, s)),
            (s += 2),
            (o.ySubscriptYSize = a.readShort(i, s)),
            (s += 2),
            (o.ySubscriptXOffset = a.readShort(i, s)),
            (s += 2),
            (o.ySubscriptYOffset = a.readShort(i, s)),
            (s += 2),
            (o.ySuperscriptXSize = a.readShort(i, s)),
            (s += 2),
            (o.ySuperscriptYSize = a.readShort(i, s)),
            (s += 2),
            (o.ySuperscriptXOffset = a.readShort(i, s)),
            (s += 2),
            (o.ySuperscriptYOffset = a.readShort(i, s)),
            (s += 2),
            (o.yStrikeoutSize = a.readShort(i, s)),
            (s += 2),
            (o.yStrikeoutPosition = a.readShort(i, s)),
            (s += 2),
            (o.sFamilyClass = a.readShort(i, s)),
            (s += 2),
            (o.panose = a.readBytes(i, s, 10)),
            (s += 10),
            (o.ulUnicodeRange1 = a.readUint(i, s)),
            (s += 4),
            (o.ulUnicodeRange2 = a.readUint(i, s)),
            (s += 4),
            (o.ulUnicodeRange3 = a.readUint(i, s)),
            (s += 4),
            (o.ulUnicodeRange4 = a.readUint(i, s)),
            (s += 4),
            (o.achVendID = [
              a.readInt8(i, s),
              a.readInt8(i, s + 1),
              a.readInt8(i, s + 2),
              a.readInt8(i, s + 3),
            ]),
            (s += 4),
            (o.fsSelection = a.readUshort(i, s)),
            (s += 2),
            (o.usFirstCharIndex = a.readUshort(i, s)),
            (s += 2),
            (o.usLastCharIndex = a.readUshort(i, s)),
            (s += 2),
            (o.sTypoAscender = a.readShort(i, s)),
            (s += 2),
            (o.sTypoDescender = a.readShort(i, s)),
            (s += 2),
            (o.sTypoLineGap = a.readShort(i, s)),
            (s += 2),
            (o.usWinAscent = a.readUshort(i, s)),
            (s += 2),
            (o.usWinDescent = a.readUshort(i, s)),
            (s += 2)
          );
        }),
        (e["OS/2"].version1 = function (i, s, o) {
          var a = e._bin;
          return (
            (s = e["OS/2"].version0(i, s, o)),
            (o.ulCodePageRange1 = a.readUint(i, s)),
            (s += 4),
            (o.ulCodePageRange2 = a.readUint(i, s)),
            (s += 4)
          );
        }),
        (e["OS/2"].version2 = function (i, s, o) {
          var a = e._bin;
          return (
            (s = e["OS/2"].version1(i, s, o)),
            (o.sxHeight = a.readShort(i, s)),
            (s += 2),
            (o.sCapHeight = a.readShort(i, s)),
            (s += 2),
            (o.usDefault = a.readUshort(i, s)),
            (s += 2),
            (o.usBreak = a.readUshort(i, s)),
            (s += 2),
            (o.usMaxContext = a.readUshort(i, s)),
            (s += 2)
          );
        }),
        (e["OS/2"].version5 = function (i, s, o) {
          var a = e._bin;
          return (
            (s = e["OS/2"].version2(i, s, o)),
            (o.usLowerOpticalPointSize = a.readUshort(i, s)),
            (s += 2),
            (o.usUpperOpticalPointSize = a.readUshort(i, s)),
            (s += 2)
          );
        }),
        (e.post = {}),
        (e.post.parse = function (i, s, o) {
          var a = e._bin,
            l = {};
          return (
            (l.version = a.readFixed(i, s)),
            (s += 4),
            (l.italicAngle = a.readFixed(i, s)),
            (s += 4),
            (l.underlinePosition = a.readShort(i, s)),
            (s += 2),
            (l.underlineThickness = a.readShort(i, s)),
            (s += 2),
            l
          );
        }),
        e == null && (e = {}),
        e.U == null && (e.U = {}),
        (e.U.codeToGlyph = function (i, s) {
          var o = i.cmap,
            a = -1;
          if (
            (o.p0e4 != null
              ? (a = o.p0e4)
              : o.p3e1 != null
              ? (a = o.p3e1)
              : o.p1e0 != null
              ? (a = o.p1e0)
              : o.p0e3 != null && (a = o.p0e3),
            a == -1)
          )
            throw "no familiar platform and encoding!";
          var l = o.tables[a];
          if (l.format == 0) return s >= l.map.length ? 0 : l.map[s];
          if (l.format == 4) {
            for (var c = -1, u = 0; u < l.endCount.length; u++)
              if (s <= l.endCount[u]) {
                c = u;
                break;
              }
            return c == -1 || l.startCount[c] > s
              ? 0
              : 65535 &
                  (l.idRangeOffset[c] != 0
                    ? l.glyphIdArray[
                        s -
                          l.startCount[c] +
                          (l.idRangeOffset[c] >> 1) -
                          (l.idRangeOffset.length - c)
                      ]
                    : s + l.idDelta[c]);
          }
          if (l.format == 12) {
            if (s > l.groups[l.groups.length - 1][1]) return 0;
            for (u = 0; u < l.groups.length; u++) {
              var d = l.groups[u];
              if (d[0] <= s && s <= d[1]) return d[2] + (s - d[0]);
            }
            return 0;
          }
          throw "unknown cmap table format " + l.format;
        }),
        (e.U.glyphToPath = function (i, s) {
          var o = { cmds: [], crds: [] };
          if (i.SVG && i.SVG.entries[s]) {
            var a = i.SVG.entries[s];
            return a == null
              ? o
              : (typeof a == "string" &&
                  ((a = e.SVG.toPath(a)), (i.SVG.entries[s] = a)),
                a);
          }
          if (i.CFF) {
            var l = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: !1,
                width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                open: !1,
              },
              c = i.CFF,
              u = i.CFF.Private;
            if (c.ROS) {
              for (var d = 0; c.FDSelect[d + 2] <= s; ) d += 2;
              u = c.FDArray[c.FDSelect[d + 1]].Private;
            }
            e.U._drawCFF(i.CFF.CharStrings[s], l, c, u, o);
          } else i.glyf && e.U._drawGlyf(s, i, o);
          return o;
        }),
        (e.U._drawGlyf = function (i, s, o) {
          var a = s.glyf[i];
          a == null && (a = s.glyf[i] = e.glyf._parseGlyf(s, i)),
            a != null &&
              (a.noc > -1 ? e.U._simpleGlyph(a, o) : e.U._compoGlyph(a, s, o));
        }),
        (e.U._simpleGlyph = function (i, s) {
          for (var o = 0; o < i.noc; o++) {
            for (
              var a = o == 0 ? 0 : i.endPts[o - 1] + 1, l = i.endPts[o], c = a;
              c <= l;
              c++
            ) {
              var u = c == a ? l : c - 1,
                d = c == l ? a : c + 1,
                h = 1 & i.flags[c],
                m = 1 & i.flags[u],
                g = 1 & i.flags[d],
                x = i.xs[c],
                y = i.ys[c];
              if (c == a)
                if (h) {
                  if (!m) {
                    e.U.P.moveTo(s, x, y);
                    continue;
                  }
                  e.U.P.moveTo(s, i.xs[u], i.ys[u]);
                } else
                  m
                    ? e.U.P.moveTo(s, i.xs[u], i.ys[u])
                    : e.U.P.moveTo(s, (i.xs[u] + x) / 2, (i.ys[u] + y) / 2);
              h
                ? m && e.U.P.lineTo(s, x, y)
                : g
                ? e.U.P.qcurveTo(s, x, y, i.xs[d], i.ys[d])
                : e.U.P.qcurveTo(s, x, y, (x + i.xs[d]) / 2, (y + i.ys[d]) / 2);
            }
            e.U.P.closePath(s);
          }
        }),
        (e.U._compoGlyph = function (i, s, o) {
          for (var a = 0; a < i.parts.length; a++) {
            var l = { cmds: [], crds: [] },
              c = i.parts[a];
            e.U._drawGlyf(c.glyphIndex, s, l);
            for (var u = c.m, d = 0; d < l.crds.length; d += 2) {
              var h = l.crds[d],
                m = l.crds[d + 1];
              o.crds.push(h * u.a + m * u.b + u.tx),
                o.crds.push(h * u.c + m * u.d + u.ty);
            }
            for (d = 0; d < l.cmds.length; d++) o.cmds.push(l.cmds[d]);
          }
        }),
        (e.U._getGlyphClass = function (i, s) {
          var o = e._lctf.getInterval(s, i);
          return o == -1 ? 0 : s[o + 2];
        }),
        (e.U._applySubs = function (i, s, o, a) {
          for (var l = i.length - s - 1, c = 0; c < o.tabs.length; c++)
            if (o.tabs[c] != null) {
              var u,
                d = o.tabs[c];
              if (
                !d.coverage ||
                (u = e._lctf.coverageIndex(d.coverage, i[s])) != -1
              ) {
                if (o.ltype == 1)
                  i[s],
                    d.fmt == 1 ? (i[s] = i[s] + d.delta) : (i[s] = d.newg[u]);
                else if (o.ltype == 4)
                  for (var h = d.vals[u], m = 0; m < h.length; m++) {
                    var g = h[m],
                      x = g.chain.length;
                    if (!(x > l)) {
                      for (var y = !0, v = 0, _ = 0; _ < x; _++) {
                        for (; i[s + v + (1 + _)] == -1; ) v++;
                        g.chain[_] != i[s + v + (1 + _)] && (y = !1);
                      }
                      if (y) {
                        for (i[s] = g.nglyph, _ = 0; _ < x + v; _++)
                          i[s + _ + 1] = -1;
                        break;
                      }
                    }
                  }
                else if (o.ltype == 5 && d.fmt == 2)
                  for (
                    var S = e._lctf.getInterval(d.cDef, i[s]),
                      w = d.cDef[S + 2],
                      T = d.scset[w],
                      E = 0;
                    E < T.length;
                    E++
                  ) {
                    var M = T[E],
                      N = M.input;
                    if (!(N.length > l)) {
                      for (y = !0, _ = 0; _ < N.length; _++) {
                        var R = e._lctf.getInterval(d.cDef, i[s + 1 + _]);
                        if (S == -1 && d.cDef[R + 2] != N[_]) {
                          y = !1;
                          break;
                        }
                      }
                      if (y) {
                        var C = M.substLookupRecords;
                        for (m = 0; m < C.length; m += 2) C[m], C[m + 1];
                      }
                    }
                  }
                else if (o.ltype == 6 && d.fmt == 3) {
                  if (
                    !e.U._glsCovered(i, d.backCvg, s - d.backCvg.length) ||
                    !e.U._glsCovered(i, d.inptCvg, s) ||
                    !e.U._glsCovered(i, d.ahedCvg, s + d.inptCvg.length)
                  )
                    continue;
                  var L = d.lookupRec;
                  for (E = 0; E < L.length; E += 2) {
                    S = L[E];
                    var O = a[L[E + 1]];
                    e.U._applySubs(i, s + S, O, a);
                  }
                }
              }
            }
        }),
        (e.U._glsCovered = function (i, s, o) {
          for (var a = 0; a < s.length; a++)
            if (e._lctf.coverageIndex(s[a], i[o + a]) == -1) return !1;
          return !0;
        }),
        (e.U.glyphsToPath = function (i, s, o) {
          for (
            var a = { cmds: [], crds: [] }, l = 0, c = 0;
            c < s.length;
            c++
          ) {
            var u = s[c];
            if (u != -1) {
              for (
                var d = c < s.length - 1 && s[c + 1] != -1 ? s[c + 1] : 0,
                  h = e.U.glyphToPath(i, u),
                  m = 0;
                m < h.crds.length;
                m += 2
              )
                a.crds.push(h.crds[m] + l), a.crds.push(h.crds[m + 1]);
              for (o && a.cmds.push(o), m = 0; m < h.cmds.length; m++)
                a.cmds.push(h.cmds[m]);
              o && a.cmds.push("X"),
                (l += i.hmtx.aWidth[u]),
                c < s.length - 1 && (l += e.U.getPairAdjustment(i, u, d));
            }
          }
          return a;
        }),
        (e.U.P = {}),
        (e.U.P.moveTo = function (i, s, o) {
          i.cmds.push("M"), i.crds.push(s, o);
        }),
        (e.U.P.lineTo = function (i, s, o) {
          i.cmds.push("L"), i.crds.push(s, o);
        }),
        (e.U.P.curveTo = function (i, s, o, a, l, c, u) {
          i.cmds.push("C"), i.crds.push(s, o, a, l, c, u);
        }),
        (e.U.P.qcurveTo = function (i, s, o, a, l) {
          i.cmds.push("Q"), i.crds.push(s, o, a, l);
        }),
        (e.U.P.closePath = function (i) {
          i.cmds.push("Z");
        }),
        (e.U._drawCFF = function (i, s, o, a, l) {
          for (
            var c = s.stack,
              u = s.nStems,
              d = s.haveWidth,
              h = s.width,
              m = s.open,
              g = 0,
              x = s.x,
              y = s.y,
              v = 0,
              _ = 0,
              S = 0,
              w = 0,
              T = 0,
              E = 0,
              M = 0,
              N = 0,
              R = 0,
              C = 0,
              L = { val: 0, size: 0 };
            g < i.length;

          ) {
            e.CFF.getCharString(i, g, L);
            var O = L.val;
            if (((g += L.size), O == "o1" || O == "o18"))
              c.length % 2 != 0 && !d && (h = c.shift() + a.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (O == "o3" || O == "o23")
              c.length % 2 != 0 && !d && (h = c.shift() + a.nominalWidthX),
                (u += c.length >> 1),
                (c.length = 0),
                (d = !0);
            else if (O == "o4")
              c.length > 1 &&
                !d &&
                ((h = c.shift() + a.nominalWidthX), (d = !0)),
                m && e.U.P.closePath(l),
                (y += c.pop()),
                e.U.P.moveTo(l, x, y),
                (m = !0);
            else if (O == "o5")
              for (; c.length > 0; )
                (x += c.shift()), (y += c.shift()), e.U.P.lineTo(l, x, y);
            else if (O == "o6" || O == "o7")
              for (var D = c.length, B = O == "o6", $ = 0; $ < D; $++) {
                var G = c.shift();
                B ? (x += G) : (y += G), (B = !B), e.U.P.lineTo(l, x, y);
              }
            else if (O == "o8" || O == "o24") {
              D = c.length;
              for (var j = 0; j + 6 <= D; )
                (v = x + c.shift()),
                  (_ = y + c.shift()),
                  (S = v + c.shift()),
                  (w = _ + c.shift()),
                  (x = S + c.shift()),
                  (y = w + c.shift()),
                  e.U.P.curveTo(l, v, _, S, w, x, y),
                  (j += 6);
              O == "o24" &&
                ((x += c.shift()), (y += c.shift()), e.U.P.lineTo(l, x, y));
            } else {
              if (O == "o11") break;
              if (O == "o1234" || O == "o1235" || O == "o1236" || O == "o1237")
                O == "o1234" &&
                  ((_ = y),
                  (S = (v = x + c.shift()) + c.shift()),
                  (C = w = _ + c.shift()),
                  (E = w),
                  (N = y),
                  (x =
                    (M = (T = (R = S + c.shift()) + c.shift()) + c.shift()) +
                    c.shift()),
                  e.U.P.curveTo(l, v, _, S, w, R, C),
                  e.U.P.curveTo(l, T, E, M, N, x, y)),
                  O == "o1235" &&
                    ((v = x + c.shift()),
                    (_ = y + c.shift()),
                    (S = v + c.shift()),
                    (w = _ + c.shift()),
                    (R = S + c.shift()),
                    (C = w + c.shift()),
                    (T = R + c.shift()),
                    (E = C + c.shift()),
                    (M = T + c.shift()),
                    (N = E + c.shift()),
                    (x = M + c.shift()),
                    (y = N + c.shift()),
                    c.shift(),
                    e.U.P.curveTo(l, v, _, S, w, R, C),
                    e.U.P.curveTo(l, T, E, M, N, x, y)),
                  O == "o1236" &&
                    ((v = x + c.shift()),
                    (_ = y + c.shift()),
                    (S = v + c.shift()),
                    (C = w = _ + c.shift()),
                    (E = w),
                    (M = (T = (R = S + c.shift()) + c.shift()) + c.shift()),
                    (N = E + c.shift()),
                    (x = M + c.shift()),
                    e.U.P.curveTo(l, v, _, S, w, R, C),
                    e.U.P.curveTo(l, T, E, M, N, x, y)),
                  O == "o1237" &&
                    ((v = x + c.shift()),
                    (_ = y + c.shift()),
                    (S = v + c.shift()),
                    (w = _ + c.shift()),
                    (R = S + c.shift()),
                    (C = w + c.shift()),
                    (T = R + c.shift()),
                    (E = C + c.shift()),
                    (M = T + c.shift()),
                    (N = E + c.shift()),
                    Math.abs(M - x) > Math.abs(N - y)
                      ? (x = M + c.shift())
                      : (y = N + c.shift()),
                    e.U.P.curveTo(l, v, _, S, w, R, C),
                    e.U.P.curveTo(l, T, E, M, N, x, y));
              else if (O == "o14") {
                if (
                  (c.length > 0 &&
                    !d &&
                    ((h = c.shift() + o.nominalWidthX), (d = !0)),
                  c.length == 4)
                ) {
                  var U = c.shift(),
                    H = c.shift(),
                    V = c.shift(),
                    k = c.shift(),
                    W = e.CFF.glyphBySE(o, V),
                    ee = e.CFF.glyphBySE(o, k);
                  e.U._drawCFF(o.CharStrings[W], s, o, a, l),
                    (s.x = U),
                    (s.y = H),
                    e.U._drawCFF(o.CharStrings[ee], s, o, a, l);
                }
                m && (e.U.P.closePath(l), (m = !1));
              } else if (O == "o19" || O == "o20")
                c.length % 2 != 0 && !d && (h = c.shift() + a.nominalWidthX),
                  (u += c.length >> 1),
                  (c.length = 0),
                  (d = !0),
                  (g += (u + 7) >> 3);
              else if (O == "o21")
                c.length > 2 &&
                  !d &&
                  ((h = c.shift() + a.nominalWidthX), (d = !0)),
                  (y += c.pop()),
                  (x += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, x, y),
                  (m = !0);
              else if (O == "o22")
                c.length > 1 &&
                  !d &&
                  ((h = c.shift() + a.nominalWidthX), (d = !0)),
                  (x += c.pop()),
                  m && e.U.P.closePath(l),
                  e.U.P.moveTo(l, x, y),
                  (m = !0);
              else if (O == "o25") {
                for (; c.length > 6; )
                  (x += c.shift()), (y += c.shift()), e.U.P.lineTo(l, x, y);
                (v = x + c.shift()),
                  (_ = y + c.shift()),
                  (S = v + c.shift()),
                  (w = _ + c.shift()),
                  (x = S + c.shift()),
                  (y = w + c.shift()),
                  e.U.P.curveTo(l, v, _, S, w, x, y);
              } else if (O == "o26")
                for (c.length % 2 && (x += c.shift()); c.length > 0; )
                  (v = x),
                    (_ = y + c.shift()),
                    (x = S = v + c.shift()),
                    (y = (w = _ + c.shift()) + c.shift()),
                    e.U.P.curveTo(l, v, _, S, w, x, y);
              else if (O == "o27")
                for (c.length % 2 && (y += c.shift()); c.length > 0; )
                  (_ = y),
                    (S = (v = x + c.shift()) + c.shift()),
                    (w = _ + c.shift()),
                    (x = S + c.shift()),
                    (y = w),
                    e.U.P.curveTo(l, v, _, S, w, x, y);
              else if (O == "o10" || O == "o29") {
                var Y = O == "o10" ? a : o;
                if (c.length == 0) console.debug("error: empty stack");
                else {
                  var K = c.pop(),
                    ae = Y.Subrs[K + Y.Bias];
                  (s.x = x),
                    (s.y = y),
                    (s.nStems = u),
                    (s.haveWidth = d),
                    (s.width = h),
                    (s.open = m),
                    e.U._drawCFF(ae, s, o, a, l),
                    (x = s.x),
                    (y = s.y),
                    (u = s.nStems),
                    (d = s.haveWidth),
                    (h = s.width),
                    (m = s.open);
                }
              } else if (O == "o30" || O == "o31") {
                var se = c.length,
                  we = ((j = 0), O == "o31");
                for (j += se - (D = -3 & se); j < D; )
                  we
                    ? ((_ = y),
                      (S = (v = x + c.shift()) + c.shift()),
                      (y = (w = _ + c.shift()) + c.shift()),
                      D - j == 5 ? ((x = S + c.shift()), j++) : (x = S),
                      (we = !1))
                    : ((v = x),
                      (_ = y + c.shift()),
                      (S = v + c.shift()),
                      (w = _ + c.shift()),
                      (x = S + c.shift()),
                      D - j == 5 ? ((y = w + c.shift()), j++) : (y = w),
                      (we = !0)),
                    e.U.P.curveTo(l, v, _, S, w, x, y),
                    (j += 4);
              } else {
                if ((O + "").charAt(0) == "o")
                  throw (console.debug("Unknown operation: " + O, i), O);
                c.push(O);
              }
            }
          }
          (s.x = x),
            (s.y = y),
            (s.nStems = u),
            (s.haveWidth = d),
            (s.width = h),
            (s.open = m);
        });
      var t = e,
        r = { Typr: t };
      return (
        (n.Typr = t),
        (n.default = r),
        Object.defineProperty(n, "__esModule", { value: !0 }),
        n
      );
    })({}).Typr
  );
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/ function lJ() {
  return (function (n) {
    var e = Uint8Array,
      t = Uint16Array,
      r = Uint32Array,
      i = new e([
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,
        5, 5, 5, 5, 0, 0, 0, 0,
      ]),
      s = new e([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
        10, 11, 11, 12, 12, 13, 13, 0, 0,
      ]),
      o = new e([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]),
      a = function (O, D) {
        for (var B = new t(31), $ = 0; $ < 31; ++$) B[$] = D += 1 << O[$ - 1];
        var G = new r(B[30]);
        for ($ = 1; $ < 30; ++$)
          for (var j = B[$]; j < B[$ + 1]; ++j) G[j] = ((j - B[$]) << 5) | $;
        return [B, G];
      },
      l = a(i, 2),
      c = l[0],
      u = l[1];
    (c[28] = 258), (u[258] = 28);
    for (var d = a(s, 0)[0], h = new t(32768), m = 0; m < 32768; ++m) {
      var g = ((43690 & m) >>> 1) | ((21845 & m) << 1);
      (g =
        ((61680 & (g = ((52428 & g) >>> 2) | ((13107 & g) << 2))) >>> 4) |
        ((3855 & g) << 4)),
        (h[m] = (((65280 & g) >>> 8) | ((255 & g) << 8)) >>> 1);
    }
    var x = function (O, D, B) {
        for (var $ = O.length, G = 0, j = new t(D); G < $; ++G) ++j[O[G] - 1];
        var U,
          H = new t(D);
        for (G = 0; G < D; ++G) H[G] = (H[G - 1] + j[G - 1]) << 1;
        {
          U = new t(1 << D);
          var V = 15 - D;
          for (G = 0; G < $; ++G)
            if (O[G])
              for (
                var k = (G << 4) | O[G],
                  W = D - O[G],
                  ee = H[O[G] - 1]++ << W,
                  Y = ee | ((1 << W) - 1);
                ee <= Y;
                ++ee
              )
                U[h[ee] >>> V] = k;
        }
        return U;
      },
      y = new e(288);
    for (m = 0; m < 144; ++m) y[m] = 8;
    for (m = 144; m < 256; ++m) y[m] = 9;
    for (m = 256; m < 280; ++m) y[m] = 7;
    for (m = 280; m < 288; ++m) y[m] = 8;
    var v = new e(32);
    for (m = 0; m < 32; ++m) v[m] = 5;
    var _ = x(y, 9),
      S = x(v, 5),
      w = function (O) {
        for (var D = O[0], B = 1; B < O.length; ++B) O[B] > D && (D = O[B]);
        return D;
      },
      T = function (O, D, B) {
        var $ = (D / 8) | 0;
        return ((O[$] | (O[$ + 1] << 8)) >> (7 & D)) & B;
      },
      E = function (O, D) {
        var B = (D / 8) | 0;
        return (O[B] | (O[B + 1] << 8) | (O[B + 2] << 16)) >> (7 & D);
      },
      M = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
      ],
      N = function (O, D, B) {
        var $ = new Error(D || M[O]);
        if (
          (($.code = O),
          Error.captureStackTrace && Error.captureStackTrace($, N),
          !B)
        )
          throw $;
        return $;
      },
      R = function (O, D, B) {
        var $ = O.length;
        if (!$ || (B && !B.l && $ < 5)) return D || new e(0);
        var G = !D || B,
          j = !B || B.i;
        B || (B = {}), D || (D = new e(3 * $));
        var U,
          H = function (re) {
            var ze = D.length;
            if (re > ze) {
              var Xe = new e(Math.max(2 * ze, re));
              Xe.set(D), (D = Xe);
            }
          },
          V = B.f || 0,
          k = B.p || 0,
          W = B.b || 0,
          ee = B.l,
          Y = B.d,
          K = B.m,
          ae = B.n,
          se = 8 * $;
        do {
          if (!ee) {
            B.f = V = T(O, k, 1);
            var we = T(O, k + 1, 3);
            if (((k += 3), !we)) {
              var Be =
                  O[(z = (((U = k) / 8) | 0) + (7 & U && 1) + 4) - 4] |
                  (O[z - 3] << 8),
                te = z + Be;
              if (te > $) {
                j && N(0);
                break;
              }
              G && H(W + Be),
                D.set(O.subarray(z, te), W),
                (B.b = W += Be),
                (B.p = k = 8 * te);
              continue;
            }
            if (we == 1) (ee = _), (Y = S), (K = 9), (ae = 5);
            else if (we == 2) {
              var ge = T(O, k, 31) + 257,
                ie = T(O, k + 10, 15) + 4,
                me = ge + T(O, k + 5, 31) + 1;
              k += 14;
              for (var fe = new e(me), Ee = new e(19), Se = 0; Se < ie; ++Se)
                Ee[o[Se]] = T(O, k + 3 * Se, 7);
              k += 3 * ie;
              var Ue = w(Ee),
                Ce = (1 << Ue) - 1,
                X = x(Ee, Ue);
              for (Se = 0; Se < me; ) {
                var z,
                  q = X[T(O, k, Ce)];
                if (((k += 15 & q), (z = q >>> 4) < 16)) fe[Se++] = z;
                else {
                  var ue = 0,
                    de = 0;
                  for (
                    z == 16
                      ? ((de = 3 + T(O, k, 3)), (k += 2), (ue = fe[Se - 1]))
                      : z == 17
                      ? ((de = 3 + T(O, k, 7)), (k += 3))
                      : z == 18 && ((de = 11 + T(O, k, 127)), (k += 7));
                    de--;

                  )
                    fe[Se++] = ue;
                }
              }
              var he = fe.subarray(0, ge),
                Ie = fe.subarray(ge);
              (K = w(he)), (ae = w(Ie)), (ee = x(he, K)), (Y = x(Ie, ae));
            } else N(1);
            if (k > se) {
              j && N(0);
              break;
            }
          }
          G && H(W + 131072);
          for (var ke = (1 << K) - 1, Me = (1 << ae) - 1, et = k; ; et = k) {
            var Ne = (ue = ee[E(O, k) & ke]) >>> 4;
            if ((k += 15 & ue) > se) {
              j && N(0);
              break;
            }
            if ((ue || N(2), Ne < 256)) D[W++] = Ne;
            else {
              if (Ne == 256) {
                (et = k), (ee = null);
                break;
              }
              var We = Ne - 254;
              if (Ne > 264) {
                var ot = i[(Se = Ne - 257)];
                (We = T(O, k, (1 << ot) - 1) + c[Se]), (k += ot);
              }
              var nt = Y[E(O, k) & Me],
                Ke = nt >>> 4;
              if (
                (nt || N(3),
                (k += 15 & nt),
                (Ie = d[Ke]),
                Ke > 3 &&
                  ((ot = s[Ke]), (Ie += E(O, k) & ((1 << ot) - 1)), (k += ot)),
                k > se)
              ) {
                j && N(0);
                break;
              }
              G && H(W + 131072);
              for (var it = W + We; W < it; W += 4)
                (D[W] = D[W - Ie]),
                  (D[W + 1] = D[W + 1 - Ie]),
                  (D[W + 2] = D[W + 2 - Ie]),
                  (D[W + 3] = D[W + 3 - Ie]);
              W = it;
            }
          }
          (B.l = ee),
            (B.p = et),
            (B.b = W),
            ee && ((V = 1), (B.m = K), (B.d = Y), (B.n = ae));
        } while (!V);
        return W == D.length
          ? D
          : (function (re, ze, Xe) {
              (Xe == null || Xe > re.length) && (Xe = re.length);
              var le = new (re instanceof t ? t : re instanceof r ? r : e)(
                Xe - ze
              );
              return le.set(re.subarray(ze, Xe)), le;
            })(D, 0, W);
      },
      C = new e(0),
      L = typeof TextDecoder < "u" && new TextDecoder();
    try {
      L.decode(C, { stream: !0 });
    } catch {}
    return (
      (n.convert_streams = function (O) {
        var D = new DataView(O),
          B = 0;
        function $() {
          var ge = D.getUint16(B);
          return (B += 2), ge;
        }
        function G() {
          var ge = D.getUint32(B);
          return (B += 4), ge;
        }
        function j(ge) {
          Be.setUint16(te, ge), (te += 2);
        }
        function U(ge) {
          Be.setUint32(te, ge), (te += 4);
        }
        for (
          var H = {
              signature: G(),
              flavor: G(),
              length: G(),
              numTables: $(),
              reserved: $(),
              totalSfntSize: G(),
              majorVersion: $(),
              minorVersion: $(),
              metaOffset: G(),
              metaLength: G(),
              metaOrigLength: G(),
              privOffset: G(),
              privLength: G(),
            },
            V = 0;
          Math.pow(2, V) <= H.numTables;

        )
          V++;
        V--;
        for (
          var k = 16 * Math.pow(2, V),
            W = 16 * H.numTables - k,
            ee = 12,
            Y = [],
            K = 0;
          K < H.numTables;
          K++
        )
          Y.push({
            tag: G(),
            offset: G(),
            compLength: G(),
            origLength: G(),
            origChecksum: G(),
          }),
            (ee += 16);
        var ae,
          se = new Uint8Array(
            12 +
              16 * Y.length +
              Y.reduce(function (ge, ie) {
                return ge + ie.origLength + 4;
              }, 0)
          ),
          we = se.buffer,
          Be = new DataView(we),
          te = 0;
        return (
          U(H.flavor),
          j(H.numTables),
          j(k),
          j(V),
          j(W),
          Y.forEach(function (ge) {
            U(ge.tag),
              U(ge.origChecksum),
              U(ee),
              U(ge.origLength),
              (ge.outOffset = ee),
              (ee += ge.origLength) % 4 != 0 && (ee += 4 - (ee % 4));
          }),
          Y.forEach(function (ge) {
            var ie,
              me = O.slice(ge.offset, ge.offset + ge.compLength);
            if (ge.compLength != ge.origLength) {
              var fe = new Uint8Array(ge.origLength);
              (ie = new Uint8Array(me, 2)), R(ie, fe);
            } else fe = new Uint8Array(me);
            se.set(fe, ge.outOffset);
            var Ee = 0;
            (ee = ge.outOffset + ge.origLength) % 4 != 0 && (Ee = 4 - (ee % 4)),
              se.set(new Uint8Array(Ee).buffer, ge.outOffset + ge.origLength),
              (ae = ee + Ee);
          }),
          we.slice(0, ae)
        );
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({}).convert_streams;
}
function cJ(n, e) {
  const t = { M: 2, L: 2, Q: 4, C: 6, Z: 0 },
    r = {
      C: "18g,ca,368,1kz",
      D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
      R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
      L: "x9u,jff,a,fd,jv",
      T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n",
    },
    i = 1,
    s = 2,
    o = 4,
    a = 8,
    l = 16,
    c = 32;
  let u;
  function d(M) {
    if (!u) {
      const N = { R: s, L: i, D: o, C: l, U: c, T: a };
      u = new Map();
      for (let R in r) {
        let C = 0;
        r[R].split(",").forEach((L) => {
          let [O, D] = L.split("+");
          (O = parseInt(O, 36)),
            (D = D ? parseInt(D, 36) : 0),
            u.set((C += O), N[R]);
          for (let B = D; B--; ) u.set(++C, N[R]);
        });
      }
    }
    return u.get(M) || c;
  }
  const h = 1,
    m = 2,
    g = 3,
    x = 4,
    y = [null, "isol", "init", "fina", "medi"];
  function v(M) {
    const N = new Uint8Array(M.length);
    let R = c,
      C = h,
      L = -1;
    for (let O = 0; O < M.length; O++) {
      const D = M.codePointAt(O);
      let B = d(D) | 0,
        $ = h;
      B & a ||
        (R & (i | o | l)
          ? B & (s | o | l)
            ? (($ = g), (C === h || C === g) && N[L]++)
            : B & (i | c) && (C === m || C === x) && N[L]--
          : R & (s | c) && (C === m || C === x) && N[L]--,
        (C = N[O] = $),
        (R = B),
        (L = O),
        D > 65535 && O++);
    }
    return N;
  }
  function _(M, N) {
    const R = [];
    for (let L = 0; L < N.length; L++) {
      const O = N.codePointAt(L);
      O > 65535 && L++, R.push(n.U.codeToGlyph(M, O));
    }
    const C = M.GSUB;
    if (C) {
      const { lookupList: L, featureList: O } = C;
      let D;
      const B = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
        $ = [];
      O.forEach((G) => {
        if (B.test(G.tag))
          for (let j = 0; j < G.tab.length; j++) {
            if ($[G.tab[j]]) continue;
            $[G.tab[j]] = !0;
            const U = L[G.tab[j]],
              H = /^(isol|init|fina|medi)$/.test(G.tag);
            H && !D && (D = v(N));
            for (let V = 0; V < R.length; V++)
              (!D || !H || y[D[V]] === G.tag) && n.U._applySubs(R, V, U, L);
          }
      });
    }
    return R;
  }
  function S(M, N) {
    const R = new Int16Array(N.length * 3);
    let C = 0;
    for (; C < N.length; C++) {
      const B = N[C];
      if (B === -1) continue;
      R[C * 3 + 2] = M.hmtx.aWidth[B];
      const $ = M.GPOS;
      if ($) {
        const G = $.lookupList;
        for (let j = 0; j < G.length; j++) {
          const U = G[j];
          for (let H = 0; H < U.tabs.length; H++) {
            const V = U.tabs[H];
            if (U.ltype === 1) {
              if (n._lctf.coverageIndex(V.coverage, B) !== -1 && V.pos) {
                D(V.pos, C);
                break;
              }
            } else if (U.ltype === 2) {
              let k = null,
                W = L();
              if (W !== -1) {
                const ee = n._lctf.coverageIndex(V.coverage, N[W]);
                if (ee !== -1) {
                  if (V.fmt === 1) {
                    const Y = V.pairsets[ee];
                    for (let K = 0; K < Y.length; K++)
                      Y[K].gid2 === B && (k = Y[K]);
                  } else if (V.fmt === 2) {
                    const Y = n.U._getGlyphClass(N[W], V.classDef1),
                      K = n.U._getGlyphClass(B, V.classDef2);
                    k = V.matrix[Y][K];
                  }
                  if (k) {
                    k.val1 && D(k.val1, W), k.val2 && D(k.val2, C);
                    break;
                  }
                }
              }
            } else if (U.ltype === 4) {
              const k = n._lctf.coverageIndex(V.markCoverage, B);
              if (k !== -1) {
                const W = L(O),
                  ee =
                    W === -1 ? -1 : n._lctf.coverageIndex(V.baseCoverage, N[W]);
                if (ee !== -1) {
                  const Y = V.markArray[k],
                    K = V.baseArray[ee][Y.markClass];
                  (R[C * 3] = K.x - Y.x + R[W * 3] - R[W * 3 + 2]),
                    (R[C * 3 + 1] = K.y - Y.y + R[W * 3 + 1]);
                  break;
                }
              }
            } else if (U.ltype === 6) {
              const k = n._lctf.coverageIndex(V.mark1Coverage, B);
              if (k !== -1) {
                const W = L();
                if (W !== -1) {
                  const ee = N[W];
                  if (w(M, ee) === 3) {
                    const Y = n._lctf.coverageIndex(V.mark2Coverage, ee);
                    if (Y !== -1) {
                      const K = V.mark1Array[k],
                        ae = V.mark2Array[Y][K.markClass];
                      (R[C * 3] = ae.x - K.x + R[W * 3] - R[W * 3 + 2]),
                        (R[C * 3 + 1] = ae.y - K.y + R[W * 3 + 1]);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (M.kern && !M.cff) {
        const G = L();
        if (G !== -1) {
          const j = M.kern.glyph1.indexOf(N[G]);
          if (j !== -1) {
            const U = M.kern.rval[j].glyph2.indexOf(B);
            U !== -1 && (R[G * 3 + 2] += M.kern.rval[j].vals[U]);
          }
        }
      }
    }
    return R;
    function L(B) {
      for (let $ = C - 1; $ >= 0; $--)
        if (N[$] !== -1 && (!B || B(N[$]))) return $;
      return -1;
    }
    function O(B) {
      return w(M, B) === 1;
    }
    function D(B, $) {
      for (let G = 0; G < 3; G++) R[$ * 3 + G] += B[G] || 0;
    }
  }
  function w(M, N) {
    const R = M.GDEF && M.GDEF.glyphClassDef;
    return R ? n.U._getGlyphClass(N, R) : 0;
  }
  function T(...M) {
    for (let N = 0; N < M.length; N++) if (typeof M[N] == "number") return M[N];
  }
  function E(M) {
    const N = Object.create(null),
      R = M["OS/2"],
      C = M.hhea,
      L = M.head.unitsPerEm,
      O = T(R && R.sTypoAscender, C && C.ascender, L),
      D = {
        unitsPerEm: L,
        ascender: O,
        descender: T(R && R.sTypoDescender, C && C.descender, 0),
        capHeight: T(R && R.sCapHeight, O),
        xHeight: T(R && R.sxHeight, O),
        lineGap: T(R && R.sTypoLineGap, C && C.lineGap),
        supportsCodePoint(B) {
          return n.U.codeToGlyph(M, B) > 0;
        },
        forEachGlyph(B, $, G, j) {
          let U = 0;
          const H = (1 / D.unitsPerEm) * $,
            V = _(M, B);
          let k = 0;
          const W = S(M, V);
          return (
            V.forEach((ee, Y) => {
              if (ee !== -1) {
                let K = N[ee];
                if (!K) {
                  const { cmds: ae, crds: se } = n.U.glyphToPath(M, ee);
                  let we = "",
                    Be = 0;
                  for (let fe = 0, Ee = ae.length; fe < Ee; fe++) {
                    const Se = t[ae[fe]];
                    we += ae[fe];
                    for (let Ue = 1; Ue <= Se; Ue++)
                      we += (Ue > 1 ? "," : "") + se[Be++];
                  }
                  let te, ge, ie, me;
                  if (se.length) {
                    (te = ge = 1 / 0), (ie = me = -1 / 0);
                    for (let fe = 0, Ee = se.length; fe < Ee; fe += 2) {
                      let Se = se[fe],
                        Ue = se[fe + 1];
                      Se < te && (te = Se),
                        Ue < ge && (ge = Ue),
                        Se > ie && (ie = Se),
                        Ue > me && (me = Ue);
                    }
                  } else te = ie = ge = me = 0;
                  K = N[ee] = {
                    index: ee,
                    advanceWidth: M.hmtx.aWidth[ee],
                    xMin: te,
                    yMin: ge,
                    xMax: ie,
                    yMax: me,
                    path: we,
                  };
                }
                j.call(null, K, U + W[Y * 3] * H, W[Y * 3 + 1] * H, k),
                  (U += W[Y * 3 + 2] * H),
                  G && (U += G * $);
              }
              k += B.codePointAt(k) > 65535 ? 2 : 1;
            }),
            U
          );
        },
      };
    return D;
  }
  return function (N) {
    const R = new Uint8Array(N, 0, 4),
      C = n._bin.readASCII(R, 0, 4);
    if (C === "wOFF") N = e(N);
    else if (C === "wOF2") throw new Error("woff2 fonts not supported");
    return E(n.parse(N)[0]);
  };
}
const uJ = up({
  name: "Typr Font Parser",
  dependencies: [aJ, lJ, cJ],
  init(n, e, t) {
    const r = n(),
      i = e();
    return t(r, i);
  },
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/ function dJ() {
  return (function (n) {
    var e = function () {
      this.buckets = new Map();
    };
    (e.prototype.add = function (S) {
      var w = S >> 5;
      this.buckets.set(w, (this.buckets.get(w) || 0) | (1 << (31 & S)));
    }),
      (e.prototype.has = function (S) {
        var w = this.buckets.get(S >> 5);
        return w !== void 0 && (w & (1 << (31 & S))) != 0;
      }),
      (e.prototype.serialize = function () {
        var S = [];
        return (
          this.buckets.forEach(function (w, T) {
            S.push((+T).toString(36) + ":" + w.toString(36));
          }),
          S.join(",")
        );
      }),
      (e.prototype.deserialize = function (S) {
        var w = this;
        this.buckets.clear(),
          S.split(",").forEach(function (T) {
            var E = T.split(":");
            w.buckets.set(parseInt(E[0], 36), parseInt(E[1], 36));
          });
      });
    var t = Math.pow(2, 8),
      r = t - 1,
      i = ~r;
    function s(S) {
      var w = (function (E) {
          return E & i;
        })(S).toString(16),
        T = (function (E) {
          return (E & i) + t - 1;
        })(S).toString(16);
      return "codepoint-index/plane" + (S >> 16) + "/" + w + "-" + T + ".json";
    }
    function o(S, w) {
      var T = S & r,
        E = w.codePointAt((T / 6) | 0);
      return ((E = (E || 48) - 48) & (1 << T % 6)) != 0;
    }
    function a(S, w) {
      var T;
      ((T = S),
      T.replace(/U\+/gi, "")
        .replace(/^,+|,+$/g, "")
        .split(/,+/)
        .map(function (E) {
          return E.split("-").map(function (M) {
            return parseInt(M.trim(), 16);
          });
        })).forEach(function (E) {
        var M = E[0],
          N = E[1];
        N === void 0 && (N = M), w(M, N);
      });
    }
    function l(S, w) {
      a(S, function (T, E) {
        for (var M = T; M <= E; M++) w(M);
      });
    }
    var c = {},
      u = {},
      d = new WeakMap(),
      h =
        "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function m(S) {
      var w = d.get(S);
      return (
        w ||
          ((w = new e()),
          l(S.ranges, function (T) {
            return w.add(T);
          }),
          d.set(S, w)),
        w
      );
    }
    var g,
      x = new Map();
    function y(S, w, T) {
      return S[w]
        ? w
        : S[T]
        ? T
        : (function (E) {
            for (var M in E) return M;
          })(S);
    }
    function v(S, w) {
      var T = w;
      if (!S.includes(T)) {
        T = 1 / 0;
        for (var E = 0; E < S.length; E++)
          Math.abs(S[E] - w) < Math.abs(T - w) && (T = S[E]);
      }
      return T;
    }
    function _(S) {
      return (
        g ||
          ((g = new Set()),
          l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function (w) {
            g.add(w);
          })),
        g.has(S)
      );
    }
    return (
      (n.CodePointSet = e),
      (n.clearCache = function () {
        (c = {}), (u = {});
      }),
      (n.getFontsForString = function (S, w) {
        w === void 0 && (w = {});
        var T,
          E = w.lang;
        E === void 0 &&
          (E = new RegExp("\\p{Script=Hangul}", "u").test((T = S))
            ? "ko"
            : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(
                T
              )
            ? "ja"
            : "en");
        var M = w.category;
        M === void 0 && (M = "sans-serif");
        var N = w.style;
        N === void 0 && (N = "normal");
        var R = w.weight;
        R === void 0 && (R = 400);
        var C = (w.dataUrl || h).replace(/\/$/g, ""),
          L = new Map(),
          O = new Uint8Array(S.length),
          D = {},
          B = {},
          $ = new Array(S.length),
          G = new Map(),
          j = !1;
        function U(k) {
          var W = x.get(k);
          return (
            W ||
              ((W = fetch(C + "/" + k)
                .then(function (ee) {
                  if (!ee.ok) throw new Error(ee.statusText);
                  return ee.json().then(function (Y) {
                    if (!Array.isArray(Y) || Y[0] !== 1)
                      throw new Error(
                        "Incorrect schema version; need 1, got " + Y[0]
                      );
                    return Y[1];
                  });
                })
                .catch(function (ee) {
                  if (C !== h)
                    return (
                      j ||
                        (console.error(
                          'unicode-font-resolver: Failed loading from dataUrl "' +
                            C +
                            '", trying default CDN. ' +
                            ee.message
                        ),
                        (j = !0)),
                      (C = h),
                      x.delete(k),
                      U(k)
                    );
                  throw ee;
                })),
              x.set(k, W)),
            W
          );
        }
        for (
          var H = function (k) {
              var W = S.codePointAt(k),
                ee = s(W);
              ($[k] = ee),
                c[ee] ||
                  G.has(ee) ||
                  G.set(
                    ee,
                    U(ee).then(function (Y) {
                      c[ee] = Y;
                    })
                  ),
                W > 65535 && (k++, (V = k));
            },
            V = 0;
          V < S.length;
          V++
        )
          H(V);
        return Promise.all(G.values())
          .then(function () {
            G.clear();
            for (
              var k = function (ee) {
                  var Y = S.codePointAt(ee),
                    K = null,
                    ae = c[$[ee]],
                    se = void 0;
                  for (var we in ae) {
                    var Be = B[we];
                    if (
                      (Be === void 0 &&
                        (Be = B[we] = new RegExp(we).test(E || "en")),
                      Be)
                    ) {
                      for (var te in ((se = we), ae[we]))
                        if (o(Y, ae[we][te])) {
                          K = te;
                          break;
                        }
                      break;
                    }
                  }
                  if (!K) {
                    e: for (var ge in ae)
                      if (ge !== se) {
                        for (var ie in ae[ge])
                          if (o(Y, ae[ge][ie])) {
                            K = ie;
                            break e;
                          }
                      }
                  }
                  K ||
                    (console.debug("No font coverage for U+" + Y.toString(16)),
                    (K = "latin")),
                    ($[ee] = K),
                    u[K] ||
                      G.has(K) ||
                      G.set(
                        K,
                        U("font-meta/" + K + ".json").then(function (me) {
                          u[K] = me;
                        })
                      ),
                    Y > 65535 && (ee++, (W = ee));
                },
                W = 0;
              W < S.length;
              W++
            )
              k(W);
            return Promise.all(G.values());
          })
          .then(function () {
            for (var k, W = null, ee = 0; ee < S.length; ee++) {
              var Y = S.codePointAt(ee);
              if (W && (_(Y) || m(W).has(Y))) O[ee] = O[ee - 1];
              else {
                W = u[$[ee]];
                var K = D[W.id];
                if (!K) {
                  var ae = W.typeforms,
                    se = y(ae, M, "sans-serif"),
                    we = y(ae[se], N, "normal"),
                    Be = v(
                      (k = ae[se]) === null || k === void 0 ? void 0 : k[we],
                      R
                    );
                  K = D[W.id] =
                    C +
                    "/font-files/" +
                    W.id +
                    "/" +
                    se +
                    "." +
                    we +
                    "." +
                    Be +
                    ".woff";
                }
                var te = L.get(K);
                te == null && ((te = L.size), L.set(K, te)), (O[ee] = te);
              }
              Y > 65535 && (ee++, (O[ee] = O[ee - 1]));
            }
            return { fontUrls: Array.from(L.keys()), chars: O };
          });
      }),
      Object.defineProperty(n, "__esModule", { value: !0 }),
      n
    );
  })({});
}
function fJ(n, e) {
  const t = Object.create(null),
    r = Object.create(null);
  function i(o, a) {
    const l = (c) => {
      console.error(`Failure loading font ${o}`, c);
    };
    try {
      const c = new XMLHttpRequest();
      c.open("get", o, !0),
        (c.responseType = "arraybuffer"),
        (c.onload = function () {
          if (c.status >= 400) l(new Error(c.statusText));
          else if (c.status > 0)
            try {
              const u = n(c.response);
              (u.src = o), a(u);
            } catch (u) {
              l(u);
            }
        }),
        (c.onerror = l),
        c.send();
    } catch (c) {
      l(c);
    }
  }
  function s(o, a) {
    let l = t[o];
    l
      ? a(l)
      : r[o]
      ? r[o].push(a)
      : ((r[o] = [a]),
        i(o, (c) => {
          (c.src = o), (t[o] = c), r[o].forEach((u) => u(c)), delete r[o];
        }));
  }
  return function (
    o,
    a,
    {
      lang: l,
      fonts: c = [],
      style: u = "normal",
      weight: d = "normal",
      unicodeFontsURL: h,
    } = {}
  ) {
    const m = new Uint8Array(o.length),
      g = [];
    o.length || _();
    const x = new Map(),
      y = [];
    if (
      (u !== "italic" && (u = "normal"),
      typeof d != "number" && (d = d === "bold" ? 700 : 400),
      c && !Array.isArray(c) && (c = [c]),
      (c = c
        .slice()
        .filter((w) => !w.lang || w.lang.test(l))
        .reverse()),
      c.length)
    ) {
      let M = 0;
      (function N(R = 0) {
        for (let C = R, L = o.length; C < L; C++) {
          const O = o.codePointAt(C);
          if ((M === 1 && g[m[C - 1]].supportsCodePoint(O)) || /\s/.test(o[C]))
            (m[C] = m[C - 1]), M === 2 && (y[y.length - 1][1] = C);
          else
            for (let D = m[C], B = c.length; D <= B; D++)
              if (D === B) {
                const $ = M === 2 ? y[y.length - 1] : (y[y.length] = [C, C]);
                ($[1] = C), (M = 2);
              } else {
                m[C] = D;
                const { src: $, unicodeRange: G } = c[D];
                if (!G || S(O, G)) {
                  const j = t[$];
                  if (!j) {
                    s($, () => {
                      N(C);
                    });
                    return;
                  }
                  if (j.supportsCodePoint(O)) {
                    let U = x.get(j);
                    typeof U != "number" &&
                      ((U = g.length), g.push(j), x.set(j, U)),
                      (m[C] = U),
                      (M = 1);
                    break;
                  }
                }
              }
          O > 65535 &&
            C + 1 < L &&
            ((m[C + 1] = m[C]), C++, M === 2 && (y[y.length - 1][1] = C));
        }
        v();
      })();
    } else y.push([0, o.length - 1]), v();
    function v() {
      if (y.length) {
        const w = y.map((T) => o.substring(T[0], T[1] + 1)).join(`
`);
        e.getFontsForString(w, {
          lang: l || void 0,
          style: u,
          weight: d,
          dataUrl: h,
        }).then(({ fontUrls: T, chars: E }) => {
          const M = g.length;
          let N = 0;
          y.forEach((C) => {
            for (let L = 0, O = C[1] - C[0]; L <= O; L++)
              m[C[0] + L] = E[N++] + M;
            N++;
          });
          let R = 0;
          T.forEach((C, L) => {
            s(C, (O) => {
              (g[L + M] = O), ++R === T.length && _();
            });
          });
        });
      } else _();
    }
    function _() {
      a({ chars: m, fonts: g });
    }
    function S(w, T) {
      for (let E = 0; E < T.length; E++) {
        const [M, N = M] = T[E];
        if (M <= w && w <= N) return !0;
      }
      return !1;
    }
  };
}
const hJ = up({
  name: "FontResolver",
  dependencies: [fJ, uJ, dJ],
  init(n, e, t) {
    return n(e, t());
  },
});
function pJ(n, e) {
  const r =
      /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
    i = "[^\\S\\u00A0]",
    s = new RegExp(
      `${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`
    );
  function o(
    {
      text: g,
      lang: x,
      fonts: y,
      style: v,
      weight: _,
      preResolvedFonts: S,
      unicodeFontsURL: w,
    },
    T
  ) {
    const E = ({ chars: M, fonts: N }) => {
      let R, C;
      const L = [];
      for (let O = 0; O < M.length; O++)
        M[O] !== C
          ? ((C = M[O]), L.push((R = { start: O, end: O, fontObj: N[M[O]] })))
          : (R.end = O);
      T(L);
    };
    S
      ? E(S)
      : n(g, E, { lang: x, fonts: y, style: v, weight: _, unicodeFontsURL: w });
  }
  function a(
    {
      text: g = "",
      font: x,
      lang: y,
      sdfGlyphSize: v = 64,
      fontSize: _ = 400,
      fontWeight: S = 1,
      fontStyle: w = "normal",
      letterSpacing: T = 0,
      lineHeight: E = "normal",
      maxWidth: M = 1 / 0,
      direction: N,
      textAlign: R = "left",
      textIndent: C = 0,
      whiteSpace: L = "normal",
      overflowWrap: O = "normal",
      anchorX: D = 0,
      anchorY: B = 0,
      metricsOnly: $ = !1,
      unicodeFontsURL: G,
      preResolvedFonts: j = null,
      includeCaretPositions: U = !1,
      chunkedBoundsSize: H = 8192,
      colorRanges: V = null,
    },
    k
  ) {
    const W = d(),
      ee = { fontLoad: 0, typesetting: 0 };
    g.indexOf("\r") > -1 &&
      (console.info("Typesetter: got text with \\r chars; normalizing to \\n"),
      (g = g
        .replace(
          /\r\n/g,
          `
`
        )
        .replace(
          /\r/g,
          `
`
        ))),
      (_ = +_),
      (T = +T),
      (M = +M),
      (E = E || "normal"),
      (C = +C),
      o(
        {
          text: g,
          lang: y,
          style: w,
          weight: S,
          fonts: typeof x == "string" ? [{ src: x }] : x,
          unicodeFontsURL: G,
          preResolvedFonts: j,
        },
        (Y) => {
          ee.fontLoad = d() - W;
          const K = isFinite(M);
          let ae = null,
            se = null,
            we = null,
            Be = null,
            te = null,
            ge = null,
            ie = null,
            me = null,
            fe = 0,
            Ee = 0,
            Se = L !== "nowrap";
          const Ue = new Map(),
            Ce = d();
          let X = C,
            z = 0,
            q = new h();
          const ue = [q];
          Y.forEach((Me) => {
            const { fontObj: et } = Me,
              {
                ascender: Ne,
                descender: We,
                unitsPerEm: ot,
                lineGap: nt,
                capHeight: Ke,
                xHeight: it,
              } = et;
            let re = Ue.get(et);
            if (!re) {
              const xe = _ / ot,
                Ye = E === "normal" ? (Ne - We + nt) * xe : E * _,
                at = (Ye - (Ne - We) * xe) / 2,
                vt = Math.min(Ye, (Ne - We) * xe),
                dt = ((Ne + We) / 2) * xe + vt / 2;
              (re = {
                index: Ue.size,
                src: et.src,
                fontObj: et,
                fontSizeMult: xe,
                unitsPerEm: ot,
                ascender: Ne * xe,
                descender: We * xe,
                capHeight: Ke * xe,
                xHeight: it * xe,
                lineHeight: Ye,
                baseline: -at - Ne * xe,
                caretTop: dt,
                caretBottom: dt - vt,
              }),
                Ue.set(et, re);
            }
            const { fontSizeMult: ze } = re,
              Xe = g.slice(Me.start, Me.end + 1);
            let le, Re;
            et.forEachGlyph(Xe, _, T, (xe, Ye, at, vt) => {
              (Ye += z), (vt += Me.start), (le = Ye), (Re = xe);
              const dt = g.charAt(vt),
                mt = xe.advanceWidth * ze,
                kt = q.count;
              let lt;
              if (
                ("isEmpty" in xe ||
                  ((xe.isWhitespace = !!dt && new RegExp(i).test(dt)),
                  (xe.canBreakAfter = !!dt && s.test(dt)),
                  (xe.isEmpty =
                    xe.xMin === xe.xMax || xe.yMin === xe.yMax || r.test(dt))),
                !xe.isWhitespace && !xe.isEmpty && Ee++,
                Se && K && !xe.isWhitespace && Ye + mt + X > M && kt)
              ) {
                if (q.glyphAt(kt - 1).glyphObj.canBreakAfter)
                  (lt = new h()), (X = -Ye);
                else
                  for (let Nt = kt; Nt--; )
                    if (Nt === 0 && O === "break-word") {
                      (lt = new h()), (X = -Ye);
                      break;
                    } else if (q.glyphAt(Nt).glyphObj.canBreakAfter) {
                      lt = q.splitAt(Nt + 1);
                      const gn = lt.glyphAt(0).x;
                      X -= gn;
                      for (let dn = lt.count; dn--; ) lt.glyphAt(dn).x -= gn;
                      break;
                    }
                lt && ((q.isSoftWrapped = !0), (q = lt), ue.push(q), (fe = M));
              }
              let St = q.glyphAt(q.count);
              (St.glyphObj = xe),
                (St.x = Ye + X),
                (St.y = at),
                (St.width = mt),
                (St.charIndex = vt),
                (St.fontData = re),
                dt ===
                  `
` && ((q = new h()), ue.push(q), (X = -(Ye + mt + T * _) + C));
            }),
              (z = le + Re.advanceWidth * ze + T * _);
          });
          let de = 0;
          ue.forEach((Me) => {
            let et = !0;
            for (let Ne = Me.count; Ne--; ) {
              const We = Me.glyphAt(Ne);
              et &&
                !We.glyphObj.isWhitespace &&
                ((Me.width = We.x + We.width),
                Me.width > fe && (fe = Me.width),
                (et = !1));
              let {
                lineHeight: ot,
                capHeight: nt,
                xHeight: Ke,
                baseline: it,
              } = We.fontData;
              ot > Me.lineHeight && (Me.lineHeight = ot);
              const re = it - Me.baseline;
              re < 0 && ((Me.baseline += re), (Me.cap += re), (Me.ex += re)),
                (Me.cap = Math.max(Me.cap, Me.baseline + nt)),
                (Me.ex = Math.max(Me.ex, Me.baseline + Ke));
            }
            (Me.baseline -= de),
              (Me.cap -= de),
              (Me.ex -= de),
              (de += Me.lineHeight);
          });
          let he = 0,
            Ie = 0;
          if (
            (D &&
              (typeof D == "number"
                ? (he = -D)
                : typeof D == "string" &&
                  (he =
                    -fe *
                    (D === "left"
                      ? 0
                      : D === "center"
                      ? 0.5
                      : D === "right"
                      ? 1
                      : c(D)))),
            B &&
              (typeof B == "number"
                ? (Ie = -B)
                : typeof B == "string" &&
                  (Ie =
                    B === "top"
                      ? 0
                      : B === "top-baseline"
                      ? -ue[0].baseline
                      : B === "top-cap"
                      ? -ue[0].cap
                      : B === "top-ex"
                      ? -ue[0].ex
                      : B === "middle"
                      ? de / 2
                      : B === "bottom"
                      ? de
                      : B === "bottom-baseline"
                      ? -ue[ue.length - 1].baseline
                      : c(B) * de)),
            !$)
          ) {
            const Me = e.getEmbeddingLevels(g, N);
            (ae = new Uint16Array(Ee)),
              (se = new Uint8Array(Ee)),
              (we = new Float32Array(Ee * 2)),
              (Be = {}),
              (ie = [1 / 0, 1 / 0, -1 / 0, -1 / 0]),
              (me = []),
              U && (ge = new Float32Array(g.length * 4)),
              V && (te = new Uint8Array(Ee * 3));
            let et = 0,
              Ne = -1,
              We = -1,
              ot,
              nt;
            if (
              (ue.forEach((Ke, it) => {
                let { count: re, width: ze } = Ke;
                if (re > 0) {
                  let Xe = 0;
                  for (
                    let vt = re;
                    vt-- && Ke.glyphAt(vt).glyphObj.isWhitespace;

                  )
                    Xe++;
                  let le = 0,
                    Re = 0;
                  if (R === "center") le = (fe - ze) / 2;
                  else if (R === "right") le = fe - ze;
                  else if (R === "justify" && Ke.isSoftWrapped) {
                    let vt = 0;
                    for (let dt = re - Xe; dt--; )
                      Ke.glyphAt(dt).glyphObj.isWhitespace && vt++;
                    Re = (fe - ze) / vt;
                  }
                  if (Re || le) {
                    let vt = 0;
                    for (let dt = 0; dt < re; dt++) {
                      let mt = Ke.glyphAt(dt);
                      const kt = mt.glyphObj;
                      (mt.x += le + vt),
                        Re !== 0 &&
                          kt.isWhitespace &&
                          dt < re - Xe &&
                          ((vt += Re), (mt.width += Re));
                    }
                  }
                  const xe = e.getReorderSegments(
                    g,
                    Me,
                    Ke.glyphAt(0).charIndex,
                    Ke.glyphAt(Ke.count - 1).charIndex
                  );
                  for (let vt = 0; vt < xe.length; vt++) {
                    const [dt, mt] = xe[vt];
                    let kt = 1 / 0,
                      lt = -1 / 0;
                    for (let St = 0; St < re; St++)
                      if (Ke.glyphAt(St).charIndex >= dt) {
                        let Nt = St,
                          gn = St;
                        for (; gn < re; gn++) {
                          let dn = Ke.glyphAt(gn);
                          if (dn.charIndex > mt) break;
                          gn < re - Xe &&
                            ((kt = Math.min(kt, dn.x)),
                            (lt = Math.max(lt, dn.x + dn.width)));
                        }
                        for (let dn = Nt; dn < gn; dn++) {
                          const gr = Ke.glyphAt(dn);
                          gr.x = lt - (gr.x + gr.width - kt);
                        }
                        break;
                      }
                  }
                  let Ye;
                  const at = (vt) => (Ye = vt);
                  for (let vt = 0; vt < re; vt++) {
                    const dt = Ke.glyphAt(vt);
                    Ye = dt.glyphObj;
                    const mt = Ye.index,
                      kt = Me.levels[dt.charIndex] & 1;
                    if (kt) {
                      const lt = e.getMirroredCharacter(g[dt.charIndex]);
                      lt && dt.fontData.fontObj.forEachGlyph(lt, 0, 0, at);
                    }
                    if (U) {
                      const { charIndex: lt, fontData: St } = dt,
                        Nt = dt.x + he,
                        gn = dt.x + dt.width + he;
                      (ge[lt * 4] = kt ? gn : Nt),
                        (ge[lt * 4 + 1] = kt ? Nt : gn),
                        (ge[lt * 4 + 2] = Ke.baseline + St.caretBottom + Ie),
                        (ge[lt * 4 + 3] = Ke.baseline + St.caretTop + Ie);
                      const dn = lt - Ne;
                      dn > 1 && u(ge, Ne, dn), (Ne = lt);
                    }
                    if (V) {
                      const { charIndex: lt } = dt;
                      for (; lt > We; )
                        We++, V.hasOwnProperty(We) && (nt = V[We]);
                    }
                    if (!Ye.isWhitespace && !Ye.isEmpty) {
                      const lt = et++,
                        { fontSizeMult: St, src: Nt, index: gn } = dt.fontData,
                        dn = Be[Nt] || (Be[Nt] = {});
                      dn[mt] ||
                        (dn[mt] = {
                          path: Ye.path,
                          pathBounds: [Ye.xMin, Ye.yMin, Ye.xMax, Ye.yMax],
                        });
                      const gr = dt.x + he,
                        Kr = dt.y + Ke.baseline + Ie;
                      (we[lt * 2] = gr), (we[lt * 2 + 1] = Kr);
                      const Ur = gr + Ye.xMin * St,
                        kr = Kr + Ye.yMin * St,
                        zr = gr + Ye.xMax * St,
                        Ai = Kr + Ye.yMax * St;
                      Ur < ie[0] && (ie[0] = Ur),
                        kr < ie[1] && (ie[1] = kr),
                        zr > ie[2] && (ie[2] = zr),
                        Ai > ie[3] && (ie[3] = Ai),
                        lt % H === 0 &&
                          ((ot = {
                            start: lt,
                            end: lt,
                            rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          }),
                          me.push(ot)),
                        ot.end++;
                      const vr = ot.rect;
                      if (
                        (Ur < vr[0] && (vr[0] = Ur),
                        kr < vr[1] && (vr[1] = kr),
                        zr > vr[2] && (vr[2] = zr),
                        Ai > vr[3] && (vr[3] = Ai),
                        (ae[lt] = mt),
                        (se[lt] = gn),
                        V)
                      ) {
                        const Ps = lt * 3;
                        (te[Ps] = (nt >> 16) & 255),
                          (te[Ps + 1] = (nt >> 8) & 255),
                          (te[Ps + 2] = nt & 255);
                      }
                    }
                  }
                }
              }),
              ge)
            ) {
              const Ke = g.length - Ne;
              Ke > 1 && u(ge, Ne, Ke);
            }
          }
          const ke = [];
          Ue.forEach(
            ({
              index: Me,
              src: et,
              unitsPerEm: Ne,
              ascender: We,
              descender: ot,
              lineHeight: nt,
              capHeight: Ke,
              xHeight: it,
            }) => {
              ke[Me] = {
                src: et,
                unitsPerEm: Ne,
                ascender: We,
                descender: ot,
                lineHeight: nt,
                capHeight: Ke,
                xHeight: it,
              };
            }
          ),
            (ee.typesetting = d() - Ce),
            k({
              glyphIds: ae,
              glyphFontIndices: se,
              glyphPositions: we,
              glyphData: Be,
              fontData: ke,
              caretPositions: ge,
              glyphColors: te,
              chunkedBounds: me,
              fontSize: _,
              topBaseline: Ie + ue[0].baseline,
              blockBounds: [he, Ie - de, he + fe, Ie],
              visibleBounds: ie,
              timings: ee,
            });
        }
      );
  }
  function l(g, x) {
    a({ ...g, metricsOnly: !0 }, (y) => {
      const [v, _, S, w] = y.blockBounds;
      x({ width: S - v, height: w - _ });
    });
  }
  function c(g) {
    let x = g.match(/^([\d.]+)%$/),
      y = x ? parseFloat(x[1]) : NaN;
    return isNaN(y) ? 0 : y / 100;
  }
  function u(g, x, y) {
    const v = g[x * 4],
      _ = g[x * 4 + 1],
      S = g[x * 4 + 2],
      w = g[x * 4 + 3],
      T = (_ - v) / y;
    for (let E = 0; E < y; E++) {
      const M = (x + E) * 4;
      (g[M] = v + T * E),
        (g[M + 1] = v + T * (E + 1)),
        (g[M + 2] = S),
        (g[M + 3] = w);
    }
  }
  function d() {
    return (self.performance || Date).now();
  }
  function h() {
    this.data = [];
  }
  const m = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return (
    (h.prototype = {
      width: 0,
      lineHeight: 0,
      baseline: 0,
      cap: 0,
      ex: 0,
      isSoftWrapped: !1,
      get count() {
        return Math.ceil(this.data.length / m.length);
      },
      glyphAt(g) {
        let x = h.flyweight;
        return (x.data = this.data), (x.index = g), x;
      },
      splitAt(g) {
        let x = new h();
        return (x.data = this.data.splice(g * m.length)), x;
      },
    }),
    (h.flyweight = m.reduce(
      (g, x, y, v) => (
        Object.defineProperty(g, x, {
          get() {
            return this.data[this.index * m.length + y];
          },
          set(_) {
            this.data[this.index * m.length + y] = _;
          },
        }),
        g
      ),
      { data: null, index: 0 }
    )),
    { typeset: a, measure: l }
  );
}
const cd = () => (self.performance || Date).now(),
  V_ = Dz();
let RL;
function mJ(n, e, t, r, i, s, o, a, l, c, u = !0) {
  return u
    ? vJ(n, e, t, r, i, s, o, a, l, c).then(
        null,
        (d) => (
          RL ||
            (console.warn("WebGL SDF generation failed, falling back to JS", d),
            (RL = !0)),
          PL(n, e, t, r, i, s, o, a, l, c)
        )
      )
    : PL(n, e, t, r, i, s, o, a, l, c);
}
const Ex = [],
  gJ = 5;
let IM = 0;
function Uz() {
  const n = cd();
  for (; Ex.length && cd() - n < gJ; ) Ex.shift()();
  IM = Ex.length ? setTimeout(Uz, 0) : 0;
}
const vJ = (...n) =>
    new Promise((e, t) => {
      Ex.push(() => {
        const r = cd();
        try {
          V_.webgl.generateIntoCanvas(...n), e({ timing: cd() - r });
        } catch (i) {
          t(i);
        }
      }),
        IM || (IM = setTimeout(Uz, 0));
    }),
  yJ = 4,
  xJ = 2e3,
  NL = {};
let _J = 0;
function PL(n, e, t, r, i, s, o, a, l, c) {
  const u = "TroikaTextSDFGenerator_JS_" + (_J++ % yJ);
  let d = NL[u];
  return (
    d ||
      (d = NL[u] =
        {
          workerModule: up({
            name: u,
            workerId: u,
            dependencies: [Dz, cd],
            init(h, m) {
              const g = h().javascript.generate;
              return function (...x) {
                const y = m();
                return { textureData: g(...x), timing: m() - y };
              };
            },
            getTransferables(h) {
              return [h.textureData.buffer];
            },
          }),
          requests: 0,
          idleTimer: null,
        }),
    d.requests++,
    clearTimeout(d.idleTimer),
    d.workerModule(n, e, t, r, i, s).then(({ textureData: h, timing: m }) => {
      const g = cd(),
        x = new Uint8Array(h.length * 4);
      for (let y = 0; y < h.length; y++) x[y * 4 + c] = h[y];
      return (
        V_.webglUtils.renderImageData(o, x, a, l, n, e, 1 << (3 - c)),
        (m += cd() - g),
        --d.requests === 0 &&
          (d.idleTimer = setTimeout(() => {
            ZQ(u);
          }, xJ)),
        { timing: m }
      );
    })
  );
}
function SJ(n) {
  n._warm || (V_.webgl.isSupported(n), (n._warm = !0));
}
const AJ = V_.webglUtils.resizeWebGLCanvasWithoutClearing,
  zf = {
    defaultFontURL: null,
    unicodeFontsURL: null,
    sdfGlyphSize: 64,
    sdfMargin: 1 / 16,
    sdfExponent: 9,
    textureWidth: 2048,
  },
  wJ = new pt();
function Pf() {
  return (self.performance || Date).now();
}
const IL = Object.create(null);
function kz(n, e) {
  n = MJ({}, n);
  const t = Pf(),
    { defaultFontURL: r } = zf,
    i = [];
  if (
    (r && i.push({ label: "default", src: LL(r) }),
    n.font && i.push({ label: "user", src: LL(n.font) }),
    (n.font = i),
    (n.text = "" + n.text),
    (n.sdfGlyphSize = n.sdfGlyphSize || zf.sdfGlyphSize),
    (n.unicodeFontsURL = n.unicodeFontsURL || zf.unicodeFontsURL),
    n.colorRanges != null)
  ) {
    let h = {};
    for (let m in n.colorRanges)
      if (n.colorRanges.hasOwnProperty(m)) {
        let g = n.colorRanges[m];
        typeof g != "number" && (g = wJ.set(g).getHex()), (h[m] = g);
      }
    n.colorRanges = h;
  }
  Object.freeze(n);
  const { textureWidth: s, sdfExponent: o } = zf,
    { sdfGlyphSize: a } = n,
    l = (s / a) * 4;
  let c = IL[a];
  if (!c) {
    const h = document.createElement("canvas");
    (h.width = s),
      (h.height = (a * 256) / l),
      (c = IL[a] =
        {
          glyphCount: 0,
          sdfGlyphSize: a,
          sdfCanvas: h,
          sdfTexture: new Fr(h, void 0, void 0, void 0, dr, dr),
          contextLost: !1,
          glyphsByFont: new Map(),
        }),
      (c.sdfTexture.generateMipmaps = !1),
      bJ(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  CJ(n).then((h) => {
    const {
        glyphIds: m,
        glyphFontIndices: g,
        fontData: x,
        glyphPositions: y,
        fontSize: v,
        timings: _,
      } = h,
      S = [],
      w = new Float32Array(m.length * 4);
    let T = 0,
      E = 0;
    const M = Pf(),
      N = x.map((D) => {
        let B = c.glyphsByFont.get(D.src);
        return B || c.glyphsByFont.set(D.src, (B = new Map())), B;
      });
    m.forEach((D, B) => {
      const $ = g[B],
        { src: G, unitsPerEm: j } = x[$];
      let U = N[$].get(D);
      if (!U) {
        const { path: ee, pathBounds: Y } = h.glyphData[G][D],
          K =
            (Math.max(Y[2] - Y[0], Y[3] - Y[1]) / a) * (zf.sdfMargin * a + 0.5),
          ae = c.glyphCount++,
          se = [Y[0] - K, Y[1] - K, Y[2] + K, Y[3] + K];
        N[$].set(D, (U = { path: ee, atlasIndex: ae, sdfViewBox: se })),
          S.push(U);
      }
      const { sdfViewBox: H } = U,
        V = y[E++],
        k = y[E++],
        W = v / j;
      (w[T++] = V + H[0] * W),
        (w[T++] = k + H[1] * W),
        (w[T++] = V + H[2] * W),
        (w[T++] = k + H[3] * W),
        (m[B] = U.atlasIndex);
    }),
      (_.quads = (_.quads || 0) + (Pf() - M));
    const R = Pf();
    _.sdf = {};
    const C = d.height,
      L = Math.ceil(c.glyphCount / l),
      O = Math.pow(2, Math.ceil(Math.log2(L * a)));
    O > C &&
      (console.info(`Increasing SDF texture size ${C}->${O}`),
      AJ(d, s, O),
      u.dispose()),
      Promise.all(
        S.map((D) =>
          zz(D, c, n.gpuAccelerateSDF).then(({ timing: B }) => {
            _.sdf[D.atlasIndex] = B;
          })
        )
      ).then(() => {
        S.length && !c.contextLost && (Bz(c), (u.needsUpdate = !0)),
          (_.sdfTotal = Pf() - R),
          (_.total = Pf() - t),
          e(
            Object.freeze({
              parameters: n,
              sdfTexture: u,
              sdfGlyphSize: a,
              sdfExponent: o,
              glyphBounds: w,
              glyphAtlasIndices: m,
              glyphColors: h.glyphColors,
              caretPositions: h.caretPositions,
              chunkedBounds: h.chunkedBounds,
              ascender: h.ascender,
              descender: h.descender,
              lineHeight: h.lineHeight,
              capHeight: h.capHeight,
              xHeight: h.xHeight,
              topBaseline: h.topBaseline,
              blockBounds: h.blockBounds,
              visibleBounds: h.visibleBounds,
              timings: h.timings,
            })
          );
      });
  }),
    Promise.resolve().then(() => {
      c.contextLost || SJ(d);
    });
}
function zz(
  { path: n, atlasIndex: e, sdfViewBox: t },
  { sdfGlyphSize: r, sdfCanvas: i, contextLost: s },
  o
) {
  if (s) return Promise.resolve({ timing: -1 });
  const { textureWidth: a, sdfExponent: l } = zf,
    c = Math.max(t[2] - t[0], t[3] - t[1]),
    u = Math.floor(e / 4),
    d = (u % (a / r)) * r,
    h = Math.floor(u / (a / r)) * r,
    m = e % 4;
  return mJ(r, r, n, t, c, l, i, d, h, m, o);
}
function bJ(n) {
  const e = n.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), (n.contextLost = !0);
  }),
    e.addEventListener("webglcontextrestored", (t) => {
      console.log("Context Restored", t), (n.contextLost = !1);
      const r = [];
      n.glyphsByFont.forEach((i) => {
        i.forEach((s) => {
          r.push(zz(s, n, !0));
        });
      }),
        Promise.all(r).then(() => {
          Bz(n), (n.sdfTexture.needsUpdate = !0);
        });
    });
}
function EJ({ font: n, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e)
    ? e.join(`
`)
    : "" + e;
  kz({ font: n, sdfGlyphSize: t, text: i }, r);
}
function MJ(n, e) {
  for (let t in e) e.hasOwnProperty(t) && (n[t] = e[t]);
  return n;
}
let Dy;
function LL(n) {
  return (
    Dy || (Dy = typeof document > "u" ? {} : document.createElement("a")),
    (Dy.href = n),
    Dy.href
  );
}
function Bz(n) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = n,
      { width: r, height: i } = e,
      s = n.sdfCanvas.getContext("webgl");
    let o = t.image.data;
    (!o || o.length !== r * i * 4) &&
      ((o = new Uint8Array(r * i * 4)),
      (t.image = { width: r, height: i, data: o }),
      (t.flipY = !1),
      (t.isDataTexture = !0)),
      s.readPixels(0, 0, r, i, s.RGBA, s.UNSIGNED_BYTE, o);
  }
}
const TJ = up({
    name: "Typesetter",
    dependencies: [pJ, hJ, JQ],
    init(n, e, t) {
      return n(e, t());
    },
  }),
  CJ = up({
    name: "Typesetter",
    dependencies: [TJ],
    init(n) {
      return function (e) {
        return new Promise((t) => {
          n.typeset(e, t);
        });
      };
    },
    getTransferables(n) {
      const e = [];
      for (let t in n) n[t] && n[t].buffer && e.push(n[t].buffer);
      return e;
    },
  }),
  OL = {};
function RJ(n) {
  let e = OL[n];
  if (!e) {
    const t = new Gl(1, 1, n, n),
      r = t.clone(),
      i = t.attributes,
      s = r.attributes,
      o = new qt(),
      a = i.uv.count;
    for (let l = 0; l < a; l++)
      (s.position.array[l * 3] *= -1), (s.normal.array[l * 3 + 2] *= -1);
    ["position", "normal", "uv"].forEach((l) => {
      o.setAttribute(l, new At([...i[l].array, ...s[l].array], i[l].itemSize));
    }),
      o.setIndex([...t.index.array, ...r.index.array.map((l) => l + a)]),
      o.translate(0.5, 0.5, 0),
      (e = OL[n] = o);
  }
  return e;
}
const NJ = "aTroikaGlyphBounds",
  DL = "aTroikaGlyphIndex",
  PJ = "aTroikaGlyphColor";
class IJ extends O2 {
  constructor() {
    super(),
      (this.detail = 1),
      (this.curveRadius = 0),
      (this.groups = [
        { start: 0, count: 1 / 0, materialIndex: 0 },
        { start: 0, count: 1 / 0, materialIndex: 1 },
      ]),
      (this.boundingSphere = new mi()),
      (this.boundingBox = new zi());
  }
  computeBoundingSphere() {}
  computeBoundingBox() {}
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === pi ? t / 2 : 0, e === Ys ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      (this._detail = e), (typeof e != "number" || e < 1) && (e = 1);
      let t = RJ(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }),
        this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && ((this._curveRadius = e), this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, r, i, s) {
    Ww(this, NJ, e, 4),
      Ww(this, DL, t, 1),
      Ww(this, PJ, s, 3),
      (this._blockBounds = r),
      (this._chunkedBounds = i),
      (this.instanceCount = t.length),
      this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: s, min: o, max: a, sin: l, cos: c } = Math,
          u = i / 2,
          d = i * 2,
          h = Math.abs(t),
          m = e[0] / h,
          g = e[2] / h,
          x = s((m + u) / d) !== s((g + u) / d) ? -h : o(l(m) * h, l(g) * h),
          y = s((m - u) / d) !== s((g - u) / d) ? h : a(l(m) * h, l(g) * h),
          v =
            s((m + i) / d) !== s((g + i) / d)
              ? h * 2
              : a(h - c(m) * h, h - c(g) * h);
        r.min.set(x, e[1], t < 0 ? -v : 0), r.max.set(y, e[3], t < 0 ? 0 : v);
      } else r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(DL).count,
      r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let s = r[i].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x) break;
      }
    this.instanceCount = t;
  }
}
function Ww(n, e, t, r) {
  const i = n.getAttribute(e);
  t
    ? i && i.array.length === t.length
      ? (i.array.set(t), (i.needsUpdate = !0))
      : (n.setAttribute(e, new Hc(t, r)),
        delete n._maxInstanceCount,
        n.dispose())
    : i && n.deleteAttribute(e);
}
const LJ = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
  OJ = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
  DJ = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
  FJ = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function UJ(n) {
  const e = PM(n, {
    chained: !0,
    extensions: { derivatives: !0 },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new He() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new rn(0, 0, 0, 0) },
      uTroikaClipRect: { value: new rn(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new He() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new pt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Qt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 },
    },
    vertexDefs: LJ,
    vertexTransform: OJ,
    fragmentDefs: DJ,
    fragmentColorTransform: FJ,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return (
        i.test(r) &&
          ((r = r
            .replace(i, "varying vec3 vTroikaGlyphColor")
            .replace(/\bdiffuse\b/g, "vTroikaGlyphColor")),
          i.test(t) ||
            (t = t.replace(
              Fz,
              `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
            ))),
        { vertexShader: t, fragmentShader: r }
      );
    },
  });
  return (
    (e.transparent = !0),
    Object.defineProperties(e, {
      isTroikaTextMaterial: { value: !0 },
      shadowSide: {
        get() {
          return this.side;
        },
        set() {},
      },
    }),
    e
  );
}
const W2 = new Za({ color: 16777215, side: Ys, transparent: !0 }),
  FL = 8421504,
  UL = new Ut(),
  Fy = new Q(),
  jw = new Q(),
  ym = [],
  kJ = new Q(),
  $w = "+x+y";
function kL(n) {
  return Array.isArray(n) ? n[0] : n;
}
let Vz = () => {
    const n = new qn(new Gl(1, 1), W2);
    return (Vz = () => n), n;
  },
  Hz = () => {
    const n = new qn(new Gl(1, 1, 32, 1), W2);
    return (Hz = () => n), n;
  };
const zJ = { type: "syncstart" },
  BJ = { type: "synccomplete" },
  Gz = [
    "font",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lang",
    "letterSpacing",
    "lineHeight",
    "maxWidth",
    "overflowWrap",
    "text",
    "direction",
    "textAlign",
    "textIndent",
    "whiteSpace",
    "anchorX",
    "anchorY",
    "colorRanges",
    "sdfGlyphSize",
  ],
  VJ = Gz.concat(
    "material",
    "color",
    "depthOffset",
    "clipRect",
    "curveRadius",
    "orientation",
    "glyphGeometryDetail"
  );
let Wz = class extends qn {
  constructor() {
    const e = new IJ();
    super(e, null),
      (this.text = ""),
      (this.anchorX = 0),
      (this.anchorY = 0),
      (this.curveRadius = 0),
      (this.direction = "auto"),
      (this.font = null),
      (this.unicodeFontsURL = null),
      (this.fontSize = 0.1),
      (this.fontWeight = "normal"),
      (this.fontStyle = "normal"),
      (this.lang = null),
      (this.letterSpacing = 0),
      (this.lineHeight = "normal"),
      (this.maxWidth = 1 / 0),
      (this.overflowWrap = "normal"),
      (this.textAlign = "left"),
      (this.textIndent = 0),
      (this.whiteSpace = "normal"),
      (this.material = null),
      (this.color = null),
      (this.colorRanges = null),
      (this.outlineWidth = 0),
      (this.outlineColor = 0),
      (this.outlineOpacity = 1),
      (this.outlineBlur = 0),
      (this.outlineOffsetX = 0),
      (this.outlineOffsetY = 0),
      (this.strokeWidth = 0),
      (this.strokeColor = FL),
      (this.strokeOpacity = 1),
      (this.fillOpacity = 1),
      (this.depthOffset = 0),
      (this.clipRect = null),
      (this.orientation = $w),
      (this.glyphGeometryDetail = 1),
      (this.sdfGlyphSize = null),
      (this.gpuAccelerateSDF = !0),
      (this.debugSDF = !1);
  }
  sync(e) {
    this._needsSync &&
      ((this._needsSync = !1),
      this._isSyncing
        ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e)
        : ((this._isSyncing = !0),
          this.dispatchEvent(zJ),
          kz(
            {
              text: this.text,
              font: this.font,
              lang: this.lang,
              fontSize: this.fontSize || 0.1,
              fontWeight: this.fontWeight || "normal",
              fontStyle: this.fontStyle || "normal",
              letterSpacing: this.letterSpacing || 0,
              lineHeight: this.lineHeight || "normal",
              maxWidth: this.maxWidth,
              direction: this.direction || "auto",
              textAlign: this.textAlign,
              textIndent: this.textIndent,
              whiteSpace: this.whiteSpace,
              overflowWrap: this.overflowWrap,
              anchorX: this.anchorX,
              anchorY: this.anchorY,
              colorRanges: this.colorRanges,
              includeCaretPositions: !0,
              sdfGlyphSize: this.sdfGlyphSize,
              gpuAccelerateSDF: this.gpuAccelerateSDF,
              unicodeFontsURL: this.unicodeFontsURL,
            },
            (t) => {
              (this._isSyncing = !1),
                (this._textRenderInfo = t),
                this.geometry.updateGlyphs(
                  t.glyphBounds,
                  t.glyphAtlasIndices,
                  t.blockBounds,
                  t.chunkedBounds,
                  t.glyphColors
                );
              const r = this._queuedSyncs;
              r &&
                ((this._queuedSyncs = null),
                (this._needsSync = !0),
                this.sync(() => {
                  r.forEach((i) => i && i());
                })),
                this.dispatchEvent(BJ),
                e && e();
            }
          )));
  }
  onBeforeRender(e, t, r, i, s, o) {
    this.sync(),
      s.isTroikaTextMaterial && this._prepareForRender(s),
      (s._hadOwnSide = s.hasOwnProperty("side")),
      this.geometry.setSide((s._actualSide = s.side)),
      (s.side = ja);
  }
  onAfterRender(e, t, r, i, s, o) {
    s._hadOwnSide ? (s.side = s._actualSide) : delete s.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let e = this._derivedMaterial;
    const t =
      this._baseMaterial ||
      this._defaultMaterial ||
      (this._defaultMaterial = W2.clone());
    if (
      ((!e || e.baseMaterial !== t) &&
        ((e = this._derivedMaterial = UJ(t)),
        t.addEventListener("dispose", function r() {
          t.removeEventListener("dispose", r), e.dispose();
        })),
      this.outlineWidth ||
        this.outlineBlur ||
        this.outlineOffsetX ||
        this.outlineOffsetY)
    ) {
      let r = e._outlineMtl;
      return (
        r ||
          ((r = e._outlineMtl =
            Object.create(e, { id: { value: e.id + 0.1 } })),
          (r.isTextOutlineMaterial = !0),
          (r.depthWrite = !1),
          (r.map = null),
          e.addEventListener("dispose", function i() {
            e.removeEventListener("dispose", i), r.dispose();
          })),
        [r, e]
      );
    } else return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial
      ? ((this._derivedMaterial = e), (this._baseMaterial = e.baseMaterial))
      : (this._baseMaterial = e);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return kL(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return kL(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial,
      r = e.uniforms,
      i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: a, blockBounds: l } = i;
      (r.uTroikaSDFTexture.value = a),
        r.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height),
        (r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize),
        (r.uTroikaSDFExponent.value = i.sdfExponent),
        r.uTroikaTotalBounds.value.fromArray(l),
        (r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors);
      let c = 0,
        u = 0,
        d = 0,
        h,
        m,
        g,
        x = 0,
        y = 0;
      if (t) {
        let {
          outlineWidth: _,
          outlineOffsetX: S,
          outlineOffsetY: w,
          outlineBlur: T,
          outlineOpacity: E,
        } = this;
        (c = this._parsePercent(_) || 0),
          (u = Math.max(0, this._parsePercent(T) || 0)),
          (h = E),
          (x = this._parsePercent(S) || 0),
          (y = this._parsePercent(w) || 0);
      } else
        (d = Math.max(0, this._parsePercent(this.strokeWidth) || 0)),
          d &&
            ((g = this.strokeColor),
            r.uTroikaStrokeColor.value.set(g ?? FL),
            (m = this.strokeOpacity),
            m == null && (m = 1)),
          (h = this.fillOpacity);
      (r.uTroikaDistanceOffset.value = c),
        r.uTroikaPositionOffset.value.set(x, y),
        (r.uTroikaBlurRadius.value = u),
        (r.uTroikaStrokeWidth.value = d),
        (r.uTroikaStrokeOpacity.value = m),
        (r.uTroikaFillOpacity.value = h ?? 1),
        (r.uTroikaCurveRadius.value = this.curveRadius || 0);
      let v = this.clipRect;
      if (v && Array.isArray(v) && v.length === 4)
        r.uTroikaClipRect.value.fromArray(v);
      else {
        const _ = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(l[0] - _, l[1] - _, l[2] + _, l[3] + _);
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    (r.uTroikaSDFDebug.value = !!this.debugSDF),
      (e.polygonOffset = !!this.depthOffset),
      (e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0);
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null) delete e.color;
    else {
      const a = e.hasOwnProperty("color") ? e.color : (e.color = new pt());
      (s !== a._input || typeof s == "object") && a.set((a._input = s));
    }
    let o = this.orientation || $w;
    if (o !== e._orientation) {
      let a = r.uTroikaOrient.value;
      o = o.replace(/[^-+xyz]/g, "");
      let l = o !== $w && o.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (l) {
        let [, c, u, d, h] = l;
        (Fy.set(0, 0, 0)[u] = c === "-" ? 1 : -1),
          (jw.set(0, 0, 0)[h] = d === "-" ? -1 : 1),
          UL.lookAt(kJ, Fy.cross(jw), jw),
          a.setFromMatrix4(UL);
      } else a.identity();
      e._orientation = o;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/),
        r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new He()) {
    t.copy(e);
    const r = this.curveRadius;
    return (
      r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t
    );
  }
  worldPositionToTextCoords(e, t = new He()) {
    return Fy.copy(e), this.localPositionToTextCoords(this.worldToLocal(Fy), t);
  }
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const s = r.blockBounds,
        o = i ? Hz() : Vz(),
        a = o.geometry,
        { position: l, uv: c } = a.attributes;
      for (let u = 0; u < c.count; u++) {
        let d = s[0] + c.getX(u) * (s[2] - s[0]);
        const h = s[1] + c.getY(u) * (s[3] - s[1]);
        let m = 0;
        i && ((m = i - Math.cos(d / i) * i), (d = Math.sin(d / i) * i)),
          l.setXYZ(u, d, h, m);
      }
      (a.boundingSphere = this.geometry.boundingSphere),
        (a.boundingBox = this.geometry.boundingBox),
        (o.matrixWorld = this.matrixWorld),
        (o.material.side = this.material.side),
        (ym.length = 0),
        o.raycast(e, ym);
      for (let u = 0; u < ym.length; u++) (ym[u].object = this), t.push(ym[u]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return (
      super.copy(e),
      (this.geometry = t),
      VJ.forEach((r) => {
        this[r] = e[r];
      }),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
Gz.forEach((n) => {
  const e = "_private_" + n;
  Object.defineProperty(Wz.prototype, n, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && ((this[e] = t), (this._needsSync = !0));
    },
  });
});
const lr = I.forwardRef(
    (
      {
        sdfGlyphSize: n = 64,
        anchorX: e = "center",
        anchorY: t = "middle",
        font: r,
        fontSize: i = 1,
        children: s,
        characters: o,
        onSync: a,
        ...l
      },
      c
    ) => {
      const u = Oa(({ invalidate: g }) => g),
        [d] = I.useState(() => new Wz()),
        [h, m] = I.useMemo(() => {
          const g = [];
          let x = "";
          return (
            I.Children.forEach(s, (y) => {
              typeof y == "string" || typeof y == "number"
                ? (x += y)
                : g.push(y);
            }),
            [g, x]
          );
        }, [s]);
      return (
        mz(
          () => new Promise((g) => EJ({ font: r, characters: o }, g)),
          ["troika-text", r, o]
        ),
        I.useLayoutEffect(
          () =>
            void d.sync(() => {
              u(), a && a(d);
            })
        ),
        I.useEffect(() => () => d.dispose(), [d]),
        I.createElement(
          "primitive",
          an(
            {
              object: d,
              ref: c,
              font: r,
              text: m,
              anchorX: e,
              anchorY: t,
              fontSize: i,
              sdfGlyphSize: n,
            },
            l
          ),
          h
        )
      );
    }
  ),
  HJ = I.forwardRef(
    (
      {
        makeDefault: n,
        camera: e,
        regress: t,
        domElement: r,
        enableDamping: i = !0,
        keyEvents: s = !1,
        onChange: o,
        onStart: a,
        onEnd: l,
        ...c
      },
      u
    ) => {
      const d = Oa((E) => E.invalidate),
        h = Oa((E) => E.camera),
        m = Oa((E) => E.gl),
        g = Oa((E) => E.events),
        x = Oa((E) => E.setEvents),
        y = Oa((E) => E.set),
        v = Oa((E) => E.get),
        _ = Oa((E) => E.performance),
        S = e || h,
        w = r || g.connected || m.domElement,
        T = I.useMemo(() => new $Q(S), [S]);
      return (
        V2(() => {
          T.enabled && T.update();
        }, -1),
        I.useEffect(
          () => (
            s && T.connect(s === !0 ? w : s),
            T.connect(w),
            () => void T.dispose()
          ),
          [s, w, t, T, d]
        ),
        I.useEffect(() => {
          const E = (R) => {
              d(), t && _.regress(), o && o(R);
            },
            M = (R) => {
              a && a(R);
            },
            N = (R) => {
              l && l(R);
            };
          return (
            T.addEventListener("change", E),
            T.addEventListener("start", M),
            T.addEventListener("end", N),
            () => {
              T.removeEventListener("start", M),
                T.removeEventListener("end", N),
                T.removeEventListener("change", E);
            }
          );
        }, [o, a, l, T, d, x]),
        I.useEffect(() => {
          if (n) {
            const E = v().controls;
            return y({ controls: T }), () => y({ controls: E });
          }
        }, [n, T]),
        I.createElement(
          "primitive",
          an({ ref: u, object: T, enableDamping: i }, c)
        )
      );
    }
  );
var jz = { exports: {} },
  GJ = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  WJ = GJ,
  jJ = WJ;
function $z() {}
function Xz() {}
Xz.resetWarningCache = $z;
var $J = function () {
  function n(r, i, s, o, a, l) {
    if (l !== jJ) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: Xz,
    resetWarningCache: $z,
  };
  return (t.PropTypes = t), t;
};
jz.exports = $J();
var XJ = jz.exports;
const mc = Qh(XJ);
function YJ(n, e) {
  const t = n + "Geometry";
  return I.forwardRef(({ args: r, children: i, ...s }, o) => {
    const a = I.useRef(null);
    return (
      I.useImperativeHandle(o, () => a.current),
      I.useLayoutEffect(() => void (e == null ? void 0 : e(a.current))),
      I.createElement(
        "mesh",
        an({ ref: a }, s),
        I.createElement(t, { attach: "geometry", args: r }),
        i
      )
    );
  });
}
const wr = YJ("box"),
  zL = {
    enabled: !1,
    files: {},
    add: function (n, e) {
      this.enabled !== !1 && (this.files[n] = e);
    },
    get: function (n) {
      if (this.enabled !== !1) return this.files[n];
    },
    remove: function (n) {
      delete this.files[n];
    },
    clear: function () {
      this.files = {};
    },
  };
class qJ {
  constructor(e, t, r) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.itemStart = function (u) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), (s = !0);
      }),
      (this.itemEnd = function (u) {
        o++,
          i.onProgress !== void 0 && i.onProgress(u, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, d) {
        return c.push(u, d), this;
      }),
      (this.removeHandler = function (u) {
        const d = c.indexOf(u);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let d = 0, h = c.length; d < h; d += 2) {
          const m = c[d],
            g = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return g;
        }
        return null;
      });
  }
}
const KJ = new qJ();
class j2 {
  constructor(e) {
    (this.manager = e !== void 0 ? e : KJ),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, s) {
      r.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
j2.DEFAULT_MATERIAL_NAME = "__DEFAULT";
function LM(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
class ZJ extends j2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = zL.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = LM("img");
    function l() {
      u(), zL.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(d) {
      u(), i && i(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class QJ {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const Yz = 300,
  BL = 1e3,
  Uy = 1001,
  VL = 1002,
  JJ = 1006,
  eee = 1008,
  tee = 1009,
  nee = 1023,
  ree = "",
  Di = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
function qz() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Di[n & 255] +
    Di[(n >> 8) & 255] +
    Di[(n >> 16) & 255] +
    Di[(n >> 24) & 255] +
    "-" +
    Di[e & 255] +
    Di[(e >> 8) & 255] +
    "-" +
    Di[((e >> 16) & 15) | 64] +
    Di[(e >> 24) & 255] +
    "-" +
    Di[(t & 63) | 128] +
    Di[(t >> 8) & 255] +
    "-" +
    Di[(t >> 16) & 255] +
    Di[(t >> 24) & 255] +
    Di[r & 255] +
    Di[(r >> 8) & 255] +
    Di[(r >> 16) & 255] +
    Di[(r >> 24) & 255]
  ).toLowerCase();
}
function iee(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
class Km {
  constructor(e = 0, t = 0) {
    (Km.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(
      Math.max(e, Math.min(t, r))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(iee(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * r - o * i + e.x), (this.y = s * i + o * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class H_ {
  constructor(e, t, r, i, s, o, a, l, c) {
    (H_.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, c);
  }
  set(e, t, r, i, s, o, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = a),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = r),
      (u[7] = o),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[3],
      l = r[6],
      c = r[1],
      u = r[4],
      d = r[7],
      h = r[2],
      m = r[5],
      g = r[8],
      x = i[0],
      y = i[3],
      v = i[6],
      _ = i[1],
      S = i[4],
      w = i[7],
      T = i[2],
      E = i[5],
      M = i[8];
    return (
      (s[0] = o * x + a * _ + l * T),
      (s[3] = o * y + a * S + l * E),
      (s[6] = o * v + a * w + l * M),
      (s[1] = c * x + u * _ + d * T),
      (s[4] = c * y + u * S + d * E),
      (s[7] = c * v + u * w + d * M),
      (s[2] = h * x + m * _ + g * T),
      (s[5] = h * y + m * S + g * E),
      (s[8] = h * v + m * w + g * M),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * o * u - t * a * c - r * s * u + r * a * l + i * s * c - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * o - a * c,
      h = a * l - u * s,
      m = c * s - o * l,
      g = t * d + r * h + i * m;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / g;
    return (
      (e[0] = d * x),
      (e[1] = (i * c - u * r) * x),
      (e[2] = (a * r - i * o) * x),
      (e[3] = h * x),
      (e[4] = (u * t - i * l) * x),
      (e[5] = (i * s - a * t) * x),
      (e[6] = m * x),
      (e[7] = (r * l - c * t) * x),
      (e[8] = (o * t - r * s) * x),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        r * l,
        r * c,
        -r * (l * o + c * a) + o + e,
        -i * c,
        i * l,
        -i * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Xw.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Xw.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Xw.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Xw = new H_();
function Yw(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
let If;
class see {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      If === void 0 && (If = LM("canvas")),
        (If.width = e.width),
        (If.height = e.height);
      const r = If.getContext("2d");
      e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (t = If);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = LM("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let o = 0; o < s.length; o++) s[o] = Yw(s[o] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(Yw(t[r] / 255) * 255))
          : (t[r] = Yw(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let oee = 0;
class aee {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: oee++ }),
      (this.uuid = qz()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? s.push(qw(i[o].image)) : s.push(qw(i[o]));
      } else s = qw(i);
      r.url = s;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function qw(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? see.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let lee = 0;
class Fc extends QJ {
  constructor(
    e = Fc.DEFAULT_IMAGE,
    t = Fc.DEFAULT_MAPPING,
    r = Uy,
    i = Uy,
    s = JJ,
    o = eee,
    a = nee,
    l = tee,
    c = Fc.DEFAULT_ANISOTROPY,
    u = ree
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: lee++ }),
      (this.uuid = qz()),
      (this.name = ""),
      (this.source = new aee(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Km(0, 0)),
      (this.repeat = new Km(1, 1)),
      (this.center = new Km(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new H_()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Yz) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case BL:
          e.x = e.x - Math.floor(e.x);
          break;
        case Uy:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case VL:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case BL:
          e.y = e.y - Math.floor(e.y);
          break;
        case Uy:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case VL:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Fc.DEFAULT_IMAGE = null;
Fc.DEFAULT_MAPPING = Yz;
Fc.DEFAULT_ANISOTROPY = 1;
class Nm extends j2 {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new Fc(),
      o = new ZJ(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        r,
        i
      ),
      s
    );
  }
}
const cee =
    "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/4QDQRXhpZgAASUkqAAgAAAADAA4BAgCGAAAAMgAAABoBBQABAAAAuAAAABsBBQABAAAAwAAAAAAAAABQb3N0ZXIgb2Ygb2xkIGZpbG0gLSB2aW50YWdlIHN0eWxlLiBEYXJrIGdyZXkgYmxhbmsgYmFja2Ryb3AgYmFubmVyIHdpdGggZHVzdCwgc2NyYXRjaCwgc2N1ZmYuIFRvcCB2aWV3IG9mIGNvbmNyZXRlLCBtZXRhbCwgd29vZCB0YWJsZSwBAAABAAAALAEAAAEAAAD/4QX2aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj4KCTxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CgkJPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczpJcHRjNHhtcENvcmU9Imh0dHA6Ly9pcHRjLm9yZy9zdGQvSXB0YzR4bXBDb3JlLzEuMC94bWxucy8iICAgeG1sbnM6R2V0dHlJbWFnZXNHSUZUPSJodHRwOi8veG1wLmdldHR5aW1hZ2VzLmNvbS9naWZ0LzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGx1cz0iaHR0cDovL25zLnVzZXBsdXMub3JnL2xkZi94bXAvMS4wLyIgIHhtbG5zOmlwdGNFeHQ9Imh0dHA6Ly9pcHRjLm9yZy9zdGQvSXB0YzR4bXBFeHQvMjAwOC0wMi0yOS8iIHhtbG5zOnhtcFJpZ2h0cz0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3JpZ2h0cy8iIHBob3Rvc2hvcDpDcmVkaXQ9IkdldHR5IEltYWdlcyIgR2V0dHlJbWFnZXNHSUZUOkFzc2V0SUQ9IjEwNTA0NDMwODIiIHhtcFJpZ2h0czpXZWJTdGF0ZW1lbnQ9Imh0dHBzOi8vd3d3LmlzdG9ja3Bob3RvLmNvbS9sZWdhbC9saWNlbnNlLWFncmVlbWVudD91dG1fbWVkaXVtPW9yZ2FuaWMmYW1wO3V0bV9zb3VyY2U9Z29vZ2xlJmFtcDt1dG1fY2FtcGFpZ249aXB0Y3VybCIgcGx1czpEYXRhTWluaW5nPSJodHRwOi8vbnMudXNlcGx1cy5vcmcvbGRmL3ZvY2FiL0RNSS1QUk9ISUJJVEVELUVYQ0VQVFNFQVJDSEVOR0lORUlOREVYSU5HIiA+CjxkYzpjcmVhdG9yPjxyZGY6U2VxPjxyZGY6bGk+YWxlbmFzcGw8L3JkZjpsaT48L3JkZjpTZXE+PC9kYzpjcmVhdG9yPjxkYzpkZXNjcmlwdGlvbj48cmRmOkFsdD48cmRmOmxpIHhtbDpsYW5nPSJ4LWRlZmF1bHQiPlBvc3RlciBvZiBvbGQgZmlsbSAtIHZpbnRhZ2Ugc3R5bGUuIERhcmsgZ3JleSBibGFuayBiYWNrZHJvcCBiYW5uZXIgd2l0aCBkdXN0LCBzY3JhdGNoLCBzY3VmZi4gVG9wIHZpZXcgb2YgY29uY3JldGUsIG1ldGFsLCB3b29kIHRhYmxlPC9yZGY6bGk+PC9yZGY6QWx0PjwvZGM6ZGVzY3JpcHRpb24+CjxwbHVzOkxpY2Vuc29yPjxyZGY6U2VxPjxyZGY6bGkgcmRmOnBhcnNlVHlwZT0nUmVzb3VyY2UnPjxwbHVzOkxpY2Vuc29yVVJMPmh0dHBzOi8vd3d3LmlzdG9ja3Bob3RvLmNvbS9waG90by9saWNlbnNlLWdtMTA1MDQ0MzA4Mi0/dXRtX21lZGl1bT1vcmdhbmljJmFtcDt1dG1fc291cmNlPWdvb2dsZSZhbXA7dXRtX2NhbXBhaWduPWlwdGN1cmw8L3BsdXM6TGljZW5zb3JVUkw+PC9yZGY6bGk+PC9yZGY6U2VxPjwvcGx1czpMaWNlbnNvcj4KCQk8L3JkZjpEZXNjcmlwdGlvbj4KCTwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cjw/eHBhY2tldCBlbmQ9InciPz4K/+0AxlBob3Rvc2hvcCAzLjAAOEJJTQQEAAAAAACpHAJQAAhhbGVuYXNwbBwCeACGUG9zdGVyIG9mIG9sZCBmaWxtIC0gdmludGFnZSBzdHlsZS4gRGFyayBncmV5IGJsYW5rIGJhY2tkcm9wIGJhbm5lciB3aXRoIGR1c3QsIHNjcmF0Y2gsIHNjdWZmLiBUb3AgdmlldyBvZiBjb25jcmV0ZSwgbWV0YWwsIHdvb2QgdGFibGUcAm4ADEdldHR5IEltYWdlcwD/2wBDAAgICAkICQsLCwsLCw0MDQ0NDQ0NDQ0NDQ0ODg4REREODg4NDQ4OEBARERITEhERERETExQUFBgYFxccHB0iIin/xABSAAEBAQEAAAAAAAAAAAAAAAAAAQIHAQEAAAAAAAAAAAAAAAAAAAAAEAEBAQEBAQAAAAAAAAAAAAAAAREhMUERAQAAAAAAAAAAAAAAAAAAAAD/wAARCAFoAoADASIAAhIAAxIA/9oADAMBAAIRAxEAPwDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKgAAAACoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKALEWJQABQBEVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAFAAVkUAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAEUAEUoAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqAAoAA1IvEtqzoAzWW6zQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAFBoAT1fDAAZ20aZAAAAQFAEAAAFAEUABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABTGpAAgAAiY3xABINVkARFqAAAAAAAoIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqCgCqzoANxKyoAirLiAArKgCCoAIAACoACooAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKp8QAVAAFiCACqgAKgAAgAACgAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAogAKIoAigAAAAIAAAAAqAAoAAioAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0yoAiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIACiAAogAKIAD//2Q==",
  uee = "images/display-BfKZ46GT.png",
  dee = "images/nature-Ckd5Zzvw.jpg",
  fee = "images/linux-DR6-HlGt.png";
function ci(n) {
  return `Minified Redux error #${n}; visit https://redux.js.org/Errors?code=${n} for the full message or use the non-minified dev environment for full errors. `;
}
var hee = (typeof Symbol == "function" && Symbol.observable) || "@@observable",
  HL = hee,
  Kw = () => Math.random().toString(36).substring(7).split("").join("."),
  pee = {
    INIT: `@@redux/INIT${Kw()}`,
    REPLACE: `@@redux/REPLACE${Kw()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${Kw()}`,
  },
  v1 = pee;
function $2(n) {
  if (typeof n != "object" || n === null) return !1;
  let e = n;
  for (; Object.getPrototypeOf(e) !== null; ) e = Object.getPrototypeOf(e);
  return Object.getPrototypeOf(n) === e || Object.getPrototypeOf(n) === null;
}
function Kz(n, e, t) {
  if (typeof n != "function") throw new Error(ci(2));
  if (
    (typeof e == "function" && typeof t == "function") ||
    (typeof t == "function" && typeof arguments[3] == "function")
  )
    throw new Error(ci(0));
  if (
    (typeof e == "function" && typeof t > "u" && ((t = e), (e = void 0)),
    typeof t < "u")
  ) {
    if (typeof t != "function") throw new Error(ci(1));
    return t(Kz)(n, e);
  }
  let r = n,
    i = e,
    s = new Map(),
    o = s,
    a = 0,
    l = !1;
  function c() {
    o === s &&
      ((o = new Map()),
      s.forEach((y, v) => {
        o.set(v, y);
      }));
  }
  function u() {
    if (l) throw new Error(ci(3));
    return i;
  }
  function d(y) {
    if (typeof y != "function") throw new Error(ci(4));
    if (l) throw new Error(ci(5));
    let v = !0;
    c();
    const _ = a++;
    return (
      o.set(_, y),
      function () {
        if (v) {
          if (l) throw new Error(ci(6));
          (v = !1), c(), o.delete(_), (s = null);
        }
      }
    );
  }
  function h(y) {
    if (!$2(y)) throw new Error(ci(7));
    if (typeof y.type > "u") throw new Error(ci(8));
    if (typeof y.type != "string") throw new Error(ci(17));
    if (l) throw new Error(ci(9));
    try {
      (l = !0), (i = r(i, y));
    } finally {
      l = !1;
    }
    return (
      (s = o).forEach((_) => {
        _();
      }),
      y
    );
  }
  function m(y) {
    if (typeof y != "function") throw new Error(ci(10));
    (r = y), h({ type: v1.REPLACE });
  }
  function g() {
    const y = d;
    return {
      subscribe(v) {
        if (typeof v != "object" || v === null) throw new Error(ci(11));
        function _() {
          const w = v;
          w.next && w.next(u());
        }
        return _(), { unsubscribe: y(_) };
      },
      [HL]() {
        return this;
      },
    };
  }
  return (
    h({ type: v1.INIT }),
    { dispatch: h, subscribe: d, getState: u, replaceReducer: m, [HL]: g }
  );
}
function mee(n) {
  Object.keys(n).forEach((e) => {
    const t = n[e];
    if (typeof t(void 0, { type: v1.INIT }) > "u") throw new Error(ci(12));
    if (typeof t(void 0, { type: v1.PROBE_UNKNOWN_ACTION() }) > "u")
      throw new Error(ci(13));
  });
}
function gee(n) {
  const e = Object.keys(n),
    t = {};
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof n[o] == "function" && (t[o] = n[o]);
  }
  const r = Object.keys(t);
  let i;
  try {
    mee(t);
  } catch (s) {
    i = s;
  }
  return function (o = {}, a) {
    if (i) throw i;
    let l = !1;
    const c = {};
    for (let u = 0; u < r.length; u++) {
      const d = r[u],
        h = t[d],
        m = o[d],
        g = h(m, a);
      if (typeof g > "u") throw (a && a.type, new Error(ci(14)));
      (c[d] = g), (l = l || g !== m);
    }
    return (l = l || r.length !== Object.keys(o).length), l ? c : o;
  };
}
function y1(...n) {
  return n.length === 0
    ? (e) => e
    : n.length === 1
    ? n[0]
    : n.reduce(
        (e, t) =>
          (...r) =>
            e(t(...r))
      );
}
function vee(...n) {
  return (e) => (t, r) => {
    const i = e(t, r);
    let s = () => {
      throw new Error(ci(15));
    };
    const o = { getState: i.getState, dispatch: (l, ...c) => s(l, ...c) },
      a = n.map((l) => l(o));
    return (s = y1(...a)(i.dispatch)), { ...i, dispatch: s };
  };
}
function yee(n) {
  return $2(n) && "type" in n && typeof n.type == "string";
}
var Zz = Symbol.for("immer-nothing"),
  GL = Symbol.for("immer-draftable"),
  lo = Symbol.for("immer-state");
function la(n, ...e) {
  throw new Error(
    `[Immer] minified error nr: ${n}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var zh = Object.getPrototypeOf;
function Wc(n) {
  return !!n && !!n[lo];
}
function kl(n) {
  var e;
  return n
    ? Qz(n) ||
        Array.isArray(n) ||
        !!n[GL] ||
        !!((e = n.constructor) != null && e[GL]) ||
        W_(n) ||
        j_(n)
    : !1;
}
var xee = Object.prototype.constructor.toString();
function Qz(n) {
  if (!n || typeof n != "object") return !1;
  const e = zh(n);
  if (e === null) return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object
    ? !0
    : typeof t == "function" && Function.toString.call(t) === xee;
}
function x1(n, e) {
  G_(n) === 0
    ? Reflect.ownKeys(n).forEach((t) => {
        e(t, n[t], n);
      })
    : n.forEach((t, r) => e(r, t, n));
}
function G_(n) {
  const e = n[lo];
  return e ? e.type_ : Array.isArray(n) ? 1 : W_(n) ? 2 : j_(n) ? 3 : 0;
}
function OM(n, e) {
  return G_(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function Jz(n, e, t) {
  const r = G_(n);
  r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : (n[e] = t);
}
function _ee(n, e) {
  return n === e ? n !== 0 || 1 / n === 1 / e : n !== n && e !== e;
}
function W_(n) {
  return n instanceof Map;
}
function j_(n) {
  return n instanceof Set;
}
function ku(n) {
  return n.copy_ || n.base_;
}
function DM(n, e) {
  if (W_(n)) return new Map(n);
  if (j_(n)) return new Set(n);
  if (Array.isArray(n)) return Array.prototype.slice.call(n);
  const t = Qz(n);
  if (e === !0 || (e === "class_only" && !t)) {
    const r = Object.getOwnPropertyDescriptors(n);
    delete r[lo];
    let i = Reflect.ownKeys(r);
    for (let s = 0; s < i.length; s++) {
      const o = i[s],
        a = r[o];
      a.writable === !1 && ((a.writable = !0), (a.configurable = !0)),
        (a.get || a.set) &&
          (r[o] = {
            configurable: !0,
            writable: !0,
            enumerable: a.enumerable,
            value: n[o],
          });
    }
    return Object.create(zh(n), r);
  } else {
    const r = zh(n);
    if (r !== null && t) return { ...n };
    const i = Object.create(r);
    return Object.assign(i, n);
  }
}
function X2(n, e = !1) {
  return (
    $_(n) ||
      Wc(n) ||
      !kl(n) ||
      (G_(n) > 1 && (n.set = n.add = n.clear = n.delete = See),
      Object.freeze(n),
      e && Object.entries(n).forEach(([t, r]) => X2(r, !0))),
    n
  );
}
function See() {
  la(2);
}
function $_(n) {
  return Object.isFrozen(n);
}
var Aee = {};
function Ad(n) {
  const e = Aee[n];
  return e || la(0, n), e;
}
var Bg;
function eB() {
  return Bg;
}
function wee(n, e) {
  return {
    drafts_: [],
    parent_: n,
    immer_: e,
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0,
  };
}
function WL(n, e) {
  e &&
    (Ad("Patches"),
    (n.patches_ = []),
    (n.inversePatches_ = []),
    (n.patchListener_ = e));
}
function FM(n) {
  UM(n), n.drafts_.forEach(bee), (n.drafts_ = null);
}
function UM(n) {
  n === Bg && (Bg = n.parent_);
}
function jL(n) {
  return (Bg = wee(Bg, n));
}
function bee(n) {
  const e = n[lo];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : (e.revoked_ = !0);
}
function $L(n, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return (
    n !== void 0 && n !== t
      ? (t[lo].modified_ && (FM(e), la(4)),
        kl(n) && ((n = _1(e, n)), e.parent_ || S1(e, n)),
        e.patches_ &&
          Ad("Patches").generateReplacementPatches_(
            t[lo].base_,
            n,
            e.patches_,
            e.inversePatches_
          ))
      : (n = _1(e, t, [])),
    FM(e),
    e.patches_ && e.patchListener_(e.patches_, e.inversePatches_),
    n !== Zz ? n : void 0
  );
}
function _1(n, e, t) {
  if ($_(e)) return e;
  const r = e[lo];
  if (!r) return x1(e, (i, s) => XL(n, r, e, i, s, t)), e;
  if (r.scope_ !== n) return e;
  if (!r.modified_) return S1(n, r.base_, !0), r.base_;
  if (!r.finalized_) {
    (r.finalized_ = !0), r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let s = i,
      o = !1;
    r.type_ === 3 && ((s = new Set(i)), i.clear(), (o = !0)),
      x1(s, (a, l) => XL(n, r, i, a, l, t, o)),
      S1(n, i, !1),
      t &&
        n.patches_ &&
        Ad("Patches").generatePatches_(r, t, n.patches_, n.inversePatches_);
  }
  return r.copy_;
}
function XL(n, e, t, r, i, s, o) {
  if (Wc(i)) {
    const a =
        s && e && e.type_ !== 3 && !OM(e.assigned_, r) ? s.concat(r) : void 0,
      l = _1(n, i, a);
    if ((Jz(t, r, l), Wc(l))) n.canAutoFreeze_ = !1;
    else return;
  } else o && t.add(i);
  if (kl(i) && !$_(i)) {
    if (!n.immer_.autoFreeze_ && n.unfinalizedDrafts_ < 1) return;
    _1(n, i),
      (!e || !e.scope_.parent_) &&
        typeof r != "symbol" &&
        Object.prototype.propertyIsEnumerable.call(t, r) &&
        S1(n, i);
  }
}
function S1(n, e, t = !1) {
  !n.parent_ && n.immer_.autoFreeze_ && n.canAutoFreeze_ && X2(e, t);
}
function Eee(n, e) {
  const t = Array.isArray(n),
    r = {
      type_: t ? 1 : 0,
      scope_: e ? e.scope_ : eB(),
      modified_: !1,
      finalized_: !1,
      assigned_: {},
      parent_: e,
      base_: n,
      draft_: null,
      copy_: null,
      revoke_: null,
      isManual_: !1,
    };
  let i = r,
    s = Y2;
  t && ((i = [r]), (s = Vg));
  const { revoke: o, proxy: a } = Proxy.revocable(i, s);
  return (r.draft_ = a), (r.revoke_ = o), a;
}
var Y2 = {
    get(n, e) {
      if (e === lo) return n;
      const t = ku(n);
      if (!OM(t, e)) return Mee(n, t, e);
      const r = t[e];
      return n.finalized_ || !kl(r)
        ? r
        : r === Zw(n.base_, e)
        ? (Qw(n), (n.copy_[e] = zM(r, n)))
        : r;
    },
    has(n, e) {
      return e in ku(n);
    },
    ownKeys(n) {
      return Reflect.ownKeys(ku(n));
    },
    set(n, e, t) {
      const r = tB(ku(n), e);
      if (r != null && r.set) return r.set.call(n.draft_, t), !0;
      if (!n.modified_) {
        const i = Zw(ku(n), e),
          s = i == null ? void 0 : i[lo];
        if (s && s.base_ === t)
          return (n.copy_[e] = t), (n.assigned_[e] = !1), !0;
        if (_ee(t, i) && (t !== void 0 || OM(n.base_, e))) return !0;
        Qw(n), kM(n);
      }
      return (
        (n.copy_[e] === t && (t !== void 0 || e in n.copy_)) ||
          (Number.isNaN(t) && Number.isNaN(n.copy_[e])) ||
          ((n.copy_[e] = t), (n.assigned_[e] = !0)),
        !0
      );
    },
    deleteProperty(n, e) {
      return (
        Zw(n.base_, e) !== void 0 || e in n.base_
          ? ((n.assigned_[e] = !1), Qw(n), kM(n))
          : delete n.assigned_[e],
        n.copy_ && delete n.copy_[e],
        !0
      );
    },
    getOwnPropertyDescriptor(n, e) {
      const t = ku(n),
        r = Reflect.getOwnPropertyDescriptor(t, e);
      return (
        r && {
          writable: !0,
          configurable: n.type_ !== 1 || e !== "length",
          enumerable: r.enumerable,
          value: t[e],
        }
      );
    },
    defineProperty() {
      la(11);
    },
    getPrototypeOf(n) {
      return zh(n.base_);
    },
    setPrototypeOf() {
      la(12);
    },
  },
  Vg = {};
x1(Y2, (n, e) => {
  Vg[n] = function () {
    return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
  };
});
Vg.deleteProperty = function (n, e) {
  return Vg.set.call(this, n, e, void 0);
};
Vg.set = function (n, e, t) {
  return Y2.set.call(this, n[0], e, t, n[0]);
};
function Zw(n, e) {
  const t = n[lo];
  return (t ? ku(t) : n)[e];
}
function Mee(n, e, t) {
  var i;
  const r = tB(e, t);
  return r
    ? "value" in r
      ? r.value
      : (i = r.get) == null
      ? void 0
      : i.call(n.draft_)
    : void 0;
}
function tB(n, e) {
  if (!(e in n)) return;
  let t = zh(n);
  for (; t; ) {
    const r = Object.getOwnPropertyDescriptor(t, e);
    if (r) return r;
    t = zh(t);
  }
}
function kM(n) {
  n.modified_ || ((n.modified_ = !0), n.parent_ && kM(n.parent_));
}
function Qw(n) {
  n.copy_ || (n.copy_ = DM(n.base_, n.scope_.immer_.useStrictShallowCopy_));
}
var Tee = class {
  constructor(n) {
    (this.autoFreeze_ = !0),
      (this.useStrictShallowCopy_ = !1),
      (this.produce = (e, t, r) => {
        if (typeof e == "function" && typeof t != "function") {
          const s = t;
          t = e;
          const o = this;
          return function (l = s, ...c) {
            return o.produce(l, (u) => t.call(this, u, ...c));
          };
        }
        typeof t != "function" && la(6),
          r !== void 0 && typeof r != "function" && la(7);
        let i;
        if (kl(e)) {
          const s = jL(this),
            o = zM(e, void 0);
          let a = !0;
          try {
            (i = t(o)), (a = !1);
          } finally {
            a ? FM(s) : UM(s);
          }
          return WL(s, r), $L(i, s);
        } else if (!e || typeof e != "object") {
          if (
            ((i = t(e)),
            i === void 0 && (i = e),
            i === Zz && (i = void 0),
            this.autoFreeze_ && X2(i, !0),
            r)
          ) {
            const s = [],
              o = [];
            Ad("Patches").generateReplacementPatches_(e, i, s, o), r(s, o);
          }
          return i;
        } else la(1, e);
      }),
      (this.produceWithPatches = (e, t) => {
        if (typeof e == "function")
          return (o, ...a) => this.produceWithPatches(o, (l) => e(l, ...a));
        let r, i;
        return [
          this.produce(e, t, (o, a) => {
            (r = o), (i = a);
          }),
          r,
          i,
        ];
      }),
      typeof (n == null ? void 0 : n.autoFreeze) == "boolean" &&
        this.setAutoFreeze(n.autoFreeze),
      typeof (n == null ? void 0 : n.useStrictShallowCopy) == "boolean" &&
        this.setUseStrictShallowCopy(n.useStrictShallowCopy);
  }
  createDraft(n) {
    kl(n) || la(8), Wc(n) && (n = nB(n));
    const e = jL(this),
      t = zM(n, void 0);
    return (t[lo].isManual_ = !0), UM(e), t;
  }
  finishDraft(n, e) {
    const t = n && n[lo];
    (!t || !t.isManual_) && la(9);
    const { scope_: r } = t;
    return WL(r, e), $L(void 0, r);
  }
  setAutoFreeze(n) {
    this.autoFreeze_ = n;
  }
  setUseStrictShallowCopy(n) {
    this.useStrictShallowCopy_ = n;
  }
  applyPatches(n, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.path.length === 0 && i.op === "replace") {
        n = i.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const r = Ad("Patches").applyPatches_;
    return Wc(n) ? r(n, e) : this.produce(n, (i) => r(i, e));
  }
};
function zM(n, e) {
  const t = W_(n)
    ? Ad("MapSet").proxyMap_(n, e)
    : j_(n)
    ? Ad("MapSet").proxySet_(n, e)
    : Eee(n, e);
  return (e ? e.scope_ : eB()).drafts_.push(t), t;
}
function nB(n) {
  return Wc(n) || la(10, n), rB(n);
}
function rB(n) {
  if (!kl(n) || $_(n)) return n;
  const e = n[lo];
  let t;
  if (e) {
    if (!e.modified_) return e.base_;
    (e.finalized_ = !0), (t = DM(n, e.scope_.immer_.useStrictShallowCopy_));
  } else t = DM(n, !0);
  return (
    x1(t, (r, i) => {
      Jz(t, r, rB(i));
    }),
    e && (e.finalized_ = !1),
    t
  );
}
var co = new Tee(),
  iB = co.produce;
co.produceWithPatches.bind(co);
co.setAutoFreeze.bind(co);
co.setUseStrictShallowCopy.bind(co);
co.applyPatches.bind(co);
co.createDraft.bind(co);
co.finishDraft.bind(co);
function Cee(n, e = `expected a function, instead received ${typeof n}`) {
  if (typeof n != "function") throw new TypeError(e);
}
function Ree(n, e = `expected an object, instead received ${typeof n}`) {
  if (typeof n != "object") throw new TypeError(e);
}
function Nee(
  n,
  e = "expected all items to be functions, instead received the following types: "
) {
  if (!n.every((t) => typeof t == "function")) {
    const t = n
      .map((r) =>
        typeof r == "function" ? `function ${r.name || "unnamed"}()` : typeof r
      )
      .join(", ");
    throw new TypeError(`${e}[${t}]`);
  }
}
var YL = (n) => (Array.isArray(n) ? n : [n]);
function Pee(n) {
  const e = Array.isArray(n[0]) ? n[0] : n;
  return (
    Nee(
      e,
      "createSelector expects all input-selectors to be functions, but received the following types: "
    ),
    e
  );
}
function Iee(n, e) {
  const t = [],
    { length: r } = n;
  for (let i = 0; i < r; i++) t.push(n[i].apply(null, e));
  return t;
}
var Lee = class {
    constructor(n) {
      this.value = n;
    }
    deref() {
      return this.value;
    }
  },
  Oee = typeof WeakRef < "u" ? WeakRef : Lee,
  Dee = 0,
  qL = 1;
function ky() {
  return { s: Dee, v: void 0, o: null, p: null };
}
function q2(n, e = {}) {
  let t = ky();
  const { resultEqualityCheck: r } = e;
  let i,
    s = 0;
  function o() {
    var d;
    let a = t;
    const { length: l } = arguments;
    for (let h = 0, m = l; h < m; h++) {
      const g = arguments[h];
      if (typeof g == "function" || (typeof g == "object" && g !== null)) {
        let x = a.o;
        x === null && (a.o = x = new WeakMap());
        const y = x.get(g);
        y === void 0 ? ((a = ky()), x.set(g, a)) : (a = y);
      } else {
        let x = a.p;
        x === null && (a.p = x = new Map());
        const y = x.get(g);
        y === void 0 ? ((a = ky()), x.set(g, a)) : (a = y);
      }
    }
    const c = a;
    let u;
    if (a.s === qL) u = a.v;
    else if (((u = n.apply(null, arguments)), s++, r)) {
      const h =
        ((d = i == null ? void 0 : i.deref) == null ? void 0 : d.call(i)) ?? i;
      h != null && r(h, u) && ((u = h), s !== 0 && s--),
        (i =
          (typeof u == "object" && u !== null) || typeof u == "function"
            ? new Oee(u)
            : u);
    }
    return (c.s = qL), (c.v = u), u;
  }
  return (
    (o.clearCache = () => {
      (t = ky()), o.resetResultsCount();
    }),
    (o.resultsCount = () => s),
    (o.resetResultsCount = () => {
      s = 0;
    }),
    o
  );
}
function sB(n, ...e) {
  const t = typeof n == "function" ? { memoize: n, memoizeOptions: e } : n,
    r = (...i) => {
      let s = 0,
        o = 0,
        a,
        l = {},
        c = i.pop();
      typeof c == "object" && ((l = c), (c = i.pop())),
        Cee(
          c,
          `createSelector expects an output function after the inputs, but received: [${typeof c}]`
        );
      const u = { ...t, ...l },
        {
          memoize: d,
          memoizeOptions: h = [],
          argsMemoize: m = q2,
          argsMemoizeOptions: g = [],
          devModeChecks: x = {},
        } = u,
        y = YL(h),
        v = YL(g),
        _ = Pee(i),
        S = d(function () {
          return s++, c.apply(null, arguments);
        }, ...y),
        w = m(function () {
          o++;
          const E = Iee(_, arguments);
          return (a = S.apply(null, E)), a;
        }, ...v);
      return Object.assign(w, {
        resultFunc: c,
        memoizedResultFunc: S,
        dependencies: _,
        dependencyRecomputations: () => o,
        resetDependencyRecomputations: () => {
          o = 0;
        },
        lastResult: () => a,
        recomputations: () => s,
        resetRecomputations: () => {
          s = 0;
        },
        memoize: d,
        argsMemoize: m,
      });
    };
  return Object.assign(r, { withTypes: () => r }), r;
}
var Fee = sB(q2),
  Uee = Object.assign(
    (n, e = Fee) => {
      Ree(
        n,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof n}`
      );
      const t = Object.keys(n),
        r = t.map((s) => n[s]);
      return e(r, (...s) => s.reduce((o, a, l) => ((o[t[l]] = a), o), {}));
    },
    { withTypes: () => Uee }
  );
function oB(n) {
  return ({ dispatch: t, getState: r }) =>
    (i) =>
    (s) =>
      typeof s == "function" ? s(t, r, n) : i(s);
}
var kee = oB(),
  zee = oB,
  Bee = (...n) => {
    const e = sB(...n),
      t = Object.assign(
        (...r) => {
          const i = e(...r),
            s = (o, ...a) => i(Wc(o) ? nB(o) : o, ...a);
          return Object.assign(s, i), s;
        },
        { withTypes: () => t }
      );
    return t;
  };
Bee(q2);
var Vee =
  typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
    : function () {
        if (arguments.length !== 0)
          return typeof arguments[0] == "object"
            ? y1
            : y1.apply(null, arguments);
      };
function Bh(n, e) {
  function t(...r) {
    if (e) {
      let i = e(...r);
      if (!i) throw new Error(bs(0));
      return {
        type: n,
        payload: i.payload,
        ...("meta" in i && { meta: i.meta }),
        ...("error" in i && { error: i.error }),
      };
    }
    return { type: n, payload: r[0] };
  }
  return (
    (t.toString = () => `${n}`),
    (t.type = n),
    (t.match = (r) => yee(r) && r.type === n),
    t
  );
}
var aB = class Pm extends Array {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Pm.prototype);
  }
  static get [Symbol.species]() {
    return Pm;
  }
  concat(...e) {
    return super.concat.apply(this, e);
  }
  prepend(...e) {
    return e.length === 1 && Array.isArray(e[0])
      ? new Pm(...e[0].concat(this))
      : new Pm(...e.concat(this));
  }
};
function KL(n) {
  return kl(n) ? iB(n, () => {}) : n;
}
function ZL(n, e, t) {
  if (n.has(e)) {
    let i = n.get(e);
    return t.update && ((i = t.update(i, e, n)), n.set(e, i)), i;
  }
  if (!t.insert) throw new Error(bs(10));
  const r = t.insert(e, n);
  return n.set(e, r), r;
}
function Hee(n) {
  return typeof n == "boolean";
}
var Gee = () =>
    function (e) {
      const {
        thunk: t = !0,
        immutableCheck: r = !0,
        serializableCheck: i = !0,
        actionCreatorCheck: s = !0,
      } = e ?? {};
      let o = new aB();
      return t && (Hee(t) ? o.push(kee) : o.push(zee(t.extraArgument))), o;
    },
  Wee = "RTK_autoBatch",
  lB = (n) => (e) => {
    setTimeout(e, n);
  },
  jee =
    typeof window < "u" && window.requestAnimationFrame
      ? window.requestAnimationFrame
      : lB(10),
  $ee =
    (n = { type: "raf" }) =>
    (e) =>
    (...t) => {
      const r = e(...t);
      let i = !0,
        s = !1,
        o = !1;
      const a = new Set(),
        l =
          n.type === "tick"
            ? queueMicrotask
            : n.type === "raf"
            ? jee
            : n.type === "callback"
            ? n.queueNotification
            : lB(n.timeout),
        c = () => {
          (o = !1), s && ((s = !1), a.forEach((u) => u()));
        };
      return Object.assign({}, r, {
        subscribe(u) {
          const d = () => i && u(),
            h = r.subscribe(d);
          return (
            a.add(u),
            () => {
              h(), a.delete(u);
            }
          );
        },
        dispatch(u) {
          var d;
          try {
            return (
              (i = !((d = u == null ? void 0 : u.meta) != null && d[Wee])),
              (s = !i),
              s && (o || ((o = !0), l(c))),
              r.dispatch(u)
            );
          } finally {
            i = !0;
          }
        },
      });
    },
  Xee = (n) =>
    function (t) {
      const { autoBatch: r = !0 } = t ?? {};
      let i = new aB(n);
      return r && i.push($ee(typeof r == "object" ? r : void 0)), i;
    },
  Yee = !0;
function qee(n) {
  const e = Gee(),
    {
      reducer: t = void 0,
      middleware: r,
      devTools: i = !0,
      preloadedState: s = void 0,
      enhancers: o = void 0,
    } = n || {};
  let a;
  if (typeof t == "function") a = t;
  else if ($2(t)) a = gee(t);
  else throw new Error(bs(1));
  let l;
  typeof r == "function" ? (l = r(e)) : (l = e());
  let c = y1;
  i && (c = Vee({ trace: !Yee, ...(typeof i == "object" && i) }));
  const u = vee(...l),
    d = Xee(u);
  let h = typeof o == "function" ? o(d) : d();
  const m = c(...h);
  return Kz(a, s, m);
}
function cB(n) {
  const e = {},
    t = [];
  let r;
  const i = {
    addCase(s, o) {
      const a = typeof s == "string" ? s : s.type;
      if (!a) throw new Error(bs(28));
      if (a in e) throw new Error(bs(29));
      return (e[a] = o), i;
    },
    addMatcher(s, o) {
      return t.push({ matcher: s, reducer: o }), i;
    },
    addDefaultCase(s) {
      return (r = s), i;
    },
  };
  return n(i), [e, t, r];
}
function Kee(n) {
  return typeof n == "function";
}
function Zee(n, e) {
  let [t, r, i] = cB(e),
    s;
  if (Kee(n)) s = () => KL(n());
  else {
    const a = KL(n);
    s = () => a;
  }
  function o(a = s(), l) {
    let c = [
      t[l.type],
      ...r.filter(({ matcher: u }) => u(l)).map(({ reducer: u }) => u),
    ];
    return (
      c.filter((u) => !!u).length === 0 && (c = [i]),
      c.reduce((u, d) => {
        if (d)
          if (Wc(u)) {
            const m = d(u, l);
            return m === void 0 ? u : m;
          } else {
            if (kl(u)) return iB(u, (h) => d(h, l));
            {
              const h = d(u, l);
              if (h === void 0) {
                if (u === null) return u;
                throw new Error(bs(9));
              }
              return h;
            }
          }
        return u;
      }, a)
    );
  }
  return (o.getInitialState = s), o;
}
var Qee = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW",
  Jee = (n = 21) => {
    let e = "",
      t = n;
    for (; t--; ) e += Qee[(Math.random() * 64) | 0];
    return e;
  },
  ete = Symbol.for("rtk-slice-createasyncthunk");
function tte(n, e) {
  return `${n}/${e}`;
}
function nte({ creators: n } = {}) {
  var t;
  const e = (t = n == null ? void 0 : n.asyncThunk) == null ? void 0 : t[ete];
  return function (i) {
    const { name: s, reducerPath: o = s } = i;
    if (!s) throw new Error(bs(11));
    typeof process < "u";
    const a =
        (typeof i.reducers == "function" ? i.reducers(ste()) : i.reducers) ||
        {},
      l = Object.keys(a),
      c = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: [],
      },
      u = {
        addCase(S, w) {
          const T = typeof S == "string" ? S : S.type;
          if (!T) throw new Error(bs(12));
          if (T in c.sliceCaseReducersByType) throw new Error(bs(13));
          return (c.sliceCaseReducersByType[T] = w), u;
        },
        addMatcher(S, w) {
          return c.sliceMatchers.push({ matcher: S, reducer: w }), u;
        },
        exposeAction(S, w) {
          return (c.actionCreators[S] = w), u;
        },
        exposeCaseReducer(S, w) {
          return (c.sliceCaseReducersByName[S] = w), u;
        },
      };
    l.forEach((S) => {
      const w = a[S],
        T = {
          reducerName: S,
          type: tte(s, S),
          createNotation: typeof i.reducers == "function",
        };
      ate(w) ? cte(T, w, u, e) : ote(T, w, u);
    });
    function d() {
      const [S = {}, w = [], T = void 0] =
          typeof i.extraReducers == "function"
            ? cB(i.extraReducers)
            : [i.extraReducers],
        E = { ...S, ...c.sliceCaseReducersByType };
      return Zee(i.initialState, (M) => {
        for (let N in E) M.addCase(N, E[N]);
        for (let N of c.sliceMatchers) M.addMatcher(N.matcher, N.reducer);
        for (let N of w) M.addMatcher(N.matcher, N.reducer);
        T && M.addDefaultCase(T);
      });
    }
    const h = (S) => S,
      m = new Map();
    let g;
    function x(S, w) {
      return g || (g = d()), g(S, w);
    }
    function y() {
      return g || (g = d()), g.getInitialState();
    }
    function v(S, w = !1) {
      function T(M) {
        let N = M[S];
        return typeof N > "u" && w && (N = y()), N;
      }
      function E(M = h) {
        const N = ZL(m, w, { insert: () => new WeakMap() });
        return ZL(N, M, {
          insert: () => {
            const R = {};
            for (const [C, L] of Object.entries(i.selectors ?? {}))
              R[C] = rte(L, M, y, w);
            return R;
          },
        });
      }
      return {
        reducerPath: S,
        getSelectors: E,
        get selectors() {
          return E(T);
        },
        selectSlice: T,
      };
    }
    const _ = {
      name: s,
      reducer: x,
      actions: c.actionCreators,
      caseReducers: c.sliceCaseReducersByName,
      getInitialState: y,
      ...v(o),
      injectInto(S, { reducerPath: w, ...T } = {}) {
        const E = w ?? o;
        return (
          S.inject({ reducerPath: E, reducer: x }, T), { ..._, ...v(E, !0) }
        );
      },
    };
    return _;
  };
}
function rte(n, e, t, r) {
  function i(s, ...o) {
    let a = e(s);
    return typeof a > "u" && r && (a = t()), n(a, ...o);
  }
  return (i.unwrapped = n), i;
}
var ite = nte();
function ste() {
  function n(e, t) {
    return { _reducerDefinitionType: "asyncThunk", payloadCreator: e, ...t };
  }
  return (
    (n.withTypes = () => n),
    {
      reducer(e) {
        return Object.assign(
          {
            [e.name](...t) {
              return e(...t);
            },
          }[e.name],
          { _reducerDefinitionType: "reducer" }
        );
      },
      preparedReducer(e, t) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare: e,
          reducer: t,
        };
      },
      asyncThunk: n,
    }
  );
}
function ote({ type: n, reducerName: e, createNotation: t }, r, i) {
  let s, o;
  if ("reducer" in r) {
    if (t && !lte(r)) throw new Error(bs(17));
    (s = r.reducer), (o = r.prepare);
  } else s = r;
  i.addCase(n, s)
    .exposeCaseReducer(e, s)
    .exposeAction(e, o ? Bh(n, o) : Bh(n));
}
function ate(n) {
  return n._reducerDefinitionType === "asyncThunk";
}
function lte(n) {
  return n._reducerDefinitionType === "reducerWithPrepare";
}
function cte({ type: n, reducerName: e }, t, r, i) {
  if (!i) throw new Error(bs(18));
  const {
      payloadCreator: s,
      fulfilled: o,
      pending: a,
      rejected: l,
      settled: c,
      options: u,
    } = t,
    d = i(n, s, u);
  r.exposeAction(e, d),
    o && r.addCase(d.fulfilled, o),
    a && r.addCase(d.pending, a),
    l && r.addCase(d.rejected, l),
    c && r.addMatcher(d.settled, c),
    r.exposeCaseReducer(e, {
      fulfilled: o || zy,
      pending: a || zy,
      rejected: l || zy,
      settled: c || zy,
    });
}
function zy() {}
var ute = (n, e) => {
    if (typeof n != "function") throw new Error(bs(32));
  },
  K2 = "listenerMiddleware",
  dte = (n) => {
    let { type: e, actionCreator: t, matcher: r, predicate: i, effect: s } = n;
    if (e) i = Bh(e).match;
    else if (t) (e = t.type), (i = t.match);
    else if (r) i = r;
    else if (!i) throw new Error(bs(21));
    return ute(s), { predicate: i, type: e, effect: s };
  },
  fte = Object.assign(
    (n) => {
      const { type: e, predicate: t, effect: r } = dte(n);
      return {
        id: Jee(),
        effect: r,
        type: e,
        predicate: t,
        pending: new Set(),
        unsubscribe: () => {
          throw new Error(bs(22));
        },
      };
    },
    { withTypes: () => fte }
  ),
  hte = Object.assign(Bh(`${K2}/add`), { withTypes: () => hte });
Bh(`${K2}/removeAll`);
var pte = Object.assign(Bh(`${K2}/remove`), { withTypes: () => pte });
function bs(n) {
  return `Minified Redux Toolkit error #${n}; visit https://redux-toolkit.js.org/Errors?code=${n} for the full message or use the non-minified dev environment for full errors. `;
}
const mte = {
    checkedValue: "1",
    openTaskManger: !1,
    DumbFile: !1,
    showDumb: "",
    step: ["1"],
    isFileTransfered: !1,
    stepType: "step-1",
    dumbFileDetails: {
      fileName: "",
      profileName: "",
      systemOffset: "",
      samOffset: "",
      hashFile: "",
    },
    volitilitySteps: ["1"],
    analyseStep: "",
    isCracked: !1,
    openComputer: !1,
    openFolder: !1,
    openImage: !1,
    carckedData: "",
    instructionIncludes: [0, 1],
    activeAccordien: ["1"],
    instructions: [],
    steps: [
      [
        "Click the MemoryDump tool button to generate a memorydump file.Copy the filename for Step 3.",
      ],
    ],
  },
  uB = ite({
    name: "expOne",
    initialState: mte,
    reducers: {
      updateCheckedValue: (n, e) => ({
        ...n,
        checkedValue: e.payload,
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        isCracked: !1,
      }),
      updateTaskManager: (n, e) => ({ ...n, openTaskManger: e.payload }),
      createDumbFile: (n, e) => ({ ...n, DumbFile: e.payload }),
      showDumbFile: (n, e) => ({ ...n, showDumb: e.payload }),
      updateStep: (n, e) => ({ ...n, step: [...n.step, e.payload] }),
      updateIsTransfer: (n, e) => ({ ...n, isFileTransfered: e.payload }),
      updateStepType: (n, e) => ({ ...n, stepType: e.payload }),
      updateDumbFileDetails: (n, e) => ({ ...n, dumbFileDetails: e.payload }),
      updateVolitilitySteps: (n, e) => ({
        ...n,
        volitilitySteps: [...n.volitilitySteps, e.payload],
      }),
      updateAnalyseStep: (n, e) => ({ ...n, analyseStep: e.payload }),
      updateCrackedHashes: (n, e) => ({ ...n, isCracked: e.payload }),
      updateOpenComputer: (n, e) => ({ ...n, openComputer: e.payload }),
      updateOpenFolder: (n, e) => ({ ...n, openFolder: e.payload }),
      updateOpenImage: (n, e) => ({ ...n, openImage: e.payload }),
      updateCreackedData: (n, e) => ({ ...n, carckedData: e.payload }),
      updateInstructionIncludes: (n, e) => {
        n.instructionIncludes = [...n.instructionIncludes, e.payload];
      },
      updateInstructions: (n, e) => {
        n.instructions.push(...e.payload);
      },
      updateSteps: (n, e) => {
        n.steps.push(e.payload);
      },
      updateActiveKey: (n, e) => {
        n.activeAccordien = e.payload;
      },
      updateStepFromSpecificArray: (n, e) => {
        const { data: t, index: r } = e.payload;
        r >= 0 && r < n.steps.length
          ? n.steps[r].push(t)
          : console.warn(`Invalid index ${r}`),
          console.log(n, "jj");
      },
      onResetAnalyse: (n, e) => ({
        ...n,
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        volitilitySteps: ["1"],
        analyseStep: "",
        openComputer: !1,
        openFolder: !1,
        openImage: !1,
        steps: [n.steps[0], n.steps[1]],
        activeAccordien: ["3"],
      }),
      onClear: (n, e) => ({
        ...n,
        checkedValue: "1",
        openTaskManger: !1,
        DumbFile: !1,
        showDumb: "",
        step: ["1"],
        isFileTransfered: !1,
        stepType: "step-1",
        dumbFileDetails: {
          fileName: "",
          profileName: "",
          systemOffset: "",
          samOffset: "",
          hashFile: "",
        },
        volitilitySteps: ["1"],
        analyseStep: "",
        instructionIncludes: [0, 1],
        steps: [
          [
            "Click the MemoryDump tool button to generate a memorydump file.Copy the filename for Step 3.",
          ],
        ],
        activeAccordien: ["1"],
      }),
    },
  }),
  {
    updateAnalyseStep: ud,
    updateCheckedValue: gte,
    updateActiveKey: b0,
    updateTaskManager: vte,
    createDumbFile: dB,
    showDumbFile: yte,
    updateStep: BM,
    updateIsTransfer: fB,
    updateStepType: By,
    updateDumbFileDetails: hB,
    updateVolitilitySteps: Vy,
    updateCrackedHashes: Rge,
    onResetAnalyse: pB,
    updateOpenComputer: xte,
    updateOpenFolder: _te,
    onClear: Ste,
    updateOpenImage: VM,
    updateInstructionIncludes: A1,
    updateCreackedData: Ate,
    updateSteps: w1,
    updateStepFromSpecificArray: Lf,
    updateInstructions: Nge,
  } = uB.actions,
  wte = uB.reducer,
  bte = "images/dmb-Ap2zo5EP.jpg",
  Ete = "images/rar-BSi_Kgt5.png",
  Mte = () => {
    const { isFileTransfered: n, checkedValue: e } = Cs((o) => o.exp),
      r = Zu(Nm, e === "1" ? bte : Ete),
      i = I.useRef(null),
      s = Sa();
    return (
      V2(() => {
        let o;
        return (
          n &&
            (i.current.position && (i.current.position.x += 0.02),
            (o = setTimeout(() => {
              i.current.position !== null &&
                ((i.current.position.x = 4), s(BM("3")), s(fB(!1)));
            }, 4e3))),
          () => {
            clearTimeout(o);
          }
        );
      }),
      J.jsxs(wr, {
        ref: i,
        args: [0.4, 0.5, 0],
        position: [-0.7, 0, 0.5],
        scale: 0.5,
        children: [
          J.jsx("meshBasicMaterial", { map: r }),
          J.jsx(lr, {
            scale: 0.1,
            fontWeight: 600,
            position: [0, -0.35, 0],
            children: "memory.dump",
          }),
        ],
      })
    );
  },
  Tte = J.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      J.jsx("br", {}),
      "Profile(s) : ",
      J.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      ", Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418,",
      J.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      J.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      J.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      J.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      J.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      J.jsx("br", {}),
      "Number of Processors :2",
      J.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      J.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      J.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      J.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      J.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      J.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  Cte = J.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      J.jsx("br", {}),
      "Profile(s) : ",
      J.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      ", Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418",
      J.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      J.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      J.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      J.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      J.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      J.jsx("br", {}),
      "Number of Processors :2",
      J.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      J.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      J.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      J.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      J.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      J.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  Rte = J.jsxs("pre", {
    children: [
      "Volatility Foundation Volatility Framework 2.6 Suggested",
      J.jsx("br", {}),
      "Profile(s) : ",
      J.jsx("b", { style: { color: "yellow" }, children: "Win7SP1x64 " }),
      "Win7SP0x64, Win2008R2SP0x64,Win2008R2SP1x64_23418,",
      J.jsx("br", {}),
      "AS Layer1 : WindowsAMD64PagedMemory (Kernel AS)",
      J.jsx("br", {}),
      "ASLayer2 : VirtualBoxCoreDumpElf64 (Unnamed AS)",
      J.jsx("br", {}),
      "AS Layer3: FileAddressSpace (/root/test.elf)",
      J.jsx("br", {}),
      "PAE type : No PAE\\nDTB : 0x187000L",
      J.jsx("br", {}),
      "KDBG : 0xf80001a4a110L",
      J.jsx("br", {}),
      "Number of Processors :2",
      J.jsx("br", {}),
      "Image Type (Service Pack) : 1",
      J.jsx("br", {}),
      "KPCRfor CPU 0 : 0xfffff80001a4bd00L",
      J.jsx("br", {}),
      "KPCR for CPU 1 :0xfdffdf880009c5000L",
      J.jsx("br", {}),
      "KUSER_SHARED_DATA :0xfffff78000000000L",
      J.jsx("br", {}),
      "Image date and time : 2017-11-0309:22:45 UTC+0000Image",
      J.jsx("br", {}),
      "local date and time : 2017-11-03 10:22:45 +0100",
    ],
  }),
  Nte = [Tte, Cte, Rte],
  Pte = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  Ite = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  Lte = `Volatility Foundation Volatility Framework 2.4
Virtual			Physical			Name
...........		...........			...........		
0xfffff8a001053010 0x000000000b1a9010 \\??\\C:\\System Volume Information\\Syscache.hve
0xfffff8a0016a7420 0x0000000012329420 \\REGISTRY\\MACHINE\\SAM
0xfffff8a0017462a0 0x00000000101822a0 \\??\\C:\\Windows\\ServiceProfiles\\NetworkService\\NTUSER.DAT
0xfffff8a001abe420 0x000000000eae0420 \\??\\C:\\Windows\\ServiceProfiles\\LocalService\\NTUSER.DAT
0xfffff8a002ccf010 0x0000000014659010 \\??\\C:\\Users\\testing\\AppData\\Local\\Microsoft
0xfffff80002b53b10 0x000000000a441b10 [no name]
0xfffff8a00000d010 0x000000000ddc6010 [no name]
0xfffff8a000022010 0x000000000da51010 \\REGISTRY\\MACHINE\\SYSTEM
0xfffff8a00005c010 0x000000000dacd010 \\REGISTRY\\MACHINE\\HARDWARE
0xfffff8a00021d010 0x000000000cd20010 \\SystemRoot\\System32\\Config\\SECURITY
0xfffff8a0009f1010 0x000000000aa1a010 \\Device\\HarddiskVolume1\\Boot\\BCD
0xfffff8a000a15010 0x000000000acf9010 \\SystemRoot\\System32\\Config\\SOFTWARE
0xfffff8a000ce5010 0x0000000008c95010 \\SystemRoot\\System32\\Config\\DEFAULT
0xfffff8a000f95010 0x000000000c2b4010 \\??\\C:\\Users\\testing\\ntuser.dat`,
  Ote = [Pte, Ite, Lte],
  Dte = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  Fte = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  Ute = "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
  kte = [Dte, Fte, Ute],
  zte = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x00000000049ce8e0      2      1 R--rwd \\$Extend\\$ObjId
0x00000000049cedd0      1      1 R--r-d \\Windows\\System32\\en-US\\vsstrace.dll.mui
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  Bte = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  Vte = `Volatility Foundation Volatility Framework 2.4
Offset(P)            #Ptr   #Hnd Access Name
------------------ ------ ------ ------ ----
0x000000000126f3a0     14      0 R--r-d \\Windows\\System32\\mswsock.dll
0x000000000126fdc0     11      0 R--r-d \\Windows\\System32\\ssdpsrv.dll
0x000000000468f7e0      6      0 R--r-d \\Windows\\System32\\cryptsp.dll
0x000000000468fdc0     16      0 R--r-d \\Windows\\System32\\Apphlpdm.dll
0x00000000048223a0      1      1 ------ \\Endpoint
0x0000000004822a30     16      0 R--r-d \\Windows\\System32\\kerberos.dll
0x0000000004906070     13      0 R--r-d \\Windows\\System32\\wbem\\repdrvfs.dll
0x0000000004906580      9      0 R--r-d \\Windows\\SysWOW64\\netprofm.dll
0x0000000004a71070     17      1 R--r-d \\Windows\\System32\\en-US\\pnidui.dll.mui
0x0000000004a71440     11      0 R--r-d \\Windows\\System32\\nci.dll
0x0000000004a41433     11      0 R--r-d \\Device\\HarddiskVolume1\\config\\nature.jpg
0x0000000004a719c0      1      1 ------ \\srvsvc
[snip]`,
  Hte = [zte, Bte, Vte],
  Gte = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  Wte = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  jte = `Volatility Foundation Volatility Framework 2.4
DataSectionObject 0x81ed6240   684    \\Device\\HarddiskVolume1\\config\\nature.jpg`,
  $te = [Gte, Wte, jte],
  Xte = "nature.jpg.dat",
  Yte = "nature.jpg.dat",
  qte = "nature.jpg.dat",
  Kte = [Xte, Yte, qte],
  Zte = [
    { id: 1, title: "Retrieving account credentials", value: "1" },
    { id: 2, title: "Dumping cached files", value: "2" },
  ],
  Qte = [
    { id: 1, title: "var", position: [-0.1, 0.3, 0.3] },
    { id: 2, title: "opt", position: [0.2, 0.3, 0.3] },
    { id: 1, title: "home", position: [0.5, 0.3, 0.3] },
  ],
  Jte = () => ({ step1: !1, step2: !1, step3: !1, step4: !1 }),
  Im = ({ position: n, title: e, scale: t, isNeed: r, isForensic: i }) => {
    const s = Zu(Nm, cee),
      o = Zu(Nm, uee),
      a = Zu(Nm, dee),
      l = Zu(Nm, fee),
      {
        openTaskManger: c,
        DumbFile: u,
        showDumb: d,
        step: h,
        stepType: m,
        steps: g,
        activeAccordien: x,
        dumbFileDetails: y,
        analyseStep: v,
        isCracked: _,
        checkedValue: S,
        openComputer: w,
        openFolder: T,
        openImage: E,
      } = Cs((G) => G.exp),
      {
        fileName: M,
        profileName: N,
        systemOffset: R,
        samOffset: C,
        hashFile: L,
      } = y,
      O = Math.floor(Math.random() * 3) + 0,
      D = Sa(),
      [B, $] = I.useState(Jte());
    return (
      I.useEffect(() => {
        let G;
        return (
          u &&
            (G = setTimeout(() => {
              D(vte(!1)), D(dB(!1)), D(yte(!0)), D(BM("2"));
            }, 3e3)),
          () => {
            clearTimeout(G);
          }
        );
      }, [c, u]),
      console.log(v),
      I.useEffect(() => {
        let G;
        return (
          v === "1"
            ? (G = setTimeout(() => {
                $((j) => ({ ...j, step1: !0 })),
                  D(Vy("2")),
                  S === "1" &&
                    D(
                      Lf({
                        data: "As a first step after getting the memorydump, we look out for the OS information like Operating system name, Service pack, version information, and the architecture from which the memory dump is taken. To do so we leverage the imageinfo plugin from the Volatility framework. Copy the OS Profile string highlighted in Yellow.",
                        index: 2,
                      })
                    ),
                  S === "2" &&
                    D(
                      Lf({
                        data: "Volatilitys filescan plugin scans for files in the memory which were open at the time the memory dump was taken. Locate the JPG image extension file from the listing and copy its corresponding virtual address.",
                        index: 2,
                      })
                    );
              }, 3e3))
            : v === "2"
            ? (G = setTimeout(() => {
                $((j) => ({ ...j, step1: !1, step2: !0 })),
                  D(Vy("3")),
                  S === "1" &&
                    D(
                      Lf({
                        data: "Paste the SAM and SYSTEM hive offsets in the box.",
                        index: 2,
                      })
                    ),
                  S === "1" &&
                    D(
                      Lf({
                        data: "The hashdump plugin reads the location ( virtual offsets ) of SYSTEM and SAM hives from the memory-dump. It extracts the SYSKEY from the SYSTEM hive. Using the SYSKEY, it decrypts the encrypted password hashes stored in SAM database. The plugin then outputs the password hashes, which can be used for further analysis.",
                        index: 2,
                      })
                    ),
                  S === "2" &&
                    D(
                      Lf({
                        data: "Enter the virtual address of the JPG image file. The dumpfiles plugin extracts files that were open or recently accessed on the system at the time the memory dump was taken. ",
                        index: 2,
                      })
                    );
              }, 3e3))
            : v === "3"
            ? (G = setTimeout(() => {
                $((j) => ({ ...j, step1: !1, step2: !1, step3: !0 })),
                  D(Vy("4")),
                  D(ud("4")),
                  S === "1" &&
                    D(
                      w1([
                        "Copy the hash from the previous output and paste in the box to crack the password.",
                      ])
                    ),
                  S === "1" &&
                    D(
                      Lf({
                        data: "The hashed credentials can also be made run against tools such as John-The-Ripper to obtain the crack-able passwords.",
                        index: 3,
                      })
                    ),
                  S === "2" &&
                    D(
                      w1([
                        "Press the Open Image button to view the image file extracted from the memorydump.",
                      ])
                    ),
                  D(b0(["4"]));
              }, 3e3))
            : v === "4" &&
              (G = setTimeout(() => {
                $((j) => ({
                  ...j,
                  step1: !1,
                  step2: !1,
                  step3: !1,
                  step4: !0,
                })),
                  D(Vy("5")),
                  D(BM("4"));
              }, 3e3)),
          $((j) => ({ ...j, step1: !1, step2: !1, step3: !1, step4: !1 })),
          () => {
            clearTimeout(G);
          }
        );
      }, [v]),
      console.log(x, h, v, "hi"),
      J.jsxs("group", {
        position: n,
        scale: t,
        children: [
          J.jsx(lr, { scale: 0.1, position: [0, 1.5, 0], children: e }),
          J.jsx(wr, {
            name: "display",
            args: [3, 2, 0.2],
            children: J.jsx("meshBasicMaterial", { map: r ? o : l }),
          }),
          J.jsxs(wr, {
            name: "display",
            position: [0, 0, -0.1],
            args: [3, 2, 0.2],
            children: [
              J.jsx("meshBasicMaterial", { map: s }),
              d && r && J.jsx(Mte, {}),
            ],
          }),
          J.jsx(wr, {
            name: "sideTop",
            position: [0, 1.05, 0],
            args: [3, 0.1, 0.2],
            children: J.jsx("meshBasicMaterial", { map: s }),
          }),
          J.jsx(wr, {
            name: "sideBotton",
            position: [0, -1.05, 0],
            args: [3, 0.1, 0.2],
            children: J.jsx("meshBasicMaterial", { map: s }),
          }),
          J.jsx(wr, {
            name: "sideRight",
            position: [1.55, 0, 0],
            args: [0.1, 2.2, 0.2],
            children: J.jsx("meshBasicMaterial", { map: s }),
          }),
          J.jsx(wr, {
            name: "sideLeft",
            position: [-1.55, 0, 0],
            args: [0.1, 2.2, 0.2],
            children: J.jsx("meshBasicMaterial", { map: s }),
          }),
          J.jsx(wr, {
            name: "stand",
            position: [0, -1.3, 0],
            args: [0.2, 0.5, 0.2],
            children: J.jsx("meshBasicMaterial", { map: s }),
          }),
          J.jsx(wr, {
            name: "keyboard",
            position: [0, -1.5, 0],
            args: [2, 0.2, 0.2],
            children: J.jsx("meshBasicMaterial", { color: "black" }),
          }),
          c &&
            J.jsxs(wr, {
              args: [2.2, 1.2, 0],
              position: [0, 0, 0.11],
              children: [
                J.jsxs(wr, {
                  args: [2.2, 0.1, 0],
                  position: [0, 0.55, 0.001],
                  children: [
                    J.jsx("meshBasicMaterial", { color: "#341128" }),
                    J.jsx(lr, {
                      scale: 0.05,
                      color: "white",
                      position: [0, 0, 0.01],
                      children: "Memory Dump tool",
                    }),
                  ],
                }),
                J.jsxs(wr, {
                  args: [1, 0.2, 0],
                  position: [0, 0, 0.001],
                  children: [
                    J.jsx("meshBasicMaterial", { color: u ? "grey" : "blue" }),
                    J.jsx(lr, {
                      fontWeight: 800,
                      scale: 0.05,
                      color: "white",
                      position: [0, 0, 0.02],
                      children: "Create memory dump File",
                    }),
                  ],
                }),
              ],
            }),
          u &&
            J.jsx("group", {
              args: [2.2, 1.2, 0],
              position: [0, 0.2, 0.15],
              children: J.jsx(lr, {
                scale: 0.08,
                color: "black",
                children: "Loading...",
              }),
            }),
          ((h.includes("3") && x.includes("3")) || _) &&
            J.jsx("group", {
              children: J.jsxs(wr, {
                name: "command",
                position: [0, 0, 0.07],
                args: [2.7, 1.7, 0.1],
                children: [
                  J.jsx("meshBasicMaterial", { color: "#341128" }),
                  J.jsxs(wr, {
                    name: "topbar",
                    position: [0, 0.76, 0.08],
                    args: [2.65, 0.15, 0],
                    children: [
                      J.jsx(lr, { scale: 0.05, children: "Command prompt" }),
                      J.jsx("meshBasicMaterial", { color: "#4d4c49" }),
                    ],
                  }),
                  J.jsx(lr, {
                    position: [-1, 0.6, 0.09],
                    color: "#85c12e",
                    fontWeight: 800,
                    fontSize: 0.05,
                    children: "root@linux-desktop:~$",
                  }),
                  v === "1" &&
                    J.jsxs("group", {
                      children: [
                        J.jsx(lr, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children:
                            S === "2"
                              ? `./vol.py  -f ${M} imageinfo`
                              : `Volatility imageinfo -f ${M}`,
                        }),
                        B.step1
                          ? J.jsx(lr, {
                              position: [-1.2, 0.65, 0.09],
                              color: "white",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: J.jsx(vm, {
                                children: J.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 10.5,
                                    display: "flex",
                                    flexWrap: "wrap",
                                    alignItems: "center",
                                  },
                                  children: Nte[O],
                                }),
                              }),
                            })
                          : J.jsx(lr, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  v === "2" &&
                    J.jsxs("group", {
                      children: [
                        J.jsx(lr, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children:
                            S === "2"
                              ? `Volatility -f  ${M} --profile= ${N}`
                              : `Volatility -f ${M} hivelist --profile= ${N}`,
                        }),
                        B.step2
                          ? J.jsx(lr, {
                              position: [-1.1, 0.6, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.03,
                              anchorX: -2,
                              anchorY: -0.05,
                              children: J.jsx(vm, {
                                position: [-0.1, 0, 0],
                                children: J.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 10.5,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children: S === "2" ? Hte[O] : Ote[O],
                                }),
                              }),
                            })
                          : J.jsx(lr, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  v === "3" &&
                    !E &&
                    J.jsxs("group", {
                      children: [
                        J.jsx(lr, {
                          position: [-0.7, 0.66, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.2,
                          anchorY: -0.03,
                          children: J.jsx(vm, {
                            children: J.jsx("pre", {
                              style: {
                                width: 600,
                                color: "green",
                                fontSize: 10.5,
                              },
                              children:
                                S === "2"
                                  ? `Volatility -f  ${M} --profile= ${N} 
 dumpfiles -Q ${R} `
                                  : ` Volatility -f ${M} hivelist --profile= ${N} hashdumb 
 -y ${R}  -s ${C} `,
                            }),
                          }),
                        }),
                        B.step3
                          ? J.jsx(lr, {
                              position: [-1.2, 0.3, 0.09],
                              color: "white",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.06,
                              children: J.jsx(vm, {
                                children: J.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 11,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children:
                                    S === "2"
                                      ? $te[O]
                                      : "Hashed password retrived successfully",
                                }),
                              }),
                            })
                          : J.jsx(lr, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                  v === "4" &&
                    S === "2" &&
                    J.jsxs("group", {
                      children: [
                        J.jsxs(lr, {
                          position: [-0.4, 0.6, 0.09],
                          color: "green",
                          fontWeight: 800,
                          fontSize: 0.05,
                          anchorX: 0.3,
                          children: [S === "2" ? "ls" : "cat", " ", L],
                        }),
                        B.step4
                          ? J.jsx(lr, {
                              position: [-1.25, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.05,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: J.jsx(vm, {
                                children: J.jsx("pre", {
                                  style: {
                                    width: 500,
                                    color: "white",
                                    fontSize: 12,
                                    display: "flex",
                                    flexWrap: "wrap",
                                  },
                                  children: S === "2" ? Kte[O] : kte[O],
                                }),
                              }),
                            })
                          : J.jsx(lr, {
                              position: [-0.95, 0.5, 0.09],
                              color: "#ffffff",
                              fontWeight: 500,
                              fontSize: 0.04,
                              anchorX: 0.3,
                              anchorY: -0.05,
                              children: "Loading ....",
                            }),
                      ],
                    }),
                ],
              }),
            }),
          E &&
            J.jsx(wr, {
              position: [0.1, 0, 1],
              args: [1.2, 0.5, 0.1],
              children: J.jsx("meshBasicMaterial", { map: a }),
            }),
          w &&
            J.jsx(wr, {
              args: [2.2, 1.5, 0.5],
              children: J.jsxs(wr, {
                position: [-0.55, 0, 0],
                args: [1.1, 1.5, 0.5],
                children: [
                  J.jsx("meshBasicMaterial", { color: "white" }),
                  J.jsx(wr, {
                    position: [0.555, 0.6679, 0.3],
                    args: [2.11, 0.1, 0],
                    children: J.jsx("meshBasicMaterial", { color: "#624456" }),
                  }),
                  T &&
                    J.jsxs(wr, {
                      position: [0.6, -0.01, 0.4],
                      args: [1.5, 1.1, 0],
                      children: [
                        J.jsx("meshBasicMaterial", { color: "white" }),
                        J.jsxs(wr, {
                          position: [-0.8, 0.4, 0],
                          args: [0.2, 0.2, 0],
                          children: [
                            J.jsx("meshBasicMaterial", { map: a }),
                            J.jsx(lr, {
                              position: [0, -0.13, -1],
                              color: "black",
                              fontWeight: 500,
                              fontSize: 0.03,
                              children: "nature.jpg.dat",
                            }),
                          ],
                        }),
                      ],
                    }),
                  Qte.map((G) =>
                    J.jsxs(
                      wr,
                      {
                        position: G.position,
                        args: [0.2, 0.2, 0],
                        children: [
                          J.jsx("meshBasicMaterial", { color: "skyblue" }),
                          J.jsx(lr, {
                            color: "black",
                            fontWeight: 500,
                            fontSize: 0.03,
                            children: G.title,
                          }),
                        ],
                      },
                      G.id
                    )
                  ),
                  J.jsxs(lr, {
                    position: [0.25, 0.5, 0.5],
                    color: "white",
                    fontWeight: 500,
                    fontSize: 0.03,
                    anchorX: 0.5,
                    anchorY: -0.07,
                    children: [" ", "My Computer ", T && "/ opt"],
                  }),
                ],
              }),
            }),
        ],
      })
    );
  };
Im.propTypes = {
  title: mc.string.isRequired,
  scale: mc.number,
  position: mc.arrayOf(mc.number),
  isNeed: mc.bool,
  isForensic: mc.bool,
};
const ene = () => {
  const { stepType: n, checkedValue: e, activeAccordien: t } = Cs((r) => r.exp);
  return J.jsx("div", {
    style: { flex: "3 3 75%", maxWidth: "50%", background: "#00122e" },
    children: J.jsxs(LQ, {
      camera: { position: [0, 0, 1], fov: 110 },
      children: [
        J.jsx("pointLight", {}),
        J.jsx(HJ, { enableRotate: !1 }),
        J.jsx("color", { attach: "background", args: ["#00122e"] }),
        t.includes("1") &&
          (e === "1" || e === "2") &&
          J.jsx(Im, {
            title: "Crime Scene Computer",
            scale: 0.5,
            position: [-0.1, 0, 0],
            isNeed: !0,
          }),
        t.includes("2") &&
          J.jsxs("group", {
            children: [
              J.jsx(Im, {
                title: "Crime Scene Computer",
                scale: 0.3,
                position: [-0.8, 0, 0],
                isNeed: !0,
              }),
              J.jsx(Im, {
                title: "Forensic Computer",
                scale: 0.3,
                position: [0.8, 0, 0],
                isForensic: !0,
              }),
            ],
          }),
        (t.includes("3") || t.includes("4")) &&
          J.jsx("group", {
            children: J.jsx(Im, {
              title: "Forensic Computer",
              scale: t.includes("4") ? 0.5 : 0.6,
              position: [-0.1, 0, 0],
            }),
          }),
      ],
    }),
  });
};
var mB = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (n) {
  (function () {
    var e = {}.hasOwnProperty;
    function t() {
      for (var s = "", o = 0; o < arguments.length; o++) {
        var a = arguments[o];
        a && (s = i(s, r(a)));
      }
      return s;
    }
    function r(s) {
      if (typeof s == "string" || typeof s == "number") return s;
      if (typeof s != "object") return "";
      if (Array.isArray(s)) return t.apply(null, s);
      if (
        s.toString !== Object.prototype.toString &&
        !s.toString.toString().includes("[native code]")
      )
        return s.toString();
      var o = "";
      for (var a in s) e.call(s, a) && s[a] && (o = i(o, a));
      return o;
    }
    function i(s, o) {
      return o ? (s ? s + " " + o : s + o) : s;
    }
    n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t);
  })();
})(mB);
var tne = mB.exports;
const Mt = Qh(tne);
var gB = { exports: {} },
  Tn = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Z2 = Symbol.for("react.element"),
  Q2 = Symbol.for("react.portal"),
  X_ = Symbol.for("react.fragment"),
  Y_ = Symbol.for("react.strict_mode"),
  q_ = Symbol.for("react.profiler"),
  K_ = Symbol.for("react.provider"),
  Z_ = Symbol.for("react.context"),
  nne = Symbol.for("react.server_context"),
  Q_ = Symbol.for("react.forward_ref"),
  J_ = Symbol.for("react.suspense"),
  eS = Symbol.for("react.suspense_list"),
  tS = Symbol.for("react.memo"),
  nS = Symbol.for("react.lazy"),
  rne = Symbol.for("react.offscreen"),
  vB;
vB = Symbol.for("react.module.reference");
function Wo(n) {
  if (typeof n == "object" && n !== null) {
    var e = n.$$typeof;
    switch (e) {
      case Z2:
        switch (((n = n.type), n)) {
          case X_:
          case q_:
          case Y_:
          case J_:
          case eS:
            return n;
          default:
            switch (((n = n && n.$$typeof), n)) {
              case nne:
              case Z_:
              case Q_:
              case nS:
              case tS:
              case K_:
                return n;
              default:
                return e;
            }
        }
      case Q2:
        return e;
    }
  }
}
Tn.ContextConsumer = Z_;
Tn.ContextProvider = K_;
Tn.Element = Z2;
Tn.ForwardRef = Q_;
Tn.Fragment = X_;
Tn.Lazy = nS;
Tn.Memo = tS;
Tn.Portal = Q2;
Tn.Profiler = q_;
Tn.StrictMode = Y_;
Tn.Suspense = J_;
Tn.SuspenseList = eS;
Tn.isAsyncMode = function () {
  return !1;
};
Tn.isConcurrentMode = function () {
  return !1;
};
Tn.isContextConsumer = function (n) {
  return Wo(n) === Z_;
};
Tn.isContextProvider = function (n) {
  return Wo(n) === K_;
};
Tn.isElement = function (n) {
  return typeof n == "object" && n !== null && n.$$typeof === Z2;
};
Tn.isForwardRef = function (n) {
  return Wo(n) === Q_;
};
Tn.isFragment = function (n) {
  return Wo(n) === X_;
};
Tn.isLazy = function (n) {
  return Wo(n) === nS;
};
Tn.isMemo = function (n) {
  return Wo(n) === tS;
};
Tn.isPortal = function (n) {
  return Wo(n) === Q2;
};
Tn.isProfiler = function (n) {
  return Wo(n) === q_;
};
Tn.isStrictMode = function (n) {
  return Wo(n) === Y_;
};
Tn.isSuspense = function (n) {
  return Wo(n) === J_;
};
Tn.isSuspenseList = function (n) {
  return Wo(n) === eS;
};
Tn.isValidElementType = function (n) {
  return (
    typeof n == "string" ||
    typeof n == "function" ||
    n === X_ ||
    n === q_ ||
    n === Y_ ||
    n === J_ ||
    n === eS ||
    n === rne ||
    (typeof n == "object" &&
      n !== null &&
      (n.$$typeof === nS ||
        n.$$typeof === tS ||
        n.$$typeof === K_ ||
        n.$$typeof === Z_ ||
        n.$$typeof === Q_ ||
        n.$$typeof === vB ||
        n.getModuleId !== void 0))
  );
};
Tn.typeOf = Wo;
gB.exports = Tn;
var Mx = gB.exports;
function Vh(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = [];
  return (
    Je.Children.forEach(n, function (r) {
      (r == null && !e.keepEmpty) ||
        (Array.isArray(r)
          ? (t = t.concat(Vh(r)))
          : Mx.isFragment(r) && r.props
          ? (t = t.concat(Vh(r.props.children, e)))
          : t.push(r));
    }),
    t
  );
}
var HM = {},
  ine = function (e) {};
function sne(n, e) {}
function one(n, e) {}
function ane() {
  HM = {};
}
function yB(n, e, t) {
  !e && !HM[t] && (n(!1, t), (HM[t] = !0));
}
function Es(n, e) {
  yB(sne, n, e);
}
function lne(n, e) {
  yB(one, n, e);
}
Es.preMessage = ine;
Es.resetWarned = ane;
Es.noteOnce = lne;
function $t(n) {
  "@babel/helpers - typeof";
  return (
    ($t =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    $t(n)
  );
}
function cne(n, e) {
  if ($t(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if ($t(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function xB(n) {
  var e = cne(n, "string");
  return $t(e) == "symbol" ? e : e + "";
}
function Te(n, e, t) {
  return (
    (e = xB(e)) in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function QL(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(n, i).enumerable;
      })),
      t.push.apply(t, r);
  }
  return t;
}
function Ze(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? QL(Object(t), !0).forEach(function (r) {
          Te(n, r, t[r]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : QL(Object(t)).forEach(function (r) {
          Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
        });
  }
  return n;
}
function JL(n) {
  return n instanceof HTMLElement || n instanceof SVGElement;
}
function une(n) {
  return n && $t(n) === "object" && JL(n.nativeElement)
    ? n.nativeElement
    : JL(n)
    ? n
    : null;
}
function Tx(n) {
  var e = une(n);
  if (e) return e;
  if (n instanceof Je.Component) {
    var t;
    return (t = DE.findDOMNode) === null || t === void 0
      ? void 0
      : t.call(DE, n);
  }
  return null;
}
function J2(n, e, t) {
  var r = I.useRef({});
  return (
    (!("value" in r.current) || t(r.current.condition, e)) &&
      ((r.current.value = n()), (r.current.condition = e)),
    r.current.value
  );
}
var _B = function (e, t) {
    typeof e == "function"
      ? e(t)
      : $t(e) === "object" && e && "current" in e && (e.current = t);
  },
  eu = function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    var i = t.filter(Boolean);
    return i.length <= 1
      ? i[0]
      : function (s) {
          t.forEach(function (o) {
            _B(o, s);
          });
        };
  },
  dne = function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return J2(
      function () {
        return eu.apply(void 0, t);
      },
      t,
      function (i, s) {
        return (
          i.length !== s.length ||
          i.every(function (o, a) {
            return o !== s[a];
          })
        );
      }
    );
  },
  eR = function (e) {
    var t,
      r,
      i = Mx.isMemo(e) ? e.type.type : e.type;
    return !(
      (typeof i == "function" &&
        !((t = i.prototype) !== null && t !== void 0 && t.render) &&
        i.$$typeof !== Mx.ForwardRef) ||
      (typeof e == "function" &&
        !((r = e.prototype) !== null && r !== void 0 && r.render) &&
        e.$$typeof !== Mx.ForwardRef)
    );
  },
  GM = I.createContext(null);
function fne(n) {
  var e = n.children,
    t = n.onBatchResize,
    r = I.useRef(0),
    i = I.useRef([]),
    s = I.useContext(GM),
    o = I.useCallback(
      function (a, l, c) {
        r.current += 1;
        var u = r.current;
        i.current.push({ size: a, element: l, data: c }),
          Promise.resolve().then(function () {
            u === r.current && (t == null || t(i.current), (i.current = []));
          }),
          s == null || s(a, l, c);
      },
      [t, s]
    );
  return I.createElement(GM.Provider, { value: o }, e);
}
var SB = (function () {
    if (typeof Map < "u") return Map;
    function n(e, t) {
      var r = -1;
      return (
        e.some(function (i, s) {
          return i[0] === t ? ((r = s), !0) : !1;
        }),
        r
      );
    }
    return (function () {
      function e() {
        this.__entries__ = [];
      }
      return (
        Object.defineProperty(e.prototype, "size", {
          get: function () {
            return this.__entries__.length;
          },
          enumerable: !0,
          configurable: !0,
        }),
        (e.prototype.get = function (t) {
          var r = n(this.__entries__, t),
            i = this.__entries__[r];
          return i && i[1];
        }),
        (e.prototype.set = function (t, r) {
          var i = n(this.__entries__, t);
          ~i ? (this.__entries__[i][1] = r) : this.__entries__.push([t, r]);
        }),
        (e.prototype.delete = function (t) {
          var r = this.__entries__,
            i = n(r, t);
          ~i && r.splice(i, 1);
        }),
        (e.prototype.has = function (t) {
          return !!~n(this.__entries__, t);
        }),
        (e.prototype.clear = function () {
          this.__entries__.splice(0);
        }),
        (e.prototype.forEach = function (t, r) {
          r === void 0 && (r = null);
          for (var i = 0, s = this.__entries__; i < s.length; i++) {
            var o = s[i];
            t.call(r, o[1], o[0]);
          }
        }),
        e
      );
    })();
  })(),
  WM =
    typeof window < "u" &&
    typeof document < "u" &&
    window.document === document,
  b1 = (function () {
    return typeof global < "u" && global.Math === Math
      ? global
      : typeof self < "u" && self.Math === Math
      ? self
      : typeof window < "u" && window.Math === Math
      ? window
      : Function("return this")();
  })(),
  hne = (function () {
    return typeof requestAnimationFrame == "function"
      ? requestAnimationFrame.bind(b1)
      : function (n) {
          return setTimeout(function () {
            return n(Date.now());
          }, 1e3 / 60);
        };
  })(),
  pne = 2;
function mne(n, e) {
  var t = !1,
    r = !1,
    i = 0;
  function s() {
    t && ((t = !1), n()), r && a();
  }
  function o() {
    hne(s);
  }
  function a() {
    var l = Date.now();
    if (t) {
      if (l - i < pne) return;
      r = !0;
    } else (t = !0), (r = !1), setTimeout(o, e);
    i = l;
  }
  return a;
}
var gne = 20,
  vne = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
  yne = typeof MutationObserver < "u",
  xne = (function () {
    function n() {
      (this.connected_ = !1),
        (this.mutationEventsAdded_ = !1),
        (this.mutationsObserver_ = null),
        (this.observers_ = []),
        (this.onTransitionEnd_ = this.onTransitionEnd_.bind(this)),
        (this.refresh = mne(this.refresh.bind(this), gne));
    }
    return (
      (n.prototype.addObserver = function (e) {
        ~this.observers_.indexOf(e) || this.observers_.push(e),
          this.connected_ || this.connect_();
      }),
      (n.prototype.removeObserver = function (e) {
        var t = this.observers_,
          r = t.indexOf(e);
        ~r && t.splice(r, 1),
          !t.length && this.connected_ && this.disconnect_();
      }),
      (n.prototype.refresh = function () {
        var e = this.updateObservers_();
        e && this.refresh();
      }),
      (n.prototype.updateObservers_ = function () {
        var e = this.observers_.filter(function (t) {
          return t.gatherActive(), t.hasActive();
        });
        return (
          e.forEach(function (t) {
            return t.broadcastActive();
          }),
          e.length > 0
        );
      }),
      (n.prototype.connect_ = function () {
        !WM ||
          this.connected_ ||
          (document.addEventListener("transitionend", this.onTransitionEnd_),
          window.addEventListener("resize", this.refresh),
          yne
            ? ((this.mutationsObserver_ = new MutationObserver(this.refresh)),
              this.mutationsObserver_.observe(document, {
                attributes: !0,
                childList: !0,
                characterData: !0,
                subtree: !0,
              }))
            : (document.addEventListener("DOMSubtreeModified", this.refresh),
              (this.mutationEventsAdded_ = !0)),
          (this.connected_ = !0));
      }),
      (n.prototype.disconnect_ = function () {
        !WM ||
          !this.connected_ ||
          (document.removeEventListener("transitionend", this.onTransitionEnd_),
          window.removeEventListener("resize", this.refresh),
          this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
          this.mutationEventsAdded_ &&
            document.removeEventListener("DOMSubtreeModified", this.refresh),
          (this.mutationsObserver_ = null),
          (this.mutationEventsAdded_ = !1),
          (this.connected_ = !1));
      }),
      (n.prototype.onTransitionEnd_ = function (e) {
        var t = e.propertyName,
          r = t === void 0 ? "" : t,
          i = vne.some(function (s) {
            return !!~r.indexOf(s);
          });
        i && this.refresh();
      }),
      (n.getInstance = function () {
        return this.instance_ || (this.instance_ = new n()), this.instance_;
      }),
      (n.instance_ = null),
      n
    );
  })(),
  AB = function (n, e) {
    for (var t = 0, r = Object.keys(e); t < r.length; t++) {
      var i = r[t];
      Object.defineProperty(n, i, {
        value: e[i],
        enumerable: !1,
        writable: !1,
        configurable: !0,
      });
    }
    return n;
  },
  Hh = function (n) {
    var e = n && n.ownerDocument && n.ownerDocument.defaultView;
    return e || b1;
  },
  wB = rS(0, 0, 0, 0);
function E1(n) {
  return parseFloat(n) || 0;
}
function eO(n) {
  for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  return e.reduce(function (r, i) {
    var s = n["border-" + i + "-width"];
    return r + E1(s);
  }, 0);
}
function _ne(n) {
  for (
    var e = ["top", "right", "bottom", "left"], t = {}, r = 0, i = e;
    r < i.length;
    r++
  ) {
    var s = i[r],
      o = n["padding-" + s];
    t[s] = E1(o);
  }
  return t;
}
function Sne(n) {
  var e = n.getBBox();
  return rS(0, 0, e.width, e.height);
}
function Ane(n) {
  var e = n.clientWidth,
    t = n.clientHeight;
  if (!e && !t) return wB;
  var r = Hh(n).getComputedStyle(n),
    i = _ne(r),
    s = i.left + i.right,
    o = i.top + i.bottom,
    a = E1(r.width),
    l = E1(r.height);
  if (
    (r.boxSizing === "border-box" &&
      (Math.round(a + s) !== e && (a -= eO(r, "left", "right") + s),
      Math.round(l + o) !== t && (l -= eO(r, "top", "bottom") + o)),
    !bne(n))
  ) {
    var c = Math.round(a + s) - e,
      u = Math.round(l + o) - t;
    Math.abs(c) !== 1 && (a -= c), Math.abs(u) !== 1 && (l -= u);
  }
  return rS(i.left, i.top, a, l);
}
var wne = (function () {
  return typeof SVGGraphicsElement < "u"
    ? function (n) {
        return n instanceof Hh(n).SVGGraphicsElement;
      }
    : function (n) {
        return n instanceof Hh(n).SVGElement && typeof n.getBBox == "function";
      };
})();
function bne(n) {
  return n === Hh(n).document.documentElement;
}
function Ene(n) {
  return WM ? (wne(n) ? Sne(n) : Ane(n)) : wB;
}
function Mne(n) {
  var e = n.x,
    t = n.y,
    r = n.width,
    i = n.height,
    s = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object,
    o = Object.create(s.prototype);
  return (
    AB(o, {
      x: e,
      y: t,
      width: r,
      height: i,
      top: t,
      right: e + r,
      bottom: i + t,
      left: e,
    }),
    o
  );
}
function rS(n, e, t, r) {
  return { x: n, y: e, width: t, height: r };
}
var Tne = (function () {
    function n(e) {
      (this.broadcastWidth = 0),
        (this.broadcastHeight = 0),
        (this.contentRect_ = rS(0, 0, 0, 0)),
        (this.target = e);
    }
    return (
      (n.prototype.isActive = function () {
        var e = Ene(this.target);
        return (
          (this.contentRect_ = e),
          e.width !== this.broadcastWidth || e.height !== this.broadcastHeight
        );
      }),
      (n.prototype.broadcastRect = function () {
        var e = this.contentRect_;
        return (
          (this.broadcastWidth = e.width), (this.broadcastHeight = e.height), e
        );
      }),
      n
    );
  })(),
  Cne = (function () {
    function n(e, t) {
      var r = Mne(t);
      AB(this, { target: e, contentRect: r });
    }
    return n;
  })(),
  Rne = (function () {
    function n(e, t, r) {
      if (
        ((this.activeObservations_ = []),
        (this.observations_ = new SB()),
        typeof e != "function")
      )
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      (this.callback_ = e), (this.controller_ = t), (this.callbackCtx_ = r);
    }
    return (
      (n.prototype.observe = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof Hh(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var t = this.observations_;
          t.has(e) ||
            (t.set(e, new Tne(e)),
            this.controller_.addObserver(this),
            this.controller_.refresh());
        }
      }),
      (n.prototype.unobserve = function (e) {
        if (!arguments.length)
          throw new TypeError("1 argument required, but only 0 present.");
        if (!(typeof Element > "u" || !(Element instanceof Object))) {
          if (!(e instanceof Hh(e).Element))
            throw new TypeError('parameter 1 is not of type "Element".');
          var t = this.observations_;
          t.has(e) &&
            (t.delete(e), t.size || this.controller_.removeObserver(this));
        }
      }),
      (n.prototype.disconnect = function () {
        this.clearActive(),
          this.observations_.clear(),
          this.controller_.removeObserver(this);
      }),
      (n.prototype.gatherActive = function () {
        var e = this;
        this.clearActive(),
          this.observations_.forEach(function (t) {
            t.isActive() && e.activeObservations_.push(t);
          });
      }),
      (n.prototype.broadcastActive = function () {
        if (this.hasActive()) {
          var e = this.callbackCtx_,
            t = this.activeObservations_.map(function (r) {
              return new Cne(r.target, r.broadcastRect());
            });
          this.callback_.call(e, t, e), this.clearActive();
        }
      }),
      (n.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
      }),
      (n.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
      }),
      n
    );
  })(),
  bB = typeof WeakMap < "u" ? new WeakMap() : new SB(),
  EB = (function () {
    function n(e) {
      if (!(this instanceof n))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var t = xne.getInstance(),
        r = new Rne(e, t, this);
      bB.set(this, r);
    }
    return n;
  })();
["observe", "unobserve", "disconnect"].forEach(function (n) {
  EB.prototype[n] = function () {
    var e;
    return (e = bB.get(this))[n].apply(e, arguments);
  };
});
var Nne = (function () {
    return typeof b1.ResizeObserver < "u" ? b1.ResizeObserver : EB;
  })(),
  Ac = new Map();
function Pne(n) {
  n.forEach(function (e) {
    var t,
      r = e.target;
    (t = Ac.get(r)) === null ||
      t === void 0 ||
      t.forEach(function (i) {
        return i(r);
      });
  });
}
var MB = new Nne(Pne);
function Ine(n, e) {
  Ac.has(n) || (Ac.set(n, new Set()), MB.observe(n)), Ac.get(n).add(e);
}
function Lne(n, e) {
  Ac.has(n) &&
    (Ac.get(n).delete(e), Ac.get(n).size || (MB.unobserve(n), Ac.delete(n)));
}
function ss(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function tO(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    (r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(n, xB(r.key), r);
  }
}
function os(n, e, t) {
  return (
    e && tO(n.prototype, e),
    t && tO(n, t),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  );
}
function Hg(n, e) {
  return (
    (Hg = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (t, r) {
          return (t.__proto__ = r), t;
        }),
    Hg(n, e)
  );
}
function Ud(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  (n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    e && Hg(n, e);
}
function wd(n) {
  return (
    (wd = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        }),
    wd(n)
  );
}
function iS() {
  try {
    var n = !Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    );
  } catch {}
  return (iS = function () {
    return !!n;
  })();
}
function fn(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return n;
}
function TB(n, e) {
  if (e && ($t(e) == "object" || typeof e == "function")) return e;
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    );
  return fn(n);
}
function E0(n) {
  var e = iS();
  return function () {
    var t,
      r = wd(n);
    if (e) {
      var i = wd(this).constructor;
      t = Reflect.construct(r, arguments, i);
    } else t = r.apply(this, arguments);
    return TB(this, t);
  };
}
var One = (function (n) {
  Ud(t, n);
  var e = E0(t);
  function t() {
    return ss(this, t), e.apply(this, arguments);
  }
  return (
    os(t, [
      {
        key: "render",
        value: function () {
          return this.props.children;
        },
      },
    ]),
    t
  );
})(I.Component);
function Dne(n, e) {
  var t = n.children,
    r = n.disabled,
    i = I.useRef(null),
    s = I.useRef(null),
    o = I.useContext(GM),
    a = typeof t == "function",
    l = a ? t(i) : t,
    c = I.useRef({ width: -1, height: -1, offsetWidth: -1, offsetHeight: -1 }),
    u = !a && I.isValidElement(l) && eR(l),
    d = u ? l.ref : null,
    h = dne(d, i),
    m = function () {
      var v;
      return (
        Tx(i.current) ||
        (i.current && $t(i.current) === "object"
          ? Tx(
              (v = i.current) === null || v === void 0
                ? void 0
                : v.nativeElement
            )
          : null) ||
        Tx(s.current)
      );
    };
  I.useImperativeHandle(e, function () {
    return m();
  });
  var g = I.useRef(n);
  g.current = n;
  var x = I.useCallback(function (y) {
    var v = g.current,
      _ = v.onResize,
      S = v.data,
      w = y.getBoundingClientRect(),
      T = w.width,
      E = w.height,
      M = y.offsetWidth,
      N = y.offsetHeight,
      R = Math.floor(T),
      C = Math.floor(E);
    if (
      c.current.width !== R ||
      c.current.height !== C ||
      c.current.offsetWidth !== M ||
      c.current.offsetHeight !== N
    ) {
      var L = { width: R, height: C, offsetWidth: M, offsetHeight: N };
      c.current = L;
      var O = M === Math.round(T) ? T : M,
        D = N === Math.round(E) ? E : N,
        B = Ze(Ze({}, L), {}, { offsetWidth: O, offsetHeight: D });
      o == null || o(B, y, S),
        _ &&
          Promise.resolve().then(function () {
            _(B, y);
          });
    }
  }, []);
  return (
    I.useEffect(
      function () {
        var y = m();
        return (
          y && !r && Ine(y, x),
          function () {
            return Lne(y, x);
          }
        );
      },
      [i.current, r]
    ),
    I.createElement(One, { ref: s }, u ? I.cloneElement(l, { ref: h }) : l)
  );
}
var Fne = I.forwardRef(Dne),
  Une = "rc-observer-key";
function kne(n, e) {
  var t = n.children,
    r = typeof t == "function" ? [t] : Vh(t);
  return r.map(function (i, s) {
    var o = (i == null ? void 0 : i.key) || "".concat(Une, "-").concat(s);
    return I.createElement(
      Fne,
      an({}, n, { key: o, ref: s === 0 ? e : void 0 }),
      i
    );
  });
}
var CB = I.forwardRef(kne);
CB.Collection = fne;
function Gg(n, e) {
  var t = Ze({}, n);
  return (
    Array.isArray(e) &&
      e.forEach(function (r) {
        delete t[r];
      }),
    t
  );
}
function jM(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function zne(n) {
  if (Array.isArray(n)) return jM(n);
}
function RB(n) {
  if (
    (typeof Symbol < "u" && n[Symbol.iterator] != null) ||
    n["@@iterator"] != null
  )
    return Array.from(n);
}
function tR(n, e) {
  if (n) {
    if (typeof n == "string") return jM(n, e);
    var t = {}.toString.call(n).slice(8, -1);
    return (
      t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set"
        ? Array.from(n)
        : t === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)
        ? jM(n, e)
        : void 0
    );
  }
}
function Bne() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ot(n) {
  return zne(n) || RB(n) || tR(n) || Bne();
}
var NB = function (e) {
    return +setTimeout(e, 16);
  },
  PB = function (e) {
    return clearTimeout(e);
  };
typeof window < "u" &&
  "requestAnimationFrame" in window &&
  ((NB = function (e) {
    return window.requestAnimationFrame(e);
  }),
  (PB = function (e) {
    return window.cancelAnimationFrame(e);
  }));
var nO = 0,
  nR = new Map();
function IB(n) {
  nR.delete(n);
}
var Ya = function (e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  nO += 1;
  var r = nO;
  function i(s) {
    if (s === 0) IB(r), e();
    else {
      var o = NB(function () {
        i(s - 1);
      });
      nR.set(r, o);
    }
  }
  return i(t), r;
};
Ya.cancel = function (n) {
  var e = nR.get(n);
  return IB(n), PB(e);
};
function LB(n) {
  if (Array.isArray(n)) return n;
}
function Vne(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol < "u" && n[Symbol.iterator]) || n["@@iterator"];
  if (t != null) {
    var r,
      i,
      s,
      o,
      a = [],
      l = !0,
      c = !1;
    try {
      if (((s = (t = t.call(n)).next), e === 0)) {
        if (Object(t) !== t) return;
        l = !1;
      } else
        for (
          ;
          !(l = (r = s.call(t)).done) && (a.push(r.value), a.length !== e);
          l = !0
        );
    } catch (u) {
      (c = !0), (i = u);
    } finally {
      try {
        if (!l && t.return != null && ((o = t.return()), Object(o) !== o))
          return;
      } finally {
        if (c) throw i;
      }
    }
    return a;
  }
}
function OB() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Et(n, e) {
  return LB(n) || Vne(n, e) || tR(n, e) || OB();
}
function Wg(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    (t =
      (n.charCodeAt(r) & 255) |
      ((n.charCodeAt(++r) & 255) << 8) |
      ((n.charCodeAt(++r) & 255) << 16) |
      ((n.charCodeAt(++r) & 255) << 24)),
      (t = (t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)),
      (t ^= t >>> 24),
      (e =
        ((t & 65535) * 1540483477 + (((t >>> 16) * 59797) << 16)) ^
        ((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      (e ^= n.charCodeAt(r) & 255),
        (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
  }
  return (
    (e ^= e >>> 13),
    (e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
    ((e ^ (e >>> 15)) >>> 0).toString(36)
  );
}
function Wl() {
  return !!(
    typeof window < "u" &&
    window.document &&
    window.document.createElement
  );
}
function Hne(n, e) {
  if (!n) return !1;
  if (n.contains) return n.contains(e);
  for (var t = e; t; ) {
    if (t === n) return !0;
    t = t.parentNode;
  }
  return !1;
}
var rO = "data-rc-order",
  iO = "data-rc-priority",
  Gne = "rc-util-key",
  $M = new Map();
function DB() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = n.mark;
  return e ? (e.startsWith("data-") ? e : "data-".concat(e)) : Gne;
}
function sS(n) {
  if (n.attachTo) return n.attachTo;
  var e = document.querySelector("head");
  return e || document.body;
}
function Wne(n) {
  return n === "queue" ? "prependQueue" : n ? "prepend" : "append";
}
function rR(n) {
  return Array.from(($M.get(n) || n).children).filter(function (e) {
    return e.tagName === "STYLE";
  });
}
function FB(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Wl()) return null;
  var t = e.csp,
    r = e.prepend,
    i = e.priority,
    s = i === void 0 ? 0 : i,
    o = Wne(r),
    a = o === "prependQueue",
    l = document.createElement("style");
  l.setAttribute(rO, o),
    a && s && l.setAttribute(iO, "".concat(s)),
    t != null && t.nonce && (l.nonce = t == null ? void 0 : t.nonce),
    (l.innerHTML = n);
  var c = sS(e),
    u = c.firstChild;
  if (r) {
    if (a) {
      var d = (e.styles || rR(c)).filter(function (h) {
        if (!["prepend", "prependQueue"].includes(h.getAttribute(rO)))
          return !1;
        var m = Number(h.getAttribute(iO) || 0);
        return s >= m;
      });
      if (d.length) return c.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    c.insertBefore(l, u);
  } else c.appendChild(l);
  return l;
}
function UB(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = sS(e);
  return (e.styles || rR(t)).find(function (r) {
    return r.getAttribute(DB(e)) === n;
  });
}
function kB(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = UB(n, e);
  if (t) {
    var r = sS(e);
    r.removeChild(t);
  }
}
function jne(n, e) {
  var t = $M.get(n);
  if (!t || !Hne(document, t)) {
    var r = FB("", e),
      i = r.parentNode;
    $M.set(n, i), n.removeChild(r);
  }
}
function dd(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = sS(t),
    i = rR(r),
    s = Ze(Ze({}, t), {}, { styles: i });
  jne(r, s);
  var o = UB(e, s);
  if (o) {
    var a, l;
    if (
      (a = s.csp) !== null &&
      a !== void 0 &&
      a.nonce &&
      o.nonce !== ((l = s.csp) === null || l === void 0 ? void 0 : l.nonce)
    ) {
      var c;
      o.nonce = (c = s.csp) === null || c === void 0 ? void 0 : c.nonce;
    }
    return o.innerHTML !== n && (o.innerHTML = n), o;
  }
  var u = FB(n, s);
  return u.setAttribute(DB(s), e), u;
}
function $ne(n, e) {
  if (n == null) return {};
  var t = {};
  for (var r in n)
    if ({}.hasOwnProperty.call(n, r)) {
      if (e.indexOf(r) >= 0) continue;
      t[r] = n[r];
    }
  return t;
}
function xi(n, e) {
  if (n == null) return {};
  var t,
    r,
    i = $ne(n, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (r = 0; r < s.length; r++)
      (t = s[r]),
        e.indexOf(t) >= 0 ||
          ({}.propertyIsEnumerable.call(n, t) && (i[t] = n[t]));
  }
  return i;
}
function XM(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    r = new Set();
  function i(s, o) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
      l = r.has(s);
    if ((Es(!l, "Warning: There may be circular references"), l)) return !1;
    if (s === o) return !0;
    if (t && a > 1) return !1;
    r.add(s);
    var c = a + 1;
    if (Array.isArray(s)) {
      if (!Array.isArray(o) || s.length !== o.length) return !1;
      for (var u = 0; u < s.length; u++) if (!i(s[u], o[u], c)) return !1;
      return !0;
    }
    if (s && o && $t(s) === "object" && $t(o) === "object") {
      var d = Object.keys(s);
      return d.length !== Object.keys(o).length
        ? !1
        : d.every(function (h) {
            return i(s[h], o[h], c);
          });
    }
    return !1;
  }
  return i(n, e);
}
var Xne = "%";
function YM(n) {
  return n.join(Xne);
}
var Yne = (function () {
    function n(e) {
      ss(this, n),
        Te(this, "instanceId", void 0),
        Te(this, "cache", new Map()),
        (this.instanceId = e);
    }
    return (
      os(n, [
        {
          key: "get",
          value: function (t) {
            return this.opGet(YM(t));
          },
        },
        {
          key: "opGet",
          value: function (t) {
            return this.cache.get(t) || null;
          },
        },
        {
          key: "update",
          value: function (t, r) {
            return this.opUpdate(YM(t), r);
          },
        },
        {
          key: "opUpdate",
          value: function (t, r) {
            var i = this.cache.get(t),
              s = r(i);
            s === null ? this.cache.delete(t) : this.cache.set(t, s);
          },
        },
      ]),
      n
    );
  })(),
  Gh = "data-token-hash",
  fa = "data-css-hash",
  wc = "__cssinjs_instance__";
function qne() {
  var n = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var e = document.body.querySelectorAll("style[".concat(fa, "]")) || [],
      t = document.head.firstChild;
    Array.from(e).forEach(function (i) {
      (i[wc] = i[wc] || n), i[wc] === n && document.head.insertBefore(i, t);
    });
    var r = {};
    Array.from(document.querySelectorAll("style[".concat(fa, "]"))).forEach(
      function (i) {
        var s = i.getAttribute(fa);
        if (r[s]) {
          if (i[wc] === n) {
            var o;
            (o = i.parentNode) === null || o === void 0 || o.removeChild(i);
          }
        } else r[s] = !0;
      }
    );
  }
  return new Yne(n);
}
var oS = I.createContext({
  hashPriority: "low",
  cache: qne(),
  defaultCache: !0,
});
function Kne(n, e) {
  if (n.length !== e.length) return !1;
  for (var t = 0; t < n.length; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
var iR = (function () {
  function n() {
    ss(this, n),
      Te(this, "cache", void 0),
      Te(this, "keys", void 0),
      Te(this, "cacheCallTimes", void 0),
      (this.cache = new Map()),
      (this.keys = []),
      (this.cacheCallTimes = 0);
  }
  return (
    os(n, [
      {
        key: "size",
        value: function () {
          return this.keys.length;
        },
      },
      {
        key: "internalGet",
        value: function (t) {
          var r,
            i,
            s =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : !1,
            o = { map: this.cache };
          return (
            t.forEach(function (a) {
              if (!o) o = void 0;
              else {
                var l;
                o =
                  (l = o) === null ||
                  l === void 0 ||
                  (l = l.map) === null ||
                  l === void 0
                    ? void 0
                    : l.get(a);
              }
            }),
            (r = o) !== null &&
              r !== void 0 &&
              r.value &&
              s &&
              (o.value[1] = this.cacheCallTimes++),
            (i = o) === null || i === void 0 ? void 0 : i.value
          );
        },
      },
      {
        key: "get",
        value: function (t) {
          var r;
          return (r = this.internalGet(t, !0)) === null || r === void 0
            ? void 0
            : r[0];
        },
      },
      {
        key: "has",
        value: function (t) {
          return !!this.internalGet(t);
        },
      },
      {
        key: "set",
        value: function (t, r) {
          var i = this;
          if (!this.has(t)) {
            if (this.size() + 1 > n.MAX_CACHE_SIZE + n.MAX_CACHE_OFFSET) {
              var s = this.keys.reduce(
                  function (c, u) {
                    var d = Et(c, 2),
                      h = d[1];
                    return i.internalGet(u)[1] < h
                      ? [u, i.internalGet(u)[1]]
                      : c;
                  },
                  [this.keys[0], this.cacheCallTimes]
                ),
                o = Et(s, 1),
                a = o[0];
              this.delete(a);
            }
            this.keys.push(t);
          }
          var l = this.cache;
          t.forEach(function (c, u) {
            if (u === t.length - 1)
              l.set(c, { value: [r, i.cacheCallTimes++] });
            else {
              var d = l.get(c);
              d ? d.map || (d.map = new Map()) : l.set(c, { map: new Map() }),
                (l = l.get(c).map);
            }
          });
        },
      },
      {
        key: "deleteByPath",
        value: function (t, r) {
          var i = t.get(r[0]);
          if (r.length === 1) {
            var s;
            return (
              i.map ? t.set(r[0], { map: i.map }) : t.delete(r[0]),
              (s = i.value) === null || s === void 0 ? void 0 : s[0]
            );
          }
          var o = this.deleteByPath(i.map, r.slice(1));
          return (!i.map || i.map.size === 0) && !i.value && t.delete(r[0]), o;
        },
      },
      {
        key: "delete",
        value: function (t) {
          if (this.has(t))
            return (
              (this.keys = this.keys.filter(function (r) {
                return !Kne(r, t);
              })),
              this.deleteByPath(this.cache, t)
            );
        },
      },
    ]),
    n
  );
})();
Te(iR, "MAX_CACHE_SIZE", 20);
Te(iR, "MAX_CACHE_OFFSET", 5);
var sO = 0,
  zB = (function () {
    function n(e) {
      ss(this, n),
        Te(this, "derivatives", void 0),
        Te(this, "id", void 0),
        (this.derivatives = Array.isArray(e) ? e : [e]),
        (this.id = sO),
        e.length === 0 && (e.length > 0, void 0),
        (sO += 1);
    }
    return (
      os(n, [
        {
          key: "getDerivativeToken",
          value: function (t) {
            return this.derivatives.reduce(function (r, i) {
              return i(t, r);
            }, void 0);
          },
        },
      ]),
      n
    );
  })(),
  Jw = new iR();
function qM(n) {
  var e = Array.isArray(n) ? n : [n];
  return Jw.has(e) || Jw.set(e, new zB(e)), Jw.get(e);
}
var Zne = new WeakMap(),
  eb = {};
function Qne(n, e) {
  for (var t = Zne, r = 0; r < e.length; r += 1) {
    var i = e[r];
    t.has(i) || t.set(i, new WeakMap()), (t = t.get(i));
  }
  return t.has(eb) || t.set(eb, n()), t.get(eb);
}
var oO = new WeakMap();
function Zm(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t = oO.get(n) || "";
  return (
    t ||
      (Object.keys(n).forEach(function (r) {
        var i = n[r];
        (t += r),
          i instanceof zB
            ? (t += i.id)
            : i && $t(i) === "object"
            ? (t += Zm(i, e))
            : (t += i);
      }),
      e && (t = Wg(t)),
      oO.set(n, t)),
    t
  );
}
function aO(n, e) {
  return Wg("".concat(e, "_").concat(Zm(n, !0)));
}
var KM = Wl();
function jt(n) {
  return typeof n == "number" ? "".concat(n, "px") : n;
}
function M1(n, e, t) {
  var r,
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
    s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (s) return n;
  var o = Ze(Ze({}, i), {}, ((r = {}), Te(r, Gh, e), Te(r, fa, t), r)),
    a = Object.keys(o)
      .map(function (l) {
        var c = o[l];
        return c ? "".concat(l, '="').concat(c, '"') : null;
      })
      .filter(function (l) {
        return l;
      })
      .join(" ");
  return "<style ".concat(a, ">").concat(n, "</style>");
}
var BB = function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return "--"
      .concat(t ? "".concat(t, "-") : "")
      .concat(e)
      .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
      .replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2")
      .replace(/([a-z])([A-Z0-9])/g, "$1-$2")
      .toLowerCase();
  },
  Jne = function (e, t, r) {
    return Object.keys(e).length
      ? "."
          .concat(t)
          .concat(r != null && r.scope ? ".".concat(r.scope) : "", "{")
          .concat(
            Object.entries(e)
              .map(function (i) {
                var s = Et(i, 2),
                  o = s[0],
                  a = s[1];
                return "".concat(o, ":").concat(a, ";");
              })
              .join(""),
            "}"
          )
      : "";
  },
  VB = function (e, t, r) {
    var i = {},
      s = {};
    return (
      Object.entries(e).forEach(function (o) {
        var a,
          l,
          c = Et(o, 2),
          u = c[0],
          d = c[1];
        if (r != null && (a = r.preserve) !== null && a !== void 0 && a[u])
          s[u] = d;
        else if (
          (typeof d == "string" || typeof d == "number") &&
          !(r != null && (l = r.ignore) !== null && l !== void 0 && l[u])
        ) {
          var h,
            m = BB(u, r == null ? void 0 : r.prefix);
          (i[m] =
            typeof d == "number" &&
            !(r != null && (h = r.unitless) !== null && h !== void 0 && h[u])
              ? "".concat(d, "px")
              : String(d)),
            (s[u] = "var(".concat(m, ")"));
        }
      }),
      [s, Jne(i, t, { scope: r == null ? void 0 : r.scope })]
    );
  },
  lO = Wl() ? I.useLayoutEffect : I.useEffect,
  T1 = function (e, t) {
    var r = I.useRef(!0);
    lO(function () {
      return e(r.current);
    }, t),
      lO(function () {
        return (
          (r.current = !1),
          function () {
            r.current = !0;
          }
        );
      }, []);
  },
  cO = function (e, t) {
    T1(function (r) {
      if (!r) return e();
    }, t);
  },
  ere = Ze({}, ng),
  uO = ere.useInsertionEffect,
  tre = function (e, t, r) {
    I.useMemo(e, r),
      T1(function () {
        return t(!0);
      }, r);
  },
  nre = uO
    ? function (n, e, t) {
        return uO(function () {
          return n(), e();
        }, t);
      }
    : tre,
  rre = Ze({}, ng),
  ire = rre.useInsertionEffect,
  sre = function (e) {
    var t = [],
      r = !1;
    function i(s) {
      r || t.push(s);
    }
    return (
      I.useEffect(function () {
        return (
          (r = !1),
          function () {
            (r = !0),
              t.length &&
                t.forEach(function (s) {
                  return s();
                });
          }
        );
      }, e),
      i
    );
  },
  ore = function () {
    return function (e) {
      e();
    };
  },
  are = typeof ire < "u" ? sre : ore;
function sR(n, e, t, r, i) {
  var s = I.useContext(oS),
    o = s.cache,
    a = [n].concat(Ot(e)),
    l = YM(a),
    c = are([l]),
    u = function (g) {
      o.opUpdate(l, function (x) {
        var y = x || [void 0, void 0],
          v = Et(y, 2),
          _ = v[0],
          S = _ === void 0 ? 0 : _,
          w = v[1],
          T = w,
          E = T || t(),
          M = [S, E];
        return g ? g(M) : M;
      });
    };
  I.useMemo(
    function () {
      u();
    },
    [l]
  );
  var d = o.opGet(l),
    h = d[1];
  return (
    nre(
      function () {
        i == null || i(h);
      },
      function (m) {
        return (
          u(function (g) {
            var x = Et(g, 2),
              y = x[0],
              v = x[1];
            return m && y === 0 && (i == null || i(h)), [y + 1, v];
          }),
          function () {
            o.opUpdate(l, function (g) {
              var x = g || [],
                y = Et(x, 2),
                v = y[0],
                _ = v === void 0 ? 0 : v,
                S = y[1],
                w = _ - 1;
              return w === 0
                ? (c(function () {
                    (m || !o.opGet(l)) && (r == null || r(S, !1));
                  }),
                  null)
                : [_ - 1, S];
            });
          }
        );
      },
      [l]
    ),
    h
  );
}
var lre = {},
  cre = "css",
  Vu = new Map();
function ure(n) {
  Vu.set(n, (Vu.get(n) || 0) + 1);
}
function dre(n, e) {
  if (typeof document < "u") {
    var t = document.querySelectorAll(
      "style[".concat(Gh, '="').concat(n, '"]')
    );
    t.forEach(function (r) {
      if (r[wc] === e) {
        var i;
        (i = r.parentNode) === null || i === void 0 || i.removeChild(r);
      }
    });
  }
}
var fre = 0;
function hre(n, e) {
  Vu.set(n, (Vu.get(n) || 0) - 1);
  var t = Array.from(Vu.keys()),
    r = t.filter(function (i) {
      var s = Vu.get(i) || 0;
      return s <= 0;
    });
  t.length - r.length > fre &&
    r.forEach(function (i) {
      dre(i, e), Vu.delete(i);
    });
}
var pre = function (e, t, r, i) {
    var s = r.getDerivativeToken(e),
      o = Ze(Ze({}, s), t);
    return i && (o = i(o)), o;
  },
  HB = "token";
function mre(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    r = I.useContext(oS),
    i = r.cache.instanceId,
    s = r.container,
    o = t.salt,
    a = o === void 0 ? "" : o,
    l = t.override,
    c = l === void 0 ? lre : l,
    u = t.formatToken,
    d = t.getComputedToken,
    h = t.cssVar,
    m = Qne(function () {
      return Object.assign.apply(Object, [{}].concat(Ot(e)));
    }, e),
    g = Zm(m),
    x = Zm(c),
    y = h ? Zm(h) : "",
    v = sR(
      HB,
      [a, n.id, g, x, y],
      function () {
        var _,
          S = d ? d(m, c, n) : pre(m, c, n, u),
          w = Ze({}, S),
          T = "";
        if (h) {
          var E = VB(S, h.key, {
              prefix: h.prefix,
              ignore: h.ignore,
              unitless: h.unitless,
              preserve: h.preserve,
            }),
            M = Et(E, 2);
          (S = M[0]), (T = M[1]);
        }
        var N = aO(S, a);
        (S._tokenKey = N), (w._tokenKey = aO(w, a));
        var R =
          (_ = h == null ? void 0 : h.key) !== null && _ !== void 0 ? _ : N;
        (S._themeKey = R), ure(R);
        var C = "".concat(cre, "-").concat(Wg(N));
        return (
          (S._hashId = C), [S, C, w, T, (h == null ? void 0 : h.key) || ""]
        );
      },
      function (_) {
        hre(_[0]._themeKey, i);
      },
      function (_) {
        var S = Et(_, 4),
          w = S[0],
          T = S[3];
        if (h && T) {
          var E = dd(T, Wg("css-variables-".concat(w._themeKey)), {
            mark: fa,
            prepend: "queue",
            attachTo: s,
            priority: -999,
          });
          (E[wc] = i), E.setAttribute(Gh, w._themeKey);
        }
      }
    );
  return v;
}
var gre = function (e, t, r) {
    var i = Et(e, 5),
      s = i[2],
      o = i[3],
      a = i[4],
      l = r || {},
      c = l.plain;
    if (!o) return null;
    var u = s._tokenKey,
      d = -999,
      h = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(d) },
      m = M1(o, a, u, h, c);
    return [d, u, m];
  },
  vre = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  GB = "comm",
  WB = "rule",
  jB = "decl",
  yre = "@import",
  xre = "@keyframes",
  _re = "@layer",
  $B = Math.abs,
  oR = String.fromCharCode;
function XB(n) {
  return n.trim();
}
function Cx(n, e, t) {
  return n.replace(e, t);
}
function Sre(n, e, t) {
  return n.indexOf(e, t);
}
function jg(n, e) {
  return n.charCodeAt(e) | 0;
}
function $g(n, e, t) {
  return n.slice(e, t);
}
function _l(n) {
  return n.length;
}
function Are(n) {
  return n.length;
}
function Hy(n, e) {
  return e.push(n), n;
}
var aS = 1,
  Wh = 1,
  YB = 0,
  Vo = 0,
  Pr = 0,
  dp = "";
function aR(n, e, t, r, i, s, o, a) {
  return {
    value: n,
    root: e,
    parent: t,
    type: r,
    props: i,
    children: s,
    line: aS,
    column: Wh,
    length: o,
    return: "",
    siblings: a,
  };
}
function wre() {
  return Pr;
}
function bre() {
  return (
    (Pr = Vo > 0 ? jg(dp, --Vo) : 0), Wh--, Pr === 10 && ((Wh = 1), aS--), Pr
  );
}
function ha() {
  return (
    (Pr = Vo < YB ? jg(dp, Vo++) : 0), Wh++, Pr === 10 && ((Wh = 1), aS++), Pr
  );
}
function fd() {
  return jg(dp, Vo);
}
function Rx() {
  return Vo;
}
function lS(n, e) {
  return $g(dp, n, e);
}
function ZM(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Ere(n) {
  return (aS = Wh = 1), (YB = _l((dp = n))), (Vo = 0), [];
}
function Mre(n) {
  return (dp = ""), n;
}
function tb(n) {
  return XB(lS(Vo - 1, QM(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function Tre(n) {
  for (; (Pr = fd()) && Pr < 33; ) ha();
  return ZM(n) > 2 || ZM(Pr) > 3 ? "" : " ";
}
function Cre(n, e) {
  for (
    ;
    --e &&
    ha() &&
    !(Pr < 48 || Pr > 102 || (Pr > 57 && Pr < 65) || (Pr > 70 && Pr < 97));

  );
  return lS(n, Rx() + (e < 6 && fd() == 32 && ha() == 32));
}
function QM(n) {
  for (; ha(); )
    switch (Pr) {
      case n:
        return Vo;
      case 34:
      case 39:
        n !== 34 && n !== 39 && QM(Pr);
        break;
      case 40:
        n === 41 && QM(n);
        break;
      case 92:
        ha();
        break;
    }
  return Vo;
}
function Rre(n, e) {
  for (; ha() && n + Pr !== 57; ) if (n + Pr === 84 && fd() === 47) break;
  return "/*" + lS(e, Vo - 1) + "*" + oR(n === 47 ? n : ha());
}
function Nre(n) {
  for (; !ZM(fd()); ) ha();
  return lS(n, Vo);
}
function Pre(n) {
  return Mre(Nx("", null, null, null, [""], (n = Ere(n)), 0, [0], n));
}
function Nx(n, e, t, r, i, s, o, a, l) {
  for (
    var c = 0,
      u = 0,
      d = o,
      h = 0,
      m = 0,
      g = 0,
      x = 1,
      y = 1,
      v = 1,
      _ = 0,
      S = "",
      w = i,
      T = s,
      E = r,
      M = S;
    y;

  )
    switch (((g = _), (_ = ha()))) {
      case 40:
        if (g != 108 && jg(M, d - 1) == 58) {
          Sre((M += Cx(tb(_), "&", "&\f")), "&\f", $B(c ? a[c - 1] : 0)) !=
            -1 && (v = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        M += tb(_);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        M += Tre(g);
        break;
      case 92:
        M += Cre(Rx() - 1, 7);
        continue;
      case 47:
        switch (fd()) {
          case 42:
          case 47:
            Hy(Ire(Rre(ha(), Rx()), e, t, l), l);
            break;
          default:
            M += "/";
        }
        break;
      case 123 * x:
        a[c++] = _l(M) * v;
      case 125 * x:
      case 59:
      case 0:
        switch (_) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            v == -1 && (M = Cx(M, /\f/g, "")),
              m > 0 &&
                _l(M) - d &&
                Hy(
                  m > 32
                    ? fO(M + ";", r, t, d - 1, l)
                    : fO(Cx(M, " ", "") + ";", r, t, d - 2, l),
                  l
                );
            break;
          case 59:
            M += ";";
          default:
            if (
              (Hy(
                (E = dO(M, e, t, c, u, i, a, S, (w = []), (T = []), d, s)),
                s
              ),
              _ === 123)
            )
              if (u === 0) Nx(M, e, E, E, w, s, d, a, T);
              else
                switch (h === 99 && jg(M, 3) === 110 ? 100 : h) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Nx(
                      n,
                      E,
                      E,
                      r && Hy(dO(n, E, E, 0, 0, i, a, S, i, (w = []), d, T), T),
                      i,
                      T,
                      d,
                      a,
                      r ? w : T
                    );
                    break;
                  default:
                    Nx(M, E, E, E, [""], T, 0, a, T);
                }
        }
        (c = u = m = 0), (x = v = 1), (S = M = ""), (d = o);
        break;
      case 58:
        (d = 1 + _l(M)), (m = g);
      default:
        if (x < 1) {
          if (_ == 123) --x;
          else if (_ == 125 && x++ == 0 && bre() == 125) continue;
        }
        switch (((M += oR(_)), _ * x)) {
          case 38:
            v = u > 0 ? 1 : ((M += "\f"), -1);
            break;
          case 44:
            (a[c++] = (_l(M) - 1) * v), (v = 1);
            break;
          case 64:
            fd() === 45 && (M += tb(ha())),
              (h = fd()),
              (u = d = _l((S = M += Nre(Rx())))),
              _++;
            break;
          case 45:
            g === 45 && _l(M) == 2 && (x = 0);
        }
    }
  return s;
}
function dO(n, e, t, r, i, s, o, a, l, c, u, d) {
  for (
    var h = i - 1, m = i === 0 ? s : [""], g = Are(m), x = 0, y = 0, v = 0;
    x < r;
    ++x
  )
    for (var _ = 0, S = $g(n, h + 1, (h = $B((y = o[x])))), w = n; _ < g; ++_)
      (w = XB(y > 0 ? m[_] + " " + S : Cx(S, /&\f/g, m[_]))) && (l[v++] = w);
  return aR(n, e, t, i === 0 ? WB : a, l, c, u, d);
}
function Ire(n, e, t, r) {
  return aR(n, e, t, GB, oR(wre()), $g(n, 2, -2), 0, r);
}
function fO(n, e, t, r, i) {
  return aR(n, e, t, jB, $g(n, 0, r), $g(n, r + 1, -1), r, i);
}
function JM(n, e) {
  for (var t = "", r = 0; r < n.length; r++) t += e(n[r], r, n, e) || "";
  return t;
}
function Lre(n, e, t, r) {
  switch (n.type) {
    case _re:
      if (n.children.length) break;
    case yre:
    case jB:
      return (n.return = n.return || n.value);
    case GB:
      return "";
    case xre:
      return (n.return = n.value + "{" + JM(n.children, r) + "}");
    case WB:
      if (!_l((n.value = n.props.join(",")))) return "";
  }
  return _l((t = JM(n.children, r)))
    ? (n.return = n.value + "{" + t + "}")
    : "";
}
var hO = "data-ant-cssinjs-cache-path",
  qB = "_FILE_STYLE__",
  hd,
  KB = !0;
function Ore() {
  if (!hd && ((hd = {}), Wl())) {
    var n = document.createElement("div");
    (n.className = hO),
      (n.style.position = "fixed"),
      (n.style.visibility = "hidden"),
      (n.style.top = "-9999px"),
      document.body.appendChild(n);
    var e = getComputedStyle(n).content || "";
    (e = e.replace(/^"/, "").replace(/"$/, "")),
      e.split(";").forEach(function (i) {
        var s = i.split(":"),
          o = Et(s, 2),
          a = o[0],
          l = o[1];
        hd[a] = l;
      });
    var t = document.querySelector("style[".concat(hO, "]"));
    if (t) {
      var r;
      (KB = !1),
        (r = t.parentNode) === null || r === void 0 || r.removeChild(t);
    }
    document.body.removeChild(n);
  }
}
function Dre(n) {
  return Ore(), !!hd[n];
}
function Fre(n) {
  var e = hd[n],
    t = null;
  if (e && Wl())
    if (KB) t = qB;
    else {
      var r = document.querySelector(
        "style[".concat(fa, '="').concat(hd[n], '"]')
      );
      r ? (t = r.innerHTML) : delete hd[n];
    }
  return [t, e];
}
var Ure = "_skip_check_",
  ZB = "_multi_value_";
function Px(n) {
  var e = JM(Pre(n), Lre);
  return e.replace(/\{%%%\:[^;];}/g, ";");
}
function kre(n) {
  return $t(n) === "object" && n && (Ure in n || ZB in n);
}
function zre(n, e, t) {
  if (!e) return n;
  var r = ".".concat(e),
    i = t === "low" ? ":where(".concat(r, ")") : r,
    s = n.split(",").map(function (o) {
      var a,
        l = o.trim().split(/\s+/),
        c = l[0] || "",
        u =
          ((a = c.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) ||
          "";
      return (
        (c = "".concat(u).concat(i).concat(c.slice(u.length))),
        [c].concat(Ot(l.slice(1))).join(" ")
      );
    });
  return s.join(",");
}
var Bre = function n(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    r =
      arguments.length > 2 && arguments[2] !== void 0
        ? arguments[2]
        : { root: !0, parentSelectors: [] },
    i = r.root,
    s = r.injectHash,
    o = r.parentSelectors,
    a = t.hashId,
    l = t.layer;
  t.path;
  var c = t.hashPriority,
    u = t.transformers,
    d = u === void 0 ? [] : u;
  t.linters;
  var h = "",
    m = {};
  function g(v) {
    var _ = v.getName(a);
    if (!m[_]) {
      var S = n(v.style, t, { root: !1, parentSelectors: o }),
        w = Et(S, 1),
        T = w[0];
      m[_] = "@keyframes ".concat(v.getName(a)).concat(T);
    }
  }
  function x(v) {
    var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return (
      v.forEach(function (S) {
        Array.isArray(S) ? x(S, _) : S && _.push(S);
      }),
      _
    );
  }
  var y = x(Array.isArray(e) ? e : [e]);
  return (
    y.forEach(function (v) {
      var _ = typeof v == "string" && !i ? {} : v;
      if (typeof _ == "string")
        h += "".concat(
          _,
          `
`
        );
      else if (_._keyframe) g(_);
      else {
        var S = d.reduce(function (w, T) {
          var E;
          return (
            (T == null || (E = T.visit) === null || E === void 0
              ? void 0
              : E.call(T, w)) || w
          );
        }, _);
        Object.keys(S).forEach(function (w) {
          var T = S[w];
          if (
            $t(T) === "object" &&
            T &&
            (w !== "animationName" || !T._keyframe) &&
            !kre(T)
          ) {
            var E = !1,
              M = w.trim(),
              N = !1;
            (i || s) && a
              ? M.startsWith("@")
                ? (E = !0)
                : (M = zre(w, a, c))
              : i && !a && (M === "&" || M === "") && ((M = ""), (N = !0));
            var R = n(T, t, {
                root: N,
                injectHash: E,
                parentSelectors: [].concat(Ot(o), [M]),
              }),
              C = Et(R, 2),
              L = C[0],
              O = C[1];
            (m = Ze(Ze({}, m), O)), (h += "".concat(M).concat(L));
          } else {
            let $ = function (G, j) {
              var U = G.replace(/[A-Z]/g, function (V) {
                  return "-".concat(V.toLowerCase());
                }),
                H = j;
              !vre[G] &&
                typeof H == "number" &&
                H !== 0 &&
                (H = "".concat(H, "px")),
                G === "animationName" &&
                  j !== null &&
                  j !== void 0 &&
                  j._keyframe &&
                  (g(j), (H = j.getName(a))),
                (h += "".concat(U, ":").concat(H, ";"));
            };
            var D,
              B =
                (D = T == null ? void 0 : T.value) !== null && D !== void 0
                  ? D
                  : T;
            $t(T) === "object" &&
            T !== null &&
            T !== void 0 &&
            T[ZB] &&
            Array.isArray(B)
              ? B.forEach(function (G) {
                  $(w, G);
                })
              : $(w, B);
          }
        });
      }
    }),
    i
      ? l &&
        ((h = "@layer ".concat(l.name, " {").concat(h, "}")),
        l.dependencies &&
          (m["@layer ".concat(l.name)] = l.dependencies.map(function (v) {
            return "@layer ".concat(v, ", ").concat(l.name, ";");
          }).join(`
`)))
      : (h = "{".concat(h, "}")),
    [h, m]
  );
};
function QB(n, e) {
  return Wg("".concat(n.join("%")).concat(e));
}
function Vre() {
  return null;
}
var JB = "style";
function eT(n, e) {
  var t = n.token,
    r = n.path,
    i = n.hashId,
    s = n.layer,
    o = n.nonce,
    a = n.clientOnly,
    l = n.order,
    c = l === void 0 ? 0 : l,
    u = I.useContext(oS),
    d = u.autoClear;
  u.mock;
  var h = u.defaultCache,
    m = u.hashPriority,
    g = u.container,
    x = u.ssrInline,
    y = u.transformers,
    v = u.linters,
    _ = u.cache,
    S = u.layer,
    w = t._tokenKey,
    T = [w];
  S && T.push("layer"), T.push.apply(T, Ot(r));
  var E = KM,
    M = sR(
      JB,
      T,
      function () {
        var O = T.join("|");
        if (Dre(O)) {
          var D = Fre(O),
            B = Et(D, 2),
            $ = B[0],
            G = B[1];
          if ($) return [$, w, G, {}, a, c];
        }
        var j = e(),
          U = Bre(j, {
            hashId: i,
            hashPriority: m,
            layer: S ? s : void 0,
            path: r.join("-"),
            transformers: y,
            linters: v,
          }),
          H = Et(U, 2),
          V = H[0],
          k = H[1],
          W = Px(V),
          ee = QB(T, W);
        return [W, w, ee, k, a, c];
      },
      function (O, D) {
        var B = Et(O, 3),
          $ = B[2];
        (D || d) && KM && kB($, { mark: fa });
      },
      function (O) {
        var D = Et(O, 4),
          B = D[0];
        D[1];
        var $ = D[2],
          G = D[3];
        if (E && B !== qB) {
          var j = {
              mark: fa,
              prepend: S ? !1 : "queue",
              attachTo: g,
              priority: c,
            },
            U = typeof o == "function" ? o() : o;
          U && (j.csp = { nonce: U });
          var H = [],
            V = [];
          Object.keys(G).forEach(function (W) {
            W.startsWith("@layer") ? H.push(W) : V.push(W);
          }),
            H.forEach(function (W) {
              dd(
                Px(G[W]),
                "_layer-".concat(W),
                Ze(Ze({}, j), {}, { prepend: !0 })
              );
            });
          var k = dd(B, $, j);
          (k[wc] = _.instanceId),
            k.setAttribute(Gh, w),
            V.forEach(function (W) {
              dd(Px(G[W]), "_effect-".concat(W), j);
            });
        }
      }
    ),
    N = Et(M, 3),
    R = N[0],
    C = N[1],
    L = N[2];
  return function (O) {
    var D;
    if (!x || E || !h) D = I.createElement(Vre, null);
    else {
      var B;
      D = I.createElement(
        "style",
        an({}, ((B = {}), Te(B, Gh, C), Te(B, fa, L), B), {
          dangerouslySetInnerHTML: { __html: R },
        })
      );
    }
    return I.createElement(I.Fragment, null, D, O);
  };
}
var Hre = function (e, t, r) {
    var i = Et(e, 6),
      s = i[0],
      o = i[1],
      a = i[2],
      l = i[3],
      c = i[4],
      u = i[5],
      d = r || {},
      h = d.plain;
    if (c) return null;
    var m = s,
      g = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) };
    return (
      (m = M1(s, o, a, g, h)),
      l &&
        Object.keys(l).forEach(function (x) {
          if (!t[x]) {
            t[x] = !0;
            var y = Px(l[x]),
              v = M1(y, o, "_effect-".concat(x), g, h);
            x.startsWith("@layer") ? (m = v + m) : (m += v);
          }
        }),
      [u, a, m]
    );
  },
  e5 = "cssVar",
  Gre = function (e, t) {
    var r = e.key,
      i = e.prefix,
      s = e.unitless,
      o = e.ignore,
      a = e.token,
      l = e.scope,
      c = l === void 0 ? "" : l,
      u = I.useContext(oS),
      d = u.cache.instanceId,
      h = u.container,
      m = a._tokenKey,
      g = [].concat(Ot(e.path), [r, c, m]),
      x = sR(
        e5,
        g,
        function () {
          var y = t(),
            v = VB(y, r, { prefix: i, unitless: s, ignore: o, scope: c }),
            _ = Et(v, 2),
            S = _[0],
            w = _[1],
            T = QB(g, w);
          return [S, w, T, r];
        },
        function (y) {
          var v = Et(y, 3),
            _ = v[2];
          KM && kB(_, { mark: fa });
        },
        function (y) {
          var v = Et(y, 3),
            _ = v[1],
            S = v[2];
          if (_) {
            var w = dd(_, S, {
              mark: fa,
              prepend: "queue",
              attachTo: h,
              priority: -999,
            });
            (w[wc] = d), w.setAttribute(Gh, r);
          }
        }
      );
    return x;
  },
  Wre = function (e, t, r) {
    var i = Et(e, 4),
      s = i[1],
      o = i[2],
      a = i[3],
      l = r || {},
      c = l.plain;
    if (!s) return null;
    var u = -999,
      d = { "data-rc-order": "prependQueue", "data-rc-priority": "".concat(u) },
      h = M1(s, a, o, d, c);
    return [u, o, h];
  },
  xm;
(xm = {}), Te(xm, JB, Hre), Te(xm, HB, gre), Te(xm, e5, Wre);
var pO = (function () {
  function n(e, t) {
    ss(this, n),
      Te(this, "name", void 0),
      Te(this, "style", void 0),
      Te(this, "_keyframe", !0),
      (this.name = e),
      (this.style = t);
  }
  return (
    os(n, [
      {
        key: "getName",
        value: function () {
          var t =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          return t ? "".concat(t, "-").concat(this.name) : this.name;
        },
      },
    ]),
    n
  );
})();
function Of(n) {
  return (n.notSplit = !0), n;
}
Of(["borderTop", "borderBottom"]),
  Of(["borderTop"]),
  Of(["borderBottom"]),
  Of(["borderLeft", "borderRight"]),
  Of(["borderLeft"]),
  Of(["borderRight"]);
var lR = I.createContext({});
function jre(n) {
  return LB(n) || RB(n) || tR(n) || OB();
}
function Ba(n, e) {
  for (var t = n, r = 0; r < e.length; r += 1) {
    if (t == null) return;
    t = t[e[r]];
  }
  return t;
}
function t5(n, e, t, r) {
  if (!e.length) return t;
  var i = jre(e),
    s = i[0],
    o = i.slice(1),
    a;
  return (
    !n && typeof s == "number"
      ? (a = [])
      : Array.isArray(n)
      ? (a = Ot(n))
      : (a = Ze({}, n)),
    r && t === void 0 && o.length === 1
      ? delete a[s][o[0]]
      : (a[s] = t5(a[s], o, t, r)),
    a
  );
}
function ra(n, e, t) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return e.length && r && t === void 0 && !Ba(n, e.slice(0, -1))
    ? n
    : t5(n, e, t, r);
}
function $re(n) {
  return (
    $t(n) === "object" &&
    n !== null &&
    Object.getPrototypeOf(n) === Object.prototype
  );
}
function mO(n) {
  return Array.isArray(n) ? [] : {};
}
var Xre = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function sh() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  var r = mO(e[0]);
  return (
    e.forEach(function (i) {
      function s(o, a) {
        var l = new Set(a),
          c = Ba(i, o),
          u = Array.isArray(c);
        if (u || $re(c)) {
          if (!l.has(c)) {
            l.add(c);
            var d = Ba(r, o);
            u
              ? (r = ra(r, o, []))
              : (!d || $t(d) !== "object") && (r = ra(r, o, mO(c))),
              Xre(c).forEach(function (h) {
                s([].concat(Ot(o), [h]), l);
              });
          }
        } else r = ra(r, o, c);
      }
      s([]);
    }),
    r
  );
}
const Yre = I.createContext({}),
  qre = I.createContext(void 0);
var Kre = {
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size",
  },
  Zre = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: !0,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century",
  };
const n5 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"],
  },
  gO = {
    lang: Object.assign(
      {
        placeholder: "Select date",
        yearPlaceholder: "Select year",
        quarterPlaceholder: "Select quarter",
        monthPlaceholder: "Select month",
        weekPlaceholder: "Select week",
        rangePlaceholder: ["Start date", "End date"],
        rangeYearPlaceholder: ["Start year", "End year"],
        rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
        rangeMonthPlaceholder: ["Start month", "End month"],
        rangeWeekPlaceholder: ["Start week", "End week"],
      },
      Zre
    ),
    timePickerLocale: Object.assign({}, n5),
  },
  Hs = "${label} is not a valid ${type}",
  cS = {
    locale: "en",
    Pagination: Kre,
    DatePicker: gO,
    TimePicker: n5,
    Calendar: gO,
    global: { placeholder: "Please select" },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting",
    },
    Tour: { Next: "Next", Previous: "Previous", Finish: "Finish" },
    Modal: { okText: "OK", cancelText: "Cancel", justOkText: "OK" },
    Popconfirm: { okText: "OK", cancelText: "Cancel" },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      deselectAll: "Deselect all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page",
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file",
    },
    Empty: { description: "No data" },
    Icon: { icon: "icon" },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand",
      collapse: "Collapse",
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date",
        },
        types: {
          string: Hs,
          method: Hs,
          array: Hs,
          object: Hs,
          number: Hs,
          date: Hs,
          boolean: Hs,
          integer: Hs,
          float: Hs,
          regexp: Hs,
          email: Hs,
          url: Hs,
          hex: Hs,
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters",
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}",
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}",
        },
        pattern: { mismatch: "${label} does not match the pattern ${pattern}" },
      },
    },
    Image: { preview: "Preview" },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh",
      scanned: "Scanned",
    },
    ColorPicker: { presetEmpty: "Empty" },
  };
Object.assign({}, cS.Modal);
let Ix = [];
const vO = () =>
  Ix.reduce((n, e) => Object.assign(Object.assign({}, n), e), cS.Modal);
function Qre(n) {
  if (n) {
    const e = Object.assign({}, n);
    return (
      Ix.push(e),
      vO(),
      () => {
        (Ix = Ix.filter((t) => t !== e)), vO();
      }
    );
  }
  Object.assign({}, cS.Modal);
}
const r5 = I.createContext(void 0),
  Jre = "internalMark",
  eie = (n) => {
    const { locale: e = {}, children: t, _ANT_MARK__: r } = n;
    I.useEffect(() => Qre(e && e.Modal), [e]);
    const i = I.useMemo(
      () => Object.assign(Object.assign({}, e), { exist: !0 }),
      [e]
    );
    return I.createElement(r5.Provider, { value: i }, t);
  };
function gi(n, e) {
  tie(n) && (n = "100%");
  var t = nie(n);
  return (
    (n = e === 360 ? n : Math.min(e, Math.max(0, parseFloat(n)))),
    t && (n = parseInt(String(n * e), 10) / 100),
    Math.abs(n - e) < 1e-6
      ? 1
      : (e === 360
          ? (n = (n < 0 ? (n % e) + e : n % e) / parseFloat(String(e)))
          : (n = (n % e) / parseFloat(String(e))),
        n)
  );
}
function Gy(n) {
  return Math.min(1, Math.max(0, n));
}
function tie(n) {
  return typeof n == "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function nie(n) {
  return typeof n == "string" && n.indexOf("%") !== -1;
}
function i5(n) {
  return (n = parseFloat(n)), (isNaN(n) || n < 0 || n > 1) && (n = 1), n;
}
function Wy(n) {
  return n <= 1 ? "".concat(Number(n) * 100, "%") : n;
}
function Qu(n) {
  return n.length === 1 ? "0" + n : String(n);
}
function rie(n, e, t) {
  return { r: gi(n, 255) * 255, g: gi(e, 255) * 255, b: gi(t, 255) * 255 };
}
function yO(n, e, t) {
  (n = gi(n, 255)), (e = gi(e, 255)), (t = gi(t, 255));
  var r = Math.max(n, e, t),
    i = Math.min(n, e, t),
    s = 0,
    o = 0,
    a = (r + i) / 2;
  if (r === i) (o = 0), (s = 0);
  else {
    var l = r - i;
    switch (((o = a > 0.5 ? l / (2 - r - i) : l / (r + i)), r)) {
      case n:
        s = (e - t) / l + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - n) / l + 2;
        break;
      case t:
        s = (n - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: o, l: a };
}
function nb(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * (6 * t)
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function iie(n, e, t) {
  var r, i, s;
  if (((n = gi(n, 360)), (e = gi(e, 100)), (t = gi(t, 100)), e === 0))
    (i = t), (s = t), (r = t);
  else {
    var o = t < 0.5 ? t * (1 + e) : t + e - t * e,
      a = 2 * t - o;
    (r = nb(a, o, n + 1 / 3)), (i = nb(a, o, n)), (s = nb(a, o, n - 1 / 3));
  }
  return { r: r * 255, g: i * 255, b: s * 255 };
}
function tT(n, e, t) {
  (n = gi(n, 255)), (e = gi(e, 255)), (t = gi(t, 255));
  var r = Math.max(n, e, t),
    i = Math.min(n, e, t),
    s = 0,
    o = r,
    a = r - i,
    l = r === 0 ? 0 : a / r;
  if (r === i) s = 0;
  else {
    switch (r) {
      case n:
        s = (e - t) / a + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - n) / a + 2;
        break;
      case t:
        s = (n - e) / a + 4;
        break;
    }
    s /= 6;
  }
  return { h: s, s: l, v: o };
}
function sie(n, e, t) {
  (n = gi(n, 360) * 6), (e = gi(e, 100)), (t = gi(t, 100));
  var r = Math.floor(n),
    i = n - r,
    s = t * (1 - e),
    o = t * (1 - i * e),
    a = t * (1 - (1 - i) * e),
    l = r % 6,
    c = [t, o, s, s, a, t][l],
    u = [a, t, t, o, s, s][l],
    d = [s, s, a, t, t, o][l];
  return { r: c * 255, g: u * 255, b: d * 255 };
}
function nT(n, e, t, r) {
  var i = [
    Qu(Math.round(n).toString(16)),
    Qu(Math.round(e).toString(16)),
    Qu(Math.round(t).toString(16)),
  ];
  return r &&
    i[0].startsWith(i[0].charAt(1)) &&
    i[1].startsWith(i[1].charAt(1)) &&
    i[2].startsWith(i[2].charAt(1))
    ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0)
    : i.join("");
}
function oie(n, e, t, r, i) {
  var s = [
    Qu(Math.round(n).toString(16)),
    Qu(Math.round(e).toString(16)),
    Qu(Math.round(t).toString(16)),
    Qu(aie(r)),
  ];
  return i &&
    s[0].startsWith(s[0].charAt(1)) &&
    s[1].startsWith(s[1].charAt(1)) &&
    s[2].startsWith(s[2].charAt(1)) &&
    s[3].startsWith(s[3].charAt(1))
    ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0)
    : s.join("");
}
function aie(n) {
  return Math.round(parseFloat(n) * 255).toString(16);
}
function xO(n) {
  return js(n) / 255;
}
function js(n) {
  return parseInt(n, 16);
}
function lie(n) {
  return { r: n >> 16, g: (n & 65280) >> 8, b: n & 255 };
}
var rT = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32",
};
function Bf(n) {
  var e = { r: 0, g: 0, b: 0 },
    t = 1,
    r = null,
    i = null,
    s = null,
    o = !1,
    a = !1;
  return (
    typeof n == "string" && (n = die(n)),
    typeof n == "object" &&
      (gl(n.r) && gl(n.g) && gl(n.b)
        ? ((e = rie(n.r, n.g, n.b)),
          (o = !0),
          (a = String(n.r).substr(-1) === "%" ? "prgb" : "rgb"))
        : gl(n.h) && gl(n.s) && gl(n.v)
        ? ((r = Wy(n.s)),
          (i = Wy(n.v)),
          (e = sie(n.h, r, i)),
          (o = !0),
          (a = "hsv"))
        : gl(n.h) &&
          gl(n.s) &&
          gl(n.l) &&
          ((r = Wy(n.s)),
          (s = Wy(n.l)),
          (e = iie(n.h, r, s)),
          (o = !0),
          (a = "hsl")),
      Object.prototype.hasOwnProperty.call(n, "a") && (t = n.a)),
    (t = i5(t)),
    {
      ok: o,
      format: n.format || a,
      r: Math.min(255, Math.max(e.r, 0)),
      g: Math.min(255, Math.max(e.g, 0)),
      b: Math.min(255, Math.max(e.b, 0)),
      a: t,
    }
  );
}
var cie = "[-\\+]?\\d+%?",
  uie = "[-\\+]?\\d*\\.\\d+%?",
  bc = "(?:".concat(uie, ")|(?:").concat(cie, ")"),
  rb = "[\\s|\\(]+("
    .concat(bc, ")[,|\\s]+(")
    .concat(bc, ")[,|\\s]+(")
    .concat(bc, ")\\s*\\)?"),
  ib = "[\\s|\\(]+("
    .concat(bc, ")[,|\\s]+(")
    .concat(bc, ")[,|\\s]+(")
    .concat(bc, ")[,|\\s]+(")
    .concat(bc, ")\\s*\\)?"),
  Jo = {
    CSS_UNIT: new RegExp(bc),
    rgb: new RegExp("rgb" + rb),
    rgba: new RegExp("rgba" + ib),
    hsl: new RegExp("hsl" + rb),
    hsla: new RegExp("hsla" + ib),
    hsv: new RegExp("hsv" + rb),
    hsva: new RegExp("hsva" + ib),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  };
function die(n) {
  if (((n = n.trim().toLowerCase()), n.length === 0)) return !1;
  var e = !1;
  if (rT[n]) (n = rT[n]), (e = !0);
  else if (n === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var t = Jo.rgb.exec(n);
  return t
    ? { r: t[1], g: t[2], b: t[3] }
    : ((t = Jo.rgba.exec(n)),
      t
        ? { r: t[1], g: t[2], b: t[3], a: t[4] }
        : ((t = Jo.hsl.exec(n)),
          t
            ? { h: t[1], s: t[2], l: t[3] }
            : ((t = Jo.hsla.exec(n)),
              t
                ? { h: t[1], s: t[2], l: t[3], a: t[4] }
                : ((t = Jo.hsv.exec(n)),
                  t
                    ? { h: t[1], s: t[2], v: t[3] }
                    : ((t = Jo.hsva.exec(n)),
                      t
                        ? { h: t[1], s: t[2], v: t[3], a: t[4] }
                        : ((t = Jo.hex8.exec(n)),
                          t
                            ? {
                                r: js(t[1]),
                                g: js(t[2]),
                                b: js(t[3]),
                                a: xO(t[4]),
                                format: e ? "name" : "hex8",
                              }
                            : ((t = Jo.hex6.exec(n)),
                              t
                                ? {
                                    r: js(t[1]),
                                    g: js(t[2]),
                                    b: js(t[3]),
                                    format: e ? "name" : "hex",
                                  }
                                : ((t = Jo.hex4.exec(n)),
                                  t
                                    ? {
                                        r: js(t[1] + t[1]),
                                        g: js(t[2] + t[2]),
                                        b: js(t[3] + t[3]),
                                        a: xO(t[4] + t[4]),
                                        format: e ? "name" : "hex8",
                                      }
                                    : ((t = Jo.hex3.exec(n)),
                                      t
                                        ? {
                                            r: js(t[1] + t[1]),
                                            g: js(t[2] + t[2]),
                                            b: js(t[3] + t[3]),
                                            format: e ? "name" : "hex",
                                          }
                                        : !1)))))))));
}
function gl(n) {
  return !!Jo.CSS_UNIT.exec(String(n));
}
var Js = (function () {
    function n(e, t) {
      e === void 0 && (e = ""), t === void 0 && (t = {});
      var r;
      if (e instanceof n) return e;
      typeof e == "number" && (e = lie(e)), (this.originalInput = e);
      var i = Bf(e);
      (this.originalInput = e),
        (this.r = i.r),
        (this.g = i.g),
        (this.b = i.b),
        (this.a = i.a),
        (this.roundA = Math.round(100 * this.a) / 100),
        (this.format = (r = t.format) !== null && r !== void 0 ? r : i.format),
        (this.gradientType = t.gradientType),
        this.r < 1 && (this.r = Math.round(this.r)),
        this.g < 1 && (this.g = Math.round(this.g)),
        this.b < 1 && (this.b = Math.round(this.b)),
        (this.isValid = i.ok);
    }
    return (
      (n.prototype.isDark = function () {
        return this.getBrightness() < 128;
      }),
      (n.prototype.isLight = function () {
        return !this.isDark();
      }),
      (n.prototype.getBrightness = function () {
        var e = this.toRgb();
        return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
      }),
      (n.prototype.getLuminance = function () {
        var e = this.toRgb(),
          t,
          r,
          i,
          s = e.r / 255,
          o = e.g / 255,
          a = e.b / 255;
        return (
          s <= 0.03928
            ? (t = s / 12.92)
            : (t = Math.pow((s + 0.055) / 1.055, 2.4)),
          o <= 0.03928
            ? (r = o / 12.92)
            : (r = Math.pow((o + 0.055) / 1.055, 2.4)),
          a <= 0.03928
            ? (i = a / 12.92)
            : (i = Math.pow((a + 0.055) / 1.055, 2.4)),
          0.2126 * t + 0.7152 * r + 0.0722 * i
        );
      }),
      (n.prototype.getAlpha = function () {
        return this.a;
      }),
      (n.prototype.setAlpha = function (e) {
        return (
          (this.a = i5(e)), (this.roundA = Math.round(100 * this.a) / 100), this
        );
      }),
      (n.prototype.isMonochrome = function () {
        var e = this.toHsl().s;
        return e === 0;
      }),
      (n.prototype.toHsv = function () {
        var e = tT(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, v: e.v, a: this.a };
      }),
      (n.prototype.toHsvString = function () {
        var e = tT(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          i = Math.round(e.v * 100);
        return this.a === 1
          ? "hsv(".concat(t, ", ").concat(r, "%, ").concat(i, "%)")
          : "hsva("
              .concat(t, ", ")
              .concat(r, "%, ")
              .concat(i, "%, ")
              .concat(this.roundA, ")");
      }),
      (n.prototype.toHsl = function () {
        var e = yO(this.r, this.g, this.b);
        return { h: e.h * 360, s: e.s, l: e.l, a: this.a };
      }),
      (n.prototype.toHslString = function () {
        var e = yO(this.r, this.g, this.b),
          t = Math.round(e.h * 360),
          r = Math.round(e.s * 100),
          i = Math.round(e.l * 100);
        return this.a === 1
          ? "hsl(".concat(t, ", ").concat(r, "%, ").concat(i, "%)")
          : "hsla("
              .concat(t, ", ")
              .concat(r, "%, ")
              .concat(i, "%, ")
              .concat(this.roundA, ")");
      }),
      (n.prototype.toHex = function (e) {
        return e === void 0 && (e = !1), nT(this.r, this.g, this.b, e);
      }),
      (n.prototype.toHexString = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex(e);
      }),
      (n.prototype.toHex8 = function (e) {
        return e === void 0 && (e = !1), oie(this.r, this.g, this.b, this.a, e);
      }),
      (n.prototype.toHex8String = function (e) {
        return e === void 0 && (e = !1), "#" + this.toHex8(e);
      }),
      (n.prototype.toHexShortString = function (e) {
        return (
          e === void 0 && (e = !1),
          this.a === 1 ? this.toHexString(e) : this.toHex8String(e)
        );
      }),
      (n.prototype.toRgb = function () {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a,
        };
      }),
      (n.prototype.toRgbString = function () {
        var e = Math.round(this.r),
          t = Math.round(this.g),
          r = Math.round(this.b);
        return this.a === 1
          ? "rgb(".concat(e, ", ").concat(t, ", ").concat(r, ")")
          : "rgba("
              .concat(e, ", ")
              .concat(t, ", ")
              .concat(r, ", ")
              .concat(this.roundA, ")");
      }),
      (n.prototype.toPercentageRgb = function () {
        var e = function (t) {
          return "".concat(Math.round(gi(t, 255) * 100), "%");
        };
        return { r: e(this.r), g: e(this.g), b: e(this.b), a: this.a };
      }),
      (n.prototype.toPercentageRgbString = function () {
        var e = function (t) {
          return Math.round(gi(t, 255) * 100);
        };
        return this.a === 1
          ? "rgb("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%)")
          : "rgba("
              .concat(e(this.r), "%, ")
              .concat(e(this.g), "%, ")
              .concat(e(this.b), "%, ")
              .concat(this.roundA, ")");
      }),
      (n.prototype.toName = function () {
        if (this.a === 0) return "transparent";
        if (this.a < 1) return !1;
        for (
          var e = "#" + nT(this.r, this.g, this.b, !1),
            t = 0,
            r = Object.entries(rT);
          t < r.length;
          t++
        ) {
          var i = r[t],
            s = i[0],
            o = i[1];
          if (e === o) return s;
        }
        return !1;
      }),
      (n.prototype.toString = function (e) {
        var t = !!e;
        e = e ?? this.format;
        var r = !1,
          i = this.a < 1 && this.a >= 0,
          s = !t && i && (e.startsWith("hex") || e === "name");
        return s
          ? e === "name" && this.a === 0
            ? this.toName()
            : this.toRgbString()
          : (e === "rgb" && (r = this.toRgbString()),
            e === "prgb" && (r = this.toPercentageRgbString()),
            (e === "hex" || e === "hex6") && (r = this.toHexString()),
            e === "hex3" && (r = this.toHexString(!0)),
            e === "hex4" && (r = this.toHex8String(!0)),
            e === "hex8" && (r = this.toHex8String()),
            e === "name" && (r = this.toName()),
            e === "hsl" && (r = this.toHslString()),
            e === "hsv" && (r = this.toHsvString()),
            r || this.toHexString());
      }),
      (n.prototype.toNumber = function () {
        return (
          (Math.round(this.r) << 16) +
          (Math.round(this.g) << 8) +
          Math.round(this.b)
        );
      }),
      (n.prototype.clone = function () {
        return new n(this.toString());
      }),
      (n.prototype.lighten = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.l += e / 100), (t.l = Gy(t.l)), new n(t);
      }),
      (n.prototype.brighten = function (e) {
        e === void 0 && (e = 10);
        var t = this.toRgb();
        return (
          (t.r = Math.max(
            0,
            Math.min(255, t.r - Math.round(255 * -(e / 100)))
          )),
          (t.g = Math.max(
            0,
            Math.min(255, t.g - Math.round(255 * -(e / 100)))
          )),
          (t.b = Math.max(
            0,
            Math.min(255, t.b - Math.round(255 * -(e / 100)))
          )),
          new n(t)
        );
      }),
      (n.prototype.darken = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.l -= e / 100), (t.l = Gy(t.l)), new n(t);
      }),
      (n.prototype.tint = function (e) {
        return e === void 0 && (e = 10), this.mix("white", e);
      }),
      (n.prototype.shade = function (e) {
        return e === void 0 && (e = 10), this.mix("black", e);
      }),
      (n.prototype.desaturate = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.s -= e / 100), (t.s = Gy(t.s)), new n(t);
      }),
      (n.prototype.saturate = function (e) {
        e === void 0 && (e = 10);
        var t = this.toHsl();
        return (t.s += e / 100), (t.s = Gy(t.s)), new n(t);
      }),
      (n.prototype.greyscale = function () {
        return this.desaturate(100);
      }),
      (n.prototype.spin = function (e) {
        var t = this.toHsl(),
          r = (t.h + e) % 360;
        return (t.h = r < 0 ? 360 + r : r), new n(t);
      }),
      (n.prototype.mix = function (e, t) {
        t === void 0 && (t = 50);
        var r = this.toRgb(),
          i = new n(e).toRgb(),
          s = t / 100,
          o = {
            r: (i.r - r.r) * s + r.r,
            g: (i.g - r.g) * s + r.g,
            b: (i.b - r.b) * s + r.b,
            a: (i.a - r.a) * s + r.a,
          };
        return new n(o);
      }),
      (n.prototype.analogous = function (e, t) {
        e === void 0 && (e = 6), t === void 0 && (t = 30);
        var r = this.toHsl(),
          i = 360 / t,
          s = [this];
        for (r.h = (r.h - ((i * e) >> 1) + 720) % 360; --e; )
          (r.h = (r.h + i) % 360), s.push(new n(r));
        return s;
      }),
      (n.prototype.complement = function () {
        var e = this.toHsl();
        return (e.h = (e.h + 180) % 360), new n(e);
      }),
      (n.prototype.monochromatic = function (e) {
        e === void 0 && (e = 6);
        for (
          var t = this.toHsv(), r = t.h, i = t.s, s = t.v, o = [], a = 1 / e;
          e--;

        )
          o.push(new n({ h: r, s: i, v: s })), (s = (s + a) % 1);
        return o;
      }),
      (n.prototype.splitcomplement = function () {
        var e = this.toHsl(),
          t = e.h;
        return [
          this,
          new n({ h: (t + 72) % 360, s: e.s, l: e.l }),
          new n({ h: (t + 216) % 360, s: e.s, l: e.l }),
        ];
      }),
      (n.prototype.onBackground = function (e) {
        var t = this.toRgb(),
          r = new n(e).toRgb(),
          i = t.a + r.a * (1 - t.a);
        return new n({
          r: (t.r * t.a + r.r * r.a * (1 - t.a)) / i,
          g: (t.g * t.a + r.g * r.a * (1 - t.a)) / i,
          b: (t.b * t.a + r.b * r.a * (1 - t.a)) / i,
          a: i,
        });
      }),
      (n.prototype.triad = function () {
        return this.polyad(3);
      }),
      (n.prototype.tetrad = function () {
        return this.polyad(4);
      }),
      (n.prototype.polyad = function (e) {
        for (
          var t = this.toHsl(), r = t.h, i = [this], s = 360 / e, o = 1;
          o < e;
          o++
        )
          i.push(new n({ h: (r + o * s) % 360, s: t.s, l: t.l }));
        return i;
      }),
      (n.prototype.equals = function (e) {
        return this.toRgbString() === new n(e).toRgbString();
      }),
      n
    );
  })(),
  jy = 2,
  _O = 0.16,
  fie = 0.05,
  hie = 0.05,
  pie = 0.15,
  s5 = 5,
  o5 = 4,
  mie = [
    { index: 7, opacity: 0.15 },
    { index: 6, opacity: 0.25 },
    { index: 5, opacity: 0.3 },
    { index: 5, opacity: 0.45 },
    { index: 5, opacity: 0.65 },
    { index: 5, opacity: 0.85 },
    { index: 4, opacity: 0.9 },
    { index: 3, opacity: 0.95 },
    { index: 2, opacity: 0.97 },
    { index: 1, opacity: 0.98 },
  ];
function SO(n) {
  var e = n.r,
    t = n.g,
    r = n.b,
    i = tT(e, t, r);
  return { h: i.h * 360, s: i.s, v: i.v };
}
function $y(n) {
  var e = n.r,
    t = n.g,
    r = n.b;
  return "#".concat(nT(e, t, r, !1));
}
function gie(n, e, t) {
  var r = t / 100,
    i = {
      r: (e.r - n.r) * r + n.r,
      g: (e.g - n.g) * r + n.g,
      b: (e.b - n.b) * r + n.b,
    };
  return i;
}
function AO(n, e, t) {
  var r;
  return (
    Math.round(n.h) >= 60 && Math.round(n.h) <= 240
      ? (r = t ? Math.round(n.h) - jy * e : Math.round(n.h) + jy * e)
      : (r = t ? Math.round(n.h) + jy * e : Math.round(n.h) - jy * e),
    r < 0 ? (r += 360) : r >= 360 && (r -= 360),
    r
  );
}
function wO(n, e, t) {
  if (n.h === 0 && n.s === 0) return n.s;
  var r;
  return (
    t ? (r = n.s - _O * e) : e === o5 ? (r = n.s + _O) : (r = n.s + fie * e),
    r > 1 && (r = 1),
    t && e === s5 && r > 0.1 && (r = 0.1),
    r < 0.06 && (r = 0.06),
    Number(r.toFixed(2))
  );
}
function bO(n, e, t) {
  var r;
  return (
    t ? (r = n.v + hie * e) : (r = n.v - pie * e),
    r > 1 && (r = 1),
    Number(r.toFixed(2))
  );
}
function bd(n) {
  for (
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      t = [],
      r = Bf(n),
      i = s5;
    i > 0;
    i -= 1
  ) {
    var s = SO(r),
      o = $y(Bf({ h: AO(s, i, !0), s: wO(s, i, !0), v: bO(s, i, !0) }));
    t.push(o);
  }
  t.push($y(r));
  for (var a = 1; a <= o5; a += 1) {
    var l = SO(r),
      c = $y(Bf({ h: AO(l, a), s: wO(l, a), v: bO(l, a) }));
    t.push(c);
  }
  return e.theme === "dark"
    ? mie.map(function (u) {
        var d = u.index,
          h = u.opacity,
          m = $y(gie(Bf(e.backgroundColor || "#141414"), Bf(t[d]), h * 100));
        return m;
      })
    : t;
}
var sb = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666",
  },
  Lx = {},
  ob = {};
Object.keys(sb).forEach(function (n) {
  (Lx[n] = bd(sb[n])),
    (Lx[n].primary = Lx[n][5]),
    (ob[n] = bd(sb[n], { theme: "dark", backgroundColor: "#141414" })),
    (ob[n].primary = ob[n][5]);
});
var vie = Lx.blue;
const a5 = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911",
  },
  Xg = Object.assign(Object.assign({}, a5), {
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorLink: "",
    colorTextBase: "",
    colorBgBase: "",
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode:
      "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
    fontSize: 14,
    lineWidth: 1,
    lineType: "solid",
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    borderRadius: 6,
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    controlHeight: 32,
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    opacityImage: 1,
    wireframe: !1,
    motion: !0,
  });
function yie(n, e) {
  let { generateColorPalettes: t, generateNeutralColorPalettes: r } = e;
  const {
      colorSuccess: i,
      colorWarning: s,
      colorError: o,
      colorInfo: a,
      colorPrimary: l,
      colorBgBase: c,
      colorTextBase: u,
    } = n,
    d = t(l),
    h = t(i),
    m = t(s),
    g = t(o),
    x = t(a),
    y = r(c, u),
    v = n.colorLink || n.colorInfo,
    _ = t(v);
  return Object.assign(Object.assign({}, y), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: h[1],
    colorSuccessBgHover: h[2],
    colorSuccessBorder: h[3],
    colorSuccessBorderHover: h[4],
    colorSuccessHover: h[4],
    colorSuccess: h[6],
    colorSuccessActive: h[7],
    colorSuccessTextHover: h[8],
    colorSuccessText: h[9],
    colorSuccessTextActive: h[10],
    colorErrorBg: g[1],
    colorErrorBgHover: g[2],
    colorErrorBgActive: g[3],
    colorErrorBorder: g[3],
    colorErrorBorderHover: g[4],
    colorErrorHover: g[5],
    colorError: g[6],
    colorErrorActive: g[7],
    colorErrorTextHover: g[8],
    colorErrorText: g[9],
    colorErrorTextActive: g[10],
    colorWarningBg: m[1],
    colorWarningBgHover: m[2],
    colorWarningBorder: m[3],
    colorWarningBorderHover: m[4],
    colorWarningHover: m[4],
    colorWarning: m[6],
    colorWarningActive: m[7],
    colorWarningTextHover: m[8],
    colorWarningText: m[9],
    colorWarningTextActive: m[10],
    colorInfoBg: x[1],
    colorInfoBgHover: x[2],
    colorInfoBorder: x[3],
    colorInfoBorderHover: x[4],
    colorInfoHover: x[4],
    colorInfo: x[6],
    colorInfoActive: x[7],
    colorInfoTextHover: x[8],
    colorInfoText: x[9],
    colorInfoTextActive: x[10],
    colorLinkHover: _[4],
    colorLink: _[6],
    colorLinkActive: _[7],
    colorBgMask: new Js("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff",
  });
}
const xie = (n) => {
  let e = n,
    t = n,
    r = n,
    i = n;
  return (
    n < 6 && n >= 5
      ? (e = n + 1)
      : n < 16 && n >= 6
      ? (e = n + 2)
      : n >= 16 && (e = 16),
    n < 7 && n >= 5
      ? (t = 4)
      : n < 8 && n >= 7
      ? (t = 5)
      : n < 14 && n >= 8
      ? (t = 6)
      : n < 16 && n >= 14
      ? (t = 7)
      : n >= 16 && (t = 8),
    n < 6 && n >= 2 ? (r = 1) : n >= 6 && (r = 2),
    n > 4 && n < 8 ? (i = 4) : n >= 8 && (i = 6),
    {
      borderRadius: n,
      borderRadiusXS: r,
      borderRadiusSM: t,
      borderRadiusLG: e,
      borderRadiusOuter: i,
    }
  );
};
function _ie(n) {
  const { motionUnit: e, motionBase: t, borderRadius: r, lineWidth: i } = n;
  return Object.assign(
    {
      motionDurationFast: `${(t + e).toFixed(1)}s`,
      motionDurationMid: `${(t + e * 2).toFixed(1)}s`,
      motionDurationSlow: `${(t + e * 3).toFixed(1)}s`,
      lineWidthBold: i + 1,
    },
    xie(r)
  );
}
const Sie = (n) => {
  const { controlHeight: e } = n;
  return {
    controlHeightSM: e * 0.75,
    controlHeightXS: e * 0.5,
    controlHeightLG: e * 1.25,
  };
};
function Ox(n) {
  return (n + 8) / n;
}
function Aie(n) {
  const e = new Array(10).fill(null).map((t, r) => {
    const i = r - 1,
      s = n * Math.pow(2.71828, i / 5),
      o = r > 1 ? Math.floor(s) : Math.ceil(s);
    return Math.floor(o / 2) * 2;
  });
  return (e[1] = n), e.map((t) => ({ size: t, lineHeight: Ox(t) }));
}
const wie = (n) => {
  const e = Aie(n),
    t = e.map((u) => u.size),
    r = e.map((u) => u.lineHeight),
    i = t[1],
    s = t[0],
    o = t[2],
    a = r[1],
    l = r[0],
    c = r[2];
  return {
    fontSizeSM: s,
    fontSize: i,
    fontSizeLG: o,
    fontSizeXL: t[3],
    fontSizeHeading1: t[6],
    fontSizeHeading2: t[5],
    fontSizeHeading3: t[4],
    fontSizeHeading4: t[3],
    fontSizeHeading5: t[2],
    lineHeight: a,
    lineHeightLG: c,
    lineHeightSM: l,
    fontHeight: Math.round(a * i),
    fontHeightLG: Math.round(c * o),
    fontHeightSM: Math.round(l * s),
    lineHeightHeading1: r[6],
    lineHeightHeading2: r[5],
    lineHeightHeading3: r[4],
    lineHeightHeading4: r[3],
    lineHeightHeading5: r[2],
  };
};
function bie(n) {
  const { sizeUnit: e, sizeStep: t } = n;
  return {
    sizeXXL: e * (t + 8),
    sizeXL: e * (t + 4),
    sizeLG: e * (t + 2),
    sizeMD: e * (t + 1),
    sizeMS: e * t,
    size: e * t,
    sizeSM: e * (t - 1),
    sizeXS: e * (t - 2),
    sizeXXS: e * (t - 3),
  };
}
const vl = (n, e) => new Js(n).setAlpha(e).toRgbString(),
  _m = (n, e) => new Js(n).darken(e).toHexString(),
  Eie = (n) => {
    const e = bd(n);
    return {
      1: e[0],
      2: e[1],
      3: e[2],
      4: e[3],
      5: e[4],
      6: e[5],
      7: e[6],
      8: e[4],
      9: e[5],
      10: e[6],
    };
  },
  Mie = (n, e) => {
    const t = n || "#fff",
      r = e || "#000";
    return {
      colorBgBase: t,
      colorTextBase: r,
      colorText: vl(r, 0.88),
      colorTextSecondary: vl(r, 0.65),
      colorTextTertiary: vl(r, 0.45),
      colorTextQuaternary: vl(r, 0.25),
      colorFill: vl(r, 0.15),
      colorFillSecondary: vl(r, 0.06),
      colorFillTertiary: vl(r, 0.04),
      colorFillQuaternary: vl(r, 0.02),
      colorBgLayout: _m(t, 4),
      colorBgContainer: _m(t, 0),
      colorBgElevated: _m(t, 0),
      colorBgSpotlight: vl(r, 0.85),
      colorBgBlur: "transparent",
      colorBorder: _m(t, 15),
      colorBorderSecondary: _m(t, 6),
    };
  };
function Tie(n) {
  const e = Object.keys(a5)
    .map((t) => {
      const r = bd(n[t]);
      return new Array(10)
        .fill(1)
        .reduce(
          (i, s, o) => (
            (i[`${t}-${o + 1}`] = r[o]), (i[`${t}${o + 1}`] = r[o]), i
          ),
          {}
        );
    })
    .reduce((t, r) => ((t = Object.assign(Object.assign({}, t), r)), t), {});
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, n), e),
            yie(n, {
              generateColorPalettes: Eie,
              generateNeutralColorPalettes: Mie,
            })
          ),
          wie(n.fontSize)
        ),
        bie(n)
      ),
      Sie(n)
    ),
    _ie(n)
  );
}
const l5 = qM(Tie),
  iT = { token: Xg, override: { override: Xg }, hashed: !0 },
  c5 = Je.createContext(iT),
  cR = "anticon",
  Cie = (n, e) => e || (n ? `ant-${n}` : "ant"),
  mr = I.createContext({ getPrefixCls: Cie, iconPrefixCls: cR }),
  Rie = `-ant-${Date.now()}-${Math.random()}`;
function Nie(n, e) {
  const t = {},
    r = (o, a) => {
      let l = o.clone();
      return (l = (a == null ? void 0 : a(l)) || l), l.toRgbString();
    },
    i = (o, a) => {
      const l = new Js(o),
        c = bd(l.toRgbString());
      (t[`${a}-color`] = r(l)),
        (t[`${a}-color-disabled`] = c[1]),
        (t[`${a}-color-hover`] = c[4]),
        (t[`${a}-color-active`] = c[6]),
        (t[`${a}-color-outline`] = l.clone().setAlpha(0.2).toRgbString()),
        (t[`${a}-color-deprecated-bg`] = c[0]),
        (t[`${a}-color-deprecated-border`] = c[2]);
    };
  if (e.primaryColor) {
    i(e.primaryColor, "primary");
    const o = new Js(e.primaryColor),
      a = bd(o.toRgbString());
    a.forEach((c, u) => {
      t[`primary-${u + 1}`] = c;
    }),
      (t["primary-color-deprecated-l-35"] = r(o, (c) => c.lighten(35))),
      (t["primary-color-deprecated-l-20"] = r(o, (c) => c.lighten(20))),
      (t["primary-color-deprecated-t-20"] = r(o, (c) => c.tint(20))),
      (t["primary-color-deprecated-t-50"] = r(o, (c) => c.tint(50))),
      (t["primary-color-deprecated-f-12"] = r(o, (c) =>
        c.setAlpha(c.getAlpha() * 0.12)
      ));
    const l = new Js(a[0]);
    (t["primary-color-active-deprecated-f-30"] = r(l, (c) =>
      c.setAlpha(c.getAlpha() * 0.3)
    )),
      (t["primary-color-active-deprecated-d-02"] = r(l, (c) => c.darken(2)));
  }
  return (
    e.successColor && i(e.successColor, "success"),
    e.warningColor && i(e.warningColor, "warning"),
    e.errorColor && i(e.errorColor, "error"),
    e.infoColor && i(e.infoColor, "info"),
    `
  :root {
    ${Object.keys(t).map((o) => `--${n}-${o}: ${t[o]};`).join(`
`)}
  }
  `.trim()
  );
}
function Pie(n, e) {
  const t = Nie(n, e);
  Wl() && dd(t, `${Rie}-dynamic-theme`);
}
const Ed = I.createContext(!1),
  Iie = (n) => {
    let { children: e, disabled: t } = n;
    const r = I.useContext(Ed);
    return I.createElement(Ed.Provider, { value: t ?? r }, e);
  },
  jh = I.createContext(void 0),
  Lie = (n) => {
    let { children: e, size: t } = n;
    const r = I.useContext(jh);
    return I.createElement(jh.Provider, { value: t || r }, e);
  };
function Oie() {
  const n = I.useContext(Ed),
    e = I.useContext(jh);
  return { componentDisabled: n, componentSize: e };
}
const Die = "5.17.4";
function ab(n) {
  return n >= 0 && n <= 255;
}
function Xy(n, e) {
  const { r: t, g: r, b: i, a: s } = new Js(n).toRgb();
  if (s < 1) return n;
  const { r: o, g: a, b: l } = new Js(e).toRgb();
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((t - o * (1 - c)) / c),
      d = Math.round((r - a * (1 - c)) / c),
      h = Math.round((i - l * (1 - c)) / c);
    if (ab(u) && ab(d) && ab(h))
      return new Js({
        r: u,
        g: d,
        b: h,
        a: Math.round(c * 100) / 100,
      }).toRgbString();
  }
  return new Js({ r: t, g: r, b: i, a: 1 }).toRgbString();
}
var Fie = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
function u5(n) {
  const { override: e } = n,
    t = Fie(n, ["override"]),
    r = Object.assign({}, e);
  Object.keys(Xg).forEach((h) => {
    delete r[h];
  });
  const i = Object.assign(Object.assign({}, t), r),
    s = 480,
    o = 576,
    a = 768,
    l = 992,
    c = 1200,
    u = 1600;
  if (i.motion === !1) {
    const h = "0s";
    (i.motionDurationFast = h),
      (i.motionDurationMid = h),
      (i.motionDurationSlow = h);
  }
  return Object.assign(
    Object.assign(Object.assign({}, i), {
      colorFillContent: i.colorFillSecondary,
      colorFillContentHover: i.colorFill,
      colorFillAlter: i.colorFillQuaternary,
      colorBgContainerDisabled: i.colorFillTertiary,
      colorBorderBg: i.colorBgContainer,
      colorSplit: Xy(i.colorBorderSecondary, i.colorBgContainer),
      colorTextPlaceholder: i.colorTextQuaternary,
      colorTextDisabled: i.colorTextQuaternary,
      colorTextHeading: i.colorText,
      colorTextLabel: i.colorTextSecondary,
      colorTextDescription: i.colorTextTertiary,
      colorTextLightSolid: i.colorWhite,
      colorHighlight: i.colorError,
      colorBgTextHover: i.colorFillSecondary,
      colorBgTextActive: i.colorFill,
      colorIcon: i.colorTextTertiary,
      colorIconHover: i.colorText,
      colorErrorOutline: Xy(i.colorErrorBg, i.colorBgContainer),
      colorWarningOutline: Xy(i.colorWarningBg, i.colorBgContainer),
      fontSizeIcon: i.fontSizeSM,
      lineWidthFocus: i.lineWidth * 4,
      lineWidth: i.lineWidth,
      controlOutlineWidth: i.lineWidth * 2,
      controlInteractiveSize: i.controlHeight / 2,
      controlItemBgHover: i.colorFillTertiary,
      controlItemBgActive: i.colorPrimaryBg,
      controlItemBgActiveHover: i.colorPrimaryBgHover,
      controlItemBgActiveDisabled: i.colorFill,
      controlTmpOutline: i.colorFillQuaternary,
      controlOutline: Xy(i.colorPrimaryBg, i.colorBgContainer),
      lineType: i.lineType,
      borderRadius: i.borderRadius,
      borderRadiusXS: i.borderRadiusXS,
      borderRadiusSM: i.borderRadiusSM,
      borderRadiusLG: i.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: i.sizeXXS,
      paddingXS: i.sizeXS,
      paddingSM: i.sizeSM,
      padding: i.size,
      paddingMD: i.sizeMD,
      paddingLG: i.sizeLG,
      paddingXL: i.sizeXL,
      paddingContentHorizontalLG: i.sizeLG,
      paddingContentVerticalLG: i.sizeMS,
      paddingContentHorizontal: i.sizeMS,
      paddingContentVertical: i.sizeSM,
      paddingContentHorizontalSM: i.size,
      paddingContentVerticalSM: i.sizeXS,
      marginXXS: i.sizeXXS,
      marginXS: i.sizeXS,
      marginSM: i.sizeSM,
      margin: i.size,
      marginMD: i.sizeMD,
      marginLG: i.sizeLG,
      marginXL: i.sizeXL,
      marginXXL: i.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS: s,
      screenXSMin: s,
      screenXSMax: o - 1,
      screenSM: o,
      screenSMMin: o,
      screenSMMax: a - 1,
      screenMD: a,
      screenMDMin: a,
      screenMDMax: l - 1,
      screenLG: l,
      screenLGMin: l,
      screenLGMax: c - 1,
      screenXL: c,
      screenXLMin: c,
      screenXLMax: u - 1,
      screenXXL: u,
      screenXXLMin: u,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new Js("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Js("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Js("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)",
    }),
    r
  );
}
var EO = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const d5 = {
    lineHeight: !0,
    lineHeightSM: !0,
    lineHeightLG: !0,
    lineHeightHeading1: !0,
    lineHeightHeading2: !0,
    lineHeightHeading3: !0,
    lineHeightHeading4: !0,
    lineHeightHeading5: !0,
    opacityLoading: !0,
    fontWeightStrong: !0,
    zIndexPopupBase: !0,
    zIndexBase: !0,
  },
  f5 = {
    size: !0,
    sizeSM: !0,
    sizeLG: !0,
    sizeMD: !0,
    sizeXS: !0,
    sizeXXS: !0,
    sizeMS: !0,
    sizeXL: !0,
    sizeXXL: !0,
    sizeUnit: !0,
    sizeStep: !0,
    motionBase: !0,
    motionUnit: !0,
  },
  Uie = {
    screenXS: !0,
    screenXSMin: !0,
    screenXSMax: !0,
    screenSM: !0,
    screenSMMin: !0,
    screenSMMax: !0,
    screenMD: !0,
    screenMDMin: !0,
    screenMDMax: !0,
    screenLG: !0,
    screenLGMin: !0,
    screenLGMax: !0,
    screenXL: !0,
    screenXLMin: !0,
    screenXLMax: !0,
    screenXXL: !0,
    screenXXLMin: !0,
  },
  h5 = (n, e, t) => {
    const r = t.getDerivativeToken(n),
      { override: i } = e,
      s = EO(e, ["override"]);
    let o = Object.assign(Object.assign({}, r), { override: i });
    return (
      (o = u5(o)),
      s &&
        Object.entries(s).forEach((a) => {
          let [l, c] = a;
          const { theme: u } = c,
            d = EO(c, ["theme"]);
          let h = d;
          u &&
            (h = h5(
              Object.assign(Object.assign({}, o), d),
              { override: d },
              u
            )),
            (o[l] = h);
        }),
      o
    );
  };
function jc() {
  const {
      token: n,
      hashed: e,
      theme: t,
      override: r,
      cssVar: i,
    } = Je.useContext(c5),
    s = `${Die}-${e || ""}`,
    o = t || l5,
    [a, l, c] = mre(o, [Xg, n], {
      salt: s,
      override: r,
      getComputedToken: h5,
      formatToken: u5,
      cssVar: i && {
        prefix: i.prefix,
        key: i.key,
        unitless: d5,
        ignore: f5,
        preserve: Uie,
      },
    });
  return [o, c, e ? l : "", a, i];
}
function p5(n, e, t) {
  return (
    (e = wd(e)),
    TB(n, iS() ? Reflect.construct(e, [], wd(n).constructor) : e.apply(n, t))
  );
}
let m5 = os(function n() {
  ss(this, n);
});
const g5 = "CALC_UNIT",
  kie = new RegExp(g5, "g");
function lb(n) {
  return typeof n == "number" ? `${n}${g5}` : n;
}
let zie = (function (n) {
    function e(t) {
      var r;
      return (
        ss(this, e),
        (r = p5(this, e)),
        (r.result = ""),
        t instanceof e
          ? (r.result = `(${t.result})`)
          : typeof t == "number"
          ? (r.result = lb(t))
          : typeof t == "string" && (r.result = t),
        r
      );
    }
    return (
      Ud(e, n),
      os(e, [
        {
          key: "add",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result = `${this.result} + ${r.getResult()}`)
                : (typeof r == "number" || typeof r == "string") &&
                  (this.result = `${this.result} + ${lb(r)}`),
              (this.lowPriority = !0),
              this
            );
          },
        },
        {
          key: "sub",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result = `${this.result} - ${r.getResult()}`)
                : (typeof r == "number" || typeof r == "string") &&
                  (this.result = `${this.result} - ${lb(r)}`),
              (this.lowPriority = !0),
              this
            );
          },
        },
        {
          key: "mul",
          value: function (r) {
            return (
              this.lowPriority && (this.result = `(${this.result})`),
              r instanceof e
                ? (this.result = `${this.result} * ${r.getResult(!0)}`)
                : (typeof r == "number" || typeof r == "string") &&
                  (this.result = `${this.result} * ${r}`),
              (this.lowPriority = !1),
              this
            );
          },
        },
        {
          key: "div",
          value: function (r) {
            return (
              this.lowPriority && (this.result = `(${this.result})`),
              r instanceof e
                ? (this.result = `${this.result} / ${r.getResult(!0)}`)
                : (typeof r == "number" || typeof r == "string") &&
                  (this.result = `${this.result} / ${r}`),
              (this.lowPriority = !1),
              this
            );
          },
        },
        {
          key: "getResult",
          value: function (r) {
            return this.lowPriority || r ? `(${this.result})` : this.result;
          },
        },
        {
          key: "equal",
          value: function (r) {
            const { unit: i = !0 } = r || {};
            return (
              (this.result = this.result.replace(kie, i ? "px" : "")),
              typeof this.lowPriority < "u"
                ? `calc(${this.result})`
                : this.result
            );
          },
        },
      ])
    );
  })(m5),
  Bie = (function (n) {
    function e(t) {
      var r;
      return (
        ss(this, e),
        (r = p5(this, e)),
        (r.result = 0),
        t instanceof e
          ? (r.result = t.result)
          : typeof t == "number" && (r.result = t),
        r
      );
    }
    return (
      Ud(e, n),
      os(e, [
        {
          key: "add",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result += r.result)
                : typeof r == "number" && (this.result += r),
              this
            );
          },
        },
        {
          key: "sub",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result -= r.result)
                : typeof r == "number" && (this.result -= r),
              this
            );
          },
        },
        {
          key: "mul",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result *= r.result)
                : typeof r == "number" && (this.result *= r),
              this
            );
          },
        },
        {
          key: "div",
          value: function (r) {
            return (
              r instanceof e
                ? (this.result /= r.result)
                : typeof r == "number" && (this.result /= r),
              this
            );
          },
        },
        {
          key: "equal",
          value: function () {
            return this.result;
          },
        },
      ])
    );
  })(m5);
const Vie = (n) => {
  const e = n === "css" ? zie : Bie;
  return (t) => new e(t);
};
function $h(n) {
  var e = I.useRef();
  e.current = n;
  var t = I.useCallback(function () {
    for (var r, i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return (r = e.current) === null || r === void 0
      ? void 0
      : r.call.apply(r, [e].concat(s));
  }, []);
  return t;
}
function xh(n) {
  var e = I.useRef(!1),
    t = I.useState(n),
    r = Et(t, 2),
    i = r[0],
    s = r[1];
  I.useEffect(function () {
    return (
      (e.current = !1),
      function () {
        e.current = !0;
      }
    );
  }, []);
  function o(a, l) {
    (l && e.current) || s(a);
  }
  return [i, o];
}
function cb(n) {
  return n !== void 0;
}
function fp(n, e) {
  var t = e || {},
    r = t.defaultValue,
    i = t.value,
    s = t.onChange,
    o = t.postState,
    a = xh(function () {
      return cb(i)
        ? i
        : cb(r)
        ? typeof r == "function"
          ? r()
          : r
        : typeof n == "function"
        ? n()
        : n;
    }),
    l = Et(a, 2),
    c = l[0],
    u = l[1],
    d = i !== void 0 ? i : c,
    h = o ? o(d) : d,
    m = $h(s),
    g = xh([d]),
    x = Et(g, 2),
    y = x[0],
    v = x[1];
  cO(
    function () {
      var S = y[0];
      c !== S && m(c, S);
    },
    [y]
  ),
    cO(
      function () {
        cb(i) || u(i);
      },
      [i]
    );
  var _ = $h(function (S, w) {
    u(S, w), v([d], w);
  });
  return [h, _];
}
const Md = function (n) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return {
      boxSizing: "border-box",
      margin: 0,
      padding: 0,
      color: n.colorText,
      fontSize: n.fontSize,
      lineHeight: n.lineHeight,
      listStyle: "none",
      fontFamily: e ? "inherit" : n.fontFamily,
    };
  },
  v5 = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": { lineHeight: 1 },
    svg: { display: "inline-block" },
  }),
  Hie = () => ({
    "&::before": { display: "table", content: '""' },
    "&::after": { display: "table", clear: "both", content: '""' },
  }),
  Gie = (n) => ({
    a: {
      color: n.colorLink,
      textDecoration: n.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${n.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": { color: n.colorLinkHover },
      "&:active": { color: n.colorLinkActive },
      "&:active,\n  &:hover": {
        textDecoration: n.linkHoverDecoration,
        outline: 0,
      },
      "&:focus": { textDecoration: n.linkFocusDecoration, outline: 0 },
      "&[disabled]": { color: n.colorTextDisabled, cursor: "not-allowed" },
    },
  }),
  Wie = (n, e, t, r) => {
    const i = `[class^="${e}"], [class*=" ${e}"]`,
      s = t ? `.${t}` : i,
      o = {
        boxSizing: "border-box",
        "&::before, &::after": { boxSizing: "border-box" },
      };
    let a = {};
    return (
      r !== !1 && (a = { fontFamily: n.fontFamily, fontSize: n.fontSize }),
      { [s]: Object.assign(Object.assign(Object.assign({}, a), o), { [i]: o }) }
    );
  },
  uR = (n) => ({
    outline: `${jt(n.lineWidthFocus)} solid ${n.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s",
  }),
  jie = (n) => ({ "&:focus-visible": Object.assign({}, uR(n)) });
function $ie(n) {
  return n === "js"
    ? { max: Math.max, min: Math.min }
    : {
        max: function () {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
            t[r] = arguments[r];
          return `max(${t.map((i) => jt(i)).join(",")})`;
        },
        min: function () {
          for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
            t[r] = arguments[r];
          return `min(${t.map((i) => jt(i)).join(",")})`;
        },
      };
}
const y5 = typeof CSSINJS_STATISTIC < "u";
let sT = !0;
function mo() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  if (!y5) return Object.assign.apply(Object, [{}].concat(e));
  sT = !1;
  const r = {};
  return (
    e.forEach((i) => {
      Object.keys(i).forEach((o) => {
        Object.defineProperty(r, o, {
          configurable: !0,
          enumerable: !0,
          get: () => i[o],
        });
      });
    }),
    (sT = !0),
    r
  );
}
const MO = {};
function Xie() {}
const Yie = (n) => {
    let e,
      t = n,
      r = Xie;
    return (
      y5 &&
        typeof Proxy < "u" &&
        ((e = new Set()),
        (t = new Proxy(n, {
          get(i, s) {
            return sT && e.add(s), i[s];
          },
        })),
        (r = (i, s) => {
          var o;
          MO[i] = {
            global: Array.from(e),
            component: Object.assign(
              Object.assign(
                {},
                (o = MO[i]) === null || o === void 0 ? void 0 : o.component
              ),
              s
            ),
          };
        })),
      { token: t, keys: e, flush: r }
    );
  },
  x5 = (n, e) => {
    const [t, r] = jc();
    return eT(
      {
        theme: t,
        token: r,
        hashId: "",
        path: ["ant-design-icons", n],
        nonce: () => (e == null ? void 0 : e.nonce),
        layer: { name: "antd" },
      },
      () => [
        {
          [`.${n}`]: Object.assign(Object.assign({}, v5()), {
            [`.${n} .${n}-icon`]: { display: "block" },
          }),
        },
      ]
    );
  },
  _5 = (n, e, t) => {
    var r;
    return typeof t == "function"
      ? t(mo(e, (r = e[n]) !== null && r !== void 0 ? r : {}))
      : t ?? {};
  },
  S5 = (n, e, t, r) => {
    const i = Object.assign({}, e[n]);
    if (r != null && r.deprecatedTokens) {
      const { deprecatedTokens: o } = r;
      o.forEach((a) => {
        let [l, c] = a;
        var u;
        ((i != null && i[l]) || (i != null && i[c])) &&
          (((u = i[c]) !== null && u !== void 0) ||
            (i[c] = i == null ? void 0 : i[l]));
      });
    }
    const s = Object.assign(Object.assign({}, t), i);
    return (
      Object.keys(s).forEach((o) => {
        s[o] === e[o] && delete s[o];
      }),
      s
    );
  },
  qie = (n, e) =>
    `${[
      e,
      n
        .replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2")
        .replace(/([a-z])([A-Z])/g, "$1-$2"),
    ]
      .filter(Boolean)
      .join("-")}`;
function dR(n, e, t) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(n) ? n : [n, n],
    [s] = i,
    o = i.join("-");
  return function (a) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : a;
    const [c, u, d, h, m] = jc(),
      { getPrefixCls: g, iconPrefixCls: x, csp: y } = I.useContext(mr),
      v = g(),
      _ = m ? "css" : "js",
      S = Vie(_),
      { max: w, min: T } = $ie(_),
      E = {
        theme: c,
        token: h,
        hashId: d,
        nonce: () => (y == null ? void 0 : y.nonce),
        clientOnly: r.clientOnly,
        layer: { name: "antd" },
        order: r.order || -999,
      };
    return (
      eT(
        Object.assign(Object.assign({}, E), {
          clientOnly: !1,
          path: ["Shared", v],
        }),
        () => [{ "&": Gie(h) }]
      ),
      x5(x, y),
      [
        eT(Object.assign(Object.assign({}, E), { path: [o, a, x] }), () => {
          if (r.injectStyle === !1) return [];
          const { token: N, flush: R } = Yie(h),
            C = _5(s, u, t),
            L = `.${a}`,
            O = S5(s, u, C, { deprecatedTokens: r.deprecatedTokens });
          m &&
            Object.keys(C).forEach(($) => {
              C[$] = `var(${BB($, qie(s, m.prefix))})`;
            });
          const D = mo(
              N,
              {
                componentCls: L,
                prefixCls: a,
                iconCls: `.${x}`,
                antCls: `.${v}`,
                calc: S,
                max: w,
                min: T,
              },
              m ? C : O
            ),
            B = e(D, {
              hashId: d,
              prefixCls: a,
              rootPrefixCls: v,
              iconPrefixCls: x,
            });
          return (
            R(s, O), [r.resetStyle === !1 ? null : Wie(D, a, l, r.resetFont), B]
          );
        }),
        d,
      ]
    );
  };
}
const Kie = (n, e, t, r) => {
    const i = dR(n, e, t, Object.assign({ resetStyle: !1, order: -998 }, r));
    return (o) => {
      let { prefixCls: a, rootCls: l = a } = o;
      return i(a, l), null;
    };
  },
  Zie = (n, e, t) => {
    function r(c) {
      return `${n}${c.slice(0, 1).toUpperCase()}${c.slice(1)}`;
    }
    const { unitless: i = {}, injectStyle: s = !0 } = t ?? {},
      o = { [r("zIndexPopup")]: !0 };
    Object.keys(i).forEach((c) => {
      o[r(c)] = i[c];
    });
    const a = (c) => {
      let { rootCls: u, cssVar: d } = c;
      const [, h] = jc();
      return (
        Gre(
          {
            path: [n],
            prefix: d.prefix,
            key: d == null ? void 0 : d.key,
            unitless: Object.assign(Object.assign({}, d5), o),
            ignore: f5,
            token: h,
            scope: u,
          },
          () => {
            const m = _5(n, h, e),
              g = S5(n, h, m, {
                deprecatedTokens: t == null ? void 0 : t.deprecatedTokens,
              });
            return (
              Object.keys(m).forEach((x) => {
                (g[r(x)] = g[x]), delete g[x];
              }),
              g
            );
          }
        ),
        null
      );
    };
    return (c) => {
      const [, , , , u] = jc();
      return [
        (d) =>
          s && u
            ? Je.createElement(
                Je.Fragment,
                null,
                Je.createElement(a, { rootCls: c, cssVar: u, component: n }),
                d
              )
            : d,
        u == null ? void 0 : u.key,
      ];
    };
  },
  hp = (n, e, t, r) => {
    const i = dR(n, e, t, r),
      s = Zie(Array.isArray(n) ? n[0] : n, t, r);
    return function (o) {
      let a =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : o;
      const [, l] = i(o, a),
        [c, u] = s(a);
      return [c, l, u];
    };
  },
  Qie = Object.assign({}, ng),
  { useId: TO } = Qie,
  Jie = () => "",
  ese = typeof TO > "u" ? Jie : TO;
function tse(n, e, t) {
  var r;
  const i = n || {},
    s =
      i.inherit === !1 || !e
        ? Object.assign(Object.assign({}, iT), {
            hashed:
              (r = e == null ? void 0 : e.hashed) !== null && r !== void 0
                ? r
                : iT.hashed,
            cssVar: e == null ? void 0 : e.cssVar,
          })
        : e,
    o = ese();
  return J2(
    () => {
      var a, l;
      if (!n) return e;
      const c = Object.assign({}, s.components);
      Object.keys(n.components || {}).forEach((h) => {
        c[h] = Object.assign(Object.assign({}, c[h]), n.components[h]);
      });
      const u = `css-var-${o.replace(/:/g, "")}`,
        d =
          ((a = i.cssVar) !== null && a !== void 0 ? a : s.cssVar) &&
          Object.assign(
            Object.assign(
              Object.assign(
                { prefix: t == null ? void 0 : t.prefixCls },
                typeof s.cssVar == "object" ? s.cssVar : {}
              ),
              typeof i.cssVar == "object" ? i.cssVar : {}
            ),
            {
              key:
                (typeof i.cssVar == "object" &&
                  ((l = i.cssVar) === null || l === void 0 ? void 0 : l.key)) ||
                u,
            }
          );
      return Object.assign(Object.assign(Object.assign({}, s), i), {
        token: Object.assign(Object.assign({}, s.token), i.token),
        components: c,
        cssVar: d,
      });
    },
    [i, s],
    (a, l) =>
      a.some((c, u) => {
        const d = l[u];
        return !XM(c, d, !0);
      })
  );
}
var nse = ["children"],
  A5 = I.createContext({});
function rse(n) {
  var e = n.children,
    t = xi(n, nse);
  return I.createElement(A5.Provider, { value: t }, e);
}
var ise = (function (n) {
    Ud(t, n);
    var e = E0(t);
    function t() {
      return ss(this, t), e.apply(this, arguments);
    }
    return (
      os(t, [
        {
          key: "render",
          value: function () {
            return this.props.children;
          },
        },
      ]),
      t
    );
  })(I.Component),
  fc = "none",
  Yy = "appear",
  qy = "enter",
  Ky = "leave",
  CO = "none",
  ia = "prepare",
  oh = "start",
  ah = "active",
  fR = "end",
  w5 = "prepared";
function RO(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit".concat(n)] = "webkit".concat(e)),
    (t["Moz".concat(n)] = "moz".concat(e)),
    (t["ms".concat(n)] = "MS".concat(e)),
    (t["O".concat(n)] = "o".concat(e.toLowerCase())),
    t
  );
}
function sse(n, e) {
  var t = {
    animationend: RO("Animation", "AnimationEnd"),
    transitionend: RO("Transition", "TransitionEnd"),
  };
  return (
    n &&
      ("AnimationEvent" in e || delete t.animationend.animation,
      "TransitionEvent" in e || delete t.transitionend.transition),
    t
  );
}
var ose = sse(Wl(), typeof window < "u" ? window : {}),
  b5 = {};
if (Wl()) {
  var ase = document.createElement("div");
  b5 = ase.style;
}
var Zy = {};
function E5(n) {
  if (Zy[n]) return Zy[n];
  var e = ose[n];
  if (e)
    for (var t = Object.keys(e), r = t.length, i = 0; i < r; i += 1) {
      var s = t[i];
      if (Object.prototype.hasOwnProperty.call(e, s) && s in b5)
        return (Zy[n] = e[s]), Zy[n];
    }
  return "";
}
var M5 = E5("animationend"),
  T5 = E5("transitionend"),
  C5 = !!(M5 && T5),
  NO = M5 || "animationend",
  PO = T5 || "transitionend";
function IO(n, e) {
  if (!n) return null;
  if ($t(n) === "object") {
    var t = e.replace(/-\w/g, function (r) {
      return r[1].toUpperCase();
    });
    return n[t];
  }
  return "".concat(n, "-").concat(e);
}
const lse = function (n) {
  var e = I.useRef();
  function t(i) {
    i && (i.removeEventListener(PO, n), i.removeEventListener(NO, n));
  }
  function r(i) {
    e.current && e.current !== i && t(e.current),
      i &&
        i !== e.current &&
        (i.addEventListener(PO, n), i.addEventListener(NO, n), (e.current = i));
  }
  return (
    I.useEffect(function () {
      return function () {
        t(e.current);
      };
    }, []),
    [r, t]
  );
};
var R5 = Wl() ? I.useLayoutEffect : I.useEffect;
const cse = function () {
  var n = I.useRef(null);
  function e() {
    Ya.cancel(n.current);
  }
  function t(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    e();
    var s = Ya(function () {
      i <= 1
        ? r({
            isCanceled: function () {
              return s !== n.current;
            },
          })
        : t(r, i - 1);
    });
    n.current = s;
  }
  return (
    I.useEffect(function () {
      return function () {
        e();
      };
    }, []),
    [t, e]
  );
};
var use = [ia, oh, ah, fR],
  dse = [ia, w5],
  N5 = !1,
  fse = !0;
function P5(n) {
  return n === ah || n === fR;
}
const hse = function (n, e, t) {
  var r = xh(CO),
    i = Et(r, 2),
    s = i[0],
    o = i[1],
    a = cse(),
    l = Et(a, 2),
    c = l[0],
    u = l[1];
  function d() {
    o(ia, !0);
  }
  var h = e ? dse : use;
  return (
    R5(
      function () {
        if (s !== CO && s !== fR) {
          var m = h.indexOf(s),
            g = h[m + 1],
            x = t(s);
          x === N5
            ? o(g, !0)
            : g &&
              c(function (y) {
                function v() {
                  y.isCanceled() || o(g, !0);
                }
                x === !0 ? v() : Promise.resolve(x).then(v);
              });
        }
      },
      [n, s]
    ),
    I.useEffect(function () {
      return function () {
        u();
      };
    }, []),
    [d, s]
  );
};
function pse(n, e, t, r) {
  var i = r.motionEnter,
    s = i === void 0 ? !0 : i,
    o = r.motionAppear,
    a = o === void 0 ? !0 : o,
    l = r.motionLeave,
    c = l === void 0 ? !0 : l,
    u = r.motionDeadline,
    d = r.motionLeaveImmediately,
    h = r.onAppearPrepare,
    m = r.onEnterPrepare,
    g = r.onLeavePrepare,
    x = r.onAppearStart,
    y = r.onEnterStart,
    v = r.onLeaveStart,
    _ = r.onAppearActive,
    S = r.onEnterActive,
    w = r.onLeaveActive,
    T = r.onAppearEnd,
    E = r.onEnterEnd,
    M = r.onLeaveEnd,
    N = r.onVisibleChanged,
    R = xh(),
    C = Et(R, 2),
    L = C[0],
    O = C[1],
    D = xh(fc),
    B = Et(D, 2),
    $ = B[0],
    G = B[1],
    j = xh(null),
    U = Et(j, 2),
    H = U[0],
    V = U[1],
    k = I.useRef(!1),
    W = I.useRef(null);
  function ee() {
    return t();
  }
  var Y = I.useRef(!1);
  function K() {
    G(fc, !0), V(null, !0);
  }
  var ae = $h(function (X) {
      if ($ !== fc) {
        var z = ee();
        if (!(X && !X.deadline && X.target !== z)) {
          var q = Y.current,
            ue;
          $ === Yy && q
            ? (ue = T == null ? void 0 : T(z, X))
            : $ === qy && q
            ? (ue = E == null ? void 0 : E(z, X))
            : $ === Ky && q && (ue = M == null ? void 0 : M(z, X)),
            q && ue !== !1 && K();
        }
      }
    }),
    se = lse(ae),
    we = Et(se, 1),
    Be = we[0],
    te = function (z) {
      switch (z) {
        case Yy:
          return Te(Te(Te({}, ia, h), oh, x), ah, _);
        case qy:
          return Te(Te(Te({}, ia, m), oh, y), ah, S);
        case Ky:
          return Te(Te(Te({}, ia, g), oh, v), ah, w);
        default:
          return {};
      }
    },
    ge = I.useMemo(
      function () {
        return te($);
      },
      [$]
    ),
    ie = hse($, !n, function (X) {
      if (X === ia) {
        var z = ge[ia];
        return z ? z(ee()) : N5;
      }
      if (Ee in ge) {
        var q;
        V(
          ((q = ge[Ee]) === null || q === void 0
            ? void 0
            : q.call(ge, ee(), null)) || null
        );
      }
      return (
        Ee === ah &&
          $ !== fc &&
          (Be(ee()),
          u > 0 &&
            (clearTimeout(W.current),
            (W.current = setTimeout(function () {
              ae({ deadline: !0 });
            }, u)))),
        Ee === w5 && K(),
        fse
      );
    }),
    me = Et(ie, 2),
    fe = me[0],
    Ee = me[1],
    Se = P5(Ee);
  (Y.current = Se),
    R5(
      function () {
        O(e);
        var X = k.current;
        k.current = !0;
        var z;
        !X && e && a && (z = Yy),
          X && e && s && (z = qy),
          ((X && !e && c) || (!X && d && !e && c)) && (z = Ky);
        var q = te(z);
        z && (n || q[ia]) ? (G(z), fe()) : G(fc);
      },
      [e]
    ),
    I.useEffect(
      function () {
        (($ === Yy && !a) || ($ === qy && !s) || ($ === Ky && !c)) && G(fc);
      },
      [a, s, c]
    ),
    I.useEffect(function () {
      return function () {
        (k.current = !1), clearTimeout(W.current);
      };
    }, []);
  var Ue = I.useRef(!1);
  I.useEffect(
    function () {
      L && (Ue.current = !0),
        L !== void 0 &&
          $ === fc &&
          ((Ue.current || L) && (N == null || N(L)), (Ue.current = !0));
    },
    [L, $]
  );
  var Ce = H;
  return (
    ge[ia] && Ee === oh && (Ce = Ze({ transition: "none" }, Ce)),
    [$, Ee, Ce, L ?? e]
  );
}
function mse(n) {
  var e = n;
  $t(n) === "object" && (e = n.transitionSupport);
  function t(i, s) {
    return !!(i.motionName && e && s !== !1);
  }
  var r = I.forwardRef(function (i, s) {
    var o = i.visible,
      a = o === void 0 ? !0 : o,
      l = i.removeOnLeave,
      c = l === void 0 ? !0 : l,
      u = i.forceRender,
      d = i.children,
      h = i.motionName,
      m = i.leavedClassName,
      g = i.eventProps,
      x = I.useContext(A5),
      y = x.motion,
      v = t(i, y),
      _ = I.useRef(),
      S = I.useRef();
    function w() {
      try {
        return _.current instanceof HTMLElement ? _.current : Tx(S.current);
      } catch {
        return null;
      }
    }
    var T = pse(v, a, w, i),
      E = Et(T, 4),
      M = E[0],
      N = E[1],
      R = E[2],
      C = E[3],
      L = I.useRef(C);
    C && (L.current = !0);
    var O = I.useCallback(
        function (H) {
          (_.current = H), _B(s, H);
        },
        [s]
      ),
      D,
      B = Ze(Ze({}, g), {}, { visible: a });
    if (!d) D = null;
    else if (M === fc)
      C
        ? (D = d(Ze({}, B), O))
        : !c && L.current && m
        ? (D = d(Ze(Ze({}, B), {}, { className: m }), O))
        : u || (!c && !m)
        ? (D = d(Ze(Ze({}, B), {}, { style: { display: "none" } }), O))
        : (D = null);
    else {
      var $;
      N === ia
        ? ($ = "prepare")
        : P5(N)
        ? ($ = "active")
        : N === oh && ($ = "start");
      var G = IO(h, "".concat(M, "-").concat($));
      D = d(
        Ze(
          Ze({}, B),
          {},
          {
            className: Mt(
              IO(h, M),
              Te(Te({}, G, G && $), h, typeof h == "string")
            ),
            style: R,
          }
        ),
        O
      );
    }
    if (I.isValidElement(D) && eR(D)) {
      var j = D,
        U = j.ref;
      U || (D = I.cloneElement(D, { ref: O }));
    }
    return I.createElement(ise, { ref: S }, D);
  });
  return (r.displayName = "CSSMotion"), r;
}
const uS = mse(C5);
var oT = "add",
  aT = "keep",
  lT = "remove",
  ub = "removed";
function gse(n) {
  var e;
  return (
    n && $t(n) === "object" && "key" in n ? (e = n) : (e = { key: n }),
    Ze(Ze({}, e), {}, { key: String(e.key) })
  );
}
function cT() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return n.map(gse);
}
function vse() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    t = [],
    r = 0,
    i = e.length,
    s = cT(n),
    o = cT(e);
  s.forEach(function (c) {
    for (var u = !1, d = r; d < i; d += 1) {
      var h = o[d];
      if (h.key === c.key) {
        r < d &&
          ((t = t.concat(
            o.slice(r, d).map(function (m) {
              return Ze(Ze({}, m), {}, { status: oT });
            })
          )),
          (r = d)),
          t.push(Ze(Ze({}, h), {}, { status: aT })),
          (r += 1),
          (u = !0);
        break;
      }
    }
    u || t.push(Ze(Ze({}, c), {}, { status: lT }));
  }),
    r < i &&
      (t = t.concat(
        o.slice(r).map(function (c) {
          return Ze(Ze({}, c), {}, { status: oT });
        })
      ));
  var a = {};
  t.forEach(function (c) {
    var u = c.key;
    a[u] = (a[u] || 0) + 1;
  });
  var l = Object.keys(a).filter(function (c) {
    return a[c] > 1;
  });
  return (
    l.forEach(function (c) {
      (t = t.filter(function (u) {
        var d = u.key,
          h = u.status;
        return d !== c || h !== lT;
      })),
        t.forEach(function (u) {
          u.key === c && (u.status = aT);
        });
    }),
    t
  );
}
var yse = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  xse = ["status"],
  _se = [
    "eventProps",
    "visible",
    "children",
    "motionName",
    "motionAppear",
    "motionEnter",
    "motionLeave",
    "motionLeaveImmediately",
    "motionDeadline",
    "removeOnLeave",
    "leavedClassName",
    "onAppearPrepare",
    "onAppearStart",
    "onAppearActive",
    "onAppearEnd",
    "onEnterStart",
    "onEnterActive",
    "onEnterEnd",
    "onLeaveStart",
    "onLeaveActive",
    "onLeaveEnd",
  ];
function Sse(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : uS,
    t = (function (r) {
      Ud(s, r);
      var i = E0(s);
      function s() {
        var o;
        ss(this, s);
        for (var a = arguments.length, l = new Array(a), c = 0; c < a; c++)
          l[c] = arguments[c];
        return (
          (o = i.call.apply(i, [this].concat(l))),
          Te(fn(o), "state", { keyEntities: [] }),
          Te(fn(o), "removeKey", function (u) {
            var d = o.state.keyEntities,
              h = d.map(function (m) {
                return m.key !== u ? m : Ze(Ze({}, m), {}, { status: ub });
              });
            return (
              o.setState({ keyEntities: h }),
              h.filter(function (m) {
                var g = m.status;
                return g !== ub;
              }).length
            );
          }),
          o
        );
      }
      return (
        os(
          s,
          [
            {
              key: "render",
              value: function () {
                var a = this,
                  l = this.state.keyEntities,
                  c = this.props,
                  u = c.component,
                  d = c.children,
                  h = c.onVisibleChanged,
                  m = c.onAllRemoved,
                  g = xi(c, yse),
                  x = u || I.Fragment,
                  y = {};
                return (
                  _se.forEach(function (v) {
                    (y[v] = g[v]), delete g[v];
                  }),
                  delete g.keys,
                  I.createElement(
                    x,
                    g,
                    l.map(function (v, _) {
                      var S = v.status,
                        w = xi(v, xse),
                        T = S === oT || S === aT;
                      return I.createElement(
                        e,
                        an({}, y, {
                          key: w.key,
                          visible: T,
                          eventProps: w,
                          onVisibleChanged: function (M) {
                            if ((h == null || h(M, { key: w.key }), !M)) {
                              var N = a.removeKey(w.key);
                              N === 0 && m && m();
                            }
                          },
                        }),
                        function (E, M) {
                          return d(Ze(Ze({}, E), {}, { index: _ }), M);
                        }
                      );
                    })
                  )
                );
              },
            },
          ],
          [
            {
              key: "getDerivedStateFromProps",
              value: function (a, l) {
                var c = a.keys,
                  u = l.keyEntities,
                  d = cT(c),
                  h = vse(u, d);
                return {
                  keyEntities: h.filter(function (m) {
                    var g = u.find(function (x) {
                      var y = x.key;
                      return m.key === y;
                    });
                    return !(g && g.status === ub && m.status === lT);
                  }),
                };
              },
            },
          ]
        ),
        s
      );
    })(I.Component);
  return Te(t, "defaultProps", { component: "div" }), t;
}
const Ase = Sse(C5);
function wse(n) {
  const { children: e } = n,
    [, t] = jc(),
    { motion: r } = t,
    i = I.useRef(!1);
  return (
    (i.current = i.current || r === !1),
    i.current ? I.createElement(rse, { motion: r }, e) : e
  );
}
const bse = () => null;
var Ese = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Mse = [
    "getTargetContainer",
    "getPopupContainer",
    "renderEmpty",
    "input",
    "pagination",
    "form",
    "select",
    "button",
  ],
  Tse = "ant";
let C1, I5, L5, O5;
function Dx() {
  return C1 || Tse;
}
function Cse() {
  return I5 || cR;
}
function Rse(n) {
  return Object.keys(n).some((e) => e.endsWith("Color"));
}
const Nse = (n) => {
    const { prefixCls: e, iconPrefixCls: t, theme: r, holderRender: i } = n;
    e !== void 0 && (C1 = e),
      t !== void 0 && (I5 = t),
      "holderRender" in n && (O5 = i),
      r && (Rse(r) ? Pie(Dx(), r) : (L5 = r));
  },
  Pse = () => ({
    getPrefixCls: (n, e) => e || (n ? `${Dx()}-${n}` : Dx()),
    getIconPrefixCls: Cse,
    getRootPrefixCls: () => C1 || Dx(),
    getTheme: () => L5,
    holderRender: O5,
  }),
  Ise = (n) => {
    const {
        children: e,
        csp: t,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: s,
        form: o,
        locale: a,
        componentSize: l,
        direction: c,
        space: u,
        virtual: d,
        dropdownMatchSelectWidth: h,
        popupMatchSelectWidth: m,
        popupOverflow: g,
        legacyLocale: x,
        parentContext: y,
        iconPrefixCls: v,
        theme: _,
        componentDisabled: S,
        segmented: w,
        statistic: T,
        spin: E,
        calendar: M,
        carousel: N,
        cascader: R,
        collapse: C,
        typography: L,
        checkbox: O,
        descriptions: D,
        divider: B,
        drawer: $,
        skeleton: G,
        steps: j,
        image: U,
        layout: H,
        list: V,
        mentions: k,
        modal: W,
        progress: ee,
        result: Y,
        slider: K,
        breadcrumb: ae,
        menu: se,
        pagination: we,
        input: Be,
        textArea: te,
        empty: ge,
        badge: ie,
        radio: me,
        rate: fe,
        switch: Ee,
        transfer: Se,
        avatar: Ue,
        message: Ce,
        tag: X,
        table: z,
        card: q,
        tabs: ue,
        timeline: de,
        timePicker: he,
        upload: Ie,
        notification: ke,
        tree: Me,
        colorPicker: et,
        datePicker: Ne,
        rangePicker: We,
        flex: ot,
        wave: nt,
        dropdown: Ke,
        warning: it,
        tour: re,
        floatButtonGroup: ze,
      } = n,
      Xe = I.useCallback(
        (St, Nt) => {
          const { prefixCls: gn } = n;
          if (Nt) return Nt;
          const dn = gn || y.getPrefixCls("");
          return St ? `${dn}-${St}` : dn;
        },
        [y.getPrefixCls, n.prefixCls]
      ),
      le = v || y.iconPrefixCls || cR,
      Re = t || y.csp;
    x5(le, Re);
    const xe = tse(_, y.theme, { prefixCls: Xe("") }),
      Ye = {
        csp: Re,
        autoInsertSpaceInButton: r,
        alert: i,
        anchor: s,
        locale: a || x,
        direction: c,
        space: u,
        virtual: d,
        popupMatchSelectWidth: m ?? h,
        popupOverflow: g,
        getPrefixCls: Xe,
        iconPrefixCls: le,
        theme: xe,
        segmented: w,
        statistic: T,
        spin: E,
        calendar: M,
        carousel: N,
        cascader: R,
        collapse: C,
        typography: L,
        checkbox: O,
        descriptions: D,
        divider: B,
        drawer: $,
        skeleton: G,
        steps: j,
        image: U,
        input: Be,
        textArea: te,
        layout: H,
        list: V,
        mentions: k,
        modal: W,
        progress: ee,
        result: Y,
        slider: K,
        breadcrumb: ae,
        menu: se,
        pagination: we,
        empty: ge,
        badge: ie,
        radio: me,
        rate: fe,
        switch: Ee,
        transfer: Se,
        avatar: Ue,
        message: Ce,
        tag: X,
        table: z,
        card: q,
        tabs: ue,
        timeline: de,
        timePicker: he,
        upload: Ie,
        notification: ke,
        tree: Me,
        colorPicker: et,
        datePicker: Ne,
        rangePicker: We,
        flex: ot,
        wave: nt,
        dropdown: Ke,
        warning: it,
        tour: re,
        floatButtonGroup: ze,
      },
      at = Object.assign({}, y);
    Object.keys(Ye).forEach((St) => {
      Ye[St] !== void 0 && (at[St] = Ye[St]);
    }),
      Mse.forEach((St) => {
        const Nt = n[St];
        Nt && (at[St] = Nt);
      }),
      typeof r < "u" &&
        (at.button = Object.assign({ autoInsertSpace: r }, at.button));
    const vt = J2(
        () => at,
        at,
        (St, Nt) => {
          const gn = Object.keys(St),
            dn = Object.keys(Nt);
          return gn.length !== dn.length || gn.some((gr) => St[gr] !== Nt[gr]);
        }
      ),
      dt = I.useMemo(() => ({ prefixCls: le, csp: Re }), [le, Re]);
    let mt = I.createElement(
      I.Fragment,
      null,
      I.createElement(bse, { dropdownMatchSelectWidth: h }),
      e
    );
    const kt = I.useMemo(() => {
      var St, Nt, gn, dn;
      return sh(
        ((St = cS.Form) === null || St === void 0
          ? void 0
          : St.defaultValidateMessages) || {},
        ((gn =
          (Nt = vt.locale) === null || Nt === void 0 ? void 0 : Nt.Form) ===
          null || gn === void 0
          ? void 0
          : gn.defaultValidateMessages) || {},
        ((dn = vt.form) === null || dn === void 0
          ? void 0
          : dn.validateMessages) || {},
        (o == null ? void 0 : o.validateMessages) || {}
      );
    }, [vt, o == null ? void 0 : o.validateMessages]);
    Object.keys(kt).length > 0 &&
      (mt = I.createElement(qre.Provider, { value: kt }, mt)),
      a && (mt = I.createElement(eie, { locale: a, _ANT_MARK__: Jre }, mt)),
      (le || Re) && (mt = I.createElement(lR.Provider, { value: dt }, mt)),
      l && (mt = I.createElement(Lie, { size: l }, mt)),
      (mt = I.createElement(wse, null, mt));
    const lt = I.useMemo(() => {
      const St = xe || {},
        { algorithm: Nt, token: gn, components: dn, cssVar: gr } = St,
        Kr = Ese(St, ["algorithm", "token", "components", "cssVar"]),
        Ur = Nt && (!Array.isArray(Nt) || Nt.length > 0) ? qM(Nt) : l5,
        kr = {};
      Object.entries(dn || {}).forEach((Ai) => {
        let [vr, Ps] = Ai;
        const wi = Object.assign({}, Ps);
        "algorithm" in wi &&
          (wi.algorithm === !0
            ? (wi.theme = Ur)
            : (Array.isArray(wi.algorithm) ||
                typeof wi.algorithm == "function") &&
              (wi.theme = qM(wi.algorithm)),
          delete wi.algorithm),
          (kr[vr] = wi);
      });
      const zr = Object.assign(Object.assign({}, Xg), gn);
      return Object.assign(Object.assign({}, Kr), {
        theme: Ur,
        token: zr,
        components: kr,
        override: Object.assign({ override: zr }, kr),
        cssVar: gr,
      });
    }, [xe]);
    return (
      _ && (mt = I.createElement(c5.Provider, { value: lt }, mt)),
      vt.warning &&
        (mt = I.createElement(Yre.Provider, { value: vt.warning }, mt)),
      S !== void 0 && (mt = I.createElement(Iie, { disabled: S }, mt)),
      I.createElement(mr.Provider, { value: vt }, mt)
    );
  },
  pp = (n) => {
    const e = I.useContext(mr),
      t = I.useContext(r5);
    return I.createElement(
      Ise,
      Object.assign({ parentContext: e, legacyLocale: t }, n)
    );
  };
pp.ConfigContext = mr;
pp.SizeContext = jh;
pp.config = Nse;
pp.useConfig = Oie;
Object.defineProperty(pp, "SizeContext", { get: () => jh });
var Lse = {
  icon: {
    tag: "svg",
    attrs: { viewBox: "64 64 896 896", focusable: "false" },
    children: [
      {
        tag: "path",
        attrs: {
          d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z",
        },
      },
    ],
  },
  name: "check-circle",
  theme: "filled",
};
function D5(n) {
  var e;
  return n == null || (e = n.getRootNode) === null || e === void 0
    ? void 0
    : e.call(n);
}
function Ose(n) {
  return D5(n) instanceof ShadowRoot;
}
function Dse(n) {
  return Ose(n) ? D5(n) : null;
}
function Fse(n) {
  return n.replace(/-(.)/g, function (e, t) {
    return t.toUpperCase();
  });
}
function Use(n, e) {
  Es(n, "[@ant-design/icons] ".concat(e));
}
function LO(n) {
  return (
    $t(n) === "object" &&
    typeof n.name == "string" &&
    typeof n.theme == "string" &&
    ($t(n.icon) === "object" || typeof n.icon == "function")
  );
}
function OO() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(n).reduce(function (e, t) {
    var r = n[t];
    switch (t) {
      case "class":
        (e.className = r), delete e.class;
        break;
      default:
        delete e[t], (e[Fse(t)] = r);
    }
    return e;
  }, {});
}
function uT(n, e, t) {
  return t
    ? Je.createElement(
        n.tag,
        Ze(Ze({ key: e }, OO(n.attrs)), t),
        (n.children || []).map(function (r, i) {
          return uT(r, "".concat(e, "-").concat(n.tag, "-").concat(i));
        })
      )
    : Je.createElement(
        n.tag,
        Ze({ key: e }, OO(n.attrs)),
        (n.children || []).map(function (r, i) {
          return uT(r, "".concat(e, "-").concat(n.tag, "-").concat(i));
        })
      );
}
function F5(n) {
  return bd(n)[0];
}
function U5(n) {
  return n ? (Array.isArray(n) ? n : [n]) : [];
}
var kse = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`,
  zse = function (e) {
    var t = I.useContext(lR),
      r = t.csp,
      i = t.prefixCls,
      s = kse;
    i && (s = s.replace(/anticon/g, i)),
      I.useEffect(function () {
        var o = e.current,
          a = Dse(o);
        dd(s, "@ant-design-icons", { prepend: !0, csp: r, attachTo: a });
      }, []);
  },
  Bse = [
    "icon",
    "className",
    "onClick",
    "style",
    "primaryColor",
    "secondaryColor",
  ],
  Qm = { primaryColor: "#333", secondaryColor: "#E6E6E6", calculated: !1 };
function Vse(n) {
  var e = n.primaryColor,
    t = n.secondaryColor;
  (Qm.primaryColor = e),
    (Qm.secondaryColor = t || F5(e)),
    (Qm.calculated = !!t);
}
function Hse() {
  return Ze({}, Qm);
}
var mp = function (e) {
  var t = e.icon,
    r = e.className,
    i = e.onClick,
    s = e.style,
    o = e.primaryColor,
    a = e.secondaryColor,
    l = xi(e, Bse),
    c = I.useRef(),
    u = Qm;
  if (
    (o && (u = { primaryColor: o, secondaryColor: a || F5(o) }),
    zse(c),
    Use(LO(t), "icon should be icon definiton, but got ".concat(t)),
    !LO(t))
  )
    return null;
  var d = t;
  return (
    d &&
      typeof d.icon == "function" &&
      (d = Ze(
        Ze({}, d),
        {},
        { icon: d.icon(u.primaryColor, u.secondaryColor) }
      )),
    uT(
      d.icon,
      "svg-".concat(d.name),
      Ze(
        Ze(
          {
            className: r,
            onClick: i,
            style: s,
            "data-icon": d.name,
            width: "1em",
            height: "1em",
            fill: "currentColor",
            "aria-hidden": "true",
          },
          l
        ),
        {},
        { ref: c }
      )
    )
  );
};
mp.displayName = "IconReact";
mp.getTwoToneColors = Hse;
mp.setTwoToneColors = Vse;
function k5(n) {
  var e = U5(n),
    t = Et(e, 2),
    r = t[0],
    i = t[1];
  return mp.setTwoToneColors({ primaryColor: r, secondaryColor: i });
}
function Gse() {
  var n = mp.getTwoToneColors();
  return n.calculated ? [n.primaryColor, n.secondaryColor] : n.primaryColor;
}
var Wse = [
  "className",
  "icon",
  "spin",
  "rotate",
  "tabIndex",
  "onClick",
  "twoToneColor",
];
k5(vie.primary);
var Ns = I.forwardRef(function (n, e) {
  var t = n.className,
    r = n.icon,
    i = n.spin,
    s = n.rotate,
    o = n.tabIndex,
    a = n.onClick,
    l = n.twoToneColor,
    c = xi(n, Wse),
    u = I.useContext(lR),
    d = u.prefixCls,
    h = d === void 0 ? "anticon" : d,
    m = u.rootClassName,
    g = Mt(
      m,
      h,
      Te(
        Te({}, "".concat(h, "-").concat(r.name), !!r.name),
        "".concat(h, "-spin"),
        !!i || r.name === "loading"
      ),
      t
    ),
    x = o;
  x === void 0 && a && (x = -1);
  var y = s
      ? {
          msTransform: "rotate(".concat(s, "deg)"),
          transform: "rotate(".concat(s, "deg)"),
        }
      : void 0,
    v = U5(l),
    _ = Et(v, 2),
    S = _[0],
    w = _[1];
  return I.createElement(
    "span",
    an({ role: "img", "aria-label": r.name }, c, {
      ref: e,
      tabIndex: x,
      onClick: a,
      className: g,
    }),
    I.createElement(mp, {
      icon: r,
      primaryColor: S,
      secondaryColor: w,
      style: y,
    })
  );
});
Ns.displayName = "AntdIcon";
Ns.getTwoToneColor = Gse;
Ns.setTwoToneColor = k5;
var jse = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: Lse }));
  },
  $se = I.forwardRef(jse),
  Xse = {
    icon: {
      tag: "svg",
      attrs: {
        "fill-rule": "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
      },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z",
          },
        },
      ],
    },
    name: "close-circle",
    theme: "filled",
  },
  Yse = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: Xse }));
  },
  z5 = I.forwardRef(Yse),
  qse = {
    icon: {
      tag: "svg",
      attrs: {
        "fill-rule": "evenodd",
        viewBox: "64 64 896 896",
        focusable: "false",
      },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z",
          },
        },
      ],
    },
    name: "close",
    theme: "outlined",
  },
  Kse = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: qse }));
  },
  Zse = I.forwardRef(Kse),
  Qse = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z",
          },
        },
      ],
    },
    name: "exclamation-circle",
    theme: "filled",
  },
  Jse = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: Qse }));
  },
  eoe = I.forwardRef(Jse),
  toe = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z",
          },
        },
      ],
    },
    name: "info-circle",
    theme: "filled",
  },
  noe = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: toe }));
  },
  roe = I.forwardRef(noe),
  ioe = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`,
  soe = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`,
  ooe = ""
    .concat(ioe, " ")
    .concat(soe)
    .split(/[\s\n]+/),
  aoe = "aria-",
  loe = "data-";
function DO(n, e) {
  return n.indexOf(e) === 0;
}
function dS(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t;
  e === !1
    ? (t = { aria: !0, data: !0, attr: !0 })
    : e === !0
    ? (t = { aria: !0 })
    : (t = Ze({}, e));
  var r = {};
  return (
    Object.keys(n).forEach(function (i) {
      ((t.aria && (i === "role" || DO(i, aoe))) ||
        (t.data && DO(i, loe)) ||
        (t.attr && ooe.includes(i))) &&
        (r[i] = n[i]);
    }),
    r
  );
}
function coe(n) {
  return n && Je.isValidElement(n) && n.type === Je.Fragment;
}
const uoe = (n, e, t) =>
  Je.isValidElement(n)
    ? Je.cloneElement(n, typeof t == "function" ? t(n.props || {}) : t)
    : e;
function Xh(n, e) {
  return uoe(n, n, e);
}
const kd = (n) => {
  const [, , , , e] = jc();
  return e ? `${n}-css-var` : "";
};
var Bt = {
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    QUESTION_MARK: 63,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    WIN_IME: 229,
    isTextModifyingKeyEvent: function (e) {
      var t = e.keyCode;
      if ((e.altKey && !e.ctrlKey) || e.metaKey || (t >= Bt.F1 && t <= Bt.F12))
        return !1;
      switch (t) {
        case Bt.ALT:
        case Bt.CAPS_LOCK:
        case Bt.CONTEXT_MENU:
        case Bt.CTRL:
        case Bt.DOWN:
        case Bt.END:
        case Bt.ESC:
        case Bt.HOME:
        case Bt.INSERT:
        case Bt.LEFT:
        case Bt.MAC_FF_META:
        case Bt.META:
        case Bt.NUMLOCK:
        case Bt.NUM_CENTER:
        case Bt.PAGE_DOWN:
        case Bt.PAGE_UP:
        case Bt.PAUSE:
        case Bt.PRINT_SCREEN:
        case Bt.RIGHT:
        case Bt.SHIFT:
        case Bt.UP:
        case Bt.WIN_KEY:
        case Bt.WIN_KEY_RIGHT:
          return !1;
        default:
          return !0;
      }
    },
    isCharacterKey: function (e) {
      if (
        (e >= Bt.ZERO && e <= Bt.NINE) ||
        (e >= Bt.NUM_ZERO && e <= Bt.NUM_MULTIPLY) ||
        (e >= Bt.A && e <= Bt.Z) ||
        (window.navigator.userAgent.indexOf("WebKit") !== -1 && e === 0)
      )
        return !0;
      switch (e) {
        case Bt.SPACE:
        case Bt.QUESTION_MARK:
        case Bt.NUM_PLUS:
        case Bt.NUM_MINUS:
        case Bt.NUM_PERIOD:
        case Bt.NUM_DIVISION:
        case Bt.SEMICOLON:
        case Bt.DASH:
        case Bt.EQUALS:
        case Bt.COMMA:
        case Bt.PERIOD:
        case Bt.SLASH:
        case Bt.APOSTROPHE:
        case Bt.SINGLE_QUOTE:
        case Bt.OPEN_SQUARE_BRACKET:
        case Bt.BACKSLASH:
        case Bt.CLOSE_SQUARE_BRACKET:
          return !0;
        default:
          return !1;
      }
    },
  },
  B5 = I.forwardRef(function (n, e) {
    var t = n.prefixCls,
      r = n.style,
      i = n.className,
      s = n.duration,
      o = s === void 0 ? 4.5 : s,
      a = n.eventKey,
      l = n.content,
      c = n.closable,
      u = n.closeIcon,
      d = u === void 0 ? "x" : u,
      h = n.props,
      m = n.onClick,
      g = n.onNoticeClose,
      x = n.times,
      y = n.hovering,
      v = I.useState(!1),
      _ = Et(v, 2),
      S = _[0],
      w = _[1],
      T = y || S,
      E = function () {
        g(a);
      },
      M = function (O) {
        (O.key === "Enter" || O.code === "Enter" || O.keyCode === Bt.ENTER) &&
          E();
      };
    I.useEffect(
      function () {
        if (!T && o > 0) {
          var L = setTimeout(function () {
            E();
          }, o * 1e3);
          return function () {
            clearTimeout(L);
          };
        }
      },
      [o, T, x]
    );
    var N = I.useMemo(
        function () {
          return $t(c) === "object" && c !== null
            ? c
            : c
            ? { closeIcon: d }
            : {};
        },
        [c, d]
      ),
      R = dS(N, !0),
      C = "".concat(t, "-notice");
    return I.createElement(
      "div",
      an({}, h, {
        ref: e,
        className: Mt(C, i, Te({}, "".concat(C, "-closable"), c)),
        style: r,
        onMouseEnter: function (O) {
          var D;
          w(!0),
            h == null ||
              (D = h.onMouseEnter) === null ||
              D === void 0 ||
              D.call(h, O);
        },
        onMouseLeave: function (O) {
          var D;
          w(!1),
            h == null ||
              (D = h.onMouseLeave) === null ||
              D === void 0 ||
              D.call(h, O);
        },
        onClick: m,
      }),
      I.createElement("div", { className: "".concat(C, "-content") }, l),
      c &&
        I.createElement(
          "a",
          an(
            {
              tabIndex: 0,
              className: "".concat(C, "-close"),
              onKeyDown: M,
              "aria-label": "Close",
            },
            R,
            {
              onClick: function (O) {
                O.preventDefault(), O.stopPropagation(), E();
              },
            }
          ),
          N.closeIcon
        )
    );
  }),
  V5 = Je.createContext({}),
  doe = function (e) {
    var t = e.children,
      r = e.classNames;
    return Je.createElement(V5.Provider, { value: { classNames: r } }, t);
  },
  FO = 8,
  UO = 3,
  kO = 16,
  foe = function (e) {
    var t = { offset: FO, threshold: UO, gap: kO };
    if (e && $t(e) === "object") {
      var r, i, s;
      (t.offset = (r = e.offset) !== null && r !== void 0 ? r : FO),
        (t.threshold = (i = e.threshold) !== null && i !== void 0 ? i : UO),
        (t.gap = (s = e.gap) !== null && s !== void 0 ? s : kO);
    }
    return [!!e, t];
  },
  hoe = ["className", "style", "classNames", "styles"],
  poe = function (e) {
    var t = e.configList,
      r = e.placement,
      i = e.prefixCls,
      s = e.className,
      o = e.style,
      a = e.motion,
      l = e.onAllNoticeRemoved,
      c = e.onNoticeClose,
      u = e.stack,
      d = I.useContext(V5),
      h = d.classNames,
      m = I.useRef({}),
      g = I.useState(null),
      x = Et(g, 2),
      y = x[0],
      v = x[1],
      _ = I.useState([]),
      S = Et(_, 2),
      w = S[0],
      T = S[1],
      E = t.map(function (G) {
        return { config: G, key: String(G.key) };
      }),
      M = foe(u),
      N = Et(M, 2),
      R = N[0],
      C = N[1],
      L = C.offset,
      O = C.threshold,
      D = C.gap,
      B = R && (w.length > 0 || E.length <= O),
      $ = typeof a == "function" ? a(r) : a;
    return (
      I.useEffect(
        function () {
          R &&
            w.length > 1 &&
            T(function (G) {
              return G.filter(function (j) {
                return E.some(function (U) {
                  var H = U.key;
                  return j === H;
                });
              });
            });
        },
        [w, E, R]
      ),
      I.useEffect(
        function () {
          var G;
          if (
            R &&
            m.current[
              (G = E[E.length - 1]) === null || G === void 0 ? void 0 : G.key
            ]
          ) {
            var j;
            v(
              m.current[
                (j = E[E.length - 1]) === null || j === void 0 ? void 0 : j.key
              ]
            );
          }
        },
        [E, R]
      ),
      Je.createElement(
        Ase,
        an(
          {
            key: r,
            className: Mt(
              i,
              "".concat(i, "-").concat(r),
              h == null ? void 0 : h.list,
              s,
              Te(
                Te({}, "".concat(i, "-stack"), !!R),
                "".concat(i, "-stack-expanded"),
                B
              )
            ),
            style: o,
            keys: E,
            motionAppear: !0,
          },
          $,
          {
            onAllRemoved: function () {
              l(r);
            },
          }
        ),
        function (G, j) {
          var U = G.config,
            H = G.className,
            V = G.style,
            k = G.index,
            W = U,
            ee = W.key,
            Y = W.times,
            K = String(ee),
            ae = U,
            se = ae.className,
            we = ae.style,
            Be = ae.classNames,
            te = ae.styles,
            ge = xi(ae, hoe),
            ie = E.findIndex(function (he) {
              return he.key === K;
            }),
            me = {};
          if (R) {
            var fe = E.length - 1 - (ie > -1 ? ie : k - 1),
              Ee = r === "top" || r === "bottom" ? "-50%" : "0";
            if (fe > 0) {
              var Se, Ue, Ce;
              me.height = B
                ? (Se = m.current[K]) === null || Se === void 0
                  ? void 0
                  : Se.offsetHeight
                : y == null
                ? void 0
                : y.offsetHeight;
              for (var X = 0, z = 0; z < fe; z++) {
                var q;
                X +=
                  ((q = m.current[E[E.length - 1 - z].key]) === null ||
                  q === void 0
                    ? void 0
                    : q.offsetHeight) + D;
              }
              var ue = (B ? X : fe * L) * (r.startsWith("top") ? 1 : -1),
                de =
                  !B &&
                  y !== null &&
                  y !== void 0 &&
                  y.offsetWidth &&
                  (Ue = m.current[K]) !== null &&
                  Ue !== void 0 &&
                  Ue.offsetWidth
                    ? ((y == null ? void 0 : y.offsetWidth) -
                        L * 2 * (fe < 3 ? fe : 3)) /
                      ((Ce = m.current[K]) === null || Ce === void 0
                        ? void 0
                        : Ce.offsetWidth)
                    : 1;
              me.transform = "translate3d("
                .concat(Ee, ", ")
                .concat(ue, "px, 0) scaleX(")
                .concat(de, ")");
            } else me.transform = "translate3d(".concat(Ee, ", 0, 0)");
          }
          return Je.createElement(
            "div",
            {
              ref: j,
              className: Mt(
                "".concat(i, "-notice-wrapper"),
                H,
                Be == null ? void 0 : Be.wrapper
              ),
              style: Ze(Ze(Ze({}, V), me), te == null ? void 0 : te.wrapper),
              onMouseEnter: function () {
                return T(function (Ie) {
                  return Ie.includes(K) ? Ie : [].concat(Ot(Ie), [K]);
                });
              },
              onMouseLeave: function () {
                return T(function (Ie) {
                  return Ie.filter(function (ke) {
                    return ke !== K;
                  });
                });
              },
            },
            Je.createElement(
              B5,
              an({}, ge, {
                ref: function (Ie) {
                  ie > -1 ? (m.current[K] = Ie) : delete m.current[K];
                },
                prefixCls: i,
                classNames: Be,
                styles: te,
                className: Mt(se, h == null ? void 0 : h.notice),
                style: we,
                times: Y,
                key: ee,
                eventKey: ee,
                onNoticeClose: c,
                hovering: R && w.length > 0,
              })
            )
          );
        }
      )
    );
  },
  moe = I.forwardRef(function (n, e) {
    var t = n.prefixCls,
      r = t === void 0 ? "rc-notification" : t,
      i = n.container,
      s = n.motion,
      o = n.maxCount,
      a = n.className,
      l = n.style,
      c = n.onAllRemoved,
      u = n.stack,
      d = n.renderNotifications,
      h = I.useState([]),
      m = Et(h, 2),
      g = m[0],
      x = m[1],
      y = function (R) {
        var C,
          L = g.find(function (O) {
            return O.key === R;
          });
        L == null || (C = L.onClose) === null || C === void 0 || C.call(L),
          x(function (O) {
            return O.filter(function (D) {
              return D.key !== R;
            });
          });
      };
    I.useImperativeHandle(e, function () {
      return {
        open: function (R) {
          x(function (C) {
            var L = Ot(C),
              O = L.findIndex(function ($) {
                return $.key === R.key;
              }),
              D = Ze({}, R);
            if (O >= 0) {
              var B;
              (D.times =
                (((B = C[O]) === null || B === void 0 ? void 0 : B.times) ||
                  0) + 1),
                (L[O] = D);
            } else (D.times = 0), L.push(D);
            return o > 0 && L.length > o && (L = L.slice(-o)), L;
          });
        },
        close: function (R) {
          y(R);
        },
        destroy: function () {
          x([]);
        },
      };
    });
    var v = I.useState({}),
      _ = Et(v, 2),
      S = _[0],
      w = _[1];
    I.useEffect(
      function () {
        var N = {};
        g.forEach(function (R) {
          var C = R.placement,
            L = C === void 0 ? "topRight" : C;
          L && ((N[L] = N[L] || []), N[L].push(R));
        }),
          Object.keys(S).forEach(function (R) {
            N[R] = N[R] || [];
          }),
          w(N);
      },
      [g]
    );
    var T = function (R) {
        w(function (C) {
          var L = Ze({}, C),
            O = L[R] || [];
          return O.length || delete L[R], L;
        });
      },
      E = I.useRef(!1);
    if (
      (I.useEffect(
        function () {
          Object.keys(S).length > 0
            ? (E.current = !0)
            : E.current && (c == null || c(), (E.current = !1));
        },
        [S]
      ),
      !i)
    )
      return null;
    var M = Object.keys(S);
    return c_.createPortal(
      I.createElement(
        I.Fragment,
        null,
        M.map(function (N) {
          var R = S[N],
            C = I.createElement(poe, {
              key: N,
              configList: R,
              placement: N,
              prefixCls: r,
              className: a == null ? void 0 : a(N),
              style: l == null ? void 0 : l(N),
              motion: s,
              onNoticeClose: y,
              onAllNoticeRemoved: T,
              stack: u,
            });
          return d ? d(C, { prefixCls: r, key: N }) : C;
        })
      ),
      i
    );
  }),
  goe = [
    "getContainer",
    "motion",
    "prefixCls",
    "maxCount",
    "className",
    "style",
    "onAllRemoved",
    "stack",
    "renderNotifications",
  ],
  voe = function () {
    return document.body;
  },
  zO = 0;
function yoe() {
  for (var n = {}, e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  return (
    t.forEach(function (i) {
      i &&
        Object.keys(i).forEach(function (s) {
          var o = i[s];
          o !== void 0 && (n[s] = o);
        });
    }),
    n
  );
}
function xoe() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    e = n.getContainer,
    t = e === void 0 ? voe : e,
    r = n.motion,
    i = n.prefixCls,
    s = n.maxCount,
    o = n.className,
    a = n.style,
    l = n.onAllRemoved,
    c = n.stack,
    u = n.renderNotifications,
    d = xi(n, goe),
    h = I.useState(),
    m = Et(h, 2),
    g = m[0],
    x = m[1],
    y = I.useRef(),
    v = I.createElement(moe, {
      container: g,
      ref: y,
      prefixCls: i,
      motion: r,
      maxCount: s,
      className: o,
      style: a,
      onAllRemoved: l,
      stack: c,
      renderNotifications: u,
    }),
    _ = I.useState([]),
    S = Et(_, 2),
    w = S[0],
    T = S[1],
    E = I.useMemo(function () {
      return {
        open: function (N) {
          var R = yoe(d, N);
          (R.key === null || R.key === void 0) &&
            ((R.key = "rc-notification-".concat(zO)), (zO += 1)),
            T(function (C) {
              return [].concat(Ot(C), [{ type: "open", config: R }]);
            });
        },
        close: function (N) {
          T(function (R) {
            return [].concat(Ot(R), [{ type: "close", key: N }]);
          });
        },
        destroy: function () {
          T(function (N) {
            return [].concat(Ot(N), [{ type: "destroy" }]);
          });
        },
      };
    }, []);
  return (
    I.useEffect(function () {
      x(t());
    }),
    I.useEffect(
      function () {
        y.current &&
          w.length &&
          (w.forEach(function (M) {
            switch (M.type) {
              case "open":
                y.current.open(M.config);
                break;
              case "close":
                y.current.close(M.key);
                break;
              case "destroy":
                y.current.destroy();
                break;
            }
          }),
          T(function (M) {
            return M.filter(function (N) {
              return !w.includes(N);
            });
          }));
      },
      [w]
    ),
    [E, v]
  );
}
var _oe = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "0 0 1024 1024", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z",
          },
        },
      ],
    },
    name: "loading",
    theme: "outlined",
  },
  Soe = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: _oe }));
  },
  H5 = I.forwardRef(Soe);
const Aoe = 100,
  woe = 10,
  boe = Aoe * woe,
  Eoe = (n) => {
    const {
        componentCls: e,
        iconCls: t,
        boxShadow: r,
        colorText: i,
        colorSuccess: s,
        colorError: o,
        colorWarning: a,
        colorInfo: l,
        fontSizeLG: c,
        motionEaseInOutCirc: u,
        motionDurationSlow: d,
        marginXS: h,
        paddingXS: m,
        borderRadiusLG: g,
        zIndexPopup: x,
        contentPadding: y,
        contentBg: v,
      } = n,
      _ = `${e}-notice`,
      S = new pO("MessageMoveIn", {
        "0%": { padding: 0, transform: "translateY(-100%)", opacity: 0 },
        "100%": { padding: m, transform: "translateY(0)", opacity: 1 },
      }),
      w = new pO("MessageMoveOut", {
        "0%": { maxHeight: n.height, padding: m, opacity: 1 },
        "100%": { maxHeight: 0, padding: 0, opacity: 0 },
      }),
      T = {
        padding: m,
        textAlign: "center",
        [`${e}-custom-content > ${t}`]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: h,
          fontSize: c,
        },
        [`${_}-content`]: {
          display: "inline-block",
          padding: y,
          background: v,
          borderRadius: g,
          boxShadow: r,
          pointerEvents: "all",
        },
        [`${e}-success > ${t}`]: { color: s },
        [`${e}-error > ${t}`]: { color: o },
        [`${e}-warning > ${t}`]: { color: a },
        [`${e}-info > ${t},
      ${e}-loading > ${t}`]: { color: l },
      };
    return [
      {
        [e]: Object.assign(Object.assign({}, Md(n)), {
          color: i,
          position: "fixed",
          top: h,
          width: "100%",
          pointerEvents: "none",
          zIndex: x,
          [`${e}-move-up`]: { animationFillMode: "forwards" },
          [`
        ${e}-move-up-appear,
        ${e}-move-up-enter
      `]: {
            animationName: S,
            animationDuration: d,
            animationPlayState: "paused",
            animationTimingFunction: u,
          },
          [`
        ${e}-move-up-appear${e}-move-up-appear-active,
        ${e}-move-up-enter${e}-move-up-enter-active
      `]: { animationPlayState: "running" },
          [`${e}-move-up-leave`]: {
            animationName: w,
            animationDuration: d,
            animationPlayState: "paused",
            animationTimingFunction: u,
          },
          [`${e}-move-up-leave${e}-move-up-leave-active`]: {
            animationPlayState: "running",
          },
          "&-rtl": { direction: "rtl", span: { direction: "rtl" } },
        }),
      },
      { [e]: { [`${_}-wrapper`]: Object.assign({}, T) } },
      {
        [`${e}-notice-pure-panel`]: Object.assign(Object.assign({}, T), {
          padding: 0,
          textAlign: "start",
        }),
      },
    ];
  },
  Moe = (n) => ({
    zIndexPopup: n.zIndexPopupBase + boe + 10,
    contentBg: n.colorBgElevated,
    contentPadding: `${(n.controlHeightLG - n.fontSize * n.lineHeight) / 2}px ${
      n.paddingSM
    }px`,
  }),
  G5 = hp(
    "Message",
    (n) => {
      const e = mo(n, { height: 150 });
      return [Eoe(e)];
    },
    Moe
  );
var Toe = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Coe = {
    info: I.createElement(roe, null),
    success: I.createElement($se, null),
    error: I.createElement(z5, null),
    warning: I.createElement(eoe, null),
    loading: I.createElement(H5, null),
  },
  W5 = (n) => {
    let { prefixCls: e, type: t, icon: r, children: i } = n;
    return I.createElement(
      "div",
      { className: Mt(`${e}-custom-content`, `${e}-${t}`) },
      r || Coe[t],
      I.createElement("span", null, i)
    );
  },
  Roe = (n) => {
    const { prefixCls: e, className: t, type: r, icon: i, content: s } = n,
      o = Toe(n, ["prefixCls", "className", "type", "icon", "content"]),
      { getPrefixCls: a } = I.useContext(mr),
      l = e || a("message"),
      c = kd(l),
      [u, d, h] = G5(l, c);
    return u(
      I.createElement(
        B5,
        Object.assign({}, o, {
          prefixCls: l,
          className: Mt(t, d, `${l}-notice-pure-panel`, h, c),
          eventKey: "pure",
          duration: null,
          content: I.createElement(W5, { prefixCls: l, type: r, icon: i }, s),
        })
      )
    );
  };
function Noe(n, e) {
  return { motionName: e ?? `${n}-move-up` };
}
function hR(n) {
  let e;
  const t = new Promise((i) => {
      e = n(() => {
        i(!0);
      });
    }),
    r = () => {
      e == null || e();
    };
  return (r.then = (i, s) => t.then(i, s)), (r.promise = t), r;
}
var Poe = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Ioe = 8,
  Loe = 3,
  Ooe = (n) => {
    let { children: e, prefixCls: t } = n;
    const r = kd(t),
      [i, s, o] = G5(t, r);
    return i(I.createElement(doe, { classNames: { list: Mt(s, o, r) } }, e));
  },
  Doe = (n, e) => {
    let { prefixCls: t, key: r } = e;
    return I.createElement(Ooe, { prefixCls: t, key: r }, n);
  },
  Foe = I.forwardRef((n, e) => {
    const {
        top: t,
        prefixCls: r,
        getContainer: i,
        maxCount: s,
        duration: o = Loe,
        rtl: a,
        transitionName: l,
        onAllRemoved: c,
      } = n,
      {
        getPrefixCls: u,
        getPopupContainer: d,
        message: h,
        direction: m,
      } = I.useContext(mr),
      g = r || u("message"),
      x = () => ({ left: "50%", transform: "translateX(-50%)", top: t ?? Ioe }),
      y = () => Mt({ [`${g}-rtl`]: a ?? m === "rtl" }),
      v = () => Noe(g, l),
      _ = I.createElement(
        "span",
        { className: `${g}-close-x` },
        I.createElement(Zse, { className: `${g}-close-icon` })
      ),
      [S, w] = xoe({
        prefixCls: g,
        style: x,
        className: y,
        motion: v,
        closable: !1,
        closeIcon: _,
        duration: o,
        getContainer: () =>
          (i == null ? void 0 : i()) ||
          (d == null ? void 0 : d()) ||
          document.body,
        maxCount: s,
        onAllRemoved: c,
        renderNotifications: Doe,
      });
    return (
      I.useImperativeHandle(e, () =>
        Object.assign(Object.assign({}, S), { prefixCls: g, message: h })
      ),
      w
    );
  });
let BO = 0;
function j5(n) {
  const e = I.useRef(null);
  return [
    I.useMemo(() => {
      const r = (l) => {
          var c;
          (c = e.current) === null || c === void 0 || c.close(l);
        },
        i = (l) => {
          if (!e.current) {
            const E = () => {};
            return (E.then = () => {}), E;
          }
          const { open: c, prefixCls: u, message: d } = e.current,
            h = `${u}-notice`,
            {
              content: m,
              icon: g,
              type: x,
              key: y,
              className: v,
              style: _,
              onClose: S,
            } = l,
            w = Poe(l, [
              "content",
              "icon",
              "type",
              "key",
              "className",
              "style",
              "onClose",
            ]);
          let T = y;
          return (
            T == null && ((BO += 1), (T = `antd-message-${BO}`)),
            hR(
              (E) => (
                c(
                  Object.assign(Object.assign({}, w), {
                    key: T,
                    content: I.createElement(
                      W5,
                      { prefixCls: u, type: x, icon: g },
                      m
                    ),
                    placement: "top",
                    className: Mt(
                      x && `${h}-${x}`,
                      v,
                      d == null ? void 0 : d.className
                    ),
                    style: Object.assign(
                      Object.assign({}, d == null ? void 0 : d.style),
                      _
                    ),
                    onClose: () => {
                      S == null || S(), E();
                    },
                  })
                ),
                () => {
                  r(T);
                }
              )
            )
          );
        },
        o = {
          open: i,
          destroy: (l) => {
            var c;
            l !== void 0
              ? r(l)
              : (c = e.current) === null || c === void 0 || c.destroy();
          },
        };
      return (
        ["info", "success", "warning", "error", "loading"].forEach((l) => {
          const c = (u, d, h) => {
            let m;
            u && typeof u == "object" && "content" in u
              ? (m = u)
              : (m = { content: u });
            let g, x;
            typeof d == "function" ? (x = d) : ((g = d), (x = h));
            const y = Object.assign(
              Object.assign({ onClose: x, duration: g }, m),
              { type: l }
            );
            return i(y);
          };
          o[l] = c;
        }),
        o
      );
    }, []),
    I.createElement(
      Foe,
      Object.assign({ key: "message-holder" }, n, { ref: e })
    ),
  ];
}
function Uoe(n) {
  return j5(n);
}
function ts() {
  ts = function () {
    return e;
  };
  var n,
    e = {},
    t = Object.prototype,
    r = t.hasOwnProperty,
    i =
      Object.defineProperty ||
      function (G, j, U) {
        G[j] = U.value;
      },
    s = typeof Symbol == "function" ? Symbol : {},
    o = s.iterator || "@@iterator",
    a = s.asyncIterator || "@@asyncIterator",
    l = s.toStringTag || "@@toStringTag";
  function c(G, j, U) {
    return (
      Object.defineProperty(G, j, {
        value: U,
        enumerable: !0,
        configurable: !0,
        writable: !0,
      }),
      G[j]
    );
  }
  try {
    c({}, "");
  } catch {
    c = function (U, H, V) {
      return (U[H] = V);
    };
  }
  function u(G, j, U, H) {
    var V = j && j.prototype instanceof v ? j : v,
      k = Object.create(V.prototype),
      W = new B(H || []);
    return i(k, "_invoke", { value: C(G, U, W) }), k;
  }
  function d(G, j, U) {
    try {
      return { type: "normal", arg: G.call(j, U) };
    } catch (H) {
      return { type: "throw", arg: H };
    }
  }
  e.wrap = u;
  var h = "suspendedStart",
    m = "suspendedYield",
    g = "executing",
    x = "completed",
    y = {};
  function v() {}
  function _() {}
  function S() {}
  var w = {};
  c(w, o, function () {
    return this;
  });
  var T = Object.getPrototypeOf,
    E = T && T(T($([])));
  E && E !== t && r.call(E, o) && (w = E);
  var M = (S.prototype = v.prototype = Object.create(w));
  function N(G) {
    ["next", "throw", "return"].forEach(function (j) {
      c(G, j, function (U) {
        return this._invoke(j, U);
      });
    });
  }
  function R(G, j) {
    function U(V, k, W, ee) {
      var Y = d(G[V], G, k);
      if (Y.type !== "throw") {
        var K = Y.arg,
          ae = K.value;
        return ae && $t(ae) == "object" && r.call(ae, "__await")
          ? j.resolve(ae.__await).then(
              function (se) {
                U("next", se, W, ee);
              },
              function (se) {
                U("throw", se, W, ee);
              }
            )
          : j.resolve(ae).then(
              function (se) {
                (K.value = se), W(K);
              },
              function (se) {
                return U("throw", se, W, ee);
              }
            );
      }
      ee(Y.arg);
    }
    var H;
    i(this, "_invoke", {
      value: function (k, W) {
        function ee() {
          return new j(function (Y, K) {
            U(k, W, Y, K);
          });
        }
        return (H = H ? H.then(ee, ee) : ee());
      },
    });
  }
  function C(G, j, U) {
    var H = h;
    return function (V, k) {
      if (H === g) throw Error("Generator is already running");
      if (H === x) {
        if (V === "throw") throw k;
        return { value: n, done: !0 };
      }
      for (U.method = V, U.arg = k; ; ) {
        var W = U.delegate;
        if (W) {
          var ee = L(W, U);
          if (ee) {
            if (ee === y) continue;
            return ee;
          }
        }
        if (U.method === "next") U.sent = U._sent = U.arg;
        else if (U.method === "throw") {
          if (H === h) throw ((H = x), U.arg);
          U.dispatchException(U.arg);
        } else U.method === "return" && U.abrupt("return", U.arg);
        H = g;
        var Y = d(G, j, U);
        if (Y.type === "normal") {
          if (((H = U.done ? x : m), Y.arg === y)) continue;
          return { value: Y.arg, done: U.done };
        }
        Y.type === "throw" && ((H = x), (U.method = "throw"), (U.arg = Y.arg));
      }
    };
  }
  function L(G, j) {
    var U = j.method,
      H = G.iterator[U];
    if (H === n)
      return (
        (j.delegate = null),
        (U === "throw" &&
          G.iterator.return &&
          ((j.method = "return"),
          (j.arg = n),
          L(G, j),
          j.method === "throw")) ||
          (U !== "return" &&
            ((j.method = "throw"),
            (j.arg = new TypeError(
              "The iterator does not provide a '" + U + "' method"
            )))),
        y
      );
    var V = d(H, G.iterator, j.arg);
    if (V.type === "throw")
      return (j.method = "throw"), (j.arg = V.arg), (j.delegate = null), y;
    var k = V.arg;
    return k
      ? k.done
        ? ((j[G.resultName] = k.value),
          (j.next = G.nextLoc),
          j.method !== "return" && ((j.method = "next"), (j.arg = n)),
          (j.delegate = null),
          y)
        : k
      : ((j.method = "throw"),
        (j.arg = new TypeError("iterator result is not an object")),
        (j.delegate = null),
        y);
  }
  function O(G) {
    var j = { tryLoc: G[0] };
    1 in G && (j.catchLoc = G[1]),
      2 in G && ((j.finallyLoc = G[2]), (j.afterLoc = G[3])),
      this.tryEntries.push(j);
  }
  function D(G) {
    var j = G.completion || {};
    (j.type = "normal"), delete j.arg, (G.completion = j);
  }
  function B(G) {
    (this.tryEntries = [{ tryLoc: "root" }]),
      G.forEach(O, this),
      this.reset(!0);
  }
  function $(G) {
    if (G || G === "") {
      var j = G[o];
      if (j) return j.call(G);
      if (typeof G.next == "function") return G;
      if (!isNaN(G.length)) {
        var U = -1,
          H = function V() {
            for (; ++U < G.length; )
              if (r.call(G, U)) return (V.value = G[U]), (V.done = !1), V;
            return (V.value = n), (V.done = !0), V;
          };
        return (H.next = H);
      }
    }
    throw new TypeError($t(G) + " is not iterable");
  }
  return (
    (_.prototype = S),
    i(M, "constructor", { value: S, configurable: !0 }),
    i(S, "constructor", { value: _, configurable: !0 }),
    (_.displayName = c(S, l, "GeneratorFunction")),
    (e.isGeneratorFunction = function (G) {
      var j = typeof G == "function" && G.constructor;
      return (
        !!j && (j === _ || (j.displayName || j.name) === "GeneratorFunction")
      );
    }),
    (e.mark = function (G) {
      return (
        Object.setPrototypeOf
          ? Object.setPrototypeOf(G, S)
          : ((G.__proto__ = S), c(G, l, "GeneratorFunction")),
        (G.prototype = Object.create(M)),
        G
      );
    }),
    (e.awrap = function (G) {
      return { __await: G };
    }),
    N(R.prototype),
    c(R.prototype, a, function () {
      return this;
    }),
    (e.AsyncIterator = R),
    (e.async = function (G, j, U, H, V) {
      V === void 0 && (V = Promise);
      var k = new R(u(G, j, U, H), V);
      return e.isGeneratorFunction(j)
        ? k
        : k.next().then(function (W) {
            return W.done ? W.value : k.next();
          });
    }),
    N(M),
    c(M, l, "Generator"),
    c(M, o, function () {
      return this;
    }),
    c(M, "toString", function () {
      return "[object Generator]";
    }),
    (e.keys = function (G) {
      var j = Object(G),
        U = [];
      for (var H in j) U.push(H);
      return (
        U.reverse(),
        function V() {
          for (; U.length; ) {
            var k = U.pop();
            if (k in j) return (V.value = k), (V.done = !1), V;
          }
          return (V.done = !0), V;
        }
      );
    }),
    (e.values = $),
    (B.prototype = {
      constructor: B,
      reset: function (j) {
        if (
          ((this.prev = 0),
          (this.next = 0),
          (this.sent = this._sent = n),
          (this.done = !1),
          (this.delegate = null),
          (this.method = "next"),
          (this.arg = n),
          this.tryEntries.forEach(D),
          !j)
        )
          for (var U in this)
            U.charAt(0) === "t" &&
              r.call(this, U) &&
              !isNaN(+U.slice(1)) &&
              (this[U] = n);
      },
      stop: function () {
        this.done = !0;
        var j = this.tryEntries[0].completion;
        if (j.type === "throw") throw j.arg;
        return this.rval;
      },
      dispatchException: function (j) {
        if (this.done) throw j;
        var U = this;
        function H(K, ae) {
          return (
            (W.type = "throw"),
            (W.arg = j),
            (U.next = K),
            ae && ((U.method = "next"), (U.arg = n)),
            !!ae
          );
        }
        for (var V = this.tryEntries.length - 1; V >= 0; --V) {
          var k = this.tryEntries[V],
            W = k.completion;
          if (k.tryLoc === "root") return H("end");
          if (k.tryLoc <= this.prev) {
            var ee = r.call(k, "catchLoc"),
              Y = r.call(k, "finallyLoc");
            if (ee && Y) {
              if (this.prev < k.catchLoc) return H(k.catchLoc, !0);
              if (this.prev < k.finallyLoc) return H(k.finallyLoc);
            } else if (ee) {
              if (this.prev < k.catchLoc) return H(k.catchLoc, !0);
            } else {
              if (!Y) throw Error("try statement without catch or finally");
              if (this.prev < k.finallyLoc) return H(k.finallyLoc);
            }
          }
        }
      },
      abrupt: function (j, U) {
        for (var H = this.tryEntries.length - 1; H >= 0; --H) {
          var V = this.tryEntries[H];
          if (
            V.tryLoc <= this.prev &&
            r.call(V, "finallyLoc") &&
            this.prev < V.finallyLoc
          ) {
            var k = V;
            break;
          }
        }
        k &&
          (j === "break" || j === "continue") &&
          k.tryLoc <= U &&
          U <= k.finallyLoc &&
          (k = null);
        var W = k ? k.completion : {};
        return (
          (W.type = j),
          (W.arg = U),
          k
            ? ((this.method = "next"), (this.next = k.finallyLoc), y)
            : this.complete(W)
        );
      },
      complete: function (j, U) {
        if (j.type === "throw") throw j.arg;
        return (
          j.type === "break" || j.type === "continue"
            ? (this.next = j.arg)
            : j.type === "return"
            ? ((this.rval = this.arg = j.arg),
              (this.method = "return"),
              (this.next = "end"))
            : j.type === "normal" && U && (this.next = U),
          y
        );
      },
      finish: function (j) {
        for (var U = this.tryEntries.length - 1; U >= 0; --U) {
          var H = this.tryEntries[U];
          if (H.finallyLoc === j)
            return this.complete(H.completion, H.afterLoc), D(H), y;
        }
      },
      catch: function (j) {
        for (var U = this.tryEntries.length - 1; U >= 0; --U) {
          var H = this.tryEntries[U];
          if (H.tryLoc === j) {
            var V = H.completion;
            if (V.type === "throw") {
              var k = V.arg;
              D(H);
            }
            return k;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function (j, U, H) {
        return (
          (this.delegate = { iterator: $(j), resultName: U, nextLoc: H }),
          this.method === "next" && (this.arg = n),
          y
        );
      },
    }),
    e
  );
}
function VO(n, e, t, r, i, s, o) {
  try {
    var a = n[s](o),
      l = a.value;
  } catch (c) {
    return void t(c);
  }
  a.done ? e(l) : Promise.resolve(l).then(r, i);
}
function zd(n) {
  return function () {
    var e = this,
      t = arguments;
    return new Promise(function (r, i) {
      var s = n.apply(e, t);
      function o(l) {
        VO(s, r, i, o, a, "next", l);
      }
      function a(l) {
        VO(s, r, i, o, a, "throw", l);
      }
      o(void 0);
    });
  };
}
var M0 = Ze({}, T9),
  koe = M0.version,
  zoe = M0.render,
  Boe = M0.unmountComponentAtNode,
  fS;
try {
  var Voe = Number((koe || "").split(".")[0]);
  Voe >= 18 && (fS = M0.createRoot);
} catch {}
function HO(n) {
  var e = M0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  e && $t(e) === "object" && (e.usingClientEntryPoint = n);
}
var R1 = "__rc_react_root__";
function Hoe(n, e) {
  HO(!0);
  var t = e[R1] || fS(e);
  HO(!1), t.render(n), (e[R1] = t);
}
function Goe(n, e) {
  zoe(n, e);
}
function $5(n, e) {
  if (fS) {
    Hoe(n, e);
    return;
  }
  Goe(n, e);
}
function Woe(n) {
  return dT.apply(this, arguments);
}
function dT() {
  return (
    (dT = zd(
      ts().mark(function n(e) {
        return ts().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.resolve().then(function () {
                    var i;
                    (i = e[R1]) === null || i === void 0 || i.unmount(),
                      delete e[R1];
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, n);
      })
    )),
    dT.apply(this, arguments)
  );
}
function joe(n) {
  Boe(n);
}
function $oe(n) {
  return fT.apply(this, arguments);
}
function fT() {
  return (
    (fT = zd(
      ts().mark(function n(e) {
        return ts().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                if (fS === void 0) {
                  r.next = 2;
                  break;
                }
                return r.abrupt("return", Woe(e));
              case 2:
                joe(e);
              case 3:
              case "end":
                return r.stop();
            }
        }, n);
      })
    )),
    fT.apply(this, arguments)
  );
}
const db = () => ({ height: 0, opacity: 0 }),
  GO = (n) => {
    const { scrollHeight: e } = n;
    return { height: e, opacity: 1 };
  },
  Xoe = (n) => ({ height: n ? n.offsetHeight : 0 }),
  fb = (n, e) =>
    (e == null ? void 0 : e.deadline) === !0 || e.propertyName === "height",
  Yoe = function () {
    return {
      motionName: `${
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant"
      }-motion-collapse`,
      onAppearStart: db,
      onEnterStart: db,
      onAppearActive: GO,
      onEnterActive: GO,
      onLeaveStart: Xoe,
      onLeaveActive: db,
      onAppearEnd: fb,
      onEnterEnd: fb,
      onLeaveEnd: fb,
      motionDeadline: 500,
    };
  },
  qoe = function (n) {
    if (!n) return !1;
    if (n instanceof Element) {
      if (n.offsetParent) return !0;
      if (n.getBBox) {
        var e = n.getBBox(),
          t = e.width,
          r = e.height;
        if (t || r) return !0;
      }
      if (n.getBoundingClientRect) {
        var i = n.getBoundingClientRect(),
          s = i.width,
          o = i.height;
        if (s || o) return !0;
      }
    }
    return !1;
  },
  Koe = (n) => {
    const { componentCls: e, colorPrimary: t } = n;
    return {
      [e]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${t})`,
        boxShadow: "0 0 0 0 currentcolor",
        opacity: 0.2,
        "&.wave-motion-appear": {
          transition: [
            `box-shadow 0.4s ${n.motionEaseOutCirc}`,
            `opacity 2s ${n.motionEaseOutCirc}`,
          ].join(","),
          "&-active": { boxShadow: "0 0 0 6px currentcolor", opacity: 0 },
          "&.wave-quick": {
            transition: [
              `box-shadow ${n.motionDurationSlow} ${n.motionEaseInOut}`,
              `opacity ${n.motionDurationSlow} ${n.motionEaseInOut}`,
            ].join(","),
          },
        },
      },
    };
  },
  Zoe = dR("Wave", (n) => [Koe(n)]),
  pR = "ant-wave-target";
function Qoe(n) {
  const e = (n || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return e && e[1] && e[2] && e[3] ? !(e[1] === e[2] && e[2] === e[3]) : !0;
}
function hb(n) {
  return (
    n &&
    n !== "#fff" &&
    n !== "#ffffff" &&
    n !== "rgb(255, 255, 255)" &&
    n !== "rgba(255, 255, 255, 1)" &&
    Qoe(n) &&
    !/rgba\((?:\d*, ){3}0\)/.test(n) &&
    n !== "transparent"
  );
}
function Joe(n) {
  const {
    borderTopColor: e,
    borderColor: t,
    backgroundColor: r,
  } = getComputedStyle(n);
  return hb(e) ? e : hb(t) ? t : hb(r) ? r : null;
}
function pb(n) {
  return Number.isNaN(n) ? 0 : n;
}
const eae = (n) => {
    const { className: e, target: t, component: r } = n,
      i = I.useRef(null),
      [s, o] = I.useState(null),
      [a, l] = I.useState([]),
      [c, u] = I.useState(0),
      [d, h] = I.useState(0),
      [m, g] = I.useState(0),
      [x, y] = I.useState(0),
      [v, _] = I.useState(!1),
      S = {
        left: c,
        top: d,
        width: m,
        height: x,
        borderRadius: a.map((E) => `${E}px`).join(" "),
      };
    s && (S["--wave-color"] = s);
    function w() {
      const E = getComputedStyle(t);
      o(Joe(t));
      const M = E.position === "static",
        { borderLeftWidth: N, borderTopWidth: R } = E;
      u(M ? t.offsetLeft : pb(-parseFloat(N))),
        h(M ? t.offsetTop : pb(-parseFloat(R))),
        g(t.offsetWidth),
        y(t.offsetHeight);
      const {
        borderTopLeftRadius: C,
        borderTopRightRadius: L,
        borderBottomLeftRadius: O,
        borderBottomRightRadius: D,
      } = E;
      l([C, L, D, O].map((B) => pb(parseFloat(B))));
    }
    if (
      (I.useEffect(() => {
        if (t) {
          const E = Ya(() => {
            w(), _(!0);
          });
          let M;
          return (
            typeof ResizeObserver < "u" &&
              ((M = new ResizeObserver(w)), M.observe(t)),
            () => {
              Ya.cancel(E), M == null || M.disconnect();
            }
          );
        }
      }, []),
      !v)
    )
      return null;
    const T =
      (r === "Checkbox" || r === "Radio") &&
      (t == null ? void 0 : t.classList.contains(pR));
    return I.createElement(
      uS,
      {
        visible: !0,
        motionAppear: !0,
        motionName: "wave-motion",
        motionDeadline: 5e3,
        onAppearEnd: (E, M) => {
          var N;
          if (M.deadline || M.propertyName === "opacity") {
            const R =
              (N = i.current) === null || N === void 0
                ? void 0
                : N.parentElement;
            $oe(R).then(() => {
              R == null || R.remove();
            });
          }
          return !1;
        },
      },
      (E, M) => {
        let { className: N } = E;
        return I.createElement("div", {
          ref: eu(i, M),
          className: Mt(e, { "wave-quick": T }, N),
          style: S,
        });
      }
    );
  },
  tae = (n, e) => {
    var t;
    const { component: r } = e;
    if (
      r === "Checkbox" &&
      !(!((t = n.querySelector("input")) === null || t === void 0) && t.checked)
    )
      return;
    const i = document.createElement("div");
    (i.style.position = "absolute"),
      (i.style.left = "0px"),
      (i.style.top = "0px"),
      n == null || n.insertBefore(i, n == null ? void 0 : n.firstChild),
      $5(I.createElement(eae, Object.assign({}, e, { target: n })), i);
  },
  nae = (n, e, t) => {
    const { wave: r } = I.useContext(mr),
      [, i, s] = jc(),
      o = $h((c) => {
        const u = n.current;
        if ((r != null && r.disabled) || !u) return;
        const d = u.querySelector(`.${pR}`) || u,
          { showEffect: h } = r || {};
        (h || tae)(d, {
          className: e,
          token: i,
          component: t,
          event: c,
          hashId: s,
        });
      }),
      a = I.useRef();
    return (c) => {
      Ya.cancel(a.current),
        (a.current = Ya(() => {
          o(c);
        }));
    };
  },
  X5 = (n) => {
    const { children: e, disabled: t, component: r } = n,
      { getPrefixCls: i } = I.useContext(mr),
      s = I.useRef(null),
      o = i("wave"),
      [, a] = Zoe(o),
      l = nae(s, Mt(o, a), r);
    if (
      (Je.useEffect(() => {
        const u = s.current;
        if (!u || u.nodeType !== 1 || t) return;
        const d = (h) => {
          !qoe(h.target) ||
            !u.getAttribute ||
            u.getAttribute("disabled") ||
            u.disabled ||
            u.className.includes("disabled") ||
            u.className.includes("-leave") ||
            l(h);
        };
        return (
          u.addEventListener("click", d, !0),
          () => {
            u.removeEventListener("click", d, !0);
          }
        );
      }, [t]),
      !Je.isValidElement(e))
    )
      return e ?? null;
    const c = eR(e) ? eu(e.ref, s) : s;
    return Xh(e, { ref: c });
  },
  Bd = (n) => {
    const e = Je.useContext(jh);
    return Je.useMemo(
      () =>
        n
          ? typeof n == "string"
            ? n ?? e
            : n instanceof Function
            ? n(e)
            : e
          : e,
      [n, e]
    );
  },
  Y5 = I.createContext(null),
  mR = (n, e) => {
    const t = I.useContext(Y5),
      r = I.useMemo(() => {
        if (!t) return "";
        const { compactDirection: i, isFirstItem: s, isLastItem: o } = t,
          a = i === "vertical" ? "-vertical-" : "-";
        return Mt(`${n}-compact${a}item`, {
          [`${n}-compact${a}first-item`]: s,
          [`${n}-compact${a}last-item`]: o,
          [`${n}-compact${a}item-rtl`]: e === "rtl",
        });
      }, [n, e, t]);
    return {
      compactSize: t == null ? void 0 : t.compactSize,
      compactDirection: t == null ? void 0 : t.compactDirection,
      compactItemClassnames: r,
    };
  },
  rae = (n) => {
    let { children: e } = n;
    return I.createElement(Y5.Provider, { value: null }, e);
  };
var iae = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const q5 = I.createContext(void 0),
  sae = (n) => {
    const { getPrefixCls: e, direction: t } = I.useContext(mr),
      { prefixCls: r, size: i, className: s } = n,
      o = iae(n, ["prefixCls", "size", "className"]),
      a = e("btn-group", r),
      [, , l] = jc();
    let c = "";
    switch (i) {
      case "large":
        c = "lg";
        break;
      case "small":
        c = "sm";
        break;
    }
    const u = Mt(a, { [`${a}-${c}`]: c, [`${a}-rtl`]: t === "rtl" }, s, l);
    return I.createElement(
      q5.Provider,
      { value: i },
      I.createElement("div", Object.assign({}, o, { className: u }))
    );
  },
  WO = /^[\u4e00-\u9fa5]{2}$/,
  hT = WO.test.bind(WO);
function jO(n) {
  return typeof n == "string";
}
function mb(n) {
  return n === "text" || n === "link";
}
function oae(n, e) {
  if (n == null) return;
  const t = e ? " " : "";
  return typeof n != "string" &&
    typeof n != "number" &&
    jO(n.type) &&
    hT(n.props.children)
    ? Xh(n, { children: n.props.children.split("").join(t) })
    : jO(n)
    ? hT(n)
      ? Je.createElement("span", null, n.split("").join(t))
      : Je.createElement("span", null, n)
    : coe(n)
    ? Je.createElement("span", null, n)
    : n;
}
function aae(n, e) {
  let t = !1;
  const r = [];
  return (
    Je.Children.forEach(n, (i) => {
      const s = typeof i,
        o = s === "string" || s === "number";
      if (t && o) {
        const a = r.length - 1,
          l = r[a];
        r[a] = `${l}${i}`;
      } else r.push(i);
      t = o;
    }),
    Je.Children.map(r, (i) => oae(i, e))
  );
}
const K5 = I.forwardRef((n, e) => {
    const { className: t, style: r, children: i, prefixCls: s } = n,
      o = Mt(`${s}-icon`, t);
    return Je.createElement("span", { ref: e, className: o, style: r }, i);
  }),
  $O = I.forwardRef((n, e) => {
    const {
        prefixCls: t,
        className: r,
        style: i,
        iconClassName: s,
        iconPosition: o = "start",
      } = n,
      a = Mt(r, {
        [`${t}-loading-icon-end`]: o === "end",
        [`${t}-loading-icon`]: o === "start",
      });
    return Je.createElement(
      K5,
      { prefixCls: t, className: a, style: i, ref: e },
      Je.createElement(H5, { className: s })
    );
  }),
  gb = () => ({ width: 0, opacity: 0, transform: "scale(0)" }),
  vb = (n) => ({ width: n.scrollWidth, opacity: 1, transform: "scale(1)" }),
  lae = (n) => {
    const {
        prefixCls: e,
        loading: t,
        existIcon: r,
        className: i,
        style: s,
        iconPosition: o,
      } = n,
      a = !!t;
    return r
      ? Je.createElement($O, {
          prefixCls: e,
          className: i,
          style: s,
          iconPosition: o,
        })
      : Je.createElement(
          uS,
          {
            visible: a,
            motionName: `${e}-loading-icon-motion`,
            motionLeave: a,
            removeOnLeave: !0,
            onAppearStart: gb,
            onAppearActive: vb,
            onEnterStart: gb,
            onEnterActive: vb,
            onLeaveStart: vb,
            onLeaveActive: gb,
          },
          (l, c) => {
            let { className: u, style: d } = l;
            return Je.createElement($O, {
              prefixCls: e,
              className: i,
              style: Object.assign(Object.assign({}, s), d),
              ref: c,
              iconClassName: u,
              iconPosition: o,
            });
          }
        );
  },
  XO = (n, e) => ({
    [`> span, > ${n}`]: {
      "&:not(:last-child)": {
        [`&, & > ${n}`]: { "&:not(:disabled)": { borderInlineEndColor: e } },
      },
      "&:not(:first-child)": {
        [`&, & > ${n}`]: { "&:not(:disabled)": { borderInlineStartColor: e } },
      },
    },
  }),
  cae = (n) => {
    const {
      componentCls: e,
      fontSize: t,
      lineWidth: r,
      groupBorderColor: i,
      colorErrorHover: s,
    } = n;
    return {
      [`${e}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          [`> span, > ${e}`]: {
            "&:not(:last-child)": {
              [`&, & > ${e}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
              },
            },
            "&:not(:first-child)": {
              marginInlineStart: n.calc(r).mul(-1).equal(),
              [`&, & > ${e}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
              },
            },
          },
          [e]: {
            position: "relative",
            zIndex: 1,
            "&:hover,\n          &:focus,\n          &:active": { zIndex: 2 },
            "&[disabled]": { zIndex: 0 },
          },
          [`${e}-icon-only`]: { fontSize: t },
        },
        XO(`${e}-primary`, i),
        XO(`${e}-danger`, s),
      ],
    };
  },
  Z5 = (n) => {
    const { paddingInline: e, onlyIconSize: t, paddingBlock: r } = n;
    return mo(n, {
      buttonPaddingHorizontal: e,
      buttonPaddingVertical: r,
      buttonIconOnlyFontSize: t,
    });
  },
  Q5 = (n) => {
    var e, t, r, i, s, o;
    const a = (e = n.contentFontSize) !== null && e !== void 0 ? e : n.fontSize,
      l = (t = n.contentFontSizeSM) !== null && t !== void 0 ? t : n.fontSize,
      c = (r = n.contentFontSizeLG) !== null && r !== void 0 ? r : n.fontSizeLG,
      u = (i = n.contentLineHeight) !== null && i !== void 0 ? i : Ox(a),
      d = (s = n.contentLineHeightSM) !== null && s !== void 0 ? s : Ox(l),
      h = (o = n.contentLineHeightLG) !== null && o !== void 0 ? o : Ox(c);
    return {
      fontWeight: 400,
      defaultShadow: `0 ${n.controlOutlineWidth}px 0 ${n.controlTmpOutline}`,
      primaryShadow: `0 ${n.controlOutlineWidth}px 0 ${n.controlOutline}`,
      dangerShadow: `0 ${n.controlOutlineWidth}px 0 ${n.colorErrorOutline}`,
      primaryColor: n.colorTextLightSolid,
      dangerColor: n.colorTextLightSolid,
      borderColorDisabled: n.colorBorder,
      defaultGhostColor: n.colorBgContainer,
      ghostBg: "transparent",
      defaultGhostBorderColor: n.colorBgContainer,
      paddingInline: n.paddingContentHorizontal - n.lineWidth,
      paddingInlineLG: n.paddingContentHorizontal - n.lineWidth,
      paddingInlineSM: 8 - n.lineWidth,
      onlyIconSize: n.fontSizeLG,
      onlyIconSizeSM: n.fontSizeLG - 2,
      onlyIconSizeLG: n.fontSizeLG + 2,
      groupBorderColor: n.colorPrimaryHover,
      linkHoverBg: "transparent",
      textHoverBg: n.colorBgTextHover,
      defaultColor: n.colorText,
      defaultBg: n.colorBgContainer,
      defaultBorderColor: n.colorBorder,
      defaultBorderColorDisabled: n.colorBorder,
      defaultHoverBg: n.colorBgContainer,
      defaultHoverColor: n.colorPrimaryHover,
      defaultHoverBorderColor: n.colorPrimaryHover,
      defaultActiveBg: n.colorBgContainer,
      defaultActiveColor: n.colorPrimaryActive,
      defaultActiveBorderColor: n.colorPrimaryActive,
      contentFontSize: a,
      contentFontSizeSM: l,
      contentFontSizeLG: c,
      contentLineHeight: u,
      contentLineHeightSM: d,
      contentLineHeightLG: h,
      paddingBlock: Math.max((n.controlHeight - a * u) / 2 - n.lineWidth, 0),
      paddingBlockSM: Math.max(
        (n.controlHeightSM - l * d) / 2 - n.lineWidth,
        0
      ),
      paddingBlockLG: Math.max(
        (n.controlHeightLG - c * h) / 2 - n.lineWidth,
        0
      ),
    };
  },
  uae = (n) => {
    const { componentCls: e, iconCls: t, fontWeight: r } = n;
    return {
      [e]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight: r,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        background: "transparent",
        border: `${jt(n.lineWidth)} ${n.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${n.motionDurationMid} ${n.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        color: n.colorText,
        "&:disabled > *": { pointerEvents: "none" },
        "> span": { display: "inline-block" },
        [`${e}-icon`]: {
          lineHeight: 0,
          "&-end": { marginInlineStart: n.marginXS },
        },
        [`> ${t} + span, > span + ${t}`]: { marginInlineStart: n.marginXS },
        [`&:not(${e}-icon-only) > ${e}-icon`]: {
          [`&${e}-loading-icon, &:not(:last-child)`]: {
            marginInlineEnd: n.marginXS,
          },
          [`&${e}-loading-icon-end`]: { marginInlineStart: n.marginXS },
        },
        "> a": { color: "currentColor" },
        "&:not(:disabled)": Object.assign({}, jie(n)),
        [`&${e}-two-chinese-chars::first-letter`]: { letterSpacing: "0.34em" },
        [`&${e}-two-chinese-chars > *:not(${t})`]: {
          marginInlineEnd: "-0.34em",
          letterSpacing: "0.34em",
        },
        [`&-icon-only${e}-compact-item`]: { flex: "none" },
      },
    };
  },
  zl = (n, e, t) => ({
    [`&:not(:disabled):not(${n}-disabled)`]: { "&:hover": e, "&:active": t },
  }),
  dae = (n) => ({
    minWidth: n.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%",
  }),
  fae = (n) => ({
    borderRadius: n.controlHeight,
    paddingInlineStart: n.calc(n.controlHeight).div(2).equal(),
    paddingInlineEnd: n.calc(n.controlHeight).div(2).equal(),
  }),
  hae = (n) => ({
    cursor: "not-allowed",
    borderColor: n.borderColorDisabled,
    color: n.colorTextDisabled,
    background: n.colorBgContainerDisabled,
    boxShadow: "none",
  }),
  Yg = (n, e, t, r, i, s, o, a) => ({
    [`&${n}-background-ghost`]: Object.assign(
      Object.assign(
        {
          color: t || void 0,
          background: e,
          borderColor: r || void 0,
          boxShadow: "none",
        },
        zl(
          n,
          Object.assign({ background: e }, o),
          Object.assign({ background: e }, a)
        )
      ),
      {
        "&:disabled": {
          cursor: "not-allowed",
          color: i || void 0,
          borderColor: s || void 0,
        },
      }
    ),
  }),
  gR = (n) => ({
    [`&:disabled, &${n.componentCls}-disabled`]: Object.assign({}, hae(n)),
  }),
  J5 = (n) => Object.assign({}, gR(n)),
  N1 = (n) => ({
    [`&:disabled, &${n.componentCls}-disabled`]: {
      cursor: "not-allowed",
      color: n.colorTextDisabled,
    },
  }),
  eV = (n) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, J5(n)), {
            background: n.defaultBg,
            borderColor: n.defaultBorderColor,
            color: n.defaultColor,
            boxShadow: n.defaultShadow,
          }),
          zl(
            n.componentCls,
            {
              color: n.defaultHoverColor,
              borderColor: n.defaultHoverBorderColor,
              background: n.defaultHoverBg,
            },
            {
              color: n.defaultActiveColor,
              borderColor: n.defaultActiveBorderColor,
              background: n.defaultActiveBg,
            }
          )
        ),
        Yg(
          n.componentCls,
          n.ghostBg,
          n.defaultGhostColor,
          n.defaultGhostBorderColor,
          n.colorTextDisabled,
          n.colorBorder
        )
      ),
      {
        [`&${n.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            Object.assign(
              { color: n.colorError, borderColor: n.colorError },
              zl(
                n.componentCls,
                {
                  color: n.colorErrorHover,
                  borderColor: n.colorErrorBorderHover,
                },
                { color: n.colorErrorActive, borderColor: n.colorErrorActive }
              )
            ),
            Yg(
              n.componentCls,
              n.ghostBg,
              n.colorError,
              n.colorError,
              n.colorTextDisabled,
              n.colorBorder
            )
          ),
          gR(n)
        ),
      }
    ),
  pae = (n) =>
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, J5(n)), {
            color: n.primaryColor,
            background: n.colorPrimary,
            boxShadow: n.primaryShadow,
          }),
          zl(
            n.componentCls,
            { color: n.colorTextLightSolid, background: n.colorPrimaryHover },
            { color: n.colorTextLightSolid, background: n.colorPrimaryActive }
          )
        ),
        Yg(
          n.componentCls,
          n.ghostBg,
          n.colorPrimary,
          n.colorPrimary,
          n.colorTextDisabled,
          n.colorBorder,
          { color: n.colorPrimaryHover, borderColor: n.colorPrimaryHover },
          { color: n.colorPrimaryActive, borderColor: n.colorPrimaryActive }
        )
      ),
      {
        [`&${n.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            Object.assign(
              {
                background: n.colorError,
                boxShadow: n.dangerShadow,
                color: n.dangerColor,
              },
              zl(
                n.componentCls,
                { background: n.colorErrorHover },
                { background: n.colorErrorActive }
              )
            ),
            Yg(
              n.componentCls,
              n.ghostBg,
              n.colorError,
              n.colorError,
              n.colorTextDisabled,
              n.colorBorder,
              { color: n.colorErrorHover, borderColor: n.colorErrorHover },
              { color: n.colorErrorActive, borderColor: n.colorErrorActive }
            )
          ),
          gR(n)
        ),
      }
    ),
  mae = (n) =>
    Object.assign(Object.assign({}, eV(n)), { borderStyle: "dashed" }),
  gae = (n) =>
    Object.assign(
      Object.assign(
        Object.assign(
          { color: n.colorLink },
          zl(
            n.componentCls,
            { color: n.colorLinkHover, background: n.linkHoverBg },
            { color: n.colorLinkActive }
          )
        ),
        N1(n)
      ),
      {
        [`&${n.componentCls}-dangerous`]: Object.assign(
          Object.assign(
            { color: n.colorError },
            zl(
              n.componentCls,
              { color: n.colorErrorHover },
              { color: n.colorErrorActive }
            )
          ),
          N1(n)
        ),
      }
    ),
  vae = (n) =>
    Object.assign(
      Object.assign(
        Object.assign(
          {},
          zl(
            n.componentCls,
            { color: n.colorText, background: n.textHoverBg },
            { color: n.colorText, background: n.colorBgTextActive }
          )
        ),
        N1(n)
      ),
      {
        [`&${n.componentCls}-dangerous`]: Object.assign(
          Object.assign({ color: n.colorError }, N1(n)),
          zl(
            n.componentCls,
            { color: n.colorErrorHover, background: n.colorErrorBg },
            { color: n.colorErrorHover, background: n.colorErrorBgActive }
          )
        ),
      }
    ),
  yae = (n) => {
    const { componentCls: e } = n;
    return {
      [`${e}-default`]: eV(n),
      [`${e}-primary`]: pae(n),
      [`${e}-dashed`]: mae(n),
      [`${e}-link`]: gae(n),
      [`${e}-text`]: vae(n),
      [`${e}-ghost`]: Yg(
        n.componentCls,
        n.ghostBg,
        n.colorBgContainer,
        n.colorBgContainer,
        n.colorTextDisabled,
        n.colorBorder
      ),
    };
  },
  vR = function (n) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
        componentCls: t,
        controlHeight: r,
        fontSize: i,
        lineHeight: s,
        borderRadius: o,
        buttonPaddingHorizontal: a,
        iconCls: l,
        buttonPaddingVertical: c,
      } = n,
      u = `${t}-icon-only`;
    return [
      {
        [`${e}`]: {
          fontSize: i,
          lineHeight: s,
          height: r,
          padding: `${jt(c)} ${jt(a)}`,
          borderRadius: o,
          [`&${u}`]: {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            width: r,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${t}-round`]: { width: "auto" },
            [l]: { fontSize: n.buttonIconOnlyFontSize },
          },
          [`&${t}-loading`]: { opacity: n.opacityLoading, cursor: "default" },
          [`${t}-loading-icon`]: {
            transition: `width ${n.motionDurationSlow} ${n.motionEaseInOut}, opacity ${n.motionDurationSlow} ${n.motionEaseInOut}`,
          },
        },
      },
      { [`${t}${t}-circle${e}`]: dae(n) },
      { [`${t}${t}-round${e}`]: fae(n) },
    ];
  },
  xae = (n) => {
    const e = mo(n, {
      fontSize: n.contentFontSize,
      lineHeight: n.contentLineHeight,
    });
    return vR(e, n.componentCls);
  },
  _ae = (n) => {
    const e = mo(n, {
      controlHeight: n.controlHeightSM,
      fontSize: n.contentFontSizeSM,
      lineHeight: n.contentLineHeightSM,
      padding: n.paddingXS,
      buttonPaddingHorizontal: n.paddingInlineSM,
      buttonPaddingVertical: n.paddingBlockSM,
      borderRadius: n.borderRadiusSM,
      buttonIconOnlyFontSize: n.onlyIconSizeSM,
    });
    return vR(e, `${n.componentCls}-sm`);
  },
  Sae = (n) => {
    const e = mo(n, {
      controlHeight: n.controlHeightLG,
      fontSize: n.contentFontSizeLG,
      lineHeight: n.contentLineHeightLG,
      buttonPaddingHorizontal: n.paddingInlineLG,
      buttonPaddingVertical: n.paddingBlockLG,
      borderRadius: n.borderRadiusLG,
      buttonIconOnlyFontSize: n.onlyIconSizeLG,
    });
    return vR(e, `${n.componentCls}-lg`);
  },
  Aae = (n) => {
    const { componentCls: e } = n;
    return { [e]: { [`&${e}-block`]: { width: "100%" } } };
  },
  wae = hp(
    "Button",
    (n) => {
      const e = Z5(n);
      return [uae(e), xae(e), _ae(e), Sae(e), Aae(e), yae(e), cae(e)];
    },
    Q5,
    {
      unitless: {
        fontWeight: !0,
        contentLineHeight: !0,
        contentLineHeightSM: !0,
        contentLineHeightLG: !0,
      },
    }
  );
function bae(n, e, t) {
  const { focusElCls: r, focus: i, borderElCls: s } = t,
    o = s ? "> *" : "",
    a = ["hover", i ? "focus" : null, "active"]
      .filter(Boolean)
      .map((l) => `&:${l} ${o}`)
      .join(",");
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal(),
    },
    "&-item": Object.assign(
      Object.assign(
        { [a]: { zIndex: 2 } },
        r ? { [`&${r}`]: { zIndex: 2 } } : {}
      ),
      { [`&[disabled] ${o}`]: { zIndex: 0 } }
    ),
  };
}
function Eae(n, e, t) {
  const { borderElCls: r } = t,
    i = r ? `> ${r}` : "";
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item) ${i}`]: {
      borderRadius: 0,
    },
    [`&-item:not(${e}-last-item)${e}-first-item`]: {
      [`& ${i}, &${n}-sm ${i}, &${n}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
      },
    },
    [`&-item:not(${e}-first-item)${e}-last-item`]: {
      [`& ${i}, &${n}-sm ${i}, &${n}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
      },
    },
  };
}
function tV(n) {
  let e =
    arguments.length > 1 && arguments[1] !== void 0
      ? arguments[1]
      : { focus: !0 };
  const { componentCls: t } = n,
    r = `${t}-compact`;
  return { [r]: Object.assign(Object.assign({}, bae(n, r, e)), Eae(t, r, e)) };
}
function Mae(n, e) {
  return {
    [`&-item:not(${e}-last-item)`]: {
      marginBottom: n.calc(n.lineWidth).mul(-1).equal(),
    },
    "&-item": {
      "&:hover,&:focus,&:active": { zIndex: 2 },
      "&[disabled]": { zIndex: 0 },
    },
  };
}
function Tae(n, e) {
  return {
    [`&-item:not(${e}-first-item):not(${e}-last-item)`]: { borderRadius: 0 },
    [`&-item${e}-first-item:not(${e}-last-item)`]: {
      [`&, &${n}-sm, &${n}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0,
      },
    },
    [`&-item${e}-last-item:not(${e}-first-item)`]: {
      [`&, &${n}-sm, &${n}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0,
      },
    },
  };
}
function Cae(n) {
  const e = `${n.componentCls}-compact-vertical`;
  return {
    [e]: Object.assign(Object.assign({}, Mae(n, e)), Tae(n.componentCls, e)),
  };
}
const Rae = (n) => {
    const { componentCls: e, calc: t } = n;
    return {
      [e]: {
        [`&-compact-item${e}-primary`]: {
          [`&:not([disabled]) + ${e}-compact-item${e}-primary:not([disabled])`]:
            {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: t(n.lineWidth).mul(-1).equal(),
                insetInlineStart: t(n.lineWidth).mul(-1).equal(),
                display: "inline-block",
                width: n.lineWidth,
                height: `calc(100% + ${jt(n.lineWidth)} * 2)`,
                backgroundColor: n.colorPrimaryHover,
                content: '""',
              },
            },
        },
        "&-compact-vertical-item": {
          [`&${e}-primary`]: {
            [`&:not([disabled]) + ${e}-compact-vertical-item${e}-primary:not([disabled])`]:
              {
                position: "relative",
                "&:before": {
                  position: "absolute",
                  top: t(n.lineWidth).mul(-1).equal(),
                  insetInlineStart: t(n.lineWidth).mul(-1).equal(),
                  display: "inline-block",
                  width: `calc(100% + ${jt(n.lineWidth)} * 2)`,
                  height: n.lineWidth,
                  backgroundColor: n.colorPrimaryHover,
                  content: '""',
                },
              },
          },
        },
      },
    };
  },
  Nae = Kie(
    ["Button", "compact"],
    (n) => {
      const e = Z5(n);
      return [tV(e), Cae(e), Rae(e)];
    },
    Q5
  );
var Pae = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
function Iae(n) {
  if (typeof n == "object" && n) {
    let e = n == null ? void 0 : n.delay;
    return (
      (e = !Number.isNaN(e) && typeof e == "number" ? e : 0),
      { loading: e <= 0, delay: e }
    );
  }
  return { loading: !!n, delay: 0 };
}
const Lae = Je.forwardRef((n, e) => {
    var t, r, i;
    const {
        loading: s = !1,
        prefixCls: o,
        type: a,
        danger: l,
        shape: c = "default",
        size: u,
        styles: d,
        disabled: h,
        className: m,
        rootClassName: g,
        children: x,
        icon: y,
        iconPosition: v = "start",
        ghost: _ = !1,
        block: S = !1,
        htmlType: w = "button",
        classNames: T,
        style: E = {},
        autoInsertSpace: M,
      } = n,
      N = Pae(n, [
        "loading",
        "prefixCls",
        "type",
        "danger",
        "shape",
        "size",
        "styles",
        "disabled",
        "className",
        "rootClassName",
        "children",
        "icon",
        "iconPosition",
        "ghost",
        "block",
        "htmlType",
        "classNames",
        "style",
        "autoInsertSpace",
      ]),
      R = a || "default",
      { getPrefixCls: C, direction: L, button: O } = I.useContext(mr),
      D =
        (t = M ?? (O == null ? void 0 : O.autoInsertSpace)) !== null &&
        t !== void 0
          ? t
          : !0,
      B = C("btn", o),
      [$, G, j] = wae(B),
      U = I.useContext(Ed),
      H = h ?? U,
      V = I.useContext(q5),
      k = I.useMemo(() => Iae(s), [s]),
      [W, ee] = I.useState(k.loading),
      [Y, K] = I.useState(!1),
      se = eu(e, I.createRef()),
      we = I.Children.count(x) === 1 && !y && !mb(R);
    I.useEffect(() => {
      let ke = null;
      k.delay > 0
        ? (ke = setTimeout(() => {
            (ke = null), ee(!0);
          }, k.delay))
        : ee(k.loading);
      function Me() {
        ke && (clearTimeout(ke), (ke = null));
      }
      return Me;
    }, [k]),
      I.useEffect(() => {
        if (!se || !se.current || !D) return;
        const ke = se.current.textContent;
        we && hT(ke) ? Y || K(!0) : Y && K(!1);
      }, [se]);
    const Be = (ke) => {
        const { onClick: Me } = n;
        if (W || H) {
          ke.preventDefault();
          return;
        }
        Me == null || Me(ke);
      },
      { compactSize: te, compactItemClassnames: ge } = mR(B, L),
      ie = { large: "lg", small: "sm", middle: void 0 },
      me = Bd((ke) => {
        var Me, et;
        return (et = (Me = u ?? te) !== null && Me !== void 0 ? Me : V) !==
          null && et !== void 0
          ? et
          : ke;
      }),
      fe = (me && ie[me]) || "",
      Ee = W ? "loading" : y,
      Se = Gg(N, ["navigate"]),
      Ue = Mt(
        B,
        G,
        j,
        {
          [`${B}-${c}`]: c !== "default" && c,
          [`${B}-${R}`]: R,
          [`${B}-${fe}`]: fe,
          [`${B}-icon-only`]: !x && x !== 0 && !!Ee,
          [`${B}-background-ghost`]: _ && !mb(R),
          [`${B}-loading`]: W,
          [`${B}-two-chinese-chars`]: Y && D && !W,
          [`${B}-block`]: S,
          [`${B}-dangerous`]: !!l,
          [`${B}-rtl`]: L === "rtl",
        },
        ge,
        m,
        g,
        O == null ? void 0 : O.className
      ),
      Ce = Object.assign(Object.assign({}, O == null ? void 0 : O.style), E),
      X = v === "end" && x && x !== 0 && Ee,
      z = Mt(
        T == null ? void 0 : T.icon,
        (r = O == null ? void 0 : O.classNames) === null || r === void 0
          ? void 0
          : r.icon,
        { [`${B}-icon-end`]: X }
      ),
      q = Object.assign(
        Object.assign({}, (d == null ? void 0 : d.icon) || {}),
        ((i = O == null ? void 0 : O.styles) === null || i === void 0
          ? void 0
          : i.icon) || {}
      ),
      ue =
        y && !W
          ? Je.createElement(K5, { prefixCls: B, className: z, style: q }, y)
          : Je.createElement(lae, {
              existIcon: !!y,
              prefixCls: B,
              loading: !!W,
              iconPosition: v,
            }),
      de = x || x === 0 ? aae(x, we && D) : null,
      he = (ke, Me) =>
        v === "start"
          ? Je.createElement(Je.Fragment, null, ke, Me)
          : Je.createElement(Je.Fragment, null, Me, ke);
    if (Se.href !== void 0)
      return $(
        Je.createElement(
          "a",
          Object.assign({}, Se, {
            className: Mt(Ue, { [`${B}-disabled`]: H }),
            href: H ? void 0 : Se.href,
            style: Ce,
            onClick: Be,
            ref: se,
            tabIndex: H ? -1 : 0,
          }),
          he(ue, de)
        )
      );
    let Ie = Je.createElement(
      "button",
      Object.assign({}, N, {
        type: w,
        className: Ue,
        style: Ce,
        onClick: Be,
        disabled: H,
        ref: se,
      }),
      he(ue, de),
      !!ge && Je.createElement(Nae, { key: "compact", prefixCls: B })
    );
    return (
      mb(R) ||
        (Ie = Je.createElement(X5, { component: "Button", disabled: !!W }, Ie)),
      $(Ie)
    );
  }),
  jl = Lae;
jl.Group = sae;
jl.__ANT_BUTTON = !0;
var Ju = "RC_FORM_INTERNAL_HOOKS",
  Rn = function () {
    Es(
      !1,
      "Can not find FormContext. Please make sure you wrap Field under Form."
    );
  },
  Yh = I.createContext({
    getFieldValue: Rn,
    getFieldsValue: Rn,
    getFieldError: Rn,
    getFieldWarning: Rn,
    getFieldsError: Rn,
    isFieldsTouched: Rn,
    isFieldTouched: Rn,
    isFieldValidating: Rn,
    isFieldsValidating: Rn,
    resetFields: Rn,
    setFields: Rn,
    setFieldValue: Rn,
    setFieldsValue: Rn,
    validateFields: Rn,
    submit: Rn,
    getInternalHooks: function () {
      return (
        Rn(),
        {
          dispatch: Rn,
          initEntityValue: Rn,
          registerField: Rn,
          useSubscribe: Rn,
          setInitialValues: Rn,
          destroyForm: Rn,
          setCallbacks: Rn,
          registerWatch: Rn,
          getFields: Rn,
          setValidateMessages: Rn,
          setPreserve: Rn,
          getInitialValue: Rn,
        }
      );
    },
  }),
  P1 = I.createContext(null);
function pT(n) {
  return n == null ? [] : Array.isArray(n) ? n : [n];
}
function Oae(n) {
  return n && !!n._init;
}
function mT() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid",
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s",
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters",
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s",
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length",
    },
    pattern: { mismatch: "%s value %s does not match pattern %s" },
    clone: function () {
      var e = JSON.parse(JSON.stringify(this));
      return (e.clone = this.clone), e;
    },
  };
}
var gT = mT();
function Dae(n) {
  try {
    return Function.toString.call(n).indexOf("[native code]") !== -1;
  } catch {
    return typeof n == "function";
  }
}
function Fae(n, e, t) {
  if (iS()) return Reflect.construct.apply(null, arguments);
  var r = [null];
  r.push.apply(r, e);
  var i = new (n.bind.apply(n, r))();
  return t && Hg(i, t.prototype), i;
}
function vT(n) {
  var e = typeof Map == "function" ? new Map() : void 0;
  return (
    (vT = function (r) {
      if (r === null || !Dae(r)) return r;
      if (typeof r != "function")
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (e !== void 0) {
        if (e.has(r)) return e.get(r);
        e.set(r, i);
      }
      function i() {
        return Fae(r, arguments, wd(this).constructor);
      }
      return (
        (i.prototype = Object.create(r.prototype, {
          constructor: {
            value: i,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        Hg(i, r)
      );
    }),
    vT(n)
  );
}
var Uae = /%[sdj%]/g,
  kae = function () {};
function yT(n) {
  if (!n || !n.length) return null;
  var e = {};
  return (
    n.forEach(function (t) {
      var r = t.field;
      (e[r] = e[r] || []), e[r].push(t);
    }),
    e
  );
}
function eo(n) {
  for (
    var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1;
    r < e;
    r++
  )
    t[r - 1] = arguments[r];
  var i = 0,
    s = t.length;
  if (typeof n == "function") return n.apply(null, t);
  if (typeof n == "string") {
    var o = n.replace(Uae, function (a) {
      if (a === "%%") return "%";
      if (i >= s) return a;
      switch (a) {
        case "%s":
          return String(t[i++]);
        case "%d":
          return Number(t[i++]);
        case "%j":
          try {
            return JSON.stringify(t[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return o;
  }
  return n;
}
function zae(n) {
  return (
    n === "string" ||
    n === "url" ||
    n === "hex" ||
    n === "email" ||
    n === "date" ||
    n === "pattern"
  );
}
function qr(n, e) {
  return !!(
    n == null ||
    (e === "array" && Array.isArray(n) && !n.length) ||
    (zae(e) && typeof n == "string" && !n)
  );
}
function Bae(n, e, t) {
  var r = [],
    i = 0,
    s = n.length;
  function o(a) {
    r.push.apply(r, Ot(a || [])), i++, i === s && t(r);
  }
  n.forEach(function (a) {
    e(a, o);
  });
}
function YO(n, e, t) {
  var r = 0,
    i = n.length;
  function s(o) {
    if (o && o.length) {
      t(o);
      return;
    }
    var a = r;
    (r = r + 1), a < i ? e(n[a], s) : t([]);
  }
  s([]);
}
function Vae(n) {
  var e = [];
  return (
    Object.keys(n).forEach(function (t) {
      e.push.apply(e, Ot(n[t] || []));
    }),
    e
  );
}
var qO = (function (n) {
  Ud(t, n);
  var e = E0(t);
  function t(r, i) {
    var s;
    return (
      ss(this, t),
      (s = e.call(this, "Async Validation Error")),
      Te(fn(s), "errors", void 0),
      Te(fn(s), "fields", void 0),
      (s.errors = r),
      (s.fields = i),
      s
    );
  }
  return os(t);
})(vT(Error));
function Hae(n, e, t, r, i) {
  if (e.first) {
    var s = new Promise(function (h, m) {
      var g = function (v) {
          return r(v), v.length ? m(new qO(v, yT(v))) : h(i);
        },
        x = Vae(n);
      YO(x, t, g);
    });
    return (
      s.catch(function (h) {
        return h;
      }),
      s
    );
  }
  var o = e.firstFields === !0 ? Object.keys(n) : e.firstFields || [],
    a = Object.keys(n),
    l = a.length,
    c = 0,
    u = [],
    d = new Promise(function (h, m) {
      var g = function (y) {
        if ((u.push.apply(u, y), c++, c === l))
          return r(u), u.length ? m(new qO(u, yT(u))) : h(i);
      };
      a.length || (r(u), h(i)),
        a.forEach(function (x) {
          var y = n[x];
          o.indexOf(x) !== -1 ? YO(y, t, g) : Bae(y, t, g);
        });
    });
  return (
    d.catch(function (h) {
      return h;
    }),
    d
  );
}
function Gae(n) {
  return !!(n && n.message !== void 0);
}
function Wae(n, e) {
  for (var t = n, r = 0; r < e.length; r++) {
    if (t == null) return t;
    t = t[e[r]];
  }
  return t;
}
function KO(n, e) {
  return function (t) {
    var r;
    return (
      n.fullFields
        ? (r = Wae(e, n.fullFields))
        : (r = e[t.field || n.fullField]),
      Gae(t)
        ? ((t.field = t.field || n.fullField), (t.fieldValue = r), t)
        : {
            message: typeof t == "function" ? t() : t,
            fieldValue: r,
            field: t.field || n.fullField,
          }
    );
  };
}
function ZO(n, e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t)) {
        var r = e[t];
        $t(r) === "object" && $t(n[t]) === "object"
          ? (n[t] = Ze(Ze({}, n[t]), r))
          : (n[t] = r);
      }
  }
  return n;
}
var Df = "enum",
  jae = function (e, t, r, i, s) {
    (e[Df] = Array.isArray(e[Df]) ? e[Df] : []),
      e[Df].indexOf(t) === -1 &&
        i.push(eo(s.messages[Df], e.fullField, e[Df].join(", ")));
  },
  $ae = function (e, t, r, i, s) {
    if (e.pattern) {
      if (e.pattern instanceof RegExp)
        (e.pattern.lastIndex = 0),
          e.pattern.test(t) ||
            i.push(eo(s.messages.pattern.mismatch, e.fullField, t, e.pattern));
      else if (typeof e.pattern == "string") {
        var o = new RegExp(e.pattern);
        o.test(t) ||
          i.push(eo(s.messages.pattern.mismatch, e.fullField, t, e.pattern));
      }
    }
  },
  Xae = function (e, t, r, i, s) {
    var o = typeof e.len == "number",
      a = typeof e.min == "number",
      l = typeof e.max == "number",
      c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
      u = t,
      d = null,
      h = typeof t == "number",
      m = typeof t == "string",
      g = Array.isArray(t);
    if ((h ? (d = "number") : m ? (d = "string") : g && (d = "array"), !d))
      return !1;
    g && (u = t.length),
      m && (u = t.replace(c, "_").length),
      o
        ? u !== e.len && i.push(eo(s.messages[d].len, e.fullField, e.len))
        : a && !l && u < e.min
        ? i.push(eo(s.messages[d].min, e.fullField, e.min))
        : l && !a && u > e.max
        ? i.push(eo(s.messages[d].max, e.fullField, e.max))
        : a &&
          l &&
          (u < e.min || u > e.max) &&
          i.push(eo(s.messages[d].range, e.fullField, e.min, e.max));
  },
  nV = function (e, t, r, i, s, o) {
    e.required &&
      (!r.hasOwnProperty(e.field) || qr(t, o || e.type)) &&
      i.push(eo(s.messages.required, e.fullField));
  },
  Qy;
const Yae = function () {
  if (Qy) return Qy;
  var n = "[a-fA-F\\d:]",
    e = function (E) {
      return E && E.includeBoundaries
        ? "(?:(?<=\\s|^)(?=".concat(n, ")|(?<=").concat(n, ")(?=\\s|$))")
        : "";
    },
    t =
      "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",
    r = "[a-fA-F\\d]{1,4}",
    i = [
      "(?:".concat(r, ":){7}(?:").concat(r, "|:)"),
      "(?:".concat(r, ":){6}(?:").concat(t, "|:").concat(r, "|:)"),
      "(?:".concat(r, ":){5}(?::").concat(t, "|(?::").concat(r, "){1,2}|:)"),
      "(?:"
        .concat(r, ":){4}(?:(?::")
        .concat(r, "){0,1}:")
        .concat(t, "|(?::")
        .concat(r, "){1,3}|:)"),
      "(?:"
        .concat(r, ":){3}(?:(?::")
        .concat(r, "){0,2}:")
        .concat(t, "|(?::")
        .concat(r, "){1,4}|:)"),
      "(?:"
        .concat(r, ":){2}(?:(?::")
        .concat(r, "){0,3}:")
        .concat(t, "|(?::")
        .concat(r, "){1,5}|:)"),
      "(?:"
        .concat(r, ":){1}(?:(?::")
        .concat(r, "){0,4}:")
        .concat(t, "|(?::")
        .concat(r, "){1,6}|:)"),
      "(?::(?:(?::"
        .concat(r, "){0,5}:")
        .concat(t, "|(?::")
        .concat(r, "){1,7}|:))"),
    ],
    s = "(?:%[0-9a-zA-Z]{1,})?",
    o = "(?:".concat(i.join("|"), ")").concat(s),
    a = new RegExp("(?:^".concat(t, "$)|(?:^").concat(o, "$)")),
    l = new RegExp("^".concat(t, "$")),
    c = new RegExp("^".concat(o, "$")),
    u = function (E) {
      return E && E.exact
        ? a
        : new RegExp(
            "(?:"
              .concat(e(E))
              .concat(t)
              .concat(e(E), ")|(?:")
              .concat(e(E))
              .concat(o)
              .concat(e(E), ")"),
            "g"
          );
    };
  (u.v4 = function (T) {
    return T && T.exact
      ? l
      : new RegExp("".concat(e(T)).concat(t).concat(e(T)), "g");
  }),
    (u.v6 = function (T) {
      return T && T.exact
        ? c
        : new RegExp("".concat(e(T)).concat(o).concat(e(T)), "g");
    });
  var d = "(?:(?:[a-z]+:)?//)",
    h = "(?:\\S+(?::\\S*)?@)?",
    m = u.v4().source,
    g = u.v6().source,
    x = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)",
    y = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*",
    v = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))",
    _ = "(?::\\d{2,5})?",
    S = '(?:[/?#][^\\s"]*)?',
    w = "(?:"
      .concat(d, "|www\\.)")
      .concat(h, "(?:localhost|")
      .concat(m, "|")
      .concat(g, "|")
      .concat(x)
      .concat(y)
      .concat(v, ")")
      .concat(_)
      .concat(S);
  return (Qy = new RegExp("(?:^".concat(w, "$)"), "i")), Qy;
};
var QO = {
    email:
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
  },
  Lm = {
    integer: function (e) {
      return Lm.number(e) && parseInt(e, 10) === e;
    },
    float: function (e) {
      return Lm.number(e) && !Lm.integer(e);
    },
    array: function (e) {
      return Array.isArray(e);
    },
    regexp: function (e) {
      if (e instanceof RegExp) return !0;
      try {
        return !!new RegExp(e);
      } catch {
        return !1;
      }
    },
    date: function (e) {
      return (
        typeof e.getTime == "function" &&
        typeof e.getMonth == "function" &&
        typeof e.getYear == "function" &&
        !isNaN(e.getTime())
      );
    },
    number: function (e) {
      return isNaN(e) ? !1 : typeof e == "number";
    },
    object: function (e) {
      return $t(e) === "object" && !Lm.array(e);
    },
    method: function (e) {
      return typeof e == "function";
    },
    email: function (e) {
      return typeof e == "string" && e.length <= 320 && !!e.match(QO.email);
    },
    url: function (e) {
      return typeof e == "string" && e.length <= 2048 && !!e.match(Yae());
    },
    hex: function (e) {
      return typeof e == "string" && !!e.match(QO.hex);
    },
  },
  qae = function (e, t, r, i, s) {
    if (e.required && t === void 0) {
      nV(e, t, r, i, s);
      return;
    }
    var o = [
        "integer",
        "float",
        "array",
        "regexp",
        "object",
        "method",
        "email",
        "number",
        "date",
        "url",
        "hex",
      ],
      a = e.type;
    o.indexOf(a) > -1
      ? Lm[a](t) || i.push(eo(s.messages.types[a], e.fullField, e.type))
      : a &&
        $t(t) !== e.type &&
        i.push(eo(s.messages.types[a], e.fullField, e.type));
  },
  Kae = function (e, t, r, i, s) {
    (/^\s+$/.test(t) || t === "") &&
      i.push(eo(s.messages.whitespace, e.fullField));
  };
const un = {
  required: nV,
  whitespace: Kae,
  type: qae,
  range: Xae,
  enum: jae,
  pattern: $ae,
};
var Zae = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s);
    }
    r(o);
  },
  Qae = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (t == null && !e.required) return r();
      un.required(e, t, i, o, s, "array"),
        t != null && (un.type(e, t, i, o, s), un.range(e, t, i, o, s));
    }
    r(o);
  },
  Jae = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s), t !== void 0 && un.type(e, t, i, o, s);
    }
    r(o);
  },
  ele = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t, "date") && !e.required) return r();
      if ((un.required(e, t, i, o, s), !qr(t, "date"))) {
        var l;
        t instanceof Date ? (l = t) : (l = new Date(t)),
          un.type(e, l, i, o, s),
          l && un.range(e, l.getTime(), i, o, s);
      }
    }
    r(o);
  },
  tle = "enum",
  nle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s), t !== void 0 && un[tle](e, t, i, o, s);
    }
    r(o);
  },
  rle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s),
        t !== void 0 && (un.type(e, t, i, o, s), un.range(e, t, i, o, s));
    }
    r(o);
  },
  ile = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s),
        t !== void 0 && (un.type(e, t, i, o, s), un.range(e, t, i, o, s));
    }
    r(o);
  },
  sle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s), t !== void 0 && un.type(e, t, i, o, s);
    }
    r(o);
  },
  ole = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if ((t === "" && (t = void 0), qr(t) && !e.required)) return r();
      un.required(e, t, i, o, s),
        t !== void 0 && (un.type(e, t, i, o, s), un.range(e, t, i, o, s));
    }
    r(o);
  },
  ale = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s), t !== void 0 && un.type(e, t, i, o, s);
    }
    r(o);
  },
  lle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t, "string") && !e.required) return r();
      un.required(e, t, i, o, s), qr(t, "string") || un.pattern(e, t, i, o, s);
    }
    r(o);
  },
  cle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t) && !e.required) return r();
      un.required(e, t, i, o, s), qr(t) || un.type(e, t, i, o, s);
    }
    r(o);
  },
  ule = function (e, t, r, i, s) {
    var o = [],
      a = Array.isArray(t) ? "array" : $t(t);
    un.required(e, t, i, o, s, a), r(o);
  },
  dle = function (e, t, r, i, s) {
    var o = [],
      a = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (a) {
      if (qr(t, "string") && !e.required) return r();
      un.required(e, t, i, o, s, "string"),
        qr(t, "string") ||
          (un.type(e, t, i, o, s),
          un.range(e, t, i, o, s),
          un.pattern(e, t, i, o, s),
          e.whitespace === !0 && un.whitespace(e, t, i, o, s));
    }
    r(o);
  },
  yb = function (e, t, r, i, s) {
    var o = e.type,
      a = [],
      l = e.required || (!e.required && i.hasOwnProperty(e.field));
    if (l) {
      if (qr(t, o) && !e.required) return r();
      un.required(e, t, i, a, s, o), qr(t, o) || un.type(e, t, i, a, s);
    }
    r(a);
  };
const Jm = {
  string: dle,
  method: sle,
  number: ole,
  boolean: Jae,
  regexp: cle,
  integer: ile,
  float: rle,
  array: Qae,
  object: ale,
  enum: nle,
  pattern: lle,
  date: ele,
  url: yb,
  hex: yb,
  email: yb,
  required: ule,
  any: Zae,
};
var T0 = (function () {
  function n(e) {
    ss(this, n),
      Te(this, "rules", null),
      Te(this, "_messages", gT),
      this.define(e);
  }
  return (
    os(n, [
      {
        key: "define",
        value: function (t) {
          var r = this;
          if (!t) throw new Error("Cannot configure a schema with no rules");
          if ($t(t) !== "object" || Array.isArray(t))
            throw new Error("Rules must be an object");
          (this.rules = {}),
            Object.keys(t).forEach(function (i) {
              var s = t[i];
              r.rules[i] = Array.isArray(s) ? s : [s];
            });
        },
      },
      {
        key: "messages",
        value: function (t) {
          return t && (this._messages = ZO(mT(), t)), this._messages;
        },
      },
      {
        key: "validate",
        value: function (t) {
          var r = this,
            i =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : {},
            s =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : function () {},
            o = t,
            a = i,
            l = s;
          if (
            (typeof a == "function" && ((l = a), (a = {})),
            !this.rules || Object.keys(this.rules).length === 0)
          )
            return l && l(null, o), Promise.resolve(o);
          function c(g) {
            var x = [],
              y = {};
            function v(S) {
              if (Array.isArray(S)) {
                var w;
                x = (w = x).concat.apply(w, Ot(S));
              } else x.push(S);
            }
            for (var _ = 0; _ < g.length; _++) v(g[_]);
            x.length ? ((y = yT(x)), l(x, y)) : l(null, o);
          }
          if (a.messages) {
            var u = this.messages();
            u === gT && (u = mT()), ZO(u, a.messages), (a.messages = u);
          } else a.messages = this.messages();
          var d = {},
            h = a.keys || Object.keys(this.rules);
          h.forEach(function (g) {
            var x = r.rules[g],
              y = o[g];
            x.forEach(function (v) {
              var _ = v;
              typeof _.transform == "function" &&
                (o === t && (o = Ze({}, o)),
                (y = o[g] = _.transform(y)),
                y != null &&
                  (_.type = _.type || (Array.isArray(y) ? "array" : $t(y)))),
                typeof _ == "function"
                  ? (_ = { validator: _ })
                  : (_ = Ze({}, _)),
                (_.validator = r.getValidationMethod(_)),
                _.validator &&
                  ((_.field = g),
                  (_.fullField = _.fullField || g),
                  (_.type = r.getType(_)),
                  (d[g] = d[g] || []),
                  d[g].push({ rule: _, value: y, source: o, field: g }));
            });
          });
          var m = {};
          return Hae(
            d,
            a,
            function (g, x) {
              var y = g.rule,
                v =
                  (y.type === "object" || y.type === "array") &&
                  ($t(y.fields) === "object" ||
                    $t(y.defaultField) === "object");
              (v = v && (y.required || (!y.required && g.value))),
                (y.field = g.field);
              function _(M, N) {
                return Ze(
                  Ze({}, N),
                  {},
                  {
                    fullField: "".concat(y.fullField, ".").concat(M),
                    fullFields: y.fullFields
                      ? [].concat(Ot(y.fullFields), [M])
                      : [M],
                  }
                );
              }
              function S() {
                var M =
                    arguments.length > 0 && arguments[0] !== void 0
                      ? arguments[0]
                      : [],
                  N = Array.isArray(M) ? M : [M];
                !a.suppressWarning &&
                  N.length &&
                  n.warning("async-validator:", N),
                  N.length &&
                    y.message !== void 0 &&
                    (N = [].concat(y.message));
                var R = N.map(KO(y, o));
                if (a.first && R.length) return (m[y.field] = 1), x(R);
                if (!v) x(R);
                else {
                  if (y.required && !g.value)
                    return (
                      y.message !== void 0
                        ? (R = [].concat(y.message).map(KO(y, o)))
                        : a.error &&
                          (R = [a.error(y, eo(a.messages.required, y.field))]),
                      x(R)
                    );
                  var C = {};
                  y.defaultField &&
                    Object.keys(g.value).map(function (D) {
                      C[D] = y.defaultField;
                    }),
                    (C = Ze(Ze({}, C), g.rule.fields));
                  var L = {};
                  Object.keys(C).forEach(function (D) {
                    var B = C[D],
                      $ = Array.isArray(B) ? B : [B];
                    L[D] = $.map(_.bind(null, D));
                  });
                  var O = new n(L);
                  O.messages(a.messages),
                    g.rule.options &&
                      ((g.rule.options.messages = a.messages),
                      (g.rule.options.error = a.error)),
                    O.validate(g.value, g.rule.options || a, function (D) {
                      var B = [];
                      R && R.length && B.push.apply(B, Ot(R)),
                        D && D.length && B.push.apply(B, Ot(D)),
                        x(B.length ? B : null);
                    });
                }
              }
              var w;
              if (y.asyncValidator)
                w = y.asyncValidator(y, g.value, S, g.source, a);
              else if (y.validator) {
                try {
                  w = y.validator(y, g.value, S, g.source, a);
                } catch (M) {
                  var T, E;
                  (T = (E = console).error) === null ||
                    T === void 0 ||
                    T.call(E, M),
                    a.suppressValidatorError ||
                      setTimeout(function () {
                        throw M;
                      }, 0),
                    S(M.message);
                }
                w === !0
                  ? S()
                  : w === !1
                  ? S(
                      typeof y.message == "function"
                        ? y.message(y.fullField || y.field)
                        : y.message ||
                            "".concat(y.fullField || y.field, " fails")
                    )
                  : w instanceof Array
                  ? S(w)
                  : w instanceof Error && S(w.message);
              }
              w &&
                w.then &&
                w.then(
                  function () {
                    return S();
                  },
                  function (M) {
                    return S(M);
                  }
                );
            },
            function (g) {
              c(g);
            },
            o
          );
        },
      },
      {
        key: "getType",
        value: function (t) {
          if (
            (t.type === void 0 &&
              t.pattern instanceof RegExp &&
              (t.type = "pattern"),
            typeof t.validator != "function" &&
              t.type &&
              !Jm.hasOwnProperty(t.type))
          )
            throw new Error(eo("Unknown rule type %s", t.type));
          return t.type || "string";
        },
      },
      {
        key: "getValidationMethod",
        value: function (t) {
          if (typeof t.validator == "function") return t.validator;
          var r = Object.keys(t),
            i = r.indexOf("message");
          return (
            i !== -1 && r.splice(i, 1),
            r.length === 1 && r[0] === "required"
              ? Jm.required
              : Jm[this.getType(t)] || void 0
          );
        },
      },
    ]),
    n
  );
})();
Te(T0, "register", function (e, t) {
  if (typeof t != "function")
    throw new Error(
      "Cannot register a validator by type, validator is not a function"
    );
  Jm[e] = t;
});
Te(T0, "warning", kae);
Te(T0, "messages", gT);
Te(T0, "validators", Jm);
var Gs = "'${name}' is not a valid ${type}",
  rV = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date",
    },
    types: {
      string: Gs,
      method: Gs,
      array: Gs,
      object: Gs,
      number: Gs,
      date: Gs,
      boolean: Gs,
      integer: Gs,
      float: Gs,
      regexp: Gs,
      email: Gs,
      url: Gs,
      hex: Gs,
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters",
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}",
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length",
    },
    pattern: { mismatch: "'${name}' does not match pattern ${pattern}" },
  },
  JO = T0;
function fle(n, e) {
  return n.replace(/\$\{\w+\}/g, function (t) {
    var r = t.slice(2, -1);
    return e[r];
  });
}
var eD = "CODE_LOGIC_ERROR";
function xT(n, e, t, r, i) {
  return _T.apply(this, arguments);
}
function _T() {
  return (
    (_T = zd(
      ts().mark(function n(e, t, r, i, s) {
        var o, a, l, c, u, d, h, m, g;
        return ts().wrap(
          function (y) {
            for (;;)
              switch ((y.prev = y.next)) {
                case 0:
                  return (
                    (o = Ze({}, r)),
                    delete o.ruleIndex,
                    (JO.warning = function () {}),
                    o.validator &&
                      ((a = o.validator),
                      (o.validator = function () {
                        try {
                          return a.apply(void 0, arguments);
                        } catch (v) {
                          return console.error(v), Promise.reject(eD);
                        }
                      })),
                    (l = null),
                    o &&
                      o.type === "array" &&
                      o.defaultField &&
                      ((l = o.defaultField), delete o.defaultField),
                    (c = new JO(Te({}, e, [o]))),
                    (u = sh(rV, i.validateMessages)),
                    c.messages(u),
                    (d = []),
                    (y.prev = 10),
                    (y.next = 13),
                    Promise.resolve(c.validate(Te({}, e, t), Ze({}, i)))
                  );
                case 13:
                  y.next = 18;
                  break;
                case 15:
                  (y.prev = 15),
                    (y.t0 = y.catch(10)),
                    y.t0.errors &&
                      (d = y.t0.errors.map(function (v, _) {
                        var S = v.message,
                          w = S === eD ? u.default : S;
                        return I.isValidElement(w)
                          ? I.cloneElement(w, { key: "error_".concat(_) })
                          : w;
                      }));
                case 18:
                  if (!(!d.length && l)) {
                    y.next = 23;
                    break;
                  }
                  return (
                    (y.next = 21),
                    Promise.all(
                      t.map(function (v, _) {
                        return xT("".concat(e, ".").concat(_), v, l, i, s);
                      })
                    )
                  );
                case 21:
                  return (
                    (h = y.sent),
                    y.abrupt(
                      "return",
                      h.reduce(function (v, _) {
                        return [].concat(Ot(v), Ot(_));
                      }, [])
                    )
                  );
                case 23:
                  return (
                    (m = Ze(
                      Ze({}, r),
                      {},
                      { name: e, enum: (r.enum || []).join(", ") },
                      s
                    )),
                    (g = d.map(function (v) {
                      return typeof v == "string" ? fle(v, m) : v;
                    })),
                    y.abrupt("return", g)
                  );
                case 26:
                case "end":
                  return y.stop();
              }
          },
          n,
          null,
          [[10, 15]]
        );
      })
    )),
    _T.apply(this, arguments)
  );
}
function hle(n, e, t, r, i, s) {
  var o = n.join("."),
    a = t
      .map(function (u, d) {
        var h = u.validator,
          m = Ze(Ze({}, u), {}, { ruleIndex: d });
        return (
          h &&
            (m.validator = function (g, x, y) {
              var v = !1,
                _ = function () {
                  for (
                    var T = arguments.length, E = new Array(T), M = 0;
                    M < T;
                    M++
                  )
                    E[M] = arguments[M];
                  Promise.resolve().then(function () {
                    Es(
                      !v,
                      "Your validator function has already return a promise. `callback` will be ignored."
                    ),
                      v || y.apply(void 0, E);
                  });
                },
                S = h(g, x, _);
              (v =
                S &&
                typeof S.then == "function" &&
                typeof S.catch == "function"),
                Es(
                  v,
                  "`callback` is deprecated. Please return a promise instead."
                ),
                v &&
                  S.then(function () {
                    y();
                  }).catch(function (w) {
                    y(w || " ");
                  });
            }),
          m
        );
      })
      .sort(function (u, d) {
        var h = u.warningOnly,
          m = u.ruleIndex,
          g = d.warningOnly,
          x = d.ruleIndex;
        return !!h == !!g ? m - x : h ? 1 : -1;
      }),
    l;
  if (i === !0)
    l = new Promise(
      (function () {
        var u = zd(
          ts().mark(function d(h, m) {
            var g, x, y;
            return ts().wrap(function (_) {
              for (;;)
                switch ((_.prev = _.next)) {
                  case 0:
                    g = 0;
                  case 1:
                    if (!(g < a.length)) {
                      _.next = 12;
                      break;
                    }
                    return (x = a[g]), (_.next = 5), xT(o, e, x, r, s);
                  case 5:
                    if (((y = _.sent), !y.length)) {
                      _.next = 9;
                      break;
                    }
                    return m([{ errors: y, rule: x }]), _.abrupt("return");
                  case 9:
                    (g += 1), (_.next = 1);
                    break;
                  case 12:
                    h([]);
                  case 13:
                  case "end":
                    return _.stop();
                }
            }, d);
          })
        );
        return function (d, h) {
          return u.apply(this, arguments);
        };
      })()
    );
  else {
    var c = a.map(function (u) {
      return xT(o, e, u, r, s).then(function (d) {
        return { errors: d, rule: u };
      });
    });
    l = (i ? mle(c) : ple(c)).then(function (u) {
      return Promise.reject(u);
    });
  }
  return (
    l.catch(function (u) {
      return u;
    }),
    l
  );
}
function ple(n) {
  return ST.apply(this, arguments);
}
function ST() {
  return (
    (ST = zd(
      ts().mark(function n(e) {
        return ts().wrap(function (r) {
          for (;;)
            switch ((r.prev = r.next)) {
              case 0:
                return r.abrupt(
                  "return",
                  Promise.all(e).then(function (i) {
                    var s,
                      o = (s = []).concat.apply(s, Ot(i));
                    return o;
                  })
                );
              case 1:
              case "end":
                return r.stop();
            }
        }, n);
      })
    )),
    ST.apply(this, arguments)
  );
}
function mle(n) {
  return AT.apply(this, arguments);
}
function AT() {
  return (
    (AT = zd(
      ts().mark(function n(e) {
        var t;
        return ts().wrap(function (i) {
          for (;;)
            switch ((i.prev = i.next)) {
              case 0:
                return (
                  (t = 0),
                  i.abrupt(
                    "return",
                    new Promise(function (s) {
                      e.forEach(function (o) {
                        o.then(function (a) {
                          a.errors.length && s([a]),
                            (t += 1),
                            t === e.length && s([]);
                        });
                      });
                    })
                  )
                );
              case 2:
              case "end":
                return i.stop();
            }
        }, n);
      })
    )),
    AT.apply(this, arguments)
  );
}
function br(n) {
  return pT(n);
}
function tD(n, e) {
  var t = {};
  return (
    e.forEach(function (r) {
      var i = Ba(n, r);
      t = ra(t, r, i);
    }),
    t
  );
}
function _h(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return (
    n &&
    n.some(function (r) {
      return iV(e, r, t);
    })
  );
}
function iV(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !n || !e || (!t && n.length !== e.length)
    ? !1
    : e.every(function (r, i) {
        return n[i] === r;
      });
}
function gle(n, e) {
  if (n === e) return !0;
  if (
    (!n && e) ||
    (n && !e) ||
    !n ||
    !e ||
    $t(n) !== "object" ||
    $t(e) !== "object"
  )
    return !1;
  var t = Object.keys(n),
    r = Object.keys(e),
    i = new Set([].concat(t, r));
  return Ot(i).every(function (s) {
    var o = n[s],
      a = e[s];
    return typeof o == "function" && typeof a == "function" ? !0 : o === a;
  });
}
function vle(n) {
  var e = arguments.length <= 1 ? void 0 : arguments[1];
  return e && e.target && $t(e.target) === "object" && n in e.target
    ? e.target[n]
    : e;
}
function nD(n, e, t) {
  var r = n.length;
  if (e < 0 || e >= r || t < 0 || t >= r) return n;
  var i = n[e],
    s = e - t;
  return s > 0
    ? [].concat(
        Ot(n.slice(0, t)),
        [i],
        Ot(n.slice(t, e)),
        Ot(n.slice(e + 1, r))
      )
    : s < 0
    ? [].concat(
        Ot(n.slice(0, e)),
        Ot(n.slice(e + 1, t + 1)),
        [i],
        Ot(n.slice(t + 1, r))
      )
    : n;
}
var yle = ["name"],
  Mo = [];
function rD(n, e, t, r, i, s) {
  return typeof n == "function"
    ? n(e, t, "source" in s ? { source: s.source } : {})
    : r !== i;
}
var yR = (function (n) {
  Ud(t, n);
  var e = E0(t);
  function t(r) {
    var i;
    if (
      (ss(this, t),
      (i = e.call(this, r)),
      Te(fn(i), "state", { resetCount: 0 }),
      Te(fn(i), "cancelRegisterFunc", null),
      Te(fn(i), "mounted", !1),
      Te(fn(i), "touched", !1),
      Te(fn(i), "dirty", !1),
      Te(fn(i), "validatePromise", void 0),
      Te(fn(i), "prevValidating", void 0),
      Te(fn(i), "errors", Mo),
      Te(fn(i), "warnings", Mo),
      Te(fn(i), "cancelRegister", function () {
        var l = i.props,
          c = l.preserve,
          u = l.isListField,
          d = l.name;
        i.cancelRegisterFunc && i.cancelRegisterFunc(u, c, br(d)),
          (i.cancelRegisterFunc = null);
      }),
      Te(fn(i), "getNamePath", function () {
        var l = i.props,
          c = l.name,
          u = l.fieldContext,
          d = u.prefixName,
          h = d === void 0 ? [] : d;
        return c !== void 0 ? [].concat(Ot(h), Ot(c)) : [];
      }),
      Te(fn(i), "getRules", function () {
        var l = i.props,
          c = l.rules,
          u = c === void 0 ? [] : c,
          d = l.fieldContext;
        return u.map(function (h) {
          return typeof h == "function" ? h(d) : h;
        });
      }),
      Te(fn(i), "refresh", function () {
        i.mounted &&
          i.setState(function (l) {
            var c = l.resetCount;
            return { resetCount: c + 1 };
          });
      }),
      Te(fn(i), "metaCache", null),
      Te(fn(i), "triggerMetaEvent", function (l) {
        var c = i.props.onMetaChange;
        if (c) {
          var u = Ze(Ze({}, i.getMeta()), {}, { destroy: l });
          XM(i.metaCache, u) || c(u), (i.metaCache = u);
        } else i.metaCache = null;
      }),
      Te(fn(i), "onStoreChange", function (l, c, u) {
        var d = i.props,
          h = d.shouldUpdate,
          m = d.dependencies,
          g = m === void 0 ? [] : m,
          x = d.onReset,
          y = u.store,
          v = i.getNamePath(),
          _ = i.getValue(l),
          S = i.getValue(y),
          w = c && _h(c, v);
        switch (
          (u.type === "valueUpdate" &&
            u.source === "external" &&
            !XM(_, S) &&
            ((i.touched = !0),
            (i.dirty = !0),
            (i.validatePromise = null),
            (i.errors = Mo),
            (i.warnings = Mo),
            i.triggerMetaEvent()),
          u.type)
        ) {
          case "reset":
            if (!c || w) {
              (i.touched = !1),
                (i.dirty = !1),
                (i.validatePromise = void 0),
                (i.errors = Mo),
                (i.warnings = Mo),
                i.triggerMetaEvent(),
                x == null || x(),
                i.refresh();
              return;
            }
            break;
          case "remove": {
            if (h) {
              i.reRender();
              return;
            }
            break;
          }
          case "setField": {
            var T = u.data;
            if (w) {
              "touched" in T && (i.touched = T.touched),
                "validating" in T &&
                  !("originRCField" in T) &&
                  (i.validatePromise = T.validating
                    ? Promise.resolve([])
                    : null),
                "errors" in T && (i.errors = T.errors || Mo),
                "warnings" in T && (i.warnings = T.warnings || Mo),
                (i.dirty = !0),
                i.triggerMetaEvent(),
                i.reRender();
              return;
            } else if ("value" in T && _h(c, v, !0)) {
              i.reRender();
              return;
            }
            if (h && !v.length && rD(h, l, y, _, S, u)) {
              i.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var E = g.map(br);
            if (
              E.some(function (M) {
                return _h(u.relatedFields, M);
              })
            ) {
              i.reRender();
              return;
            }
            break;
          }
          default:
            if (w || ((!g.length || v.length || h) && rD(h, l, y, _, S, u))) {
              i.reRender();
              return;
            }
            break;
        }
        h === !0 && i.reRender();
      }),
      Te(fn(i), "validateRules", function (l) {
        var c = i.getNamePath(),
          u = i.getValue(),
          d = l || {},
          h = d.triggerName,
          m = d.validateOnly,
          g = m === void 0 ? !1 : m,
          x = Promise.resolve().then(
            zd(
              ts().mark(function y() {
                var v, _, S, w, T, E, M;
                return ts().wrap(function (R) {
                  for (;;)
                    switch ((R.prev = R.next)) {
                      case 0:
                        if (i.mounted) {
                          R.next = 2;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 2:
                        if (
                          ((v = i.props),
                          (_ = v.validateFirst),
                          (S = _ === void 0 ? !1 : _),
                          (w = v.messageVariables),
                          (T = v.validateDebounce),
                          (E = i.getRules()),
                          h &&
                            (E = E.filter(function (C) {
                              return C;
                            }).filter(function (C) {
                              var L = C.validateTrigger;
                              if (!L) return !0;
                              var O = pT(L);
                              return O.includes(h);
                            })),
                          !(T && h))
                        ) {
                          R.next = 10;
                          break;
                        }
                        return (
                          (R.next = 8),
                          new Promise(function (C) {
                            setTimeout(C, T);
                          })
                        );
                      case 8:
                        if (i.validatePromise === x) {
                          R.next = 10;
                          break;
                        }
                        return R.abrupt("return", []);
                      case 10:
                        return (
                          (M = hle(c, u, E, l, S, w)),
                          M.catch(function (C) {
                            return C;
                          }).then(function () {
                            var C =
                              arguments.length > 0 && arguments[0] !== void 0
                                ? arguments[0]
                                : Mo;
                            if (i.validatePromise === x) {
                              var L;
                              i.validatePromise = null;
                              var O = [],
                                D = [];
                              (L = C.forEach) === null ||
                                L === void 0 ||
                                L.call(C, function (B) {
                                  var $ = B.rule.warningOnly,
                                    G = B.errors,
                                    j = G === void 0 ? Mo : G;
                                  $
                                    ? D.push.apply(D, Ot(j))
                                    : O.push.apply(O, Ot(j));
                                }),
                                (i.errors = O),
                                (i.warnings = D),
                                i.triggerMetaEvent(),
                                i.reRender();
                            }
                          }),
                          R.abrupt("return", M)
                        );
                      case 13:
                      case "end":
                        return R.stop();
                    }
                }, y);
              })
            )
          );
        return (
          g ||
            ((i.validatePromise = x),
            (i.dirty = !0),
            (i.errors = Mo),
            (i.warnings = Mo),
            i.triggerMetaEvent(),
            i.reRender()),
          x
        );
      }),
      Te(fn(i), "isFieldValidating", function () {
        return !!i.validatePromise;
      }),
      Te(fn(i), "isFieldTouched", function () {
        return i.touched;
      }),
      Te(fn(i), "isFieldDirty", function () {
        if (i.dirty || i.props.initialValue !== void 0) return !0;
        var l = i.props.fieldContext,
          c = l.getInternalHooks(Ju),
          u = c.getInitialValue;
        return u(i.getNamePath()) !== void 0;
      }),
      Te(fn(i), "getErrors", function () {
        return i.errors;
      }),
      Te(fn(i), "getWarnings", function () {
        return i.warnings;
      }),
      Te(fn(i), "isListField", function () {
        return i.props.isListField;
      }),
      Te(fn(i), "isList", function () {
        return i.props.isList;
      }),
      Te(fn(i), "isPreserve", function () {
        return i.props.preserve;
      }),
      Te(fn(i), "getMeta", function () {
        i.prevValidating = i.isFieldValidating();
        var l = {
          touched: i.isFieldTouched(),
          validating: i.prevValidating,
          errors: i.errors,
          warnings: i.warnings,
          name: i.getNamePath(),
          validated: i.validatePromise === null,
        };
        return l;
      }),
      Te(fn(i), "getOnlyChild", function (l) {
        if (typeof l == "function") {
          var c = i.getMeta();
          return Ze(
            Ze(
              {},
              i.getOnlyChild(l(i.getControlled(), c, i.props.fieldContext))
            ),
            {},
            { isFunction: !0 }
          );
        }
        var u = Vh(l);
        return u.length !== 1 || !I.isValidElement(u[0])
          ? { child: u, isFunction: !1 }
          : { child: u[0], isFunction: !1 };
      }),
      Te(fn(i), "getValue", function (l) {
        var c = i.props.fieldContext.getFieldsValue,
          u = i.getNamePath();
        return Ba(l || c(!0), u);
      }),
      Te(fn(i), "getControlled", function () {
        var l =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          c = i.props,
          u = c.name,
          d = c.trigger,
          h = c.validateTrigger,
          m = c.getValueFromEvent,
          g = c.normalize,
          x = c.valuePropName,
          y = c.getValueProps,
          v = c.fieldContext,
          _ = h !== void 0 ? h : v.validateTrigger,
          S = i.getNamePath(),
          w = v.getInternalHooks,
          T = v.getFieldsValue,
          E = w(Ju),
          M = E.dispatch,
          N = i.getValue(),
          R =
            y ||
            function (B) {
              return Te({}, x, B);
            },
          C = l[d],
          L = u !== void 0 ? R(N) : {},
          O = Ze(Ze({}, l), L);
        O[d] = function () {
          (i.touched = !0), (i.dirty = !0), i.triggerMetaEvent();
          for (var B, $ = arguments.length, G = new Array($), j = 0; j < $; j++)
            G[j] = arguments[j];
          m ? (B = m.apply(void 0, G)) : (B = vle.apply(void 0, [x].concat(G))),
            g && (B = g(B, N, T(!0))),
            M({ type: "updateValue", namePath: S, value: B }),
            C && C.apply(void 0, G);
        };
        var D = pT(_ || []);
        return (
          D.forEach(function (B) {
            var $ = O[B];
            O[B] = function () {
              $ && $.apply(void 0, arguments);
              var G = i.props.rules;
              G &&
                G.length &&
                M({ type: "validateField", namePath: S, triggerName: B });
            };
          }),
          O
        );
      }),
      r.fieldContext)
    ) {
      var s = r.fieldContext.getInternalHooks,
        o = s(Ju),
        a = o.initEntityValue;
      a(fn(i));
    }
    return i;
  }
  return (
    os(t, [
      {
        key: "componentDidMount",
        value: function () {
          var i = this.props,
            s = i.shouldUpdate,
            o = i.fieldContext;
          if (((this.mounted = !0), o)) {
            var a = o.getInternalHooks,
              l = a(Ju),
              c = l.registerField;
            this.cancelRegisterFunc = c(this);
          }
          s === !0 && this.reRender();
        },
      },
      {
        key: "componentWillUnmount",
        value: function () {
          this.cancelRegister(), this.triggerMetaEvent(!0), (this.mounted = !1);
        },
      },
      {
        key: "reRender",
        value: function () {
          this.mounted && this.forceUpdate();
        },
      },
      {
        key: "render",
        value: function () {
          var i = this.state.resetCount,
            s = this.props.children,
            o = this.getOnlyChild(s),
            a = o.child,
            l = o.isFunction,
            c;
          return (
            l
              ? (c = a)
              : I.isValidElement(a)
              ? (c = I.cloneElement(a, this.getControlled(a.props)))
              : (Es(!a, "`children` of Field is not validate ReactElement."),
                (c = a)),
            I.createElement(I.Fragment, { key: i }, c)
          );
        },
      },
    ]),
    t
  );
})(I.Component);
Te(yR, "contextType", Yh);
Te(yR, "defaultProps", { trigger: "onChange", valuePropName: "value" });
function sV(n) {
  var e = n.name,
    t = xi(n, yle),
    r = I.useContext(Yh),
    i = I.useContext(P1),
    s = e !== void 0 ? br(e) : void 0,
    o = "keep";
  return (
    t.isListField || (o = "_".concat((s || []).join("_"))),
    I.createElement(
      yR,
      an({ key: o, name: s, isListField: !!i }, t, { fieldContext: r })
    )
  );
}
function xle(n) {
  var e = n.name,
    t = n.initialValue,
    r = n.children,
    i = n.rules,
    s = n.validateTrigger,
    o = n.isListField,
    a = I.useContext(Yh),
    l = I.useContext(P1),
    c = I.useRef({ keys: [], id: 0 }),
    u = c.current,
    d = I.useMemo(
      function () {
        var x = br(a.prefixName) || [];
        return [].concat(Ot(x), Ot(br(e)));
      },
      [a.prefixName, e]
    ),
    h = I.useMemo(
      function () {
        return Ze(Ze({}, a), {}, { prefixName: d });
      },
      [a, d]
    ),
    m = I.useMemo(
      function () {
        return {
          getKey: function (y) {
            var v = d.length,
              _ = y[v];
            return [u.keys[_], y.slice(v + 1)];
          },
        };
      },
      [d]
    );
  if (typeof r != "function")
    return Es(!1, "Form.List only accepts function as children."), null;
  var g = function (y, v, _) {
    var S = _.source;
    return S === "internal" ? !1 : y !== v;
  };
  return I.createElement(
    P1.Provider,
    { value: m },
    I.createElement(
      Yh.Provider,
      { value: h },
      I.createElement(
        sV,
        {
          name: [],
          shouldUpdate: g,
          rules: i,
          validateTrigger: s,
          initialValue: t,
          isList: !0,
          isListField: o ?? !!l,
        },
        function (x, y) {
          var v = x.value,
            _ = v === void 0 ? [] : v,
            S = x.onChange,
            w = a.getFieldValue,
            T = function () {
              var R = w(d || []);
              return R || [];
            },
            E = {
              add: function (R, C) {
                var L = T();
                C >= 0 && C <= L.length
                  ? ((u.keys = [].concat(
                      Ot(u.keys.slice(0, C)),
                      [u.id],
                      Ot(u.keys.slice(C))
                    )),
                    S([].concat(Ot(L.slice(0, C)), [R], Ot(L.slice(C)))))
                  : ((u.keys = [].concat(Ot(u.keys), [u.id])),
                    S([].concat(Ot(L), [R]))),
                  (u.id += 1);
              },
              remove: function (R) {
                var C = T(),
                  L = new Set(Array.isArray(R) ? R : [R]);
                L.size <= 0 ||
                  ((u.keys = u.keys.filter(function (O, D) {
                    return !L.has(D);
                  })),
                  S(
                    C.filter(function (O, D) {
                      return !L.has(D);
                    })
                  ));
              },
              move: function (R, C) {
                if (R !== C) {
                  var L = T();
                  R < 0 ||
                    R >= L.length ||
                    C < 0 ||
                    C >= L.length ||
                    ((u.keys = nD(u.keys, R, C)), S(nD(L, R, C)));
                }
              },
            },
            M = _ || [];
          return (
            Array.isArray(M) || (M = []),
            r(
              M.map(function (N, R) {
                var C = u.keys[R];
                return (
                  C === void 0 &&
                    ((u.keys[R] = u.id), (C = u.keys[R]), (u.id += 1)),
                  { name: R, key: C, isListField: !0 }
                );
              }),
              E,
              y
            )
          );
        }
      )
    )
  );
}
function _le(n) {
  var e = !1,
    t = n.length,
    r = [];
  return n.length
    ? new Promise(function (i, s) {
        n.forEach(function (o, a) {
          o.catch(function (l) {
            return (e = !0), l;
          }).then(function (l) {
            (t -= 1), (r[a] = l), !(t > 0) && (e && s(r), i(r));
          });
        });
      })
    : Promise.resolve([]);
}
var oV = "__@field_split__";
function xb(n) {
  return n
    .map(function (e) {
      return "".concat($t(e), ":").concat(e);
    })
    .join(oV);
}
var Ff = (function () {
    function n() {
      ss(this, n), Te(this, "kvs", new Map());
    }
    return (
      os(n, [
        {
          key: "set",
          value: function (t, r) {
            this.kvs.set(xb(t), r);
          },
        },
        {
          key: "get",
          value: function (t) {
            return this.kvs.get(xb(t));
          },
        },
        {
          key: "update",
          value: function (t, r) {
            var i = this.get(t),
              s = r(i);
            s ? this.set(t, s) : this.delete(t);
          },
        },
        {
          key: "delete",
          value: function (t) {
            this.kvs.delete(xb(t));
          },
        },
        {
          key: "map",
          value: function (t) {
            return Ot(this.kvs.entries()).map(function (r) {
              var i = Et(r, 2),
                s = i[0],
                o = i[1],
                a = s.split(oV);
              return t({
                key: a.map(function (l) {
                  var c = l.match(/^([^:]*):(.*)$/),
                    u = Et(c, 3),
                    d = u[1],
                    h = u[2];
                  return d === "number" ? Number(h) : h;
                }),
                value: o,
              });
            });
          },
        },
        {
          key: "toJSON",
          value: function () {
            var t = {};
            return (
              this.map(function (r) {
                var i = r.key,
                  s = r.value;
                return (t[i.join(".")] = s), null;
              }),
              t
            );
          },
        },
      ]),
      n
    );
  })(),
  Sle = ["name"],
  Ale = os(function n(e) {
    var t = this;
    ss(this, n),
      Te(this, "formHooked", !1),
      Te(this, "forceRootUpdate", void 0),
      Te(this, "subscribable", !0),
      Te(this, "store", {}),
      Te(this, "fieldEntities", []),
      Te(this, "initialValues", {}),
      Te(this, "callbacks", {}),
      Te(this, "validateMessages", null),
      Te(this, "preserve", null),
      Te(this, "lastValidatePromise", null),
      Te(this, "getForm", function () {
        return {
          getFieldValue: t.getFieldValue,
          getFieldsValue: t.getFieldsValue,
          getFieldError: t.getFieldError,
          getFieldWarning: t.getFieldWarning,
          getFieldsError: t.getFieldsError,
          isFieldsTouched: t.isFieldsTouched,
          isFieldTouched: t.isFieldTouched,
          isFieldValidating: t.isFieldValidating,
          isFieldsValidating: t.isFieldsValidating,
          resetFields: t.resetFields,
          setFields: t.setFields,
          setFieldValue: t.setFieldValue,
          setFieldsValue: t.setFieldsValue,
          validateFields: t.validateFields,
          submit: t.submit,
          _init: !0,
          getInternalHooks: t.getInternalHooks,
        };
      }),
      Te(this, "getInternalHooks", function (r) {
        return r === Ju
          ? ((t.formHooked = !0),
            {
              dispatch: t.dispatch,
              initEntityValue: t.initEntityValue,
              registerField: t.registerField,
              useSubscribe: t.useSubscribe,
              setInitialValues: t.setInitialValues,
              destroyForm: t.destroyForm,
              setCallbacks: t.setCallbacks,
              setValidateMessages: t.setValidateMessages,
              getFields: t.getFields,
              setPreserve: t.setPreserve,
              getInitialValue: t.getInitialValue,
              registerWatch: t.registerWatch,
            })
          : (Es(
              !1,
              "`getInternalHooks` is internal usage. Should not call directly."
            ),
            null);
      }),
      Te(this, "useSubscribe", function (r) {
        t.subscribable = r;
      }),
      Te(this, "prevWithoutPreserves", null),
      Te(this, "setInitialValues", function (r, i) {
        if (((t.initialValues = r || {}), i)) {
          var s,
            o = sh(r, t.store);
          (s = t.prevWithoutPreserves) === null ||
            s === void 0 ||
            s.map(function (a) {
              var l = a.key;
              o = ra(o, l, Ba(r, l));
            }),
            (t.prevWithoutPreserves = null),
            t.updateStore(o);
        }
      }),
      Te(this, "destroyForm", function () {
        var r = new Ff();
        t.getFieldEntities(!0).forEach(function (i) {
          t.isMergedPreserve(i.isPreserve()) || r.set(i.getNamePath(), !0);
        }),
          (t.prevWithoutPreserves = r);
      }),
      Te(this, "getInitialValue", function (r) {
        var i = Ba(t.initialValues, r);
        return r.length ? sh(i) : i;
      }),
      Te(this, "setCallbacks", function (r) {
        t.callbacks = r;
      }),
      Te(this, "setValidateMessages", function (r) {
        t.validateMessages = r;
      }),
      Te(this, "setPreserve", function (r) {
        t.preserve = r;
      }),
      Te(this, "watchList", []),
      Te(this, "registerWatch", function (r) {
        return (
          t.watchList.push(r),
          function () {
            t.watchList = t.watchList.filter(function (i) {
              return i !== r;
            });
          }
        );
      }),
      Te(this, "notifyWatch", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (t.watchList.length) {
          var i = t.getFieldsValue(),
            s = t.getFieldsValue(!0);
          t.watchList.forEach(function (o) {
            o(i, s, r);
          });
        }
      }),
      Te(this, "timeoutId", null),
      Te(this, "warningUnhooked", function () {}),
      Te(this, "updateStore", function (r) {
        t.store = r;
      }),
      Te(this, "getFieldEntities", function () {
        var r =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
        return r
          ? t.fieldEntities.filter(function (i) {
              return i.getNamePath().length;
            })
          : t.fieldEntities;
      }),
      Te(this, "getFieldsMap", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
          i = new Ff();
        return (
          t.getFieldEntities(r).forEach(function (s) {
            var o = s.getNamePath();
            i.set(o, s);
          }),
          i
        );
      }),
      Te(this, "getFieldEntitiesForNamePathList", function (r) {
        if (!r) return t.getFieldEntities(!0);
        var i = t.getFieldsMap(!0);
        return r.map(function (s) {
          var o = br(s);
          return i.get(o) || { INVALIDATE_NAME_PATH: br(s) };
        });
      }),
      Te(this, "getFieldsValue", function (r, i) {
        t.warningUnhooked();
        var s, o, a;
        if (
          (r === !0 || Array.isArray(r)
            ? ((s = r), (o = i))
            : r && $t(r) === "object" && ((a = r.strict), (o = r.filter)),
          s === !0 && !o)
        )
          return t.store;
        var l = t.getFieldEntitiesForNamePathList(Array.isArray(s) ? s : null),
          c = [];
        return (
          l.forEach(function (u) {
            var d,
              h,
              m =
                "INVALIDATE_NAME_PATH" in u
                  ? u.INVALIDATE_NAME_PATH
                  : u.getNamePath();
            if (a) {
              var g, x;
              if ((g = (x = u).isList) !== null && g !== void 0 && g.call(x))
                return;
            } else if (!s && (d = (h = u).isListField) !== null && d !== void 0 && d.call(h)) return;
            if (!o) c.push(m);
            else {
              var y = "getMeta" in u ? u.getMeta() : null;
              o(y) && c.push(m);
            }
          }),
          tD(t.store, c.map(br))
        );
      }),
      Te(this, "getFieldValue", function (r) {
        t.warningUnhooked();
        var i = br(r);
        return Ba(t.store, i);
      }),
      Te(this, "getFieldsError", function (r) {
        t.warningUnhooked();
        var i = t.getFieldEntitiesForNamePathList(r);
        return i.map(function (s, o) {
          return s && !("INVALIDATE_NAME_PATH" in s)
            ? {
                name: s.getNamePath(),
                errors: s.getErrors(),
                warnings: s.getWarnings(),
              }
            : { name: br(r[o]), errors: [], warnings: [] };
        });
      }),
      Te(this, "getFieldError", function (r) {
        t.warningUnhooked();
        var i = br(r),
          s = t.getFieldsError([i])[0];
        return s.errors;
      }),
      Te(this, "getFieldWarning", function (r) {
        t.warningUnhooked();
        var i = br(r),
          s = t.getFieldsError([i])[0];
        return s.warnings;
      }),
      Te(this, "isFieldsTouched", function () {
        t.warningUnhooked();
        for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)
          i[s] = arguments[s];
        var o = i[0],
          a = i[1],
          l,
          c = !1;
        i.length === 0
          ? (l = null)
          : i.length === 1
          ? Array.isArray(o)
            ? ((l = o.map(br)), (c = !1))
            : ((l = null), (c = o))
          : ((l = o.map(br)), (c = a));
        var u = t.getFieldEntities(!0),
          d = function (y) {
            return y.isFieldTouched();
          };
        if (!l)
          return c
            ? u.every(function (x) {
                return d(x) || x.isList();
              })
            : u.some(d);
        var h = new Ff();
        l.forEach(function (x) {
          h.set(x, []);
        }),
          u.forEach(function (x) {
            var y = x.getNamePath();
            l.forEach(function (v) {
              v.every(function (_, S) {
                return y[S] === _;
              }) &&
                h.update(v, function (_) {
                  return [].concat(Ot(_), [x]);
                });
            });
          });
        var m = function (y) {
            return y.some(d);
          },
          g = h.map(function (x) {
            var y = x.value;
            return y;
          });
        return c ? g.every(m) : g.some(m);
      }),
      Te(this, "isFieldTouched", function (r) {
        return t.warningUnhooked(), t.isFieldsTouched([r]);
      }),
      Te(this, "isFieldsValidating", function (r) {
        t.warningUnhooked();
        var i = t.getFieldEntities();
        if (!r)
          return i.some(function (o) {
            return o.isFieldValidating();
          });
        var s = r.map(br);
        return i.some(function (o) {
          var a = o.getNamePath();
          return _h(s, a) && o.isFieldValidating();
        });
      }),
      Te(this, "isFieldValidating", function (r) {
        return t.warningUnhooked(), t.isFieldsValidating([r]);
      }),
      Te(this, "resetWithFieldInitialValue", function () {
        var r =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          i = new Ff(),
          s = t.getFieldEntities(!0);
        s.forEach(function (l) {
          var c = l.props.initialValue,
            u = l.getNamePath();
          if (c !== void 0) {
            var d = i.get(u) || new Set();
            d.add({ entity: l, value: c }), i.set(u, d);
          }
        });
        var o = function (c) {
            c.forEach(function (u) {
              var d = u.props.initialValue;
              if (d !== void 0) {
                var h = u.getNamePath(),
                  m = t.getInitialValue(h);
                if (m !== void 0)
                  Es(
                    !1,
                    "Form already set 'initialValues' with path '".concat(
                      h.join("."),
                      "'. Field can not overwrite it."
                    )
                  );
                else {
                  var g = i.get(h);
                  if (g && g.size > 1)
                    Es(
                      !1,
                      "Multiple Field with path '".concat(
                        h.join("."),
                        "' set 'initialValue'. Can not decide which one to pick."
                      )
                    );
                  else if (g) {
                    var x = t.getFieldValue(h),
                      y = u.isListField();
                    !y &&
                      (!r.skipExist || x === void 0) &&
                      t.updateStore(ra(t.store, h, Ot(g)[0].value));
                  }
                }
              }
            });
          },
          a;
        r.entities
          ? (a = r.entities)
          : r.namePathList
          ? ((a = []),
            r.namePathList.forEach(function (l) {
              var c = i.get(l);
              if (c) {
                var u;
                (u = a).push.apply(
                  u,
                  Ot(
                    Ot(c).map(function (d) {
                      return d.entity;
                    })
                  )
                );
              }
            }))
          : (a = s),
          o(a);
      }),
      Te(this, "resetFields", function (r) {
        t.warningUnhooked();
        var i = t.store;
        if (!r) {
          t.updateStore(sh(t.initialValues)),
            t.resetWithFieldInitialValue(),
            t.notifyObservers(i, null, { type: "reset" }),
            t.notifyWatch();
          return;
        }
        var s = r.map(br);
        s.forEach(function (o) {
          var a = t.getInitialValue(o);
          t.updateStore(ra(t.store, o, a));
        }),
          t.resetWithFieldInitialValue({ namePathList: s }),
          t.notifyObservers(i, s, { type: "reset" }),
          t.notifyWatch(s);
      }),
      Te(this, "setFields", function (r) {
        t.warningUnhooked();
        var i = t.store,
          s = [];
        r.forEach(function (o) {
          var a = o.name,
            l = xi(o, Sle),
            c = br(a);
          s.push(c),
            "value" in l && t.updateStore(ra(t.store, c, l.value)),
            t.notifyObservers(i, [c], { type: "setField", data: o });
        }),
          t.notifyWatch(s);
      }),
      Te(this, "getFields", function () {
        var r = t.getFieldEntities(!0),
          i = r.map(function (s) {
            var o = s.getNamePath(),
              a = s.getMeta(),
              l = Ze(Ze({}, a), {}, { name: o, value: t.getFieldValue(o) });
            return Object.defineProperty(l, "originRCField", { value: !0 }), l;
          });
        return i;
      }),
      Te(this, "initEntityValue", function (r) {
        var i = r.props.initialValue;
        if (i !== void 0) {
          var s = r.getNamePath(),
            o = Ba(t.store, s);
          o === void 0 && t.updateStore(ra(t.store, s, i));
        }
      }),
      Te(this, "isMergedPreserve", function (r) {
        var i = r !== void 0 ? r : t.preserve;
        return i ?? !0;
      }),
      Te(this, "registerField", function (r) {
        t.fieldEntities.push(r);
        var i = r.getNamePath();
        if ((t.notifyWatch([i]), r.props.initialValue !== void 0)) {
          var s = t.store;
          t.resetWithFieldInitialValue({ entities: [r], skipExist: !0 }),
            t.notifyObservers(s, [r.getNamePath()], {
              type: "valueUpdate",
              source: "internal",
            });
        }
        return function (o, a) {
          var l =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          if (
            ((t.fieldEntities = t.fieldEntities.filter(function (d) {
              return d !== r;
            })),
            !t.isMergedPreserve(a) && (!o || l.length > 1))
          ) {
            var c = o ? void 0 : t.getInitialValue(i);
            if (
              i.length &&
              t.getFieldValue(i) !== c &&
              t.fieldEntities.every(function (d) {
                return !iV(d.getNamePath(), i);
              })
            ) {
              var u = t.store;
              t.updateStore(ra(u, i, c, !0)),
                t.notifyObservers(u, [i], { type: "remove" }),
                t.triggerDependenciesUpdate(u, i);
            }
          }
          t.notifyWatch([i]);
        };
      }),
      Te(this, "dispatch", function (r) {
        switch (r.type) {
          case "updateValue": {
            var i = r.namePath,
              s = r.value;
            t.updateValue(i, s);
            break;
          }
          case "validateField": {
            var o = r.namePath,
              a = r.triggerName;
            t.validateFields([o], { triggerName: a });
            break;
          }
        }
      }),
      Te(this, "notifyObservers", function (r, i, s) {
        if (t.subscribable) {
          var o = Ze(Ze({}, s), {}, { store: t.getFieldsValue(!0) });
          t.getFieldEntities().forEach(function (a) {
            var l = a.onStoreChange;
            l(r, i, o);
          });
        } else t.forceRootUpdate();
      }),
      Te(this, "triggerDependenciesUpdate", function (r, i) {
        var s = t.getDependencyChildrenFields(i);
        return (
          s.length && t.validateFields(s),
          t.notifyObservers(r, s, {
            type: "dependenciesUpdate",
            relatedFields: [i].concat(Ot(s)),
          }),
          s
        );
      }),
      Te(this, "updateValue", function (r, i) {
        var s = br(r),
          o = t.store;
        t.updateStore(ra(t.store, s, i)),
          t.notifyObservers(o, [s], {
            type: "valueUpdate",
            source: "internal",
          }),
          t.notifyWatch([s]);
        var a = t.triggerDependenciesUpdate(o, s),
          l = t.callbacks.onValuesChange;
        if (l) {
          var c = tD(t.store, [s]);
          l(c, t.getFieldsValue());
        }
        t.triggerOnFieldsChange([s].concat(Ot(a)));
      }),
      Te(this, "setFieldsValue", function (r) {
        t.warningUnhooked();
        var i = t.store;
        if (r) {
          var s = sh(t.store, r);
          t.updateStore(s);
        }
        t.notifyObservers(i, null, { type: "valueUpdate", source: "external" }),
          t.notifyWatch();
      }),
      Te(this, "setFieldValue", function (r, i) {
        t.setFields([{ name: r, value: i }]);
      }),
      Te(this, "getDependencyChildrenFields", function (r) {
        var i = new Set(),
          s = [],
          o = new Ff();
        t.getFieldEntities().forEach(function (l) {
          var c = l.props.dependencies;
          (c || []).forEach(function (u) {
            var d = br(u);
            o.update(d, function () {
              var h =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : new Set();
              return h.add(l), h;
            });
          });
        });
        var a = function l(c) {
          var u = o.get(c) || new Set();
          u.forEach(function (d) {
            if (!i.has(d)) {
              i.add(d);
              var h = d.getNamePath();
              d.isFieldDirty() && h.length && (s.push(h), l(h));
            }
          });
        };
        return a(r), s;
      }),
      Te(this, "triggerOnFieldsChange", function (r, i) {
        var s = t.callbacks.onFieldsChange;
        if (s) {
          var o = t.getFields();
          if (i) {
            var a = new Ff();
            i.forEach(function (c) {
              var u = c.name,
                d = c.errors;
              a.set(u, d);
            }),
              o.forEach(function (c) {
                c.errors = a.get(c.name) || c.errors;
              });
          }
          var l = o.filter(function (c) {
            var u = c.name;
            return _h(r, u);
          });
          l.length && s(l, o);
        }
      }),
      Te(this, "validateFields", function (r, i) {
        t.warningUnhooked();
        var s, o;
        Array.isArray(r) || typeof r == "string" || typeof i == "string"
          ? ((s = r), (o = i))
          : (o = r);
        var a = !!s,
          l = a ? s.map(br) : [],
          c = [],
          u = String(Date.now()),
          d = new Set(),
          h = o || {},
          m = h.recursive,
          g = h.dirty;
        t.getFieldEntities(!0).forEach(function (_) {
          if (
            (a || l.push(_.getNamePath()),
            !(!_.props.rules || !_.props.rules.length) &&
              !(g && !_.isFieldDirty()))
          ) {
            var S = _.getNamePath();
            if ((d.add(S.join(u)), !a || _h(l, S, m))) {
              var w = _.validateRules(
                Ze({ validateMessages: Ze(Ze({}, rV), t.validateMessages) }, o)
              );
              c.push(
                w
                  .then(function () {
                    return { name: S, errors: [], warnings: [] };
                  })
                  .catch(function (T) {
                    var E,
                      M = [],
                      N = [];
                    return (
                      (E = T.forEach) === null ||
                        E === void 0 ||
                        E.call(T, function (R) {
                          var C = R.rule.warningOnly,
                            L = R.errors;
                          C ? N.push.apply(N, Ot(L)) : M.push.apply(M, Ot(L));
                        }),
                      M.length
                        ? Promise.reject({ name: S, errors: M, warnings: N })
                        : { name: S, errors: M, warnings: N }
                    );
                  })
              );
            }
          }
        });
        var x = _le(c);
        (t.lastValidatePromise = x),
          x
            .catch(function (_) {
              return _;
            })
            .then(function (_) {
              var S = _.map(function (w) {
                var T = w.name;
                return T;
              });
              t.notifyObservers(t.store, S, { type: "validateFinish" }),
                t.triggerOnFieldsChange(S, _);
            });
        var y = x
          .then(function () {
            return t.lastValidatePromise === x
              ? Promise.resolve(t.getFieldsValue(l))
              : Promise.reject([]);
          })
          .catch(function (_) {
            var S = _.filter(function (w) {
              return w && w.errors.length;
            });
            return Promise.reject({
              values: t.getFieldsValue(l),
              errorFields: S,
              outOfDate: t.lastValidatePromise !== x,
            });
          });
        y.catch(function (_) {
          return _;
        });
        var v = l.filter(function (_) {
          return d.has(_.join(u));
        });
        return t.triggerOnFieldsChange(v), y;
      }),
      Te(this, "submit", function () {
        t.warningUnhooked(),
          t
            .validateFields()
            .then(function (r) {
              var i = t.callbacks.onFinish;
              if (i)
                try {
                  i(r);
                } catch (s) {
                  console.error(s);
                }
            })
            .catch(function (r) {
              var i = t.callbacks.onFinishFailed;
              i && i(r);
            });
      }),
      (this.forceRootUpdate = e);
  });
function aV(n) {
  var e = I.useRef(),
    t = I.useState({}),
    r = Et(t, 2),
    i = r[1];
  if (!e.current)
    if (n) e.current = n;
    else {
      var s = function () {
          i({});
        },
        o = new Ale(s);
      e.current = o.getForm();
    }
  return [e.current];
}
var wT = I.createContext({
    triggerFormChange: function () {},
    triggerFormFinish: function () {},
    registerForm: function () {},
    unregisterForm: function () {},
  }),
  wle = function (e) {
    var t = e.validateMessages,
      r = e.onFormChange,
      i = e.onFormFinish,
      s = e.children,
      o = I.useContext(wT),
      a = I.useRef({});
    return I.createElement(
      wT.Provider,
      {
        value: Ze(
          Ze({}, o),
          {},
          {
            validateMessages: Ze(Ze({}, o.validateMessages), t),
            triggerFormChange: function (c, u) {
              r && r(c, { changedFields: u, forms: a.current }),
                o.triggerFormChange(c, u);
            },
            triggerFormFinish: function (c, u) {
              i && i(c, { values: u, forms: a.current }),
                o.triggerFormFinish(c, u);
            },
            registerForm: function (c, u) {
              c && (a.current = Ze(Ze({}, a.current), {}, Te({}, c, u))),
                o.registerForm(c, u);
            },
            unregisterForm: function (c) {
              var u = Ze({}, a.current);
              delete u[c], (a.current = u), o.unregisterForm(c);
            },
          }
        ),
      },
      s
    );
  },
  ble = [
    "name",
    "initialValues",
    "fields",
    "form",
    "preserve",
    "children",
    "component",
    "validateMessages",
    "validateTrigger",
    "onValuesChange",
    "onFieldsChange",
    "onFinish",
    "onFinishFailed",
  ],
  Ele = function (e, t) {
    var r = e.name,
      i = e.initialValues,
      s = e.fields,
      o = e.form,
      a = e.preserve,
      l = e.children,
      c = e.component,
      u = c === void 0 ? "form" : c,
      d = e.validateMessages,
      h = e.validateTrigger,
      m = h === void 0 ? "onChange" : h,
      g = e.onValuesChange,
      x = e.onFieldsChange,
      y = e.onFinish,
      v = e.onFinishFailed,
      _ = xi(e, ble),
      S = I.useContext(wT),
      w = aV(o),
      T = Et(w, 1),
      E = T[0],
      M = E.getInternalHooks(Ju),
      N = M.useSubscribe,
      R = M.setInitialValues,
      C = M.setCallbacks,
      L = M.setValidateMessages,
      O = M.setPreserve,
      D = M.destroyForm;
    I.useImperativeHandle(t, function () {
      return E;
    }),
      I.useEffect(
        function () {
          return (
            S.registerForm(r, E),
            function () {
              S.unregisterForm(r);
            }
          );
        },
        [S, E, r]
      ),
      L(Ze(Ze({}, S.validateMessages), d)),
      C({
        onValuesChange: g,
        onFieldsChange: function (W) {
          if ((S.triggerFormChange(r, W), x)) {
            for (
              var ee = arguments.length,
                Y = new Array(ee > 1 ? ee - 1 : 0),
                K = 1;
              K < ee;
              K++
            )
              Y[K - 1] = arguments[K];
            x.apply(void 0, [W].concat(Y));
          }
        },
        onFinish: function (W) {
          S.triggerFormFinish(r, W), y && y(W);
        },
        onFinishFailed: v,
      }),
      O(a);
    var B = I.useRef(null);
    R(i, !B.current),
      B.current || (B.current = !0),
      I.useEffect(function () {
        return D;
      }, []);
    var $,
      G = typeof l == "function";
    if (G) {
      var j = E.getFieldsValue(!0);
      $ = l(j, E);
    } else $ = l;
    N(!G);
    var U = I.useRef();
    I.useEffect(
      function () {
        gle(U.current || [], s || []) || E.setFields(s || []), (U.current = s);
      },
      [s, E]
    );
    var H = I.useMemo(
        function () {
          return Ze(Ze({}, E), {}, { validateTrigger: m });
        },
        [E, m]
      ),
      V = I.createElement(
        P1.Provider,
        { value: null },
        I.createElement(Yh.Provider, { value: H }, $)
      );
    return u === !1
      ? V
      : I.createElement(
          u,
          an({}, _, {
            onSubmit: function (W) {
              W.preventDefault(), W.stopPropagation(), E.submit();
            },
            onReset: function (W) {
              var ee;
              W.preventDefault(),
                E.resetFields(),
                (ee = _.onReset) === null || ee === void 0 || ee.call(_, W);
            },
          }),
          V
        );
  };
function iD(n) {
  try {
    return JSON.stringify(n);
  } catch {
    return Math.random();
  }
}
function Mle() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  var r = e[0],
    i = e[1],
    s = i === void 0 ? {} : i,
    o = Oae(s) ? { form: s } : s,
    a = o.form,
    l = I.useState(),
    c = Et(l, 2),
    u = c[0],
    d = c[1],
    h = I.useMemo(
      function () {
        return iD(u);
      },
      [u]
    ),
    m = I.useRef(h);
  m.current = h;
  var g = I.useContext(Yh),
    x = a || g,
    y = x && x._init,
    v = br(r),
    _ = I.useRef(v);
  return (
    (_.current = v),
    I.useEffect(
      function () {
        if (y) {
          var S = x.getFieldsValue,
            w = x.getInternalHooks,
            T = w(Ju),
            E = T.registerWatch,
            M = function (L, O) {
              var D = o.preserve ? O : L;
              return typeof r == "function" ? r(D) : Ba(D, _.current);
            },
            N = E(function (C, L) {
              var O = M(C, L),
                D = iD(O);
              m.current !== D && ((m.current = D), d(O));
            }),
            R = M(S(), S(!0));
          return u !== R && d(R), N;
        }
      },
      [y]
    ),
    u
  );
}
var Tle = I.forwardRef(Ele),
  C0 = Tle;
C0.FormProvider = wle;
C0.Field = sV;
C0.List = xle;
C0.useForm = aV;
C0.useWatch = Mle;
const Bl = I.createContext({}),
  Cle = (n) => {
    let { children: e, status: t, override: r } = n;
    const i = I.useContext(Bl),
      s = I.useMemo(() => {
        const o = Object.assign({}, i);
        return (
          r && delete o.isFormItemInput,
          t && (delete o.status, delete o.hasFeedback, delete o.feedbackIcon),
          o
        );
      }, [t, r, i]);
    return I.createElement(Bl.Provider, { value: s }, e);
  },
  Rle = I.createContext(void 0),
  Nle = (n) => ({
    [n.componentCls]: {
      [`${n.antCls}-motion-collapse-legacy`]: {
        overflow: "hidden",
        "&-active": {
          transition: `height ${n.motionDurationMid} ${n.motionEaseInOut},
        opacity ${n.motionDurationMid} ${n.motionEaseInOut} !important`,
        },
      },
      [`${n.antCls}-motion-collapse`]: {
        overflow: "hidden",
        transition: `height ${n.motionDurationMid} ${n.motionEaseInOut},
        opacity ${n.motionDurationMid} ${n.motionEaseInOut} !important`,
      },
    },
  }),
  Ple = Je.createContext({});
function bT(n, e, t) {
  return Mt({
    [`${n}-status-success`]: e === "success",
    [`${n}-status-warning`]: e === "warning",
    [`${n}-status-error`]: e === "error",
    [`${n}-status-validating`]: e === "validating",
    [`${n}-has-feedback`]: t,
  });
}
const xR = (n, e) => e || n,
  Ile = ["outlined", "borderless", "filled"],
  lV = function (n) {
    let e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    const t = I.useContext(Rle);
    let r;
    typeof n < "u"
      ? (r = n)
      : e === !1
      ? (r = "borderless")
      : (r = t ?? "outlined");
    const i = Ile.includes(r);
    return [r, i];
  };
var Lle = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z",
          },
        },
      ],
    },
    name: "search",
    theme: "outlined",
  },
  Ole = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: Lle }));
  },
  Dle = I.forwardRef(Ole),
  Fle = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z",
          },
        },
      ],
    },
    name: "right",
    theme: "outlined",
  },
  Ule = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: Fle }));
  },
  kle = I.forwardRef(Ule);
const cV = I.createContext(null),
  zle = cV.Provider,
  uV = I.createContext(null),
  Ble = uV.Provider;
var Vle = [
    "prefixCls",
    "className",
    "style",
    "checked",
    "disabled",
    "defaultChecked",
    "type",
    "title",
    "onChange",
  ],
  Hle = I.forwardRef(function (n, e) {
    var t = n.prefixCls,
      r = t === void 0 ? "rc-checkbox" : t,
      i = n.className,
      s = n.style,
      o = n.checked,
      a = n.disabled,
      l = n.defaultChecked,
      c = l === void 0 ? !1 : l,
      u = n.type,
      d = u === void 0 ? "checkbox" : u,
      h = n.title,
      m = n.onChange,
      g = xi(n, Vle),
      x = I.useRef(null),
      y = I.useRef(null),
      v = fp(c, { value: o }),
      _ = Et(v, 2),
      S = _[0],
      w = _[1];
    I.useImperativeHandle(e, function () {
      return {
        focus: function (N) {
          var R;
          (R = x.current) === null || R === void 0 || R.focus(N);
        },
        blur: function () {
          var N;
          (N = x.current) === null || N === void 0 || N.blur();
        },
        input: x.current,
        nativeElement: y.current,
      };
    });
    var T = Mt(
        r,
        i,
        Te(Te({}, "".concat(r, "-checked"), S), "".concat(r, "-disabled"), a)
      ),
      E = function (N) {
        a ||
          ("checked" in n || w(N.target.checked),
          m == null ||
            m({
              target: Ze(Ze({}, n), {}, { type: d, checked: N.target.checked }),
              stopPropagation: function () {
                N.stopPropagation();
              },
              preventDefault: function () {
                N.preventDefault();
              },
              nativeEvent: N.nativeEvent,
            }));
      };
    return I.createElement(
      "span",
      { className: T, title: h, style: s, ref: y },
      I.createElement(
        "input",
        an({}, g, {
          className: "".concat(r, "-input"),
          ref: x,
          onChange: E,
          disabled: a,
          checked: !!S,
          type: d,
        })
      ),
      I.createElement("span", { className: "".concat(r, "-inner") })
    );
  });
const Gle = (n) => {
    const { componentCls: e, antCls: t } = n,
      r = `${e}-group`;
    return {
      [r]: Object.assign(Object.assign({}, Md(n)), {
        display: "inline-block",
        fontSize: 0,
        [`&${r}-rtl`]: { direction: "rtl" },
        [`${t}-badge ${t}-badge-count`]: { zIndex: 1 },
        [`> ${t}-badge:not(:first-child) > ${t}-button-wrapper`]: {
          borderInlineStart: "none",
        },
      }),
    };
  },
  Wle = (n) => {
    const {
        componentCls: e,
        wrapperMarginInlineEnd: t,
        colorPrimary: r,
        radioSize: i,
        motionDurationSlow: s,
        motionDurationMid: o,
        motionEaseInOutCirc: a,
        colorBgContainer: l,
        colorBorder: c,
        lineWidth: u,
        colorBgContainerDisabled: d,
        colorTextDisabled: h,
        paddingXS: m,
        dotColorDisabled: g,
        lineType: x,
        radioColor: y,
        radioBgColor: v,
        calc: _,
      } = n,
      S = `${e}-inner`,
      T = _(i).sub(_(4).mul(2)),
      E = _(1).mul(i).equal();
    return {
      [`${e}-wrapper`]: Object.assign(Object.assign({}, Md(n)), {
        display: "inline-flex",
        alignItems: "baseline",
        marginInlineStart: 0,
        marginInlineEnd: t,
        cursor: "pointer",
        [`&${e}-wrapper-rtl`]: { direction: "rtl" },
        "&-disabled": { cursor: "not-allowed", color: n.colorTextDisabled },
        "&::after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: '"\\a0"',
        },
        [`${e}-checked::after`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          border: `${jt(u)} ${x} ${r}`,
          borderRadius: "50%",
          visibility: "hidden",
          opacity: 0,
          content: '""',
        },
        [e]: Object.assign(Object.assign({}, Md(n)), {
          position: "relative",
          display: "inline-block",
          outline: "none",
          cursor: "pointer",
          alignSelf: "center",
          borderRadius: "50%",
        }),
        [`${e}-wrapper:hover &,
        &:hover ${S}`]: { borderColor: r },
        [`${e}-input:focus-visible + ${S}`]: Object.assign({}, uR(n)),
        [`${e}:hover::after, ${e}-wrapper:hover &::after`]: {
          visibility: "visible",
        },
        [`${e}-inner`]: {
          "&::after": {
            boxSizing: "border-box",
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineStart: "50%",
            display: "block",
            width: E,
            height: E,
            marginBlockStart: _(1).mul(i).div(-2).equal(),
            marginInlineStart: _(1).mul(i).div(-2).equal(),
            backgroundColor: y,
            borderBlockStart: 0,
            borderInlineStart: 0,
            borderRadius: E,
            transform: "scale(0)",
            opacity: 0,
            transition: `all ${s} ${a}`,
            content: '""',
          },
          boxSizing: "border-box",
          position: "relative",
          insetBlockStart: 0,
          insetInlineStart: 0,
          display: "block",
          width: E,
          height: E,
          backgroundColor: l,
          borderColor: c,
          borderStyle: "solid",
          borderWidth: u,
          borderRadius: "50%",
          transition: `all ${o}`,
        },
        [`${e}-input`]: {
          position: "absolute",
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
        },
        [`${e}-checked`]: {
          [S]: {
            borderColor: r,
            backgroundColor: v,
            "&::after": {
              transform: `scale(${n.calc(n.dotSize).div(i).equal()})`,
              opacity: 1,
              transition: `all ${s} ${a}`,
            },
          },
        },
        [`${e}-disabled`]: {
          cursor: "not-allowed",
          [S]: {
            backgroundColor: d,
            borderColor: c,
            cursor: "not-allowed",
            "&::after": { backgroundColor: g },
          },
          [`${e}-input`]: { cursor: "not-allowed" },
          [`${e}-disabled + span`]: { color: h, cursor: "not-allowed" },
          [`&${e}-checked`]: {
            [S]: {
              "&::after": {
                transform: `scale(${_(T).div(i).equal({ unit: !1 })})`,
              },
            },
          },
        },
        [`span${e} + *`]: { paddingInlineStart: m, paddingInlineEnd: m },
      }),
    };
  },
  jle = (n) => {
    const {
      buttonColor: e,
      controlHeight: t,
      componentCls: r,
      lineWidth: i,
      lineType: s,
      colorBorder: o,
      motionDurationSlow: a,
      motionDurationMid: l,
      buttonPaddingInline: c,
      fontSize: u,
      buttonBg: d,
      fontSizeLG: h,
      controlHeightLG: m,
      controlHeightSM: g,
      paddingXS: x,
      borderRadius: y,
      borderRadiusSM: v,
      borderRadiusLG: _,
      buttonCheckedBg: S,
      buttonSolidCheckedColor: w,
      colorTextDisabled: T,
      colorBgContainerDisabled: E,
      buttonCheckedBgDisabled: M,
      buttonCheckedColorDisabled: N,
      colorPrimary: R,
      colorPrimaryHover: C,
      colorPrimaryActive: L,
      buttonSolidCheckedBg: O,
      buttonSolidCheckedHoverBg: D,
      buttonSolidCheckedActiveBg: B,
      calc: $,
    } = n;
    return {
      [`${r}-button-wrapper`]: {
        position: "relative",
        display: "inline-block",
        height: t,
        margin: 0,
        paddingInline: c,
        paddingBlock: 0,
        color: e,
        fontSize: u,
        lineHeight: jt($(t).sub($(i).mul(2)).equal()),
        background: d,
        border: `${jt(i)} ${s} ${o}`,
        borderBlockStartWidth: $(i).add(0.02).equal(),
        borderInlineStartWidth: 0,
        borderInlineEndWidth: i,
        cursor: "pointer",
        transition: [`color ${l}`, `background ${l}`, `box-shadow ${l}`].join(
          ","
        ),
        a: { color: e },
        [`> ${r}-button`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          zIndex: -1,
          width: "100%",
          height: "100%",
        },
        "&:not(:first-child)": {
          "&::before": {
            position: "absolute",
            insetBlockStart: $(i).mul(-1).equal(),
            insetInlineStart: $(i).mul(-1).equal(),
            display: "block",
            boxSizing: "content-box",
            width: 1,
            height: "100%",
            paddingBlock: i,
            paddingInline: 0,
            backgroundColor: o,
            transition: `background-color ${a}`,
            content: '""',
          },
        },
        "&:first-child": {
          borderInlineStart: `${jt(i)} ${s} ${o}`,
          borderStartStartRadius: y,
          borderEndStartRadius: y,
        },
        "&:last-child": { borderStartEndRadius: y, borderEndEndRadius: y },
        "&:first-child:last-child": { borderRadius: y },
        [`${r}-group-large &`]: {
          height: m,
          fontSize: h,
          lineHeight: jt($(m).sub($(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: _,
            borderEndStartRadius: _,
          },
          "&:last-child": { borderStartEndRadius: _, borderEndEndRadius: _ },
        },
        [`${r}-group-small &`]: {
          height: g,
          paddingInline: $(x).sub(i).equal(),
          paddingBlock: 0,
          lineHeight: jt($(g).sub($(i).mul(2)).equal()),
          "&:first-child": {
            borderStartStartRadius: v,
            borderEndStartRadius: v,
          },
          "&:last-child": { borderStartEndRadius: v, borderEndEndRadius: v },
        },
        "&:hover": { position: "relative", color: R },
        "&:has(:focus-visible)": Object.assign({}, uR(n)),
        [`${r}-inner, input[type='checkbox'], input[type='radio']`]: {
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none",
        },
        [`&-checked:not(${r}-button-wrapper-disabled)`]: {
          zIndex: 1,
          color: R,
          background: S,
          borderColor: R,
          "&::before": { backgroundColor: R },
          "&:first-child": { borderColor: R },
          "&:hover": {
            color: C,
            borderColor: C,
            "&::before": { backgroundColor: C },
          },
          "&:active": {
            color: L,
            borderColor: L,
            "&::before": { backgroundColor: L },
          },
        },
        [`${r}-group-solid &-checked:not(${r}-button-wrapper-disabled)`]: {
          color: w,
          background: O,
          borderColor: O,
          "&:hover": { color: w, background: D, borderColor: D },
          "&:active": { color: w, background: B, borderColor: B },
        },
        "&-disabled": {
          color: T,
          backgroundColor: E,
          borderColor: o,
          cursor: "not-allowed",
          "&:first-child, &:hover": {
            color: T,
            backgroundColor: E,
            borderColor: o,
          },
        },
        [`&-disabled${r}-button-wrapper-checked`]: {
          color: N,
          backgroundColor: M,
          borderColor: o,
          boxShadow: "none",
        },
      },
    };
  },
  $le = (n) => {
    const {
        wireframe: e,
        padding: t,
        marginXS: r,
        lineWidth: i,
        fontSizeLG: s,
        colorText: o,
        colorBgContainer: a,
        colorTextDisabled: l,
        controlItemBgActiveDisabled: c,
        colorTextLightSolid: u,
        colorPrimary: d,
        colorPrimaryHover: h,
        colorPrimaryActive: m,
        colorWhite: g,
      } = n,
      x = 4,
      y = s,
      v = e ? y - x * 2 : y - (x + i) * 2;
    return {
      radioSize: y,
      dotSize: v,
      dotColorDisabled: l,
      buttonSolidCheckedColor: u,
      buttonSolidCheckedBg: d,
      buttonSolidCheckedHoverBg: h,
      buttonSolidCheckedActiveBg: m,
      buttonBg: a,
      buttonCheckedBg: a,
      buttonColor: o,
      buttonCheckedBgDisabled: c,
      buttonCheckedColorDisabled: l,
      buttonPaddingInline: t - i,
      wrapperMarginInlineEnd: r,
      radioColor: e ? d : g,
      radioBgColor: e ? a : d,
    };
  },
  dV = hp(
    "Radio",
    (n) => {
      const { controlOutline: e, controlOutlineWidth: t } = n,
        r = `0 0 0 ${jt(t)} ${e}`,
        s = mo(n, { radioFocusShadow: r, radioButtonFocusShadow: r });
      return [Gle(s), Wle(s), jle(s)];
    },
    $le,
    { unitless: { radioSize: !0, dotSize: !0 } }
  );
var Xle = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Yle = (n, e) => {
    var t, r;
    const i = I.useContext(cV),
      s = I.useContext(uV),
      { getPrefixCls: o, direction: a, radio: l } = I.useContext(mr),
      c = I.useRef(null),
      u = eu(e, c),
      { isFormItemInput: d } = I.useContext(Bl),
      h = (B) => {
        var $, G;
        ($ = n.onChange) === null || $ === void 0 || $.call(n, B),
          (G = i == null ? void 0 : i.onChange) === null ||
            G === void 0 ||
            G.call(i, B);
      },
      {
        prefixCls: m,
        className: g,
        rootClassName: x,
        children: y,
        style: v,
        title: _,
      } = n,
      S = Xle(n, [
        "prefixCls",
        "className",
        "rootClassName",
        "children",
        "style",
        "title",
      ]),
      w = o("radio", m),
      T = ((i == null ? void 0 : i.optionType) || s) === "button",
      E = T ? `${w}-button` : w,
      M = kd(w),
      [N, R, C] = dV(w, M),
      L = Object.assign({}, S),
      O = I.useContext(Ed);
    i &&
      ((L.name = i.name),
      (L.onChange = h),
      (L.checked = n.value === i.value),
      (L.disabled =
        (t = L.disabled) !== null && t !== void 0 ? t : i.disabled)),
      (L.disabled = (r = L.disabled) !== null && r !== void 0 ? r : O);
    const D = Mt(
      `${E}-wrapper`,
      {
        [`${E}-wrapper-checked`]: L.checked,
        [`${E}-wrapper-disabled`]: L.disabled,
        [`${E}-wrapper-rtl`]: a === "rtl",
        [`${E}-wrapper-in-form-item`]: d,
      },
      l == null ? void 0 : l.className,
      g,
      x,
      R,
      C,
      M
    );
    return N(
      I.createElement(
        X5,
        { component: "Radio", disabled: L.disabled },
        I.createElement(
          "label",
          {
            className: D,
            style: Object.assign(
              Object.assign({}, l == null ? void 0 : l.style),
              v
            ),
            onMouseEnter: n.onMouseEnter,
            onMouseLeave: n.onMouseLeave,
            title: _,
          },
          I.createElement(
            Hle,
            Object.assign({}, L, {
              className: Mt(L.className, !T && pR),
              type: "radio",
              prefixCls: E,
              ref: u,
            })
          ),
          y !== void 0 ? I.createElement("span", null, y) : null
        )
      )
    );
  },
  I1 = I.forwardRef(Yle),
  qle = I.forwardRef((n, e) => {
    const { getPrefixCls: t, direction: r } = I.useContext(mr),
      [i, s] = fp(n.defaultValue, { value: n.value }),
      o = (B) => {
        const $ = i,
          G = B.target.value;
        "value" in n || s(G);
        const { onChange: j } = n;
        j && G !== $ && j(B);
      },
      {
        prefixCls: a,
        className: l,
        rootClassName: c,
        options: u,
        buttonStyle: d = "outline",
        disabled: h,
        children: m,
        size: g,
        style: x,
        id: y,
        onMouseEnter: v,
        onMouseLeave: _,
        onFocus: S,
        onBlur: w,
      } = n,
      T = t("radio", a),
      E = `${T}-group`,
      M = kd(T),
      [N, R, C] = dV(T, M);
    let L = m;
    u &&
      u.length > 0 &&
      (L = u.map((B) =>
        typeof B == "string" || typeof B == "number"
          ? I.createElement(
              I1,
              {
                key: B.toString(),
                prefixCls: T,
                disabled: h,
                value: B,
                checked: i === B,
              },
              B
            )
          : I.createElement(
              I1,
              {
                key: `radio-group-value-options-${B.value}`,
                prefixCls: T,
                disabled: B.disabled || h,
                value: B.value,
                checked: i === B.value,
                title: B.title,
                style: B.style,
                id: B.id,
                required: B.required,
              },
              B.label
            )
      ));
    const O = Bd(g),
      D = Mt(
        E,
        `${E}-${d}`,
        { [`${E}-${O}`]: O, [`${E}-rtl`]: r === "rtl" },
        l,
        c,
        R,
        C,
        M
      );
    return N(
      I.createElement(
        "div",
        Object.assign({}, dS(n, { aria: !0, data: !0 }), {
          className: D,
          style: x,
          onMouseEnter: v,
          onMouseLeave: _,
          onFocus: S,
          onBlur: w,
          id: y,
          ref: e,
        }),
        I.createElement(
          zle,
          {
            value: {
              onChange: o,
              value: i,
              disabled: n.disabled,
              name: n.name,
              optionType: n.optionType,
            },
          },
          L
        )
      )
    );
  }),
  Kle = I.memo(qle);
var Zle = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Qle = (n, e) => {
    const { getPrefixCls: t } = I.useContext(mr),
      { prefixCls: r } = n,
      i = Zle(n, ["prefixCls"]),
      s = t("radio", r);
    return I.createElement(
      Ble,
      { value: "button" },
      I.createElement(
        I1,
        Object.assign({ prefixCls: s }, i, { type: "radio", ref: e })
      )
    );
  },
  Jle = I.forwardRef(Qle),
  qg = I1;
qg.Button = Jle;
qg.Group = Kle;
qg.__ANT_RADIO = !0;
function fV(n) {
  return mo(n, { inputAffixPadding: n.paddingXXS });
}
const hV = (n) => {
    const {
      controlHeight: e,
      fontSize: t,
      lineHeight: r,
      lineWidth: i,
      controlHeightSM: s,
      controlHeightLG: o,
      fontSizeLG: a,
      lineHeightLG: l,
      paddingSM: c,
      controlPaddingHorizontalSM: u,
      controlPaddingHorizontal: d,
      colorFillAlter: h,
      colorPrimaryHover: m,
      colorPrimary: g,
      controlOutlineWidth: x,
      controlOutline: y,
      colorErrorOutline: v,
      colorWarningOutline: _,
      colorBgContainer: S,
    } = n;
    return {
      paddingBlock: Math.max(Math.round(((e - t * r) / 2) * 10) / 10 - i, 0),
      paddingBlockSM: Math.max(Math.round(((s - t * r) / 2) * 10) / 10 - i, 0),
      paddingBlockLG: Math.ceil(((o - a * l) / 2) * 10) / 10 - i,
      paddingInline: c - i,
      paddingInlineSM: u - i,
      paddingInlineLG: d - i,
      addonBg: h,
      activeBorderColor: g,
      hoverBorderColor: m,
      activeShadow: `0 0 0 ${x}px ${y}`,
      errorActiveShadow: `0 0 0 ${x}px ${v}`,
      warningActiveShadow: `0 0 0 ${x}px ${_}`,
      hoverBg: S,
      activeBg: S,
      inputFontSize: t,
      inputFontSizeLG: a,
      inputFontSizeSM: t,
    };
  },
  ece = (n) => ({
    borderColor: n.hoverBorderColor,
    backgroundColor: n.hoverBg,
  }),
  _R = (n) => ({
    color: n.colorTextDisabled,
    backgroundColor: n.colorBgContainerDisabled,
    borderColor: n.colorBorder,
    boxShadow: "none",
    cursor: "not-allowed",
    opacity: 1,
    "input[disabled], textarea[disabled]": { cursor: "not-allowed" },
    "&:hover:not([disabled])": Object.assign(
      {},
      ece(
        mo(n, {
          hoverBorderColor: n.colorBorder,
          hoverBg: n.colorBgContainerDisabled,
        })
      )
    ),
  }),
  pV = (n, e) => ({
    background: n.colorBgContainer,
    borderWidth: n.lineWidth,
    borderStyle: n.lineType,
    borderColor: e.borderColor,
    "&:hover": { borderColor: e.hoverBorderColor, backgroundColor: n.hoverBg },
    "&:focus, &:focus-within": {
      borderColor: e.activeBorderColor,
      boxShadow: e.activeShadow,
      outline: 0,
      backgroundColor: n.activeBg,
    },
  }),
  sD = (n, e) => ({
    [`&${n.componentCls}-status-${e.status}:not(${n.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, pV(n, e)), {
        [`${n.componentCls}-prefix, ${n.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
    [`&${n.componentCls}-status-${e.status}${n.componentCls}-disabled`]: {
      borderColor: e.borderColor,
    },
  }),
  tce = (n, e) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              pV(n, {
                borderColor: n.colorBorder,
                hoverBorderColor: n.hoverBorderColor,
                activeBorderColor: n.activeBorderColor,
                activeShadow: n.activeShadow,
              })
            ),
            {
              [`&${n.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                _R(n)
              ),
            }
          ),
          sD(n, {
            status: "error",
            borderColor: n.colorError,
            hoverBorderColor: n.colorErrorBorderHover,
            activeBorderColor: n.colorError,
            activeShadow: n.errorActiveShadow,
            affixColor: n.colorError,
          })
        ),
        sD(n, {
          status: "warning",
          borderColor: n.colorWarning,
          hoverBorderColor: n.colorWarningBorderHover,
          activeBorderColor: n.colorWarning,
          activeShadow: n.warningActiveShadow,
          affixColor: n.colorWarning,
        })
      ),
      e
    ),
  }),
  oD = (n, e) => ({
    [`&${n.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${n.componentCls}-group-addon`]: {
        borderColor: e.addonBorderColor,
        color: e.addonColor,
      },
    },
  }),
  nce = (n) => ({
    "&-outlined": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${n.componentCls}-group`]: {
              "&-addon": {
                background: n.addonBg,
                border: `${jt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
              },
              "&-addon:first-child": { borderInlineEnd: 0 },
              "&-addon:last-child": { borderInlineStart: 0 },
            },
          },
          oD(n, {
            status: "error",
            addonBorderColor: n.colorError,
            addonColor: n.colorErrorText,
          })
        ),
        oD(n, {
          status: "warning",
          addonBorderColor: n.colorWarning,
          addonColor: n.colorWarningText,
        })
      ),
      {
        [`&${n.componentCls}-group-wrapper-disabled`]: {
          [`${n.componentCls}-group-addon`]: Object.assign({}, _R(n)),
        },
      }
    ),
  }),
  rce = (n, e) => ({
    "&-borderless": Object.assign(
      {
        background: "transparent",
        border: "none",
        "&:focus, &:focus-within": { outline: "none" },
        [`&${n.componentCls}-disabled, &[disabled]`]: {
          color: n.colorTextDisabled,
        },
      },
      e
    ),
  }),
  mV = (n, e) => ({
    background: e.bg,
    borderWidth: n.lineWidth,
    borderStyle: n.lineType,
    borderColor: "transparent",
    "input&, & input, textarea&, & textarea": {
      color: e == null ? void 0 : e.inputColor,
    },
    "&:hover": { background: e.hoverBg },
    "&:focus, &:focus-within": {
      outline: 0,
      borderColor: e.activeBorderColor,
      backgroundColor: n.activeBg,
    },
  }),
  aD = (n, e) => ({
    [`&${n.componentCls}-status-${e.status}:not(${n.componentCls}-disabled)`]:
      Object.assign(Object.assign({}, mV(n, e)), {
        [`${n.componentCls}-prefix, ${n.componentCls}-suffix`]: {
          color: e.affixColor,
        },
      }),
  }),
  ice = (n, e) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              mV(n, {
                bg: n.colorFillTertiary,
                hoverBg: n.colorFillSecondary,
                activeBorderColor: n.colorPrimary,
              })
            ),
            {
              [`&${n.componentCls}-disabled, &[disabled]`]: Object.assign(
                {},
                _R(n)
              ),
            }
          ),
          aD(n, {
            status: "error",
            bg: n.colorErrorBg,
            hoverBg: n.colorErrorBgHover,
            activeBorderColor: n.colorError,
            inputColor: n.colorErrorText,
            affixColor: n.colorError,
          })
        ),
        aD(n, {
          status: "warning",
          bg: n.colorWarningBg,
          hoverBg: n.colorWarningBgHover,
          activeBorderColor: n.colorWarning,
          inputColor: n.colorWarningText,
          affixColor: n.colorWarning,
        })
      ),
      e
    ),
  }),
  lD = (n, e) => ({
    [`&${n.componentCls}-group-wrapper-status-${e.status}`]: {
      [`${n.componentCls}-group-addon`]: {
        background: e.addonBg,
        color: e.addonColor,
      },
    },
  }),
  sce = (n) => ({
    "&-filled": Object.assign(
      Object.assign(
        Object.assign(
          {
            [`${n.componentCls}-group`]: {
              "&-addon": { background: n.colorFillTertiary },
              [`${n.componentCls}-filled:not(:focus):not(:focus-within)`]: {
                "&:not(:first-child)": {
                  borderInlineStart: `${jt(n.lineWidth)} ${n.lineType} ${
                    n.colorSplit
                  }`,
                },
                "&:not(:last-child)": {
                  borderInlineEnd: `${jt(n.lineWidth)} ${n.lineType} ${
                    n.colorSplit
                  }`,
                },
              },
            },
          },
          lD(n, {
            status: "error",
            addonBg: n.colorErrorBg,
            addonColor: n.colorErrorText,
          })
        ),
        lD(n, {
          status: "warning",
          addonBg: n.colorWarningBg,
          addonColor: n.colorWarningText,
        })
      ),
      {
        [`&${n.componentCls}-group-wrapper-disabled`]: {
          [`${n.componentCls}-group`]: {
            "&-addon": {
              background: n.colorFillTertiary,
              color: n.colorTextDisabled,
            },
            "&-addon:first-child": {
              borderInlineStart: `${jt(n.lineWidth)} ${n.lineType} ${
                n.colorBorder
              }`,
              borderTop: `${jt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
              borderBottom: `${jt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
            },
            "&-addon:last-child": {
              borderInlineEnd: `${jt(n.lineWidth)} ${n.lineType} ${
                n.colorBorder
              }`,
              borderTop: `${jt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
              borderBottom: `${jt(n.lineWidth)} ${n.lineType} ${n.colorBorder}`,
            },
          },
        },
      }
    ),
  }),
  oce = (n) => ({
    "&::-moz-placeholder": { opacity: 1 },
    "&::placeholder": { color: n, userSelect: "none" },
    "&:placeholder-shown": { textOverflow: "ellipsis" },
  }),
  gV = (n) => {
    const {
      paddingBlockLG: e,
      lineHeightLG: t,
      borderRadiusLG: r,
      paddingInlineLG: i,
    } = n;
    return {
      padding: `${jt(e)} ${jt(i)}`,
      fontSize: n.inputFontSizeLG,
      lineHeight: t,
      borderRadius: r,
    };
  },
  vV = (n) => ({
    padding: `${jt(n.paddingBlockSM)} ${jt(n.paddingInlineSM)}`,
    fontSize: n.inputFontSizeSM,
    borderRadius: n.borderRadiusSM,
  }),
  yV = (n) =>
    Object.assign(
      Object.assign(
        {
          position: "relative",
          display: "inline-block",
          width: "100%",
          minWidth: 0,
          padding: `${jt(n.paddingBlock)} ${jt(n.paddingInline)}`,
          color: n.colorText,
          fontSize: n.inputFontSize,
          lineHeight: n.lineHeight,
          borderRadius: n.borderRadius,
          transition: `all ${n.motionDurationMid}`,
        },
        oce(n.colorTextPlaceholder)
      ),
      {
        "textarea&": {
          maxWidth: "100%",
          height: "auto",
          minHeight: n.controlHeight,
          lineHeight: n.lineHeight,
          verticalAlign: "bottom",
          transition: `all ${n.motionDurationSlow}, height 0s`,
          resize: "vertical",
        },
        "&-lg": Object.assign({}, gV(n)),
        "&-sm": Object.assign({}, vV(n)),
        "&-rtl, &-textarea-rtl": { direction: "rtl" },
      }
    ),
  ace = (n) => {
    const { componentCls: e, antCls: t } = n;
    return {
      position: "relative",
      display: "table",
      width: "100%",
      borderCollapse: "separate",
      borderSpacing: 0,
      "&[class*='col-']": {
        paddingInlineEnd: n.paddingXS,
        "&:last-child": { paddingInlineEnd: 0 },
      },
      [`&-lg ${e}, &-lg > ${e}-group-addon`]: Object.assign({}, gV(n)),
      [`&-sm ${e}, &-sm > ${e}-group-addon`]: Object.assign({}, vV(n)),
      [`&-lg ${t}-select-single ${t}-select-selector`]: {
        height: n.controlHeightLG,
      },
      [`&-sm ${t}-select-single ${t}-select-selector`]: {
        height: n.controlHeightSM,
      },
      [`> ${e}`]: {
        display: "table-cell",
        "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
      },
      [`${e}-group`]: {
        "&-addon, &-wrap": {
          display: "table-cell",
          width: 1,
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          "&:not(:first-child):not(:last-child)": { borderRadius: 0 },
        },
        "&-wrap > *": { display: "block !important" },
        "&-addon": {
          position: "relative",
          padding: `0 ${jt(n.paddingInline)}`,
          color: n.colorText,
          fontWeight: "normal",
          fontSize: n.inputFontSize,
          textAlign: "center",
          borderRadius: n.borderRadius,
          transition: `all ${n.motionDurationSlow}`,
          lineHeight: 1,
          [`${t}-select`]: {
            margin: `${jt(n.calc(n.paddingBlock).add(1).mul(-1).equal())} ${jt(
              n.calc(n.paddingInline).mul(-1).equal()
            )}`,
            [`&${t}-select-single:not(${t}-select-customize-input):not(${t}-pagination-size-changer)`]:
              {
                [`${t}-select-selector`]: {
                  backgroundColor: "inherit",
                  border: `${jt(n.lineWidth)} ${n.lineType} transparent`,
                  boxShadow: "none",
                },
              },
            "&-open, &-focused": {
              [`${t}-select-selector`]: { color: n.colorPrimary },
            },
          },
          [`${t}-cascader-picker`]: {
            margin: `-9px ${jt(n.calc(n.paddingInline).mul(-1).equal())}`,
            backgroundColor: "transparent",
            [`${t}-cascader-input`]: {
              textAlign: "start",
              border: 0,
              boxShadow: "none",
            },
          },
        },
      },
      [`${e}`]: {
        width: "100%",
        marginBottom: 0,
        textAlign: "inherit",
        "&:focus": { zIndex: 1, borderInlineEndWidth: 1 },
        "&:hover": {
          zIndex: 1,
          borderInlineEndWidth: 1,
          [`${e}-search-with-button &`]: { zIndex: 0 },
        },
      },
      [`> ${e}:first-child, ${e}-group-addon:first-child`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-select ${t}-select-selector`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}-affix-wrapper`]: {
        [`&:not(:first-child) ${e}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
        [`&:not(:last-child) ${e}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
        },
      },
      [`> ${e}:last-child, ${e}-group-addon:last-child`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0,
        [`${t}-select ${t}-select-selector`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`${e}-affix-wrapper`]: {
        "&:not(:last-child)": {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          [`${e}-search &`]: {
            borderStartStartRadius: n.borderRadius,
            borderEndStartRadius: n.borderRadius,
          },
        },
        [`&:not(:first-child), ${e}-search &:not(:first-child)`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
        },
      },
      [`&${e}-group-compact`]: Object.assign(
        Object.assign({ display: "block" }, Hie()),
        {
          [`${e}-group-addon, ${e}-group-wrap, > ${e}`]: {
            "&:not(:first-child):not(:last-child)": {
              borderInlineEndWidth: n.lineWidth,
              "&:hover, &:focus": { zIndex: 1 },
            },
          },
          "& > *": {
            display: "inline-block",
            float: "none",
            verticalAlign: "top",
            borderRadius: 0,
          },
          [`
        & > ${e}-affix-wrapper,
        & > ${e}-number-affix-wrapper,
        & > ${t}-picker-range
      `]: { display: "inline-flex" },
          "& > *:not(:last-child)": {
            marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: n.lineWidth,
          },
          [`${e}`]: { float: "none" },
          [`& > ${t}-select > ${t}-select-selector,
      & > ${t}-select-auto-complete ${e},
      & > ${t}-cascader-picker ${e},
      & > ${e}-group-wrapper ${e}`]: {
            borderInlineEndWidth: n.lineWidth,
            borderRadius: 0,
            "&:hover, &:focus": { zIndex: 1 },
          },
          [`& > ${t}-select-focused`]: { zIndex: 1 },
          [`& > ${t}-select > ${t}-select-arrow`]: { zIndex: 1 },
          [`& > *:first-child,
      & > ${t}-select:first-child > ${t}-select-selector,
      & > ${t}-select-auto-complete:first-child ${e},
      & > ${t}-cascader-picker:first-child ${e}`]: {
            borderStartStartRadius: n.borderRadius,
            borderEndStartRadius: n.borderRadius,
          },
          [`& > *:last-child,
      & > ${t}-select:last-child > ${t}-select-selector,
      & > ${t}-cascader-picker:last-child ${e},
      & > ${t}-cascader-picker-focused:last-child ${e}`]: {
            borderInlineEndWidth: n.lineWidth,
            borderStartEndRadius: n.borderRadius,
            borderEndEndRadius: n.borderRadius,
          },
          [`& > ${t}-select-auto-complete ${e}`]: { verticalAlign: "top" },
          [`${e}-group-wrapper + ${e}-group-wrapper`]: {
            marginInlineStart: n.calc(n.lineWidth).mul(-1).equal(),
            [`${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`${e}-group-wrapper:not(:last-child)`]: {
            [`&${e}-search > ${e}-group`]: {
              [`& > ${e}-group-addon > ${e}-search-button`]: {
                borderRadius: 0,
              },
              [`& > ${e}`]: {
                borderStartStartRadius: n.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: n.borderRadius,
              },
            },
          },
        }
      ),
    };
  },
  lce = (n) => {
    const { componentCls: e, controlHeightSM: t, lineWidth: r, calc: i } = n,
      o = i(t).sub(i(r).mul(2)).sub(16).div(2).equal();
    return {
      [e]: Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(Object.assign({}, Md(n)), yV(n)),
              tce(n)
            ),
            ice(n)
          ),
          rce(n)
        ),
        {
          '&[type="color"]': {
            height: n.controlHeight,
            [`&${e}-lg`]: { height: n.controlHeightLG },
            [`&${e}-sm`]: { height: t, paddingTop: o, paddingBottom: o },
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration':
            { "-webkit-appearance": "none" },
        }
      ),
    };
  },
  cce = (n) => {
    const { componentCls: e } = n;
    return {
      [`${e}-clear-icon`]: {
        margin: 0,
        color: n.colorTextQuaternary,
        fontSize: n.fontSizeIcon,
        verticalAlign: -1,
        cursor: "pointer",
        transition: `color ${n.motionDurationSlow}`,
        "&:hover": { color: n.colorTextTertiary },
        "&:active": { color: n.colorText },
        "&-hidden": { visibility: "hidden" },
        "&-has-suffix": { margin: `0 ${jt(n.inputAffixPadding)}` },
      },
    };
  },
  uce = (n) => {
    const {
      componentCls: e,
      inputAffixPadding: t,
      colorTextDescription: r,
      motionDurationSlow: i,
      colorIcon: s,
      colorIconHover: o,
      iconCls: a,
    } = n;
    return {
      [`${e}-affix-wrapper`]: Object.assign(
        Object.assign(
          Object.assign(Object.assign({}, yV(n)), {
            display: "inline-flex",
            [`&:not(${e}-disabled):hover`]: {
              zIndex: 1,
              [`${e}-search-with-button &`]: { zIndex: 0 },
            },
            "&-focused, &:focus": { zIndex: 1 },
            [`> input${e}`]: { padding: 0 },
            [`> input${e}, > textarea${e}`]: {
              fontSize: "inherit",
              border: "none",
              borderRadius: 0,
              outline: "none",
              background: "transparent",
              color: "inherit",
              "&::-ms-reveal": { display: "none" },
              "&:focus": { boxShadow: "none !important" },
            },
            "&::before": {
              display: "inline-block",
              width: 0,
              visibility: "hidden",
              content: '"\\a0"',
            },
            [`${e}`]: {
              "&-prefix, &-suffix": {
                display: "flex",
                flex: "none",
                alignItems: "center",
                "> *:not(:last-child)": { marginInlineEnd: n.paddingXS },
              },
              "&-show-count-suffix": { color: r },
              "&-show-count-has-suffix": { marginInlineEnd: n.paddingXXS },
              "&-prefix": { marginInlineEnd: t },
              "&-suffix": { marginInlineStart: t },
            },
          }),
          cce(n)
        ),
        {
          [`${a}${e}-password-icon`]: {
            color: s,
            cursor: "pointer",
            transition: `all ${i}`,
            "&:hover": { color: o },
          },
        }
      ),
    };
  },
  dce = (n) => {
    const { componentCls: e, borderRadiusLG: t, borderRadiusSM: r } = n;
    return {
      [`${e}-group`]: Object.assign(
        Object.assign(Object.assign({}, Md(n)), ace(n)),
        {
          "&-rtl": { direction: "rtl" },
          "&-wrapper": Object.assign(
            Object.assign(
              Object.assign(
                {
                  display: "inline-block",
                  width: "100%",
                  textAlign: "start",
                  verticalAlign: "top",
                  "&-rtl": { direction: "rtl" },
                  "&-lg": {
                    [`${e}-group-addon`]: {
                      borderRadius: t,
                      fontSize: n.inputFontSizeLG,
                    },
                  },
                  "&-sm": { [`${e}-group-addon`]: { borderRadius: r } },
                },
                nce(n)
              ),
              sce(n)
            ),
            {
              [`&:not(${e}-compact-first-item):not(${e}-compact-last-item)${e}-compact-item`]:
                { [`${e}, ${e}-group-addon`]: { borderRadius: 0 } },
              [`&:not(${e}-compact-last-item)${e}-compact-first-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
              [`&:not(${e}-compact-first-item)${e}-compact-last-item`]: {
                [`${e}, ${e}-group-addon`]: {
                  borderStartStartRadius: 0,
                  borderEndStartRadius: 0,
                },
              },
              [`&:not(${e}-compact-last-item)${e}-compact-item`]: {
                [`${e}-affix-wrapper`]: {
                  borderStartEndRadius: 0,
                  borderEndEndRadius: 0,
                },
              },
            }
          ),
        }
      ),
    };
  },
  fce = (n) => {
    const { componentCls: e, antCls: t } = n,
      r = `${e}-search`;
    return {
      [r]: {
        [`${e}`]: {
          "&:hover, &:focus": {
            borderColor: n.colorPrimaryHover,
            [`+ ${e}-group-addon ${r}-button:not(${t}-btn-primary)`]: {
              borderInlineStartColor: n.colorPrimaryHover,
            },
          },
        },
        [`${e}-affix-wrapper`]: { borderRadius: 0 },
        [`${e}-lg`]: {
          lineHeight: n.calc(n.lineHeightLG).sub(2e-4).equal({ unit: !1 }),
        },
        [`> ${e}-group`]: {
          [`> ${e}-group-addon:last-child`]: {
            insetInlineStart: -1,
            padding: 0,
            border: 0,
            [`${r}-button`]: {
              marginInlineEnd: -1,
              paddingTop: 0,
              paddingBottom: 0,
              borderStartStartRadius: 0,
              borderStartEndRadius: n.borderRadius,
              borderEndEndRadius: n.borderRadius,
              borderEndStartRadius: 0,
              boxShadow: "none",
            },
            [`${r}-button:not(${t}-btn-primary)`]: {
              color: n.colorTextDescription,
              "&:hover": { color: n.colorPrimaryHover },
              "&:active": { color: n.colorPrimaryActive },
              [`&${t}-btn-loading::before`]: {
                insetInlineStart: 0,
                insetInlineEnd: 0,
                insetBlockStart: 0,
                insetBlockEnd: 0,
              },
            },
          },
        },
        [`${r}-button`]: {
          height: n.controlHeight,
          "&:hover, &:focus": { zIndex: 1 },
        },
        [`&-large ${r}-button`]: { height: n.controlHeightLG },
        [`&-small ${r}-button`]: { height: n.controlHeightSM },
        "&-rtl": { direction: "rtl" },
        [`&${e}-compact-item`]: {
          [`&:not(${e}-compact-last-item)`]: {
            [`${e}-group-addon`]: {
              [`${e}-search-button`]: {
                marginInlineEnd: n.calc(n.lineWidth).mul(-1).equal(),
                borderRadius: 0,
              },
            },
          },
          [`&:not(${e}-compact-first-item)`]: {
            [`${e},${e}-affix-wrapper`]: { borderRadius: 0 },
          },
          [`> ${e}-group-addon ${e}-search-button,
        > ${e},
        ${e}-affix-wrapper`]: { "&:hover, &:focus, &:active": { zIndex: 2 } },
          [`> ${e}-affix-wrapper-focused`]: { zIndex: 2 },
        },
      },
    };
  },
  hce = (n) => {
    const { componentCls: e, paddingLG: t } = n,
      r = `${e}-textarea`;
    return {
      [r]: {
        position: "relative",
        "&-show-count": {
          [`> ${e}`]: { height: "100%" },
          [`${e}-data-count`]: {
            position: "absolute",
            bottom: n.calc(n.fontSize).mul(n.lineHeight).mul(-1).equal(),
            insetInlineEnd: 0,
            color: n.colorTextDescription,
            whiteSpace: "nowrap",
            pointerEvents: "none",
          },
        },
        [`
        &-allow-clear > ${e},
        &-affix-wrapper${r}-has-feedback ${e}
      `]: { paddingInlineEnd: t },
        [`&-affix-wrapper${e}-affix-wrapper`]: {
          padding: 0,
          [`> textarea${e}`]: {
            fontSize: "inherit",
            border: "none",
            outline: "none",
            background: "transparent",
            "&:focus": { boxShadow: "none !important" },
          },
          [`${e}-suffix`]: {
            margin: 0,
            "> *:not(:last-child)": { marginInline: 0 },
            [`${e}-clear-icon`]: {
              position: "absolute",
              insetInlineEnd: n.paddingXS,
              insetBlockStart: n.paddingXS,
            },
            [`${r}-suffix`]: {
              position: "absolute",
              top: 0,
              insetInlineEnd: n.paddingInline,
              bottom: 0,
              zIndex: 1,
              display: "inline-flex",
              alignItems: "center",
              margin: "auto",
              pointerEvents: "none",
            },
          },
        },
      },
    };
  },
  pce = (n) => {
    const { componentCls: e } = n;
    return {
      [`${e}-out-of-range`]: {
        [`&, & input, & textarea, ${e}-show-count-suffix, ${e}-data-count`]: {
          color: n.colorError,
        },
      },
    };
  },
  SR = hp(
    "Input",
    (n) => {
      const e = mo(n, fV(n));
      return [lce(e), hce(e), uce(e), dce(e), fce(e), pce(e), tV(e)];
    },
    hV,
    { resetFont: !1 }
  );
var xV = Je.forwardRef(function (n, e) {
  var t = n.prefixCls,
    r = n.forceRender,
    i = n.className,
    s = n.style,
    o = n.children,
    a = n.isActive,
    l = n.role,
    c = Je.useState(a || r),
    u = Et(c, 2),
    d = u[0],
    h = u[1];
  return (
    Je.useEffect(
      function () {
        (r || a) && h(!0);
      },
      [r, a]
    ),
    d
      ? Je.createElement(
          "div",
          {
            ref: e,
            className: Mt(
              "".concat(t, "-content"),
              Te(
                Te({}, "".concat(t, "-content-active"), a),
                "".concat(t, "-content-inactive"),
                !a
              ),
              i
            ),
            style: s,
            role: l,
          },
          Je.createElement(
            "div",
            { className: "".concat(t, "-content-box") },
            o
          )
        )
      : null
  );
});
xV.displayName = "PanelContent";
var mce = [
    "showArrow",
    "headerClass",
    "isActive",
    "onItemClick",
    "forceRender",
    "className",
    "prefixCls",
    "collapsible",
    "accordion",
    "panelKey",
    "extra",
    "header",
    "expandIcon",
    "openMotion",
    "destroyInactivePanel",
    "children",
  ],
  _V = Je.forwardRef(function (n, e) {
    var t = n.showArrow,
      r = t === void 0 ? !0 : t,
      i = n.headerClass,
      s = n.isActive,
      o = n.onItemClick,
      a = n.forceRender,
      l = n.className,
      c = n.prefixCls,
      u = n.collapsible,
      d = n.accordion,
      h = n.panelKey,
      m = n.extra,
      g = n.header,
      x = n.expandIcon,
      y = n.openMotion,
      v = n.destroyInactivePanel,
      _ = n.children,
      S = xi(n, mce),
      w = u === "disabled",
      T = u === "header",
      E = u === "icon",
      M = m != null && typeof m != "boolean",
      N = function () {
        o == null || o(h);
      },
      R = function ($) {
        ($.key === "Enter" || $.keyCode === Bt.ENTER || $.which === Bt.ENTER) &&
          N();
      },
      C =
        typeof x == "function"
          ? x(n)
          : Je.createElement("i", { className: "arrow" });
    C &&
      (C = Je.createElement(
        "div",
        {
          className: "".concat(c, "-expand-icon"),
          onClick: ["header", "icon"].includes(u) ? N : void 0,
        },
        C
      ));
    var L = Mt(
        Te(
          Te(
            Te({}, "".concat(c, "-item"), !0),
            "".concat(c, "-item-active"),
            s
          ),
          "".concat(c, "-item-disabled"),
          w
        ),
        l
      ),
      O = Mt(
        i,
        Te(
          Te(
            Te({}, "".concat(c, "-header"), !0),
            "".concat(c, "-header-collapsible-only"),
            T
          ),
          "".concat(c, "-icon-collapsible-only"),
          E
        )
      ),
      D = {
        className: O,
        "aria-expanded": s,
        "aria-disabled": w,
        onKeyDown: R,
      };
    return (
      !T &&
        !E &&
        ((D.onClick = N),
        (D.role = d ? "tab" : "button"),
        (D.tabIndex = w ? -1 : 0)),
      Je.createElement(
        "div",
        an({}, S, { ref: e, className: L }),
        Je.createElement(
          "div",
          D,
          r && C,
          Je.createElement(
            "span",
            {
              className: "".concat(c, "-header-text"),
              onClick: u === "header" ? N : void 0,
            },
            g
          ),
          M && Je.createElement("div", { className: "".concat(c, "-extra") }, m)
        ),
        Je.createElement(
          uS,
          an(
            { visible: s, leavedClassName: "".concat(c, "-content-hidden") },
            y,
            { forceRender: a, removeOnLeave: v }
          ),
          function (B, $) {
            var G = B.className,
              j = B.style;
            return Je.createElement(
              xV,
              {
                ref: $,
                prefixCls: c,
                className: G,
                style: j,
                isActive: s,
                forceRender: a,
                role: d ? "tabpanel" : void 0,
              },
              _
            );
          }
        )
      )
    );
  }),
  gce = [
    "children",
    "label",
    "key",
    "collapsible",
    "onItemClick",
    "destroyInactivePanel",
  ],
  vce = function (e, t) {
    var r = t.prefixCls,
      i = t.accordion,
      s = t.collapsible,
      o = t.destroyInactivePanel,
      a = t.onItemClick,
      l = t.activeKey,
      c = t.openMotion,
      u = t.expandIcon;
    return e.map(function (d, h) {
      var m = d.children,
        g = d.label,
        x = d.key,
        y = d.collapsible,
        v = d.onItemClick,
        _ = d.destroyInactivePanel,
        S = xi(d, gce),
        w = String(x ?? h),
        T = y ?? s,
        E = _ ?? o,
        M = function (C) {
          T !== "disabled" && (a(C), v == null || v(C));
        },
        N = !1;
      return (
        i ? (N = l[0] === w) : (N = l.indexOf(w) > -1),
        Je.createElement(
          _V,
          an({}, S, {
            prefixCls: r,
            key: w,
            panelKey: w,
            isActive: N,
            accordion: i,
            openMotion: c,
            expandIcon: u,
            header: g,
            collapsible: T,
            onItemClick: M,
            destroyInactivePanel: E,
          }),
          m
        )
      );
    });
  },
  yce = function (e, t, r) {
    if (!e) return null;
    var i = r.prefixCls,
      s = r.accordion,
      o = r.collapsible,
      a = r.destroyInactivePanel,
      l = r.onItemClick,
      c = r.activeKey,
      u = r.openMotion,
      d = r.expandIcon,
      h = e.key || String(t),
      m = e.props,
      g = m.header,
      x = m.headerClass,
      y = m.destroyInactivePanel,
      v = m.collapsible,
      _ = m.onItemClick,
      S = !1;
    s ? (S = c[0] === h) : (S = c.indexOf(h) > -1);
    var w = v ?? o,
      T = function (N) {
        w !== "disabled" && (l(N), _ == null || _(N));
      },
      E = {
        key: h,
        panelKey: h,
        header: g,
        headerClass: x,
        isActive: S,
        prefixCls: i,
        destroyInactivePanel: y ?? a,
        openMotion: u,
        accordion: s,
        children: e.props.children,
        onItemClick: T,
        expandIcon: d,
        collapsible: w,
      };
    return typeof e.type == "string"
      ? e
      : (Object.keys(E).forEach(function (M) {
          typeof E[M] > "u" && delete E[M];
        }),
        Je.cloneElement(e, E));
  };
function xce(n, e, t) {
  return Array.isArray(n)
    ? vce(n, t)
    : Vh(e).map(function (r, i) {
        return yce(r, i, t);
      });
}
function _ce(n) {
  var e = n;
  if (!Array.isArray(e)) {
    var t = $t(e);
    e = t === "number" || t === "string" ? [e] : [];
  }
  return e.map(function (r) {
    return String(r);
  });
}
var Sce = Je.forwardRef(function (n, e) {
  var t = n.prefixCls,
    r = t === void 0 ? "rc-collapse" : t,
    i = n.destroyInactivePanel,
    s = i === void 0 ? !1 : i,
    o = n.style,
    a = n.accordion,
    l = n.className,
    c = n.children,
    u = n.collapsible,
    d = n.openMotion,
    h = n.expandIcon,
    m = n.activeKey,
    g = n.defaultActiveKey,
    x = n.onChange,
    y = n.items,
    v = Mt(r, l),
    _ = fp([], {
      value: m,
      onChange: function (R) {
        return x == null ? void 0 : x(R);
      },
      defaultValue: g,
      postState: _ce,
    }),
    S = Et(_, 2),
    w = S[0],
    T = S[1],
    E = function (R) {
      return T(function () {
        if (a) return w[0] === R ? [] : [R];
        var C = w.indexOf(R),
          L = C > -1;
        return L
          ? w.filter(function (O) {
              return O !== R;
            })
          : [].concat(Ot(w), [R]);
      });
    };
  Es(
    !c,
    "[rc-collapse] `children` will be removed in next major version. Please use `items` instead."
  );
  var M = xce(y, c, {
    prefixCls: r,
    accordion: a,
    openMotion: d,
    expandIcon: h,
    collapsible: u,
    destroyInactivePanel: s,
    onItemClick: E,
    activeKey: w,
  });
  return Je.createElement(
    "div",
    an(
      { ref: e, className: v, style: o, role: a ? "tablist" : void 0 },
      dS(n, { aria: !0, data: !0 })
    ),
    M
  );
});
const AR = Object.assign(Sce, { Panel: _V });
AR.Panel;
const Ace = I.forwardRef((n, e) => {
    const { getPrefixCls: t } = I.useContext(mr),
      { prefixCls: r, className: i, showArrow: s = !0 } = n,
      o = t("collapse", r),
      a = Mt({ [`${o}-no-arrow`]: !s }, i);
    return I.createElement(
      AR.Panel,
      Object.assign({ ref: e }, n, { prefixCls: o, className: a })
    );
  }),
  wce = (n) => {
    const {
        componentCls: e,
        contentBg: t,
        padding: r,
        headerBg: i,
        headerPadding: s,
        collapseHeaderPaddingSM: o,
        collapseHeaderPaddingLG: a,
        collapsePanelBorderRadius: l,
        lineWidth: c,
        lineType: u,
        colorBorder: d,
        colorText: h,
        colorTextHeading: m,
        colorTextDisabled: g,
        fontSizeLG: x,
        lineHeight: y,
        lineHeightLG: v,
        marginSM: _,
        paddingSM: S,
        paddingLG: w,
        paddingXS: T,
        motionDurationSlow: E,
        fontSizeIcon: M,
        contentPadding: N,
        fontHeight: R,
        fontHeightLG: C,
      } = n,
      L = `${jt(c)} ${u} ${d}`;
    return {
      [e]: Object.assign(Object.assign({}, Md(n)), {
        backgroundColor: i,
        border: L,
        borderRadius: l,
        "&-rtl": { direction: "rtl" },
        [`& > ${e}-item`]: {
          borderBottom: L,
          "&:last-child": {
            [`
            &,
            & > ${e}-header`]: { borderRadius: `0 0 ${jt(l)} ${jt(l)}` },
          },
          [`> ${e}-header`]: {
            position: "relative",
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "flex-start",
            padding: s,
            color: m,
            lineHeight: y,
            cursor: "pointer",
            transition: `all ${E}, visibility 0s`,
            [`> ${e}-header-text`]: { flex: "auto" },
            "&:focus": { outline: "none" },
            [`${e}-expand-icon`]: {
              height: R,
              display: "flex",
              alignItems: "center",
              paddingInlineEnd: _,
            },
            [`${e}-arrow`]: Object.assign(Object.assign({}, v5()), {
              fontSize: M,
              transition: `transform ${E}`,
              svg: { transition: `transform ${E}` },
            }),
            [`${e}-header-text`]: { marginInlineEnd: "auto" },
          },
          [`${e}-icon-collapsible-only`]: {
            cursor: "unset",
            [`${e}-expand-icon`]: { cursor: "pointer" },
          },
        },
        [`${e}-content`]: {
          color: h,
          backgroundColor: t,
          borderTop: L,
          [`& > ${e}-content-box`]: { padding: N },
          "&-hidden": { display: "none" },
        },
        "&-small": {
          [`> ${e}-item`]: {
            [`> ${e}-header`]: {
              padding: o,
              paddingInlineStart: T,
              [`> ${e}-expand-icon`]: {
                marginInlineStart: n.calc(S).sub(T).equal(),
              },
            },
            [`> ${e}-content > ${e}-content-box`]: { padding: S },
          },
        },
        "&-large": {
          [`> ${e}-item`]: {
            fontSize: x,
            lineHeight: v,
            [`> ${e}-header`]: {
              padding: a,
              paddingInlineStart: r,
              [`> ${e}-expand-icon`]: {
                height: C,
                marginInlineStart: n.calc(w).sub(r).equal(),
              },
            },
            [`> ${e}-content > ${e}-content-box`]: { padding: w },
          },
        },
        [`${e}-item:last-child`]: {
          borderBottom: 0,
          [`> ${e}-content`]: { borderRadius: `0 0 ${jt(l)} ${jt(l)}` },
        },
        [`& ${e}-item-disabled > ${e}-header`]: {
          "\n          &,\n          & > .arrow\n        ": {
            color: g,
            cursor: "not-allowed",
          },
        },
        [`&${e}-icon-position-end`]: {
          [`& > ${e}-item`]: {
            [`> ${e}-header`]: {
              [`${e}-expand-icon`]: {
                order: 1,
                paddingInlineEnd: 0,
                paddingInlineStart: _,
              },
            },
          },
        },
      }),
    };
  },
  bce = (n) => {
    const { componentCls: e } = n,
      t = `> ${e}-item > ${e}-header ${e}-arrow`;
    return { [`${e}-rtl`]: { [t]: { transform: "rotate(180deg)" } } };
  },
  Ece = (n) => {
    const { componentCls: e, headerBg: t, paddingXXS: r, colorBorder: i } = n;
    return {
      [`${e}-borderless`]: {
        backgroundColor: t,
        border: 0,
        [`> ${e}-item`]: { borderBottom: `1px solid ${i}` },
        [`
        > ${e}-item:last-child,
        > ${e}-item:last-child ${e}-header
      `]: { borderRadius: 0 },
        [`> ${e}-item:last-child`]: { borderBottom: 0 },
        [`> ${e}-item > ${e}-content`]: {
          backgroundColor: "transparent",
          borderTop: 0,
        },
        [`> ${e}-item > ${e}-content > ${e}-content-box`]: { paddingTop: r },
      },
    };
  },
  Mce = (n) => {
    const { componentCls: e, paddingSM: t } = n;
    return {
      [`${e}-ghost`]: {
        backgroundColor: "transparent",
        border: 0,
        [`> ${e}-item`]: {
          borderBottom: 0,
          [`> ${e}-content`]: {
            backgroundColor: "transparent",
            border: 0,
            [`> ${e}-content-box`]: { paddingBlock: t },
          },
        },
      },
    };
  },
  Tce = (n) => ({
    headerPadding: `${n.paddingSM}px ${n.padding}px`,
    headerBg: n.colorFillAlter,
    contentPadding: `${n.padding}px 16px`,
    contentBg: n.colorBgContainer,
  }),
  Cce = hp(
    "Collapse",
    (n) => {
      const e = mo(n, {
        collapseHeaderPaddingSM: `${jt(n.paddingXS)} ${jt(n.paddingSM)}`,
        collapseHeaderPaddingLG: `${jt(n.padding)} ${jt(n.paddingLG)}`,
        collapsePanelBorderRadius: n.borderRadiusLG,
      });
      return [wce(e), Ece(e), Mce(e), bce(e), Nle(e)];
    },
    Tce
  ),
  Rce = I.forwardRef((n, e) => {
    const { getPrefixCls: t, direction: r, collapse: i } = I.useContext(mr),
      {
        prefixCls: s,
        className: o,
        rootClassName: a,
        style: l,
        bordered: c = !0,
        ghost: u,
        size: d,
        expandIconPosition: h = "start",
        children: m,
        expandIcon: g,
      } = n,
      x = Bd((L) => {
        var O;
        return (O = d ?? L) !== null && O !== void 0 ? O : "middle";
      }),
      y = t("collapse", s),
      v = t(),
      [_, S, w] = Cce(y),
      T = I.useMemo(
        () => (h === "left" ? "start" : h === "right" ? "end" : h),
        [h]
      ),
      E = g ?? (i == null ? void 0 : i.expandIcon),
      M = I.useCallback(
        function () {
          let L =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          const O =
            typeof E == "function"
              ? E(L)
              : I.createElement(kle, { rotate: L.isActive ? 90 : void 0 });
          return Xh(O, () => {
            var D;
            return {
              className: Mt(
                (D = O == null ? void 0 : O.props) === null || D === void 0
                  ? void 0
                  : D.className,
                `${y}-arrow`
              ),
            };
          });
        },
        [E, y]
      ),
      N = Mt(
        `${y}-icon-position-${T}`,
        {
          [`${y}-borderless`]: !c,
          [`${y}-rtl`]: r === "rtl",
          [`${y}-ghost`]: !!u,
          [`${y}-${x}`]: x !== "middle",
        },
        i == null ? void 0 : i.className,
        o,
        a,
        S,
        w
      ),
      R = Object.assign(Object.assign({}, Yoe(v)), {
        motionAppear: !1,
        leavedClassName: `${y}-content-hidden`,
      }),
      C = I.useMemo(
        () =>
          m
            ? Vh(m).map((L, O) => {
                var D, B;
                if (!((D = L.props) === null || D === void 0) && D.disabled) {
                  const $ =
                      (B = L.key) !== null && B !== void 0 ? B : String(O),
                    { disabled: G, collapsible: j } = L.props,
                    U = Object.assign(
                      Object.assign({}, Gg(L.props, ["disabled"])),
                      { key: $, collapsible: j ?? (G ? "disabled" : void 0) }
                    );
                  return Xh(L, U);
                }
                return L;
              })
            : null,
        [m]
      );
    return _(
      I.createElement(
        AR,
        Object.assign({ ref: e, openMotion: R }, Gg(n, ["rootClassName"]), {
          expandIcon: M,
          prefixCls: y,
          className: N,
          style: Object.assign(
            Object.assign({}, i == null ? void 0 : i.style),
            l
          ),
        }),
        C
      )
    );
  }),
  SV = Object.assign(Rce, { Panel: Ace });
function Nce(n) {
  return !!(n.addonBefore || n.addonAfter);
}
function Pce(n) {
  return !!(n.prefix || n.suffix || n.allowClear);
}
function cD(n, e, t) {
  var r = e.cloneNode(!0),
    i = Object.create(n, { target: { value: r }, currentTarget: { value: r } });
  return (
    (r.value = t),
    typeof e.selectionStart == "number" &&
      typeof e.selectionEnd == "number" &&
      ((r.selectionStart = e.selectionStart),
      (r.selectionEnd = e.selectionEnd)),
    (r.setSelectionRange = function () {
      e.setSelectionRange.apply(e, arguments);
    }),
    i
  );
}
function L1(n, e, t, r) {
  if (t) {
    var i = e;
    if (e.type === "click") {
      (i = cD(e, n, "")), t(i);
      return;
    }
    if (n.type !== "file" && r !== void 0) {
      (i = cD(e, n, r)), t(i);
      return;
    }
    t(i);
  }
}
function Ice(n, e) {
  if (n) {
    n.focus(e);
    var t = e || {},
      r = t.cursor;
    if (r) {
      var i = n.value.length;
      switch (r) {
        case "start":
          n.setSelectionRange(0, 0);
          break;
        case "end":
          n.setSelectionRange(i, i);
          break;
        default:
          n.setSelectionRange(0, i);
      }
    }
  }
}
var AV = Je.forwardRef(function (n, e) {
    var t,
      r,
      i = n.inputElement,
      s = n.children,
      o = n.prefixCls,
      a = n.prefix,
      l = n.suffix,
      c = n.addonBefore,
      u = n.addonAfter,
      d = n.className,
      h = n.style,
      m = n.disabled,
      g = n.readOnly,
      x = n.focused,
      y = n.triggerFocus,
      v = n.allowClear,
      _ = n.value,
      S = n.handleReset,
      w = n.hidden,
      T = n.classes,
      E = n.classNames,
      M = n.dataAttrs,
      N = n.styles,
      R = n.components,
      C = s ?? i,
      L = (R == null ? void 0 : R.affixWrapper) || "span",
      O = (R == null ? void 0 : R.groupWrapper) || "span",
      D = (R == null ? void 0 : R.wrapper) || "span",
      B = (R == null ? void 0 : R.groupAddon) || "span",
      $ = I.useRef(null),
      G = function (Ee) {
        var Se;
        (Se = $.current) !== null &&
          Se !== void 0 &&
          Se.contains(Ee.target) &&
          (y == null || y());
      },
      j = Pce(n),
      U = I.cloneElement(C, {
        value: _,
        className:
          Mt(C.props.className, !j && (E == null ? void 0 : E.variant)) || null,
      }),
      H = I.useRef(null);
    if (
      (Je.useImperativeHandle(e, function () {
        return { nativeElement: H.current || $.current };
      }),
      j)
    ) {
      var V,
        k = null;
      if (v) {
        var W,
          ee = !m && !g && _,
          Y = "".concat(o, "-clear-icon"),
          K =
            $t(v) === "object" && v !== null && v !== void 0 && v.clearIcon
              ? v.clearIcon
              : "";
        k = Je.createElement(
          "span",
          {
            onClick: S,
            onMouseDown: function (Ee) {
              return Ee.preventDefault();
            },
            className: Mt(
              Y,
              ((W = {}),
              Te(W, "".concat(Y, "-hidden"), !ee),
              Te(W, "".concat(Y, "-has-suffix"), !!l),
              W)
            ),
            role: "button",
            tabIndex: -1,
          },
          K
        );
      }
      var ae = "".concat(o, "-affix-wrapper"),
        se = Mt(
          ae,
          ((V = {}),
          Te(V, "".concat(o, "-disabled"), m),
          Te(V, "".concat(ae, "-disabled"), m),
          Te(V, "".concat(ae, "-focused"), x),
          Te(V, "".concat(ae, "-readonly"), g),
          Te(V, "".concat(ae, "-input-with-clear-btn"), l && v && _),
          V),
          T == null ? void 0 : T.affixWrapper,
          E == null ? void 0 : E.affixWrapper,
          E == null ? void 0 : E.variant
        ),
        we =
          (l || v) &&
          Je.createElement(
            "span",
            {
              className: Mt(
                "".concat(o, "-suffix"),
                E == null ? void 0 : E.suffix
              ),
              style: N == null ? void 0 : N.suffix,
            },
            k,
            l
          );
      U = Je.createElement(
        L,
        an(
          {
            className: se,
            style: N == null ? void 0 : N.affixWrapper,
            onClick: G,
          },
          M == null ? void 0 : M.affixWrapper,
          { ref: $ }
        ),
        a &&
          Je.createElement(
            "span",
            {
              className: Mt(
                "".concat(o, "-prefix"),
                E == null ? void 0 : E.prefix
              ),
              style: N == null ? void 0 : N.prefix,
            },
            a
          ),
        U,
        we
      );
    }
    if (Nce(n)) {
      var Be = "".concat(o, "-group"),
        te = "".concat(Be, "-addon"),
        ge = "".concat(Be, "-wrapper"),
        ie = Mt(
          "".concat(o, "-wrapper"),
          Be,
          T == null ? void 0 : T.wrapper,
          E == null ? void 0 : E.wrapper
        ),
        me = Mt(
          ge,
          Te({}, "".concat(ge, "-disabled"), m),
          T == null ? void 0 : T.group,
          E == null ? void 0 : E.groupWrapper
        );
      U = Je.createElement(
        O,
        { className: me, ref: H },
        Je.createElement(
          D,
          { className: ie },
          c && Je.createElement(B, { className: te }, c),
          U,
          u && Je.createElement(B, { className: te }, u)
        )
      );
    }
    return Je.cloneElement(U, {
      className:
        Mt((t = U.props) === null || t === void 0 ? void 0 : t.className, d) ||
        null,
      style: Ze(
        Ze({}, (r = U.props) === null || r === void 0 ? void 0 : r.style),
        h
      ),
      hidden: w,
    });
  }),
  Lce = ["show"];
function wV(n, e) {
  return I.useMemo(
    function () {
      var t = {};
      e && (t.show = $t(e) === "object" && e.formatter ? e.formatter : !!e),
        (t = Ze(Ze({}, t), n));
      var r = t,
        i = r.show,
        s = xi(r, Lce);
      return Ze(
        Ze({}, s),
        {},
        {
          show: !!i,
          showFormatter: typeof i == "function" ? i : void 0,
          strategy:
            s.strategy ||
            function (o) {
              return o.length;
            },
        }
      );
    },
    [n, e]
  );
}
var Oce = [
    "autoComplete",
    "onChange",
    "onFocus",
    "onBlur",
    "onPressEnter",
    "onKeyDown",
    "prefixCls",
    "disabled",
    "htmlSize",
    "className",
    "maxLength",
    "suffix",
    "showCount",
    "count",
    "type",
    "classes",
    "classNames",
    "styles",
    "onCompositionStart",
    "onCompositionEnd",
  ],
  Dce = I.forwardRef(function (n, e) {
    var t = n.autoComplete,
      r = n.onChange,
      i = n.onFocus,
      s = n.onBlur,
      o = n.onPressEnter,
      a = n.onKeyDown,
      l = n.prefixCls,
      c = l === void 0 ? "rc-input" : l,
      u = n.disabled,
      d = n.htmlSize,
      h = n.className,
      m = n.maxLength,
      g = n.suffix,
      x = n.showCount,
      y = n.count,
      v = n.type,
      _ = v === void 0 ? "text" : v,
      S = n.classes,
      w = n.classNames,
      T = n.styles,
      E = n.onCompositionStart,
      M = n.onCompositionEnd,
      N = xi(n, Oce),
      R = I.useState(!1),
      C = Et(R, 2),
      L = C[0],
      O = C[1],
      D = I.useRef(!1),
      B = I.useRef(null),
      $ = I.useRef(null),
      G = function (q) {
        B.current && Ice(B.current, q);
      },
      j = fp(n.defaultValue, { value: n.value }),
      U = Et(j, 2),
      H = U[0],
      V = U[1],
      k = H == null ? "" : String(H),
      W = I.useState(null),
      ee = Et(W, 2),
      Y = ee[0],
      K = ee[1],
      ae = wV(y, x),
      se = ae.max || m,
      we = ae.strategy(k),
      Be = !!se && we > se;
    I.useImperativeHandle(e, function () {
      var z;
      return {
        focus: G,
        blur: function () {
          var ue;
          (ue = B.current) === null || ue === void 0 || ue.blur();
        },
        setSelectionRange: function (ue, de, he) {
          var Ie;
          (Ie = B.current) === null ||
            Ie === void 0 ||
            Ie.setSelectionRange(ue, de, he);
        },
        select: function () {
          var ue;
          (ue = B.current) === null || ue === void 0 || ue.select();
        },
        input: B.current,
        nativeElement:
          ((z = $.current) === null || z === void 0
            ? void 0
            : z.nativeElement) || B.current,
      };
    }),
      I.useEffect(
        function () {
          O(function (z) {
            return z && u ? !1 : z;
          });
        },
        [u]
      );
    var te = function (q, ue, de) {
      var he = ue;
      if (
        !D.current &&
        ae.exceedFormatter &&
        ae.max &&
        ae.strategy(ue) > ae.max
      ) {
        if (((he = ae.exceedFormatter(ue, { max: ae.max })), ue !== he)) {
          var Ie, ke;
          K([
            ((Ie = B.current) === null || Ie === void 0
              ? void 0
              : Ie.selectionStart) || 0,
            ((ke = B.current) === null || ke === void 0
              ? void 0
              : ke.selectionEnd) || 0,
          ]);
        }
      } else if (de.source === "compositionEnd") return;
      V(he), B.current && L1(B.current, q, r, he);
    };
    I.useEffect(
      function () {
        if (Y) {
          var z;
          (z = B.current) === null ||
            z === void 0 ||
            z.setSelectionRange.apply(z, Ot(Y));
        }
      },
      [Y]
    );
    var ge = function (q) {
        te(q, q.target.value, { source: "change" });
      },
      ie = function (q) {
        (D.current = !1),
          te(q, q.currentTarget.value, { source: "compositionEnd" }),
          M == null || M(q);
      },
      me = function (q) {
        o && q.key === "Enter" && o(q), a == null || a(q);
      },
      fe = function (q) {
        O(!0), i == null || i(q);
      },
      Ee = function (q) {
        O(!1), s == null || s(q);
      },
      Se = function (q) {
        V(""), G(), B.current && L1(B.current, q, r);
      },
      Ue = Be && "".concat(c, "-out-of-range"),
      Ce = function () {
        var q = Gg(n, [
          "prefixCls",
          "onPressEnter",
          "addonBefore",
          "addonAfter",
          "prefix",
          "suffix",
          "allowClear",
          "defaultValue",
          "showCount",
          "count",
          "classes",
          "htmlSize",
          "styles",
          "classNames",
        ]);
        return Je.createElement(
          "input",
          an({ autoComplete: t }, q, {
            onChange: ge,
            onFocus: fe,
            onBlur: Ee,
            onKeyDown: me,
            className: Mt(
              c,
              Te({}, "".concat(c, "-disabled"), u),
              w == null ? void 0 : w.input
            ),
            style: T == null ? void 0 : T.input,
            ref: B,
            size: d,
            type: _,
            onCompositionStart: function (de) {
              (D.current = !0), E == null || E(de);
            },
            onCompositionEnd: ie,
          })
        );
      },
      X = function () {
        var q = Number(se) > 0;
        if (g || ae.show) {
          var ue = ae.showFormatter
            ? ae.showFormatter({ value: k, count: we, maxLength: se })
            : "".concat(we).concat(q ? " / ".concat(se) : "");
          return Je.createElement(
            Je.Fragment,
            null,
            ae.show &&
              Je.createElement(
                "span",
                {
                  className: Mt(
                    "".concat(c, "-show-count-suffix"),
                    Te({}, "".concat(c, "-show-count-has-suffix"), !!g),
                    w == null ? void 0 : w.count
                  ),
                  style: Ze({}, T == null ? void 0 : T.count),
                },
                ue
              ),
            g
          );
        }
        return null;
      };
    return Je.createElement(
      AV,
      an({}, N, {
        prefixCls: c,
        className: Mt(h, Ue),
        handleReset: Se,
        value: k,
        focused: L,
        triggerFocus: G,
        suffix: X(),
        disabled: u,
        classes: S,
        classNames: w,
        styles: T,
      }),
      Ce()
    );
  });
const Fce = (n) => {
    const { getPrefixCls: e, direction: t } = I.useContext(mr),
      { prefixCls: r, className: i } = n,
      s = e("input-group", r),
      o = e("input"),
      [a, l] = SR(o),
      c = Mt(
        s,
        {
          [`${s}-lg`]: n.size === "large",
          [`${s}-sm`]: n.size === "small",
          [`${s}-compact`]: n.compact,
          [`${s}-rtl`]: t === "rtl",
        },
        l,
        i
      ),
      u = I.useContext(Bl),
      d = I.useMemo(
        () => Object.assign(Object.assign({}, u), { isFormItemInput: !1 }),
        [u]
      );
    return a(
      I.createElement(
        "span",
        {
          className: c,
          style: n.style,
          onMouseEnter: n.onMouseEnter,
          onMouseLeave: n.onMouseLeave,
          onFocus: n.onFocus,
          onBlur: n.onBlur,
        },
        I.createElement(Bl.Provider, { value: d }, n.children)
      )
    );
  },
  bV = (n) => {
    let e;
    return (
      typeof n == "object" && n != null && n.clearIcon
        ? (e = n)
        : n && (e = { clearIcon: Je.createElement(z5, null) }),
      e
    );
  };
function EV(n, e) {
  const t = I.useRef([]),
    r = () => {
      t.current.push(
        setTimeout(() => {
          var i, s, o, a;
          !((i = n.current) === null || i === void 0) &&
            i.input &&
            ((s = n.current) === null || s === void 0
              ? void 0
              : s.input.getAttribute("type")) === "password" &&
            !((o = n.current) === null || o === void 0) &&
            o.input.hasAttribute("value") &&
            ((a = n.current) === null ||
              a === void 0 ||
              a.input.removeAttribute("value"));
        })
      );
    };
  return (
    I.useEffect(
      () => (
        e && r(),
        () =>
          t.current.forEach((i) => {
            i && clearTimeout(i);
          })
      ),
      []
    ),
    r
  );
}
function Uce(n) {
  return !!(n.prefix || n.suffix || n.allowClear || n.showCount);
}
var kce = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
function zce(n, e) {
  if (!n) return;
  n.focus(e);
  const { cursor: t } = e || {};
  if (t) {
    const r = n.value.length;
    switch (t) {
      case "start":
        n.setSelectionRange(0, 0);
        break;
      case "end":
        n.setSelectionRange(r, r);
        break;
      default:
        n.setSelectionRange(0, r);
    }
  }
}
const hS = I.forwardRef((n, e) => {
    var t;
    const {
        prefixCls: r,
        bordered: i = !0,
        status: s,
        size: o,
        disabled: a,
        onBlur: l,
        onFocus: c,
        suffix: u,
        allowClear: d,
        addonAfter: h,
        addonBefore: m,
        className: g,
        style: x,
        styles: y,
        rootClassName: v,
        onChange: _,
        classNames: S,
        variant: w,
      } = n,
      T = kce(n, [
        "prefixCls",
        "bordered",
        "status",
        "size",
        "disabled",
        "onBlur",
        "onFocus",
        "suffix",
        "allowClear",
        "addonAfter",
        "addonBefore",
        "className",
        "style",
        "styles",
        "rootClassName",
        "onChange",
        "classNames",
        "variant",
      ]),
      { getPrefixCls: E, direction: M, input: N } = Je.useContext(mr),
      R = E("input", r),
      C = I.useRef(null),
      L = kd(R),
      [O, D, B] = SR(R, L),
      { compactSize: $, compactItemClassnames: G } = mR(R, M),
      j = Bd((fe) => {
        var Ee;
        return (Ee = o ?? $) !== null && Ee !== void 0 ? Ee : fe;
      }),
      U = Je.useContext(Ed),
      H = a ?? U,
      { status: V, hasFeedback: k, feedbackIcon: W } = I.useContext(Bl),
      ee = xR(V, s),
      Y = Uce(n) || !!k;
    I.useRef(Y);
    const K = EV(C, !0),
      ae = (fe) => {
        K(), l == null || l(fe);
      },
      se = (fe) => {
        K(), c == null || c(fe);
      },
      we = (fe) => {
        K(), _ == null || _(fe);
      },
      Be = (k || u) && Je.createElement(Je.Fragment, null, u, k && W),
      te = (fe) =>
        fe &&
        Je.createElement(
          rae,
          null,
          Je.createElement(Cle, { override: !0, status: !0 }, fe)
        ),
      ge = bV(d ?? (N == null ? void 0 : N.allowClear)),
      [ie, me] = lV(w, i);
    return O(
      Je.createElement(
        Dce,
        Object.assign(
          {
            ref: eu(e, C),
            prefixCls: R,
            autoComplete: N == null ? void 0 : N.autoComplete,
          },
          T,
          {
            disabled: H,
            onBlur: ae,
            onFocus: se,
            style: Object.assign(
              Object.assign({}, N == null ? void 0 : N.style),
              x
            ),
            styles: Object.assign(
              Object.assign({}, N == null ? void 0 : N.styles),
              y
            ),
            suffix: Be,
            allowClear: ge,
            className: Mt(g, v, B, L, G, N == null ? void 0 : N.className),
            onChange: we,
            addonBefore: te(m),
            addonAfter: te(h),
            classNames: Object.assign(
              Object.assign(
                Object.assign({}, S),
                N == null ? void 0 : N.classNames
              ),
              {
                input: Mt(
                  {
                    [`${R}-sm`]: j === "small",
                    [`${R}-lg`]: j === "large",
                    [`${R}-rtl`]: M === "rtl",
                  },
                  S == null ? void 0 : S.input,
                  (t = N == null ? void 0 : N.classNames) === null ||
                    t === void 0
                    ? void 0
                    : t.input,
                  D
                ),
                variant: Mt({ [`${R}-${ie}`]: me }, bT(R, ee)),
                affixWrapper: Mt(
                  {
                    [`${R}-affix-wrapper-sm`]: j === "small",
                    [`${R}-affix-wrapper-lg`]: j === "large",
                    [`${R}-affix-wrapper-rtl`]: M === "rtl",
                  },
                  D
                ),
                wrapper: Mt({ [`${R}-group-rtl`]: M === "rtl" }, D),
                groupWrapper: Mt(
                  {
                    [`${R}-group-wrapper-sm`]: j === "small",
                    [`${R}-group-wrapper-lg`]: j === "large",
                    [`${R}-group-wrapper-rtl`]: M === "rtl",
                    [`${R}-group-wrapper-${ie}`]: me,
                  },
                  bT(`${R}-group-wrapper`, ee, k),
                  D
                ),
              }
            ),
          }
        )
      )
    );
  }),
  Bce = (n) => {
    const { componentCls: e, paddingXS: t } = n;
    return {
      [`${e}`]: {
        display: "inline-flex",
        alignItems: "center",
        flexWrap: "nowrap",
        columnGap: t,
        "&-rtl": { direction: "rtl" },
        [`${e}-input`]: { textAlign: "center", paddingInline: n.paddingXXS },
        [`&${e}-sm ${e}-input`]: {
          paddingInline: n.calc(n.paddingXXS).div(2).equal(),
        },
        [`&${e}-lg ${e}-input`]: { paddingInline: n.paddingXS },
      },
    };
  },
  Vce = hp(
    ["Input", "OTP"],
    (n) => {
      const e = mo(n, fV(n));
      return [Bce(e)];
    },
    hV
  );
var Hce = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const Gce = I.forwardRef((n, e) => {
  const { value: t, onChange: r, onActiveChange: i, index: s, mask: o } = n,
    a = Hce(n, ["value", "onChange", "onActiveChange", "index", "mask"]),
    l = t && typeof o == "string" ? o : t,
    c = (g) => {
      r(s, g.target.value);
    },
    u = I.useRef(null);
  I.useImperativeHandle(e, () => u.current);
  const d = () => {
      Ya(() => {
        var g;
        const x = (g = u.current) === null || g === void 0 ? void 0 : g.input;
        document.activeElement === x && x && x.select();
      });
    },
    h = (g) => {
      let { key: x } = g;
      x === "ArrowLeft" ? i(s - 1) : x === "ArrowRight" && i(s + 1), d();
    },
    m = (g) => {
      g.key === "Backspace" && !t && i(s - 1), d();
    };
  return I.createElement(
    hS,
    Object.assign({}, a, {
      ref: u,
      value: l,
      onInput: c,
      onFocus: d,
      onKeyDown: h,
      onKeyUp: m,
      onMouseDown: d,
      onMouseUp: d,
      type: o === !0 ? "password" : "text",
    })
  );
});
var Wce = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
function Jy(n) {
  return (n || "").split("");
}
const jce = I.forwardRef((n, e) => {
  const {
      prefixCls: t,
      length: r = 6,
      size: i,
      defaultValue: s,
      value: o,
      onChange: a,
      formatter: l,
      variant: c,
      disabled: u,
      status: d,
      autoFocus: h,
      mask: m,
    } = n,
    g = Wce(n, [
      "prefixCls",
      "length",
      "size",
      "defaultValue",
      "value",
      "onChange",
      "formatter",
      "variant",
      "disabled",
      "status",
      "autoFocus",
      "mask",
    ]),
    { getPrefixCls: x, direction: y } = I.useContext(mr),
    v = x("otp", t),
    _ = dS(g, { aria: !0, data: !0, attr: !0 }),
    S = kd(v),
    [w, T, E] = Vce(v, S),
    M = Bd((k) => i ?? k),
    N = I.useContext(Bl),
    R = xR(N.status, d),
    C = I.useMemo(
      () =>
        Object.assign(Object.assign({}, N), {
          status: R,
          hasFeedback: !1,
          feedbackIcon: null,
        }),
      [N, R]
    ),
    L = I.useRef(null),
    O = I.useRef({});
  I.useImperativeHandle(e, () => ({
    focus: () => {
      var k;
      (k = O.current[0]) === null || k === void 0 || k.focus();
    },
    blur: () => {
      var k;
      for (let W = 0; W < r; W += 1)
        (k = O.current[W]) === null || k === void 0 || k.blur();
    },
    nativeElement: L.current,
  }));
  const D = (k) => (l ? l(k) : k),
    [B, $] = I.useState(Jy(D(s || "")));
  I.useEffect(() => {
    o !== void 0 && $(Jy(o));
  }, [o]);
  const G = $h((k) => {
      $(k),
        a &&
          k.length === r &&
          k.every((W) => W) &&
          k.some((W, ee) => B[ee] !== W) &&
          a(k.join(""));
    }),
    j = $h((k, W) => {
      let ee = Ot(B);
      for (let K = 0; K < k; K += 1) ee[K] || (ee[K] = "");
      W.length <= 1 ? (ee[k] = W) : (ee = ee.slice(0, k).concat(Jy(W))),
        (ee = ee.slice(0, r));
      for (let K = ee.length - 1; K >= 0 && !ee[K]; K -= 1) ee.pop();
      const Y = D(ee.map((K) => K || " ").join(""));
      return (
        (ee = Jy(Y).map((K, ae) => (K === " " && !ee[ae] ? ee[ae] : K))), ee
      );
    }),
    U = (k, W) => {
      var ee;
      const Y = j(k, W),
        K = Math.min(k + W.length, r - 1);
      K !== k && ((ee = O.current[K]) === null || ee === void 0 || ee.focus()),
        G(Y);
    },
    H = (k) => {
      var W;
      (W = O.current[k]) === null || W === void 0 || W.focus();
    },
    V = { variant: c, disabled: u, status: R, mask: m };
  return w(
    I.createElement(
      "div",
      Object.assign({}, _, {
        ref: L,
        className: Mt(
          v,
          {
            [`${v}-sm`]: M === "small",
            [`${v}-lg`]: M === "large",
            [`${v}-rtl`]: y === "rtl",
          },
          E,
          T
        ),
      }),
      I.createElement(
        Bl.Provider,
        { value: C },
        Array.from({ length: r }).map((k, W) => {
          const ee = `otp-${W}`,
            Y = B[W] || "";
          return I.createElement(
            Gce,
            Object.assign(
              {
                ref: (K) => {
                  O.current[W] = K;
                },
                key: ee,
                index: W,
                size: M,
                htmlSize: 1,
                className: `${v}-input`,
                onChange: U,
                value: Y,
                onActiveChange: H,
                autoFocus: W === 0 && h,
              },
              V
            )
          );
        })
      )
    )
  );
});
var $ce = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z",
          },
        },
        {
          tag: "path",
          attrs: {
            d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z",
          },
        },
      ],
    },
    name: "eye-invisible",
    theme: "outlined",
  },
  Xce = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: $ce }));
  },
  Yce = I.forwardRef(Xce),
  qce = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z",
          },
        },
      ],
    },
    name: "eye",
    theme: "outlined",
  },
  Kce = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: qce }));
  },
  Zce = I.forwardRef(Kce),
  Qce = function (n, e) {
    var t = {};
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) &&
        e.indexOf(r) < 0 &&
        (t[r] = n[r]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
          (t[r[i]] = n[r[i]]);
    return t;
  };
const Jce = (n) =>
    n ? I.createElement(Zce, null) : I.createElement(Yce, null),
  eue = { click: "onClick", hover: "onMouseOver" },
  tue = I.forwardRef((n, e) => {
    const {
        disabled: t,
        action: r = "click",
        visibilityToggle: i = !0,
        iconRender: s = Jce,
      } = n,
      o = typeof i == "object" && i.visible !== void 0,
      [a, l] = I.useState(() => (o ? i.visible : !1)),
      c = I.useRef(null);
    I.useEffect(() => {
      o && l(i.visible);
    }, [o, i]);
    const u = EV(c),
      d = () => {
        t ||
          (a && u(),
          l((N) => {
            var R;
            const C = !N;
            return (
              typeof i == "object" &&
                ((R = i.onVisibleChange) === null ||
                  R === void 0 ||
                  R.call(i, C)),
              C
            );
          }));
      },
      h = (N) => {
        const R = eue[r] || "",
          C = s(a),
          L = {
            [R]: d,
            className: `${N}-icon`,
            key: "passwordIcon",
            onMouseDown: (O) => {
              O.preventDefault();
            },
            onMouseUp: (O) => {
              O.preventDefault();
            },
          };
        return I.cloneElement(
          I.isValidElement(C) ? C : I.createElement("span", null, C),
          L
        );
      },
      { className: m, prefixCls: g, inputPrefixCls: x, size: y } = n,
      v = Qce(n, ["className", "prefixCls", "inputPrefixCls", "size"]),
      { getPrefixCls: _ } = I.useContext(mr),
      S = _("input", x),
      w = _("input-password", g),
      T = i && h(w),
      E = Mt(w, m, { [`${w}-${y}`]: !!y }),
      M = Object.assign(
        Object.assign({}, Gg(v, ["suffix", "iconRender", "visibilityToggle"])),
        { type: a ? "text" : "password", className: E, prefixCls: S, suffix: T }
      );
    return (
      y && (M.size = y),
      I.createElement(hS, Object.assign({ ref: eu(e, c) }, M))
    );
  });
var nue = function (n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
};
const rue = I.forwardRef((n, e) => {
  const {
      prefixCls: t,
      inputPrefixCls: r,
      className: i,
      size: s,
      suffix: o,
      enterButton: a = !1,
      addonAfter: l,
      loading: c,
      disabled: u,
      onSearch: d,
      onChange: h,
      onCompositionStart: m,
      onCompositionEnd: g,
    } = n,
    x = nue(n, [
      "prefixCls",
      "inputPrefixCls",
      "className",
      "size",
      "suffix",
      "enterButton",
      "addonAfter",
      "loading",
      "disabled",
      "onSearch",
      "onChange",
      "onCompositionStart",
      "onCompositionEnd",
    ]),
    { getPrefixCls: y, direction: v } = I.useContext(mr),
    _ = I.useRef(!1),
    S = y("input-search", t),
    w = y("input", r),
    { compactSize: T } = mR(S, v),
    E = Bd((V) => {
      var k;
      return (k = s ?? T) !== null && k !== void 0 ? k : V;
    }),
    M = I.useRef(null),
    N = (V) => {
      V &&
        V.target &&
        V.type === "click" &&
        d &&
        d(V.target.value, V, { source: "clear" }),
        h && h(V);
    },
    R = (V) => {
      var k;
      document.activeElement ===
        ((k = M.current) === null || k === void 0 ? void 0 : k.input) &&
        V.preventDefault();
    },
    C = (V) => {
      var k, W;
      d &&
        d(
          (W = (k = M.current) === null || k === void 0 ? void 0 : k.input) ===
            null || W === void 0
            ? void 0
            : W.value,
          V,
          { source: "input" }
        );
    },
    L = (V) => {
      _.current || c || C(V);
    },
    O = typeof a == "boolean" ? I.createElement(Dle, null) : null,
    D = `${S}-button`;
  let B;
  const $ = a || {},
    G = $.type && $.type.__ANT_BUTTON === !0;
  G || $.type === "button"
    ? (B = Xh(
        $,
        Object.assign(
          {
            onMouseDown: R,
            onClick: (V) => {
              var k, W;
              (W =
                (k = $ == null ? void 0 : $.props) === null || k === void 0
                  ? void 0
                  : k.onClick) === null ||
                W === void 0 ||
                W.call(k, V),
                C(V);
            },
            key: "enterButton",
          },
          G ? { className: D, size: E } : {}
        )
      ))
    : (B = I.createElement(
        jl,
        {
          className: D,
          type: a ? "primary" : void 0,
          size: E,
          disabled: u,
          key: "enterButton",
          onMouseDown: R,
          onClick: C,
          loading: c,
          icon: O,
        },
        a
      )),
    l && (B = [B, Xh(l, { key: "addonAfter" })]);
  const j = Mt(
      S,
      {
        [`${S}-rtl`]: v === "rtl",
        [`${S}-${E}`]: !!E,
        [`${S}-with-button`]: !!a,
      },
      i
    ),
    U = (V) => {
      (_.current = !0), m == null || m(V);
    },
    H = (V) => {
      (_.current = !1), g == null || g(V);
    };
  return I.createElement(
    hS,
    Object.assign({ ref: eu(M, e), onPressEnter: L }, x, {
      size: E,
      onCompositionStart: U,
      onCompositionEnd: H,
      prefixCls: w,
      addonAfter: B,
      suffix: o,
      onChange: N,
      className: j,
      disabled: u,
    })
  );
});
var iue = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`,
  sue = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "font-variant",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
    "word-break",
    "white-space",
  ],
  _b = {},
  To;
function oue(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t =
      n.getAttribute("id") ||
      n.getAttribute("data-reactid") ||
      n.getAttribute("name");
  if (e && _b[t]) return _b[t];
  var r = window.getComputedStyle(n),
    i =
      r.getPropertyValue("box-sizing") ||
      r.getPropertyValue("-moz-box-sizing") ||
      r.getPropertyValue("-webkit-box-sizing"),
    s =
      parseFloat(r.getPropertyValue("padding-bottom")) +
      parseFloat(r.getPropertyValue("padding-top")),
    o =
      parseFloat(r.getPropertyValue("border-bottom-width")) +
      parseFloat(r.getPropertyValue("border-top-width")),
    a = sue
      .map(function (c) {
        return "".concat(c, ":").concat(r.getPropertyValue(c));
      })
      .join(";"),
    l = { sizingStyle: a, paddingSize: s, borderSize: o, boxSizing: i };
  return e && t && (_b[t] = l), l;
}
function aue(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
    r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  To ||
    ((To = document.createElement("textarea")),
    To.setAttribute("tab-index", "-1"),
    To.setAttribute("aria-hidden", "true"),
    document.body.appendChild(To)),
    n.getAttribute("wrap")
      ? To.setAttribute("wrap", n.getAttribute("wrap"))
      : To.removeAttribute("wrap");
  var i = oue(n, e),
    s = i.paddingSize,
    o = i.borderSize,
    a = i.boxSizing,
    l = i.sizingStyle;
  To.setAttribute("style", "".concat(l, ";").concat(iue)),
    (To.value = n.value || n.placeholder || "");
  var c = void 0,
    u = void 0,
    d,
    h = To.scrollHeight;
  if (
    (a === "border-box" ? (h += o) : a === "content-box" && (h -= s),
    t !== null || r !== null)
  ) {
    To.value = " ";
    var m = To.scrollHeight - s;
    t !== null &&
      ((c = m * t),
      a === "border-box" && (c = c + s + o),
      (h = Math.max(c, h))),
      r !== null &&
        ((u = m * r),
        a === "border-box" && (u = u + s + o),
        (d = h > u ? "" : "hidden"),
        (h = Math.min(u, h)));
  }
  var g = { height: h, overflowY: d, resize: "none" };
  return c && (g.minHeight = c), u && (g.maxHeight = u), g;
}
var lue = [
    "prefixCls",
    "onPressEnter",
    "defaultValue",
    "value",
    "autoSize",
    "onResize",
    "className",
    "style",
    "disabled",
    "onChange",
    "onInternalAutoSize",
  ],
  Sb = 0,
  Ab = 1,
  wb = 2,
  cue = I.forwardRef(function (n, e) {
    var t = n,
      r = t.prefixCls;
    t.onPressEnter;
    var i = t.defaultValue,
      s = t.value,
      o = t.autoSize,
      a = t.onResize,
      l = t.className,
      c = t.style,
      u = t.disabled,
      d = t.onChange;
    t.onInternalAutoSize;
    var h = xi(t, lue),
      m = fp(i, {
        value: s,
        postState: function (Y) {
          return Y ?? "";
        },
      }),
      g = Et(m, 2),
      x = g[0],
      y = g[1],
      v = function (Y) {
        y(Y.target.value), d == null || d(Y);
      },
      _ = I.useRef();
    I.useImperativeHandle(e, function () {
      return { textArea: _.current };
    });
    var S = I.useMemo(
        function () {
          return o && $t(o) === "object" ? [o.minRows, o.maxRows] : [];
        },
        [o]
      ),
      w = Et(S, 2),
      T = w[0],
      E = w[1],
      M = !!o,
      N = function () {
        try {
          if (document.activeElement === _.current) {
            var Y = _.current,
              K = Y.selectionStart,
              ae = Y.selectionEnd,
              se = Y.scrollTop;
            _.current.setSelectionRange(K, ae), (_.current.scrollTop = se);
          }
        } catch {}
      },
      R = I.useState(wb),
      C = Et(R, 2),
      L = C[0],
      O = C[1],
      D = I.useState(),
      B = Et(D, 2),
      $ = B[0],
      G = B[1],
      j = function () {
        O(Sb);
      };
    T1(
      function () {
        M && j();
      },
      [s, T, E, M]
    ),
      T1(
        function () {
          if (L === Sb) O(Ab);
          else if (L === Ab) {
            var ee = aue(_.current, !1, T, E);
            O(wb), G(ee);
          } else N();
        },
        [L]
      );
    var U = I.useRef(),
      H = function () {
        Ya.cancel(U.current);
      },
      V = function (Y) {
        L === wb &&
          (a == null || a(Y),
          o &&
            (H(),
            (U.current = Ya(function () {
              j();
            }))));
      };
    I.useEffect(function () {
      return H;
    }, []);
    var k = M ? $ : null,
      W = Ze(Ze({}, c), k);
    return (
      (L === Sb || L === Ab) &&
        ((W.overflowY = "hidden"), (W.overflowX = "hidden")),
      I.createElement(
        CB,
        { onResize: V, disabled: !(o || a) },
        I.createElement(
          "textarea",
          an({}, h, {
            ref: _,
            style: W,
            className: Mt(r, l, Te({}, "".concat(r, "-disabled"), u)),
            disabled: u,
            value: x,
            onChange: v,
          })
        )
      )
    );
  }),
  uue = [
    "defaultValue",
    "value",
    "onFocus",
    "onBlur",
    "onChange",
    "allowClear",
    "maxLength",
    "onCompositionStart",
    "onCompositionEnd",
    "suffix",
    "prefixCls",
    "showCount",
    "count",
    "className",
    "style",
    "disabled",
    "hidden",
    "classNames",
    "styles",
    "onResize",
    "readOnly",
  ],
  due = Je.forwardRef(function (n, e) {
    var t,
      r = n.defaultValue,
      i = n.value,
      s = n.onFocus,
      o = n.onBlur,
      a = n.onChange,
      l = n.allowClear,
      c = n.maxLength,
      u = n.onCompositionStart,
      d = n.onCompositionEnd,
      h = n.suffix,
      m = n.prefixCls,
      g = m === void 0 ? "rc-textarea" : m,
      x = n.showCount,
      y = n.count,
      v = n.className,
      _ = n.style,
      S = n.disabled,
      w = n.hidden,
      T = n.classNames,
      E = n.styles,
      M = n.onResize,
      N = n.readOnly,
      R = xi(n, uue),
      C = fp(r, { value: i, defaultValue: r }),
      L = Et(C, 2),
      O = L[0],
      D = L[1],
      B = O == null ? "" : String(O),
      $ = Je.useState(!1),
      G = Et($, 2),
      j = G[0],
      U = G[1],
      H = Je.useRef(!1),
      V = Je.useState(null),
      k = Et(V, 2),
      W = k[0],
      ee = k[1],
      Y = I.useRef(null),
      K = I.useRef(null),
      ae = function () {
        var We;
        return (We = K.current) === null || We === void 0
          ? void 0
          : We.textArea;
      },
      se = function () {
        ae().focus();
      };
    I.useImperativeHandle(e, function () {
      var Ne;
      return {
        resizableTextArea: K.current,
        focus: se,
        blur: function () {
          ae().blur();
        },
        nativeElement:
          ((Ne = Y.current) === null || Ne === void 0
            ? void 0
            : Ne.nativeElement) || ae(),
      };
    }),
      I.useEffect(
        function () {
          U(function (Ne) {
            return !S && Ne;
          });
        },
        [S]
      );
    var we = Je.useState(null),
      Be = Et(we, 2),
      te = Be[0],
      ge = Be[1];
    Je.useEffect(
      function () {
        if (te) {
          var Ne;
          (Ne = ae()).setSelectionRange.apply(Ne, Ot(te));
        }
      },
      [te]
    );
    var ie = wV(y, x),
      me = (t = ie.max) !== null && t !== void 0 ? t : c,
      fe = Number(me) > 0,
      Ee = ie.strategy(B),
      Se = !!me && Ee > me,
      Ue = function (We, ot) {
        var nt = ot;
        !H.current &&
          ie.exceedFormatter &&
          ie.max &&
          ie.strategy(ot) > ie.max &&
          ((nt = ie.exceedFormatter(ot, { max: ie.max })),
          ot !== nt && ge([ae().selectionStart || 0, ae().selectionEnd || 0])),
          D(nt),
          L1(We.currentTarget, We, a, nt);
      },
      Ce = function (We) {
        (H.current = !0), u == null || u(We);
      },
      X = function (We) {
        (H.current = !1), Ue(We, We.currentTarget.value), d == null || d(We);
      },
      z = function (We) {
        Ue(We, We.target.value);
      },
      q = function (We) {
        var ot = R.onPressEnter,
          nt = R.onKeyDown;
        We.key === "Enter" && ot && ot(We), nt == null || nt(We);
      },
      ue = function (We) {
        U(!0), s == null || s(We);
      },
      de = function (We) {
        U(!1), o == null || o(We);
      },
      he = function (We) {
        D(""), se(), L1(ae(), We, a);
      },
      Ie = h,
      ke;
    ie.show &&
      (ie.showFormatter
        ? (ke = ie.showFormatter({ value: B, count: Ee, maxLength: me }))
        : (ke = "".concat(Ee).concat(fe ? " / ".concat(me) : "")),
      (Ie = Je.createElement(
        Je.Fragment,
        null,
        Ie,
        Je.createElement(
          "span",
          {
            className: Mt(
              "".concat(g, "-data-count"),
              T == null ? void 0 : T.count
            ),
            style: E == null ? void 0 : E.count,
          },
          ke
        )
      )));
    var Me = function (We) {
        var ot;
        M == null || M(We),
          (ot = ae()) !== null && ot !== void 0 && ot.style.height && ee(!0);
      },
      et = !R.autoSize && !x && !l;
    return Je.createElement(
      AV,
      {
        ref: Y,
        value: B,
        allowClear: l,
        handleReset: he,
        suffix: Ie,
        prefixCls: g,
        classNames: Ze(
          Ze({}, T),
          {},
          {
            affixWrapper: Mt(
              T == null ? void 0 : T.affixWrapper,
              Te(
                Te({}, "".concat(g, "-show-count"), x),
                "".concat(g, "-textarea-allow-clear"),
                l
              )
            ),
          }
        ),
        disabled: S,
        focused: j,
        className: Mt(v, Se && "".concat(g, "-out-of-range")),
        style: Ze(Ze({}, _), W && !et ? { height: "auto" } : {}),
        dataAttrs: {
          affixWrapper: { "data-count": typeof ke == "string" ? ke : void 0 },
        },
        hidden: w,
        readOnly: N,
      },
      Je.createElement(
        cue,
        an({}, R, {
          maxLength: c,
          onKeyDown: q,
          onChange: z,
          onFocus: ue,
          onBlur: de,
          onCompositionStart: Ce,
          onCompositionEnd: X,
          className: Mt(T == null ? void 0 : T.textarea),
          style: Ze(
            Ze({}, E == null ? void 0 : E.textarea),
            {},
            { resize: _ == null ? void 0 : _.resize }
          ),
          disabled: S,
          prefixCls: g,
          onResize: Me,
          ref: K,
          readOnly: N,
        })
      )
    );
  }),
  fue = function (n, e) {
    var t = {};
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) &&
        e.indexOf(r) < 0 &&
        (t[r] = n[r]);
    if (n != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
        e.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
          (t[r[i]] = n[r[i]]);
    return t;
  };
const hue = I.forwardRef((n, e) => {
    var t, r;
    const {
        prefixCls: i,
        bordered: s = !0,
        size: o,
        disabled: a,
        status: l,
        allowClear: c,
        classNames: u,
        rootClassName: d,
        className: h,
        style: m,
        styles: g,
        variant: x,
      } = n,
      y = fue(n, [
        "prefixCls",
        "bordered",
        "size",
        "disabled",
        "status",
        "allowClear",
        "classNames",
        "rootClassName",
        "className",
        "style",
        "styles",
        "variant",
      ]),
      { getPrefixCls: v, direction: _, textArea: S } = I.useContext(mr),
      w = Bd(o),
      T = I.useContext(Ed),
      E = a ?? T,
      { status: M, hasFeedback: N, feedbackIcon: R } = I.useContext(Bl),
      C = xR(M, l),
      L = I.useRef(null);
    I.useImperativeHandle(e, () => {
      var V;
      return {
        resizableTextArea:
          (V = L.current) === null || V === void 0
            ? void 0
            : V.resizableTextArea,
        focus: (k) => {
          var W, ee;
          zce(
            (ee =
              (W = L.current) === null || W === void 0
                ? void 0
                : W.resizableTextArea) === null || ee === void 0
              ? void 0
              : ee.textArea,
            k
          );
        },
        blur: () => {
          var k;
          return (k = L.current) === null || k === void 0 ? void 0 : k.blur();
        },
      };
    });
    const O = v("input", i),
      D = kd(O),
      [B, $, G] = SR(O, D),
      [j, U] = lV(x, s),
      H = bV(c ?? (S == null ? void 0 : S.allowClear));
    return B(
      I.createElement(
        due,
        Object.assign(
          { autoComplete: S == null ? void 0 : S.autoComplete },
          y,
          {
            style: Object.assign(
              Object.assign({}, S == null ? void 0 : S.style),
              m
            ),
            styles: Object.assign(
              Object.assign({}, S == null ? void 0 : S.styles),
              g
            ),
            disabled: E,
            allowClear: H,
            className: Mt(G, D, h, d, S == null ? void 0 : S.className),
            classNames: Object.assign(
              Object.assign(
                Object.assign({}, u),
                S == null ? void 0 : S.classNames
              ),
              {
                textarea: Mt(
                  { [`${O}-sm`]: w === "small", [`${O}-lg`]: w === "large" },
                  $,
                  u == null ? void 0 : u.textarea,
                  (t = S == null ? void 0 : S.classNames) === null ||
                    t === void 0
                    ? void 0
                    : t.textarea
                ),
                variant: Mt({ [`${O}-${j}`]: U }, bT(O, C)),
                affixWrapper: Mt(
                  `${O}-textarea-affix-wrapper`,
                  {
                    [`${O}-affix-wrapper-rtl`]: _ === "rtl",
                    [`${O}-affix-wrapper-sm`]: w === "small",
                    [`${O}-affix-wrapper-lg`]: w === "large",
                    [`${O}-textarea-show-count`]:
                      n.showCount ||
                      ((r = n.count) === null || r === void 0
                        ? void 0
                        : r.show),
                  },
                  $
                ),
              }
            ),
            prefixCls: O,
            suffix:
              N &&
              I.createElement("span", { className: `${O}-textarea-suffix` }, R),
            ref: L,
          }
        )
      )
    );
  }),
  gp = hS;
gp.Group = Fce;
gp.Search = rue;
gp.TextArea = hue;
gp.Password = tue;
gp.OTP = jce;
let Co = null,
  ed = (n) => n(),
  Kg = [],
  Zg = {};
function uD() {
  const { getContainer: n, duration: e, rtl: t, maxCount: r, top: i } = Zg,
    s = (n == null ? void 0 : n()) || document.body;
  return { getContainer: () => s, duration: e, rtl: t, maxCount: r, top: i };
}
const pue = Je.forwardRef((n, e) => {
    const { messageConfig: t, sync: r } = n,
      { getPrefixCls: i } = I.useContext(mr),
      s = Zg.prefixCls || i("message"),
      o = I.useContext(Ple),
      [a, l] = j5(
        Object.assign(
          Object.assign(Object.assign({}, t), { prefixCls: s }),
          o.message
        )
      );
    return (
      Je.useImperativeHandle(e, () => {
        const c = Object.assign({}, a);
        return (
          Object.keys(c).forEach((u) => {
            c[u] = function () {
              return r(), a[u].apply(a, arguments);
            };
          }),
          { instance: c, sync: r }
        );
      }),
      l
    );
  }),
  mue = Je.forwardRef((n, e) => {
    const [t, r] = Je.useState(uD),
      i = () => {
        r(uD);
      };
    Je.useEffect(i, []);
    const s = Pse(),
      o = s.getRootPrefixCls(),
      a = s.getIconPrefixCls(),
      l = s.getTheme(),
      c = Je.createElement(pue, { ref: e, sync: i, messageConfig: t });
    return Je.createElement(
      pp,
      { prefixCls: o, iconPrefixCls: a, theme: l },
      s.holderRender ? s.holderRender(c) : c
    );
  });
function pS() {
  if (!Co) {
    const n = document.createDocumentFragment(),
      e = { fragment: n };
    (Co = e),
      ed(() => {
        $5(
          Je.createElement(mue, {
            ref: (t) => {
              const { instance: r, sync: i } = t || {};
              Promise.resolve().then(() => {
                !e.instance && r && ((e.instance = r), (e.sync = i), pS());
              });
            },
          }),
          n
        );
      });
    return;
  }
  Co.instance &&
    (Kg.forEach((n) => {
      const { type: e, skipped: t } = n;
      if (!t)
        switch (e) {
          case "open": {
            ed(() => {
              const r = Co.instance.open(
                Object.assign(Object.assign({}, Zg), n.config)
              );
              r == null || r.then(n.resolve), n.setCloseFn(r);
            });
            break;
          }
          case "destroy":
            ed(() => {
              Co == null || Co.instance.destroy(n.key);
            });
            break;
          default:
            ed(() => {
              var r;
              const i = (r = Co.instance)[e].apply(r, Ot(n.args));
              i == null || i.then(n.resolve), n.setCloseFn(i);
            });
        }
    }),
    (Kg = []));
}
function gue(n) {
  (Zg = Object.assign(Object.assign({}, Zg), n)),
    ed(() => {
      var e;
      (e = Co == null ? void 0 : Co.sync) === null ||
        e === void 0 ||
        e.call(Co);
    });
}
function vue(n) {
  const e = hR((t) => {
    let r;
    const i = {
      type: "open",
      config: n,
      resolve: t,
      setCloseFn: (s) => {
        r = s;
      },
    };
    return (
      Kg.push(i),
      () => {
        r
          ? ed(() => {
              r();
            })
          : (i.skipped = !0);
      }
    );
  });
  return pS(), e;
}
function yue(n, e) {
  const t = hR((r) => {
    let i;
    const s = {
      type: n,
      args: e,
      resolve: r,
      setCloseFn: (o) => {
        i = o;
      },
    };
    return (
      Kg.push(s),
      () => {
        i
          ? ed(() => {
              i();
            })
          : (s.skipped = !0);
      }
    );
  });
  return pS(), t;
}
const xue = (n) => {
    Kg.push({ type: "destroy", key: n }), pS();
  },
  _ue = ["success", "info", "warning", "error", "loading"],
  Sue = {
    open: vue,
    destroy: xue,
    config: gue,
    useMessage: Uoe,
    _InternalPanelDoNotUseOrYouWillBeFired: Roe,
  },
  Rl = Sue;
_ue.forEach((n) => {
  Rl[n] = function () {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return yue(n, t);
  };
});
const MV = ({ radioValue: n }) => {
  const { checkedValue: e } = Cs((s) => s.exp),
    t = Sa(),
    r = I.useRef(null),
    i = (s) => {
      var o;
      t(Ste()),
        t(gte((o = s == null ? void 0 : s.target) == null ? void 0 : o.value));
    };
  return J.jsx(qg.Group, {
    defaultValue: e,
    ref: r,
    buttonStyle: "solid",
    onChange: i,
    style: { display: "flex", flexDirection: "column" },
    children: n.map((s) =>
      J.jsx(
        qg.Button,
        {
          style: {
            backgroundColor: e === s.value ? "#0e2134" : "transparent",
            borderColor: "#0e2134",
            marginBottom: 8,
          },
          value: s.value,
          children: s.title,
        },
        s.id
      )
    ),
  });
};
MV.propTypes = { radioValue: mc.arrayOf(mc.object).isRequired };
const TV = () => {
    const n = Sa(),
      {
        openTaskManger: e,
        DumbFile: t,
        showDumb: r,
        checkedValue: i,
        instructionIncludes: s,
      } = Cs((a) => a.exp);
    I.useEffect(() => {}, [r]);
    const o = (a) => {
      switch (a) {
        case "create":
          n(dB(!0));
          break;
      }
    };
    return (
      I.useEffect(() => {
        r &&
          (n(
            w1([
              "To preserve integrity of the files on the victim's PC we transfer the memorydump file to an Analyst machine.",
            ])
          ),
          n(A1(s[s.length - 1] + 1)),
          n(b0(["2"])));
      }, [r, n]),
      J.jsx("div", {
        children: J.jsxs("div", {
          children: [
            i === "1"
              ? J.jsx("h4", { children: "Create a Memory Dump File " })
              : J.jsx("h4", { children: "Create a Memory Dump File" }),
            J.jsx(jl, {
              onClick: () => o("create"),
              style: {
                background: t || r ? "grey" : "#0c2133",
                color: "white",
              },
              disabled: t || r,
              children: "MemoryDump tool",
            }),
            r &&
              J.jsxs("h4", {
                style: { color: "green" },
                children: [
                  J.jsx("mark", { children: "memory.dump " }),
                  " file created successfully.",
                ],
              }),
          ],
        }),
      })
    );
  },
  dD = { VERTEX: "vertex", FRAGMENT: "fragment" },
  On = { NONE: "none", FRAME: "frame", RENDER: "render", OBJECT: "object" },
  mS = ["x", "y", "z", "w"];
function CV(n, e = !1) {
  let t = "{";
  n.isNode === !0 && (t += n.id);
  for (const { property: r, childNode: i } of O1(n))
    t += "," + r.slice(0, -4) + ":" + i.getCacheKey(e);
  return (t += "}"), t;
}
function* O1(n, e = !1) {
  for (const t in n) {
    if (t.startsWith("_") === !0) continue;
    const r = n[t];
    if (Array.isArray(r) === !0)
      for (let i = 0; i < r.length; i++) {
        const s = r[i];
        s &&
          (s.isNode === !0 || (e && typeof s.toJSON == "function")) &&
          (yield { property: t, index: i, childNode: s });
      }
    else if (r && r.isNode === !0) yield { property: t, childNode: r };
    else if (typeof r == "object")
      for (const i in r) {
        const s = r[i];
        s &&
          (s.isNode === !0 || (e && typeof s.toJSON == "function")) &&
          (yield { property: t, index: i, childNode: s });
      }
  }
}
function Ec(n) {
  if (n == null) return null;
  const e = typeof n;
  return n.isNode === !0
    ? "node"
    : e === "number"
    ? "float"
    : e === "boolean"
    ? "bool"
    : e === "string"
    ? "string"
    : e === "function"
    ? "shader"
    : n.isVector2 === !0
    ? "vec2"
    : n.isVector3 === !0
    ? "vec3"
    : n.isVector4 === !0
    ? "vec4"
    : n.isMatrix3 === !0
    ? "mat3"
    : n.isMatrix4 === !0
    ? "mat4"
    : n.isColor === !0
    ? "color"
    : n instanceof ArrayBuffer
    ? "ArrayBuffer"
    : null;
}
function RV(n, ...e) {
  const t = n ? n.slice(-4) : void 0;
  return (
    e.length === 1 &&
      (t === "vec2"
        ? (e = [e[0], e[0]])
        : t === "vec3"
        ? (e = [e[0], e[0], e[0]])
        : t === "vec4" && (e = [e[0], e[0], e[0], e[0]])),
    n === "color"
      ? new pt(...e)
      : t === "vec2"
      ? new He(...e)
      : t === "vec3"
      ? new Q(...e)
      : t === "vec4"
      ? new rn(...e)
      : t === "mat3"
      ? new Qt(...e)
      : t === "mat4"
      ? new Ut(...e)
      : n === "bool"
      ? e[0] || !1
      : n === "float" || n === "int" || n === "uint"
      ? e[0] || 0
      : n === "string"
      ? e[0] || ""
      : n === "ArrayBuffer"
      ? PV(e[0])
      : null
  );
}
function NV(n) {
  let e = "";
  const t = new Uint8Array(n);
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return btoa(e);
}
function PV(n) {
  return Uint8Array.from(atob(n), (e) => e.charCodeAt(0)).buffer;
}
const fD = new Map();
let Aue = 0;
class Lt extends Go {
  constructor(e = null) {
    super(),
      (this.nodeType = e),
      (this.updateType = On.NONE),
      (this.updateBeforeType = On.NONE),
      (this.uuid = o2.generateUUID()),
      (this.version = 0),
      (this._cacheKey = null),
      (this._cacheKeyVersion = 0),
      (this.isNode = !0),
      Object.defineProperty(this, "id", { value: Aue++ });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(e, t) {
    return (this.updateType = t), (this.update = e.bind(this.getSelf())), this;
  }
  onFrameUpdate(e) {
    return this.onUpdate(e, On.FRAME);
  }
  onRenderUpdate(e) {
    return this.onUpdate(e, On.RENDER);
  }
  onObjectUpdate(e) {
    return this.onUpdate(e, On.OBJECT);
  }
  onReference(e) {
    return (this.updateReference = e.bind(this.getSelf())), this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    for (const { childNode: e } of O1(this)) yield e;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e) {
    e(this);
    for (const t of this.getChildren()) t.traverse(e);
  }
  getCacheKey(e = !1) {
    return (
      (e = e || this.version !== this._cacheKeyVersion),
      (e === !0 || this._cacheKey === null) &&
        ((this._cacheKey = CV(this, e)),
        (this._cacheKeyVersion = this.version)),
      this._cacheKey
    );
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    for (const r of this.getChildren()) t["_node" + r.id] = r;
    return null;
  }
  construct(e) {
    return (
      console.warn(
        "THREE.Node: construct() is deprecated. Use setup() instead."
      ),
      this.setup(e)
    );
  }
  increaseUsage(e) {
    const t = e.getDataFromNode(this);
    return (
      (t.usageCount = t.usageCount === void 0 ? 1 : t.usageCount + 1),
      t.usageCount
    );
  }
  analyze(e) {
    if (this.increaseUsage(e) === 1) {
      const r = e.getNodeProperties(this);
      for (const i of Object.values(r)) i && i.isNode === !0 && i.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    if (r && r.isNode === !0) return r.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const r = this.getShared(e);
    if (this !== r) return r.build(e, t);
    e.addNode(this), e.addChain(this);
    let i = null;
    const s = e.getBuildStage();
    if (s === "setup") {
      this.updateReference(e);
      const o = e.getNodeProperties(this);
      if (o.initialized !== !0 || e.context.tempRead === !1) {
        const a = e.stack.nodes.length;
        (o.initialized = !0),
          (o.outputNode = this.setup(e)),
          o.outputNode !== null &&
            e.stack.nodes.length !== a &&
            (o.outputNode = e.stack);
        for (const l of Object.values(o)) l && l.isNode === !0 && l.build(e);
      }
    } else if (s === "analyze") this.analyze(e);
    else if (s === "generate")
      if (this.generate.length === 1) {
        const a = this.getNodeType(e),
          l = e.getDataFromNode(this);
        (i = l.snippet),
          i === void 0 && ((i = this.generate(e) || ""), (l.snippet = i)),
          (i = e.format(i, a, t));
      } else i = this.generate(e, t) || "";
    return e.removeChain(this), i;
  }
  getSerializeChildren() {
    return O1(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(),
      r = {};
    for (const { property: i, index: s, childNode: o } of t)
      s !== void 0
        ? (r[i] === void 0 && (r[i] = Number.isInteger(s) ? [] : {}),
          (r[i][s] = o.toJSON(e.meta).uuid))
        : (r[i] = o.toJSON(e.meta).uuid);
    Object.keys(r).length > 0 && (e.inputNodes = r);
  }
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const r in e.inputNodes)
        if (Array.isArray(e.inputNodes[r])) {
          const i = [];
          for (const s of e.inputNodes[r]) i.push(t[s]);
          this[r] = i;
        } else if (typeof e.inputNodes[r] == "object") {
          const i = {};
          for (const s in e.inputNodes[r]) {
            const o = e.inputNodes[r][s];
            i[s] = t[o];
          }
          this[r] = i;
        } else {
          const i = e.inputNodes[r];
          this[r] = t[i];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: r } = this,
      i = e === void 0 || typeof e == "string";
    i && (e = { textures: {}, images: {}, nodes: {} });
    let s = e.nodes[t];
    s === void 0 &&
      ((s = {
        uuid: t,
        type: r,
        meta: e,
        metadata: { version: 4.6, type: "Node", generator: "Node.toJSON" },
      }),
      i !== !0 && (e.nodes[s.uuid] = s),
      this.serialize(s),
      delete s.meta);
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
    if (i) {
      const a = o(e.textures),
        l = o(e.images),
        c = o(e.nodes);
      a.length > 0 && (s.textures = a),
        l.length > 0 && (s.images = l),
        c.length > 0 && (s.nodes = c);
    }
    return s;
  }
}
function qe(n, e) {
  if (typeof e != "function" || !n)
    throw new Error(`Node class ${n} is not a class`);
  if (fD.has(n)) {
    console.warn(`Redefinition of node class ${n}`);
    return;
  }
  fD.set(n, e), (e.type = n);
}
class Fn extends Lt {
  constructor(e) {
    super(e), (this.isTempNode = !0);
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const i = e.getVectorType(this.getNodeType(e, t)),
        s = e.getDataFromNode(this);
      if (e.context.tempRead !== !1 && s.propertyName !== void 0)
        return e.format(s.propertyName, i, t);
      if (
        e.context.tempWrite !== !1 &&
        i !== "void" &&
        t !== "void" &&
        this.hasDependencies(e)
      ) {
        const o = super.build(e, i),
          a = e.getVarFromNode(this, null, i),
          l = e.getPropertyName(a);
        return (
          e.addLineFlowCode(`${l} = ${o}`),
          (s.snippet = o),
          (s.propertyName = l),
          e.format(s.propertyName, i, t)
        );
      }
    }
    return super.build(e, t);
  }
}
qe("TempNode", Fn);
class vp extends Lt {
  constructor(e, t) {
    super(),
      (this.node = e),
      (this.indexNode = t),
      (this.isArrayElementNode = !0);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node.build(e),
      r = this.indexNode.build(e, "uint");
    return `${t}[ ${r} ]`;
  }
}
qe("ArrayElementNode", vp);
class wR extends Lt {
  constructor(e, t) {
    super(), (this.node = e), (this.convertTo = t);
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let r = null;
    for (const i of this.convertTo.split("|"))
      (r === null || e.getTypeLength(t) === e.getTypeLength(i)) && (r = i);
    return r;
  }
  serialize(e) {
    super.serialize(e), (e.convertTo = this.convertTo);
  }
  deserialize(e) {
    super.deserialize(e), (this.convertTo = e.convertTo);
  }
  generate(e, t) {
    const r = this.node,
      i = this.getNodeType(e),
      s = r.build(e, i);
    return e.format(s, i, t);
  }
}
qe("ConvertNode", wR);
class IV extends Fn {
  constructor(e = [], t = null) {
    super(t), (this.nodes = e);
  }
  getNodeType(e) {
    return this.nodeType !== null
      ? e.getVectorType(this.nodeType)
      : e.getTypeFromLength(
          this.nodes.reduce((t, r) => t + e.getTypeLength(r.getNodeType(e)), 0)
        );
  }
  generate(e, t) {
    const r = this.getNodeType(e),
      i = this.nodes,
      s = e.getComponentType(r),
      o = [];
    for (const l of i) {
      let c = l.build(e);
      const u = e.getComponentType(l.getNodeType(e));
      u !== s && (c = e.format(c, u, s)), o.push(c);
    }
    const a = `${e.getType(r)}( ${o.join(", ")} )`;
    return e.format(a, r, t);
  }
}
qe("JoinNode", IV);
const wue = mS.join("");
class ET extends Lt {
  constructor(e, t = "x") {
    super(), (this.node = e), (this.components = t), (this.isSplitNode = !0);
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components) e = Math.max(mS.indexOf(t) + 1, e);
    return e;
  }
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  getNodeType(e) {
    return e.getTypeFromLength(
      this.components.length,
      this.getComponentType(e)
    );
  }
  generate(e, t) {
    const r = this.node,
      i = e.getTypeLength(r.getNodeType(e));
    let s = null;
    if (i > 1) {
      let o = null;
      this.getVectorLength() >= i &&
        (o = e.getTypeFromLength(
          this.getVectorLength(),
          this.getComponentType(e)
        ));
      const l = r.build(e, o);
      this.components.length === i &&
      this.components === wue.slice(0, this.components.length)
        ? (s = e.format(l, o, t))
        : (s = e.format(`${l}.${this.components}`, this.getNodeType(e), t));
    } else s = r.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), (e.components = this.components);
  }
  deserialize(e) {
    super.deserialize(e), (this.components = e.components);
  }
}
qe("SplitNode", ET);
class LV extends Fn {
  constructor(e, t, r) {
    super(),
      (this.sourceNode = e),
      (this.components = t),
      (this.targetNode = r);
  }
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: r, targetNode: i } = this,
      s = this.getNodeType(e),
      o = e.getTypeFromLength(r.length),
      a = i.build(e, o),
      l = t.build(e, s),
      c = e.getTypeLength(s),
      u = [];
    for (let d = 0; d < c; d++) {
      const h = mS[d];
      h === r[0] ? (u.push(a), (d += r.length - 1)) : u.push(l + "." + h);
    }
    return `${e.getType(s)}( ${u.join(", ")} )`;
  }
}
qe("SetNode", LV);
class gS extends Lt {
  constructor(e, t = null) {
    super(t),
      (this.isInputNode = !0),
      (this.value = e),
      (this.precision = null);
  }
  getNodeType() {
    return this.nodeType === null ? Ec(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return (this.precision = e), this;
  }
  serialize(e) {
    super.serialize(e),
      (e.value = this.value),
      this.value && this.value.toArray && (e.value = this.value.toArray()),
      (e.valueType = Ec(this.value)),
      (e.nodeType = this.nodeType),
      e.valueType === "ArrayBuffer" && (e.value = NV(e.value)),
      (e.precision = this.precision);
  }
  deserialize(e) {
    super.deserialize(e),
      (this.nodeType = e.nodeType),
      (this.value = Array.isArray(e.value)
        ? RV(e.valueType, ...e.value)
        : e.value),
      (this.precision = e.precision || null),
      this.value &&
        this.value.fromArray &&
        (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
qe("InputNode", gS);
class jo extends gS {
  constructor(e, t = null) {
    super(e, t), (this.isConstNode = !0);
  }
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const r = this.getNodeType(e);
    return e.format(this.generateConst(e), r, t);
  }
}
qe("ConstNode", jo);
let qh = null;
const lh = new Map();
function Ae(n, e) {
  if (lh.has(n)) {
    console.warn(`Redefinition of node element ${n}`);
    return;
  }
  if (typeof e != "function")
    throw new Error(`Node element ${n} is not a function`);
  lh.set(n, e);
}
const hD = (n) =>
    n
      .replace(/r|s/g, "x")
      .replace(/g|t/g, "y")
      .replace(/b|p/g, "z")
      .replace(/a|q/g, "w"),
  OV = {
    setup(n, e) {
      const t = e.shift();
      return n(xS(t), ...e);
    },
    get(n, e, t) {
      if (typeof e == "string" && n[e] === void 0) {
        if (n.isStackNode !== !0 && e === "assign")
          return (...r) => (qh.assign(t, ...r), t);
        if (lh.has(e)) {
          const r = lh.get(e);
          return n.isStackNode
            ? (...i) => t.add(r(...i))
            : (...i) => r(t, ...i);
        } else {
          if (e === "self") return n;
          if (e.endsWith("Assign") && lh.has(e.slice(0, e.length - 6))) {
            const r = lh.get(e.slice(0, e.length - 6));
            return n.isStackNode
              ? (...i) => t.assign(i[0], r(...i))
              : (...i) => t.assign(r(t, ...i));
          } else {
            if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
              return (e = hD(e)), ct(new ET(t, e));
            if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
              return (
                (e = hD(e.slice(3).toLowerCase())),
                (e = e.split("").sort().join("")),
                (r) => ct(new LV(n, e, r))
              );
            if (e === "width" || e === "height" || e === "depth")
              return (
                e === "width"
                  ? (e = "x")
                  : e === "height"
                  ? (e = "y")
                  : e === "depth" && (e = "z"),
                ct(new ET(n, e))
              );
            if (/^\d+$/.test(e) === !0)
              return ct(new vp(t, new jo(Number(e), "uint")));
          }
        }
      }
      return Reflect.get(n, e, t);
    },
    set(n, e, t, r) {
      return typeof e == "string" &&
        n[e] === void 0 &&
        (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 ||
          e === "width" ||
          e === "height" ||
          e === "depth" ||
          /^\d+$/.test(e) === !0)
        ? (r[e].assign(t), !0)
        : Reflect.set(n, e, t, r);
    },
  },
  bb = new WeakMap(),
  pD = new WeakMap(),
  bue = function (n, e = null) {
    const t = Ec(n);
    if (t === "node") {
      let r = bb.get(n);
      return (
        r === void 0 && ((r = new Proxy(n, OV)), bb.set(n, r), bb.set(r, r)), r
      );
    } else {
      if (
        (e === null && (t === "float" || t === "boolean")) ||
        (t && t !== "shader" && t !== "string")
      )
        return ct(MT(n, e));
      if (t === "shader") return je(n);
    }
    return n;
  },
  Eue = function (n, e = null) {
    for (const t in n) n[t] = ct(n[t], e);
    return n;
  },
  Mue = function (n, e = null) {
    const t = n.length;
    for (let r = 0; r < t; r++) n[r] = ct(n[r], e);
    return n;
  },
  Tue = function (n, e = null, t = null, r = null) {
    const i = (s) => ct(r !== null ? Object.assign(s, r) : s);
    return e === null
      ? (...s) => i(new n(...Sh(s)))
      : t !== null
      ? ((t = ct(t)), (...s) => i(new n(e, ...Sh(s), t)))
      : (...s) => i(new n(e, ...Sh(s)));
  },
  Cue = function (n, ...e) {
    return ct(new n(...Sh(e)));
  };
class Rue extends Lt {
  constructor(e, t) {
    super(), (this.shaderNode = e), (this.inputNodes = t);
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  call(e) {
    const { shaderNode: t, inputNodes: r } = this;
    if (t.layout) {
      let o = pD.get(e.constructor);
      o === void 0 && ((o = new WeakMap()), pD.set(e.constructor, o));
      let a = o.get(t);
      return (
        a === void 0 && ((a = ct(e.buildFunctionNode(t))), o.set(t, a)),
        e.currentFunctionNode !== null &&
          e.currentFunctionNode.includes.push(a),
        ct(a.call(r))
      );
    }
    const i = t.jsFunc,
      s = r !== null ? i(r, e.stack, e) : i(e.stack, e);
    return ct(s);
  }
  setup(e) {
    return e.addStack(), (e.stack.outputNode = this.call(e)), e.removeStack();
  }
  generate(e, t) {
    const { outputNode: r } = e.getNodeProperties(this);
    return r === null ? this.call(e).build(e, t) : super.generate(e, t);
  }
}
class Nue extends Lt {
  constructor(e) {
    super(), (this.jsFunc = e), (this.layout = null);
  }
  get isArrayInput() {
    return /^\((\s+)?\[/.test(this.jsFunc.toString());
  }
  setLayout(e) {
    return (this.layout = e), this;
  }
  call(e = null) {
    return xS(e), ct(new Rue(this, e));
  }
  setup() {
    return this.call();
  }
}
const Pue = [!1, !0],
  Iue = [0, 1, 2, 3],
  Lue = [-1, -2],
  DV = [
    0.5,
    1.5,
    1 / 3,
    1e-6,
    1e6,
    Math.PI,
    Math.PI * 2,
    1 / Math.PI,
    2 / Math.PI,
    1 / (Math.PI * 2),
    Math.PI / 2,
  ],
  bR = new Map();
for (const n of Pue) bR.set(n, new jo(n));
const ER = new Map();
for (const n of Iue) ER.set(n, new jo(n, "uint"));
const MR = new Map([...ER].map((n) => new jo(n.value, "int")));
for (const n of Lue) MR.set(n, new jo(n, "int"));
const vS = new Map([...MR].map((n) => new jo(n.value)));
for (const n of DV) vS.set(n, new jo(n));
for (const n of DV) vS.set(-n, new jo(-n));
const yS = { bool: bR, uint: ER, ints: MR, float: vS },
  mD = new Map([...bR, ...vS]),
  MT = (n, e) => (mD.has(n) ? mD.get(n) : n.isNode === !0 ? n : new jo(n, e)),
  Oue = (n) => {
    try {
      return n.getNodeType();
    } catch {
      return;
    }
  },
  Cn = function (n, e = null) {
    return (...t) => {
      if (
        ((t.length === 0 ||
          (!["bool", "float", "int", "uint"].includes(n) &&
            t.every((i) => typeof i != "object"))) &&
          (t = [RV(n, ...t)]),
        t.length === 1 && e !== null && e.has(t[0]))
      )
        return ct(e.get(t[0]));
      if (t.length === 1) {
        const i = MT(t[0], n);
        return Oue(i) === n ? ct(i) : ct(new wR(i, n));
      }
      const r = t.map((i) => MT(i));
      return ct(new IV(r, n));
    };
  },
  gD = (n) => n && n.value,
  Due = (n) =>
    n != null
      ? n.nodeType || n.convertTo || (typeof n == "string" ? n : null)
      : null;
function eg(n) {
  return new Proxy(new Nue(n), OV);
}
const ct = (n, e = null) => bue(n, e),
  xS = (n, e = null) => new Eue(n, e),
  Sh = (n, e = null) => new Mue(n, e),
  De = (...n) => new Tue(...n),
  Qe = (...n) => new Cue(...n),
  je = (n) => {
    const e = new eg(n),
      t = (...r) => {
        let i;
        return (
          xS(r), r[0] && r[0].isNode ? (i = [...r]) : (i = r[0]), e.call(i)
        );
      };
    return (t.shaderNode = e), (t.setLayout = (r) => (e.setLayout(r), t)), t;
  };
qe("ShaderNode", eg);
const vD = (n) => {
    qh = n;
  },
  Fue = () => qh,
  on = (...n) => qh.if(...n);
function Uue(n) {
  return qh && qh.add(n), n;
}
Ae("append", Uue);
const kue = new Cn("color"),
  oe = new Cn("float", yS.float),
  ce = new Cn("int", yS.ints),
  ut = new Cn("uint", yS.uint),
  Td = new Cn("bool", yS.bool),
  Ct = new Cn("vec2"),
  td = new Cn("ivec2"),
  zue = new Cn("uvec2"),
  Bue = new Cn("bvec2"),
  _e = new Cn("vec3"),
  Vue = new Cn("ivec3"),
  R0 = new Cn("uvec3"),
  FV = new Cn("bvec3"),
  Tt = new Cn("vec4"),
  Hue = new Cn("ivec4"),
  Gue = new Cn("uvec4"),
  Wue = new Cn("bvec4"),
  TR = new Cn("mat2"),
  jue = new Cn("imat2"),
  $ue = new Cn("umat2"),
  Xue = new Cn("bmat2"),
  ya = new Cn("mat3"),
  Yue = new Cn("imat3"),
  que = new Cn("umat3"),
  Kue = new Cn("bmat3"),
  Ah = new Cn("mat4"),
  Zue = new Cn("imat4"),
  Que = new Cn("umat4"),
  Jue = new Cn("bmat4"),
  ede = (n = "") => ct(new jo(n, "string")),
  tde = (n) => ct(new jo(n, "ArrayBuffer"));
Ae("color", kue);
Ae("float", oe);
Ae("int", ce);
Ae("uint", ut);
Ae("bool", Td);
Ae("vec2", Ct);
Ae("ivec2", td);
Ae("uvec2", zue);
Ae("bvec2", Bue);
Ae("vec3", _e);
Ae("ivec3", Vue);
Ae("uvec3", R0);
Ae("bvec3", FV);
Ae("vec4", Tt);
Ae("ivec4", Hue);
Ae("uvec4", Gue);
Ae("bvec4", Wue);
Ae("mat2", TR);
Ae("imat2", jue);
Ae("umat2", $ue);
Ae("bmat2", Xue);
Ae("mat3", ya);
Ae("imat3", Yue);
Ae("umat3", que);
Ae("bmat3", Kue);
Ae("mat4", Ah);
Ae("imat4", Zue);
Ae("umat4", Que);
Ae("bmat4", Jue);
Ae("string", ede);
Ae("arrayBuffer", tde);
const nde = De(vp),
  rde = (n, e) => ct(new wR(ct(n), e));
Ae("element", nde);
Ae("convert", rde);
class UV extends Fn {
  constructor(e, t) {
    super(), (this.targetNode = e), (this.sourceNode = t);
  }
  hasDependencies() {
    return !1;
  }
  getNodeType(e, t) {
    return t !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  needsSplitAssign(e) {
    const { targetNode: t } = this;
    if (
      e.isAvailable("swizzleAssign") === !1 &&
      t.isSplitNode &&
      t.components.length > 1
    ) {
      const r = e.getTypeLength(t.node.getNodeType(e));
      return mS.join("").slice(0, r) !== t.components;
    }
    return !1;
  }
  generate(e, t) {
    const { targetNode: r, sourceNode: i } = this,
      s = this.needsSplitAssign(e),
      o = r.getNodeType(e),
      a = r.context({ assign: !0 }).build(e),
      l = i.build(e, o),
      c = i.getNodeType(e),
      u = e.getDataFromNode(this);
    let d;
    if (u.initialized === !0) t !== "void" && (d = a);
    else if (s) {
      const h = e.getVarFromNode(this, null, o),
        m = e.getPropertyName(h);
      e.addLineFlowCode(`${m} = ${l}`);
      const g = r.node.context({ assign: !0 }).build(e);
      for (let x = 0; x < r.components.length; x++) {
        const y = r.components[x];
        e.addLineFlowCode(`${g}.${y} = ${m}[ ${x} ]`);
      }
      t !== "void" && (d = a);
    } else
      (d = `${a} = ${l}`),
        (t === "void" || c === "void") &&
          (e.addLineFlowCode(d), t !== "void" && (d = a));
    return (u.initialized = !0), e.format(d, o, t);
  }
}
const ide = De(UV);
qe("AssignNode", UV);
Ae("assign", ide);
class kV extends Lt {
  constructor(e, t = null) {
    super(), (this.node = e), (this.name = t), (this.isVaryingNode = !0);
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: r } = this,
      i = this.getNodeType(e),
      s = e.getVaryingFromNode(this, t, i);
    s.needsInterpolation ||
      (s.needsInterpolation = e.shaderStage === "fragment");
    const o = e.getPropertyName(s, dD.VERTEX);
    return e.flowNodeFromShaderStage(dD.VERTEX, r, i, o), e.getPropertyName(s);
  }
}
const fr = De(kV);
Ae("varying", fr);
qe("VaryingNode", kV);
class _S extends Lt {
  constructor(e, t = null) {
    super(t), (this._attributeName = e);
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (t === null) {
      const r = this.getAttributeName(e);
      if (e.hasGeometryAttribute(r)) {
        const i = e.geometry.getAttribute(r);
        t = e.getTypeFromAttribute(i);
      } else t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return (this._attributeName = e), this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e),
      r = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t),
        o = e.getTypeFromAttribute(s),
        a = e.getAttribute(t, o);
      return e.shaderStage === "vertex"
        ? e.format(a.name, o, r)
        : fr(this).build(e, r);
    } else
      return (
        console.warn(
          `AttributeNode: Vertex attribute "${t}" not found on geometry.`
        ),
        e.generateConst(r)
      );
  }
}
const Ui = (n, e) => ct(new _S(n, e));
qe("AttributeNode", _S);
class zV extends Lt {
  constructor(e, t) {
    super(),
      (this.isBypassNode = !0),
      (this.outputNode = e),
      (this.callNode = t);
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const BV = De(zV);
Ae("bypass", BV);
qe("BypassNode", zV);
let sde = 0;
class ode {
  constructor() {
    (this.id = sde++), (this.nodesData = new WeakMap());
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
}
class VV extends Lt {
  constructor(e, t = new ode()) {
    super(), (this.isCacheNode = !0), (this.node = e), (this.cache = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const r = e.getCache(),
      i = this.cache || e.globalCache;
    e.setCache(i);
    const s = this.node.build(e, ...t);
    return e.setCache(r), s;
  }
}
const D1 = De(VV),
  ade = (n) => D1(n, null);
Ae("cache", D1);
Ae("globalCache", ade);
qe("CacheNode", VV);
class CR extends Lt {
  constructor(e, t = {}) {
    super(), (this.isContextNode = !0), (this.node = e), (this.context = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const r = this.node.build(e);
    return e.setContext(t), r;
  }
  generate(e, t) {
    const r = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const i = this.node.build(e, t);
    return e.setContext(r), i;
  }
}
const Nl = De(CR),
  lde = (n, e) => Nl(n, { label: e });
Ae("context", Nl);
Ae("label", lde);
qe("ContextNode", CR);
class qa extends Lt {
  constructor(e) {
    super("uint"), (this.scope = e), (this.isInstanceIndexNode = !0);
  }
  generate(e) {
    const t = this.getNodeType(e),
      r = this.scope;
    let i;
    if (r === qa.VERTEX) i = e.getVertexIndex();
    else if (r === qa.INSTANCE) i = e.getInstanceIndex();
    else throw new Error("THREE.IndexNode: Unknown scope: " + r);
    let s;
    return (
      e.shaderStage === "vertex" || e.shaderStage === "compute"
        ? (s = i)
        : (s = fr(this).build(e, t)),
      s
    );
  }
}
qa.VERTEX = "vertex";
qa.INSTANCE = "instance";
const cde = Qe(qa, qa.VERTEX),
  HV = Qe(qa, qa.INSTANCE);
qe("IndexNode", qa);
class RR {
  start() {}
  finish() {}
  direct() {}
  indirectDiffuse() {}
  indirectSpecular() {}
  ambientOcclusion() {}
}
class GV extends Lt {
  constructor(e, t = null) {
    super(), (this.node = e), (this.name = t), (this.isVarNode = !0);
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: t, name: r } = this,
      i = e.getVarFromNode(this, r, e.getVectorType(this.getNodeType(e))),
      s = e.getPropertyName(i),
      o = t.build(e, i.type);
    return e.addLineFlowCode(`${s} = ${o}`), s;
  }
}
const Qg = De(GV);
Ae("temp", Qg);
Ae("toVar", (...n) => Qg(...n).append());
qe("VarNode", GV);
class An extends Lt {
  constructor(e, t = null, r = !1) {
    super(e), (this.name = t), (this.varying = r), (this.isPropertyNode = !0);
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    let t;
    return (
      this.varying === !0
        ? ((t = e.getVaryingFromNode(this, this.name)),
          (t.needsInterpolation = !0))
        : (t = e.getVarFromNode(this, this.name)),
      e.getPropertyName(t)
    );
  }
}
const di = (n, e) => ct(new An(n, e)),
  Da = (n, e) => ct(new An(n, e, !0)),
  er = Qe(An, "vec4", "DiffuseColor"),
  Mc = Qe(An, "float", "Roughness"),
  F1 = Qe(An, "float", "Metalness"),
  TT = Qe(An, "float", "Clearcoat"),
  U1 = Qe(An, "float", "ClearcoatRoughness"),
  ch = Qe(An, "vec3", "Sheen"),
  NR = Qe(An, "float", "SheenRoughness"),
  PR = Qe(An, "float", "Iridescence"),
  WV = Qe(An, "float", "IridescenceIOR"),
  jV = Qe(An, "float", "IridescenceThickness"),
  CT = Qe(An, "float", "AlphaT"),
  zu = Qe(An, "float", "Anisotropy"),
  Fx = Qe(An, "vec3", "AnisotropyT"),
  wh = Qe(An, "vec3", "AnisotropyB"),
  sa = Qe(An, "color", "SpecularColor"),
  k1 = Qe(An, "float", "SpecularF90"),
  RT = Qe(An, "float", "Shininess"),
  ude = Qe(An, "vec4", "Output"),
  bh = Qe(An, "float", "dashSize"),
  z1 = Qe(An, "float", "gapSize");
Qe(An, "float", "pointWidth");
const Ux = Qe(An, "float", "IOR"),
  NT = Qe(An, "float", "Transmission"),
  $V = Qe(An, "float", "Thickness"),
  XV = Qe(An, "float", "AttenuationDistance"),
  YV = Qe(An, "color", "AttenuationColor");
qe("PropertyNode", An);
class dde extends An {
  constructor(e, t = null) {
    super(e, t), (this.isParameterNode = !0);
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
qe("ParameterNode", dde);
class IR extends Lt {
  constructor(e = "", t = [], r = "") {
    super("code"),
      (this.isCodeNode = !0),
      (this.code = e),
      (this.language = r),
      (this.includes = t);
  }
  isGlobal() {
    return !0;
  }
  setIncludes(e) {
    return (this.includes = e), this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const i of t) i.build(e);
    const r = e.getCodeFromNode(this, this.getNodeType(e));
    return (r.code = this.code), r.code;
  }
  serialize(e) {
    super.serialize(e), (e.code = this.code), (e.language = this.language);
  }
  deserialize(e) {
    super.deserialize(e), (this.code = e.code), (this.language = e.language);
  }
}
De(IR);
qe("CodeNode", IR);
class fde extends IR {
  constructor(e = "", t = [], r = "") {
    super(e, t, r), (this.keywords = {});
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let r = t.nodeFunction;
    return (
      r === void 0 &&
        ((r = e.parser.parseFunction(this.code)), (t.nodeFunction = r)),
      r
    );
  }
  generate(e, t) {
    super.generate(e);
    const r = this.getNodeFunction(e),
      i = r.name,
      s = r.type,
      o = e.getCodeFromNode(this, s);
    i !== "" && (o.name = i);
    const a = e.getPropertyName(o);
    let l = this.getNodeFunction(e).getCode(a);
    const c = this.keywords,
      u = Object.keys(c);
    if (u.length > 0)
      for (const d of u) {
        const h = new RegExp(`\\b${d}\\b`, "g"),
          m = c[d].build(e, "property");
        l = l.replace(h, m);
      }
    return (
      (o.code =
        l +
        `
`),
      t === "property" ? a : e.format(`${a}()`, s, t)
    );
  }
}
qe("FunctionNode", fde);
class LR extends Lt {
  constructor(e, t = !1) {
    super("string"),
      (this.name = e),
      (this.version = 0),
      (this.shared = t),
      (this.isUniformGroup = !0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const hde = (n) => new LR(n),
  qV = (n) => new LR(n, !0);
qV("frame");
qV("render");
const pde = hde("object");
qe("UniformGroupNode", LR);
class Vd extends gS {
  constructor(e, t = null) {
    super(e, t), (this.isUniformNode = !0), (this.groupNode = pde);
  }
  setGroup(e) {
    return (this.groupNode = e), this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, t) {
    const r = this.getSelf();
    return (
      (e = e.bind(r)),
      super.onUpdate((i) => {
        const s = e(i, r);
        s !== void 0 && (this.value = s);
      }, t)
    );
  }
  generate(e, t) {
    const r = this.getNodeType(e),
      i = this.getUniformHash(e);
    let s = e.getNodeFromHash(i);
    s === void 0 && (e.setHashNode(this, i), (s = this));
    const o = s.getInputType(e),
      a = e.getUniformFromNode(s, o, e.shaderStage, e.context.label),
      l = e.getPropertyName(a);
    return (
      e.context.label !== void 0 && delete e.context.label, e.format(l, r, t)
    );
  }
}
const Dn = (n, e) => {
  const t = Due(e || n),
    r = n && n.isNode === !0 ? (n.node && n.node.value) || n.value : n;
  return ct(new Vd(r, t));
};
qe("UniformNode", Vd);
class KV extends _S {
  constructor(e = 0) {
    super(null, "vec2"), (this.isUVNode = !0), (this.index = e);
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), (e.index = this.index);
  }
  deserialize(e) {
    super.deserialize(e), (this.index = e.index);
  }
}
const Ja = (...n) => ct(new KV(...n));
qe("UVNode", KV);
class ZV extends Lt {
  constructor(e, t = null) {
    super("uvec2"),
      (this.isTextureSizeNode = !0),
      (this.textureNode = e),
      (this.levelNode = t);
  }
  generate(e, t) {
    const r = this.textureNode.build(e, "property"),
      i = this.levelNode.build(e, "int");
    return e.format(
      `${e.getMethod("textureDimensions")}( ${r}, ${i} )`,
      this.getNodeType(e),
      t
    );
  }
}
const OR = De(ZV);
Ae("textureSize", OR);
qe("TextureSizeNode", ZV);
class Kn extends Fn {
  constructor(e, t, r, ...i) {
    if ((super(), (this.op = e), i.length > 0)) {
      let s = r;
      for (let o = 0; o < i.length; o++) s = new Kn(e, s, i[o]);
      r = s;
    }
    (this.aNode = t), (this.bNode = r);
  }
  getNodeType(e, t) {
    const r = this.op,
      i = this.aNode,
      s = this.bNode,
      o = i.getNodeType(e),
      a = typeof s < "u" ? s.getNodeType(e) : null;
    if (o === "void" || a === "void") return "void";
    if (r === "%") return o;
    if (
      r === "~" ||
      r === "&" ||
      r === "|" ||
      r === "^" ||
      r === ">>" ||
      r === "<<"
    )
      return e.getIntegerType(o);
    if (r === "!" || r === "==" || r === "&&" || r === "||" || r === "^^")
      return "bool";
    if (r === "<" || r === ">" || r === "<=" || r === ">=") {
      const l = t
        ? e.getTypeLength(t)
        : Math.max(e.getTypeLength(o), e.getTypeLength(a));
      return l > 1 ? `bvec${l}` : "bool";
    } else
      return o === "float" && e.isMatrix(a)
        ? a
        : e.isMatrix(o) && e.isVector(a)
        ? e.getVectorFromMatrix(o)
        : e.isVector(o) && e.isMatrix(a)
        ? e.getVectorFromMatrix(a)
        : e.getTypeLength(a) > e.getTypeLength(o)
        ? a
        : o;
  }
  generate(e, t) {
    const r = this.op,
      i = this.aNode,
      s = this.bNode,
      o = this.getNodeType(e, t);
    let a = null,
      l = null;
    o !== "void"
      ? ((a = i.getNodeType(e)),
        (l = typeof s < "u" ? s.getNodeType(e) : null),
        r === "<" || r === ">" || r === "<=" || r === ">=" || r === "=="
          ? e.isVector(a)
            ? (l = a)
            : (a = l = "float")
          : r === ">>" || r === "<<"
          ? ((a = o), (l = e.changeComponentType(l, "uint")))
          : e.isMatrix(a) && e.isVector(l)
          ? (l = e.getVectorFromMatrix(a))
          : e.isVector(a) && e.isMatrix(l)
          ? (a = e.getVectorFromMatrix(l))
          : (a = l = o))
      : (a = l = o);
    const c = i.build(e, a),
      u = typeof s < "u" ? s.build(e, l) : null,
      d = e.getTypeLength(t),
      h = e.getFunctionOperator(r);
    if (t !== "void")
      return r === "<" && d > 1
        ? e.format(`${e.getMethod("lessThan")}( ${c}, ${u} )`, o, t)
        : r === "<=" && d > 1
        ? e.format(`${e.getMethod("lessThanEqual")}( ${c}, ${u} )`, o, t)
        : r === ">" && d > 1
        ? e.format(`${e.getMethod("greaterThan")}( ${c}, ${u} )`, o, t)
        : r === ">=" && d > 1
        ? e.format(`${e.getMethod("greaterThanEqual")}( ${c}, ${u} )`, o, t)
        : r === "!" || r === "~"
        ? e.format(`(${r}${c})`, a, t)
        : h
        ? e.format(`${h}( ${c}, ${u} )`, o, t)
        : e.format(`( ${c} ${r} ${u} )`, o, t);
    if (a !== "void")
      return h
        ? e.format(`${h}( ${c}, ${u} )`, o, t)
        : e.format(`${c} ${r} ${u}`, o, t);
  }
  serialize(e) {
    super.serialize(e), (e.op = this.op);
  }
  deserialize(e) {
    super.deserialize(e), (this.op = e.op);
  }
}
const uo = De(Kn, "+"),
  Mr = De(Kn, "-"),
  hn = De(Kn, "*"),
  $c = De(Kn, "/"),
  mde = De(Kn, "%"),
  gde = De(Kn, "=="),
  vde = De(Kn, "!="),
  yde = De(Kn, "<"),
  QV = De(Kn, ">"),
  xde = De(Kn, "<="),
  _de = De(Kn, ">="),
  Sde = De(Kn, "&&"),
  Ade = De(Kn, "||"),
  wde = De(Kn, "!"),
  bde = De(Kn, "^^"),
  Ede = De(Kn, "&"),
  Mde = De(Kn, "~"),
  Tde = De(Kn, "|"),
  Cde = De(Kn, "^"),
  Rde = De(Kn, "<<"),
  Nde = De(Kn, ">>");
Ae("add", uo);
Ae("sub", Mr);
Ae("mul", hn);
Ae("div", $c);
Ae("remainder", mde);
Ae("equal", gde);
Ae("notEqual", vde);
Ae("lessThan", yde);
Ae("greaterThan", QV);
Ae("lessThanEqual", xde);
Ae("greaterThanEqual", _de);
Ae("and", Sde);
Ae("or", Ade);
Ae("not", wde);
Ae("xor", bde);
Ae("bitAnd", Ede);
Ae("bitNot", Mde);
Ae("bitOr", Tde);
Ae("bitXor", Cde);
Ae("shiftLeft", Rde);
Ae("shiftRight", Nde);
qe("OperatorNode", Kn);
class ye extends Fn {
  constructor(e, t, r = null, i = null) {
    super(),
      (this.method = e),
      (this.aNode = t),
      (this.bNode = r),
      (this.cNode = i);
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e),
      r = this.bNode ? this.bNode.getNodeType(e) : null,
      i = this.cNode ? this.cNode.getNodeType(e) : null,
      s = e.isMatrix(t) ? 0 : e.getTypeLength(t),
      o = e.isMatrix(r) ? 0 : e.getTypeLength(r),
      a = e.isMatrix(i) ? 0 : e.getTypeLength(i);
    return s > o && s > a ? t : o > a ? r : a > s ? i : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === ye.LENGTH || t === ye.DISTANCE || t === ye.DOT
      ? "float"
      : t === ye.CROSS
      ? "vec3"
      : t === ye.ALL
      ? "bool"
      : t === ye.EQUALS
      ? e.changeComponentType(this.aNode.getNodeType(e), "bool")
      : t === ye.MOD
      ? this.aNode.getNodeType(e)
      : this.getInputType(e);
  }
  generate(e, t) {
    const r = this.method,
      i = this.getNodeType(e),
      s = this.getInputType(e),
      o = this.aNode,
      a = this.bNode,
      l = this.cNode,
      c = e.renderer.isWebGLRenderer === !0;
    if (r === ye.TRANSFORM_DIRECTION) {
      let u = o,
        d = a;
      e.isMatrix(u.getNodeType(e)) ? (d = Tt(_e(d), 0)) : (u = Tt(_e(u), 0));
      const h = hn(u, d).xyz;
      return ns(h).build(e, t);
    } else {
      if (r === ye.NEGATE) return e.format("( - " + o.build(e, s) + " )", i, t);
      if (r === ye.ONE_MINUS) return Mr(1, o).build(e, t);
      if (r === ye.RECIPROCAL) return $c(1, o).build(e, t);
      if (r === ye.DIFFERENCE) return Ir(Mr(o, a)).build(e, t);
      {
        const u = [];
        return (
          r === ye.CROSS || r === ye.MOD
            ? u.push(o.build(e, i), a.build(e, i))
            : r === ye.STEP
            ? u.push(
                o.build(
                  e,
                  e.getTypeLength(o.getNodeType(e)) === 1 ? "float" : s
                ),
                a.build(e, s)
              )
            : (c && (r === ye.MIN || r === ye.MAX)) || r === ye.MOD
            ? u.push(
                o.build(e, s),
                a.build(
                  e,
                  e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : s
                )
              )
            : r === ye.REFRACT
            ? u.push(o.build(e, s), a.build(e, s), l.build(e, "float"))
            : r === ye.MIX
            ? u.push(
                o.build(e, s),
                a.build(e, s),
                l.build(
                  e,
                  e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : s
                )
              )
            : (u.push(o.build(e, s)),
              a !== null && u.push(a.build(e, s)),
              l !== null && u.push(l.build(e, s))),
          e.format(`${e.getMethod(r, i)}( ${u.join(", ")} )`, i, t)
        );
      }
    }
  }
  serialize(e) {
    super.serialize(e), (e.method = this.method);
  }
  deserialize(e) {
    super.deserialize(e), (this.method = e.method);
  }
}
ye.ALL = "all";
ye.ANY = "any";
ye.EQUALS = "equals";
ye.RADIANS = "radians";
ye.DEGREES = "degrees";
ye.EXP = "exp";
ye.EXP2 = "exp2";
ye.LOG = "log";
ye.LOG2 = "log2";
ye.SQRT = "sqrt";
ye.INVERSE_SQRT = "inversesqrt";
ye.FLOOR = "floor";
ye.CEIL = "ceil";
ye.NORMALIZE = "normalize";
ye.FRACT = "fract";
ye.SIN = "sin";
ye.COS = "cos";
ye.TAN = "tan";
ye.ASIN = "asin";
ye.ACOS = "acos";
ye.ATAN = "atan";
ye.ABS = "abs";
ye.SIGN = "sign";
ye.LENGTH = "length";
ye.NEGATE = "negate";
ye.ONE_MINUS = "oneMinus";
ye.DFDX = "dFdx";
ye.DFDY = "dFdy";
ye.ROUND = "round";
ye.RECIPROCAL = "reciprocal";
ye.TRUNC = "trunc";
ye.FWIDTH = "fwidth";
ye.BITCAST = "bitcast";
ye.ATAN2 = "atan2";
ye.MIN = "min";
ye.MAX = "max";
ye.MOD = "mod";
ye.STEP = "step";
ye.REFLECT = "reflect";
ye.DISTANCE = "distance";
ye.DIFFERENCE = "difference";
ye.DOT = "dot";
ye.CROSS = "cross";
ye.POW = "pow";
ye.TRANSFORM_DIRECTION = "transformDirection";
ye.MIX = "mix";
ye.CLAMP = "clamp";
ye.REFRACT = "refract";
ye.SMOOTHSTEP = "smoothstep";
ye.FACEFORWARD = "faceforward";
const JV = oe(1e-6);
oe(1e6);
const yD = oe(Math.PI);
oe(Math.PI * 2);
const e6 = De(ye, ye.ALL),
  Pde = De(ye, ye.ANY),
  Ide = De(ye, ye.EQUALS),
  Lde = De(ye, ye.RADIANS),
  Ode = De(ye, ye.DEGREES),
  t6 = De(ye, ye.EXP),
  PT = De(ye, ye.EXP2),
  n6 = De(ye, ye.LOG),
  SS = De(ye, ye.LOG2),
  Hd = De(ye, ye.SQRT),
  Dde = De(ye, ye.INVERSE_SQRT),
  yp = De(ye, ye.FLOOR),
  r6 = De(ye, ye.CEIL),
  ns = De(ye, ye.NORMALIZE),
  AS = De(ye, ye.FRACT),
  Sl = De(ye, ye.SIN),
  gc = De(ye, ye.COS),
  Fde = De(ye, ye.TAN),
  Ude = De(ye, ye.ASIN),
  kde = De(ye, ye.ACOS),
  zde = De(ye, ye.ATAN),
  Ir = De(ye, ye.ABS),
  DR = De(ye, ye.SIGN),
  tg = De(ye, ye.LENGTH),
  Bde = De(ye, ye.NEGATE),
  Vde = De(ye, ye.ONE_MINUS),
  Hde = De(ye, ye.DFDX),
  Gde = De(ye, ye.DFDY),
  Wde = De(ye, ye.ROUND),
  jde = De(ye, ye.RECIPROCAL),
  i6 = De(ye, ye.TRUNC),
  $de = De(ye, ye.FWIDTH);
De(ye, ye.BITCAST);
const Xde = De(ye, ye.ATAN2),
  Kh = De(ye, ye.MIN),
  fo = De(ye, ye.MAX),
  Yde = De(ye, ye.MOD),
  qde = De(ye, ye.STEP),
  Kde = De(ye, ye.REFLECT),
  Zde = De(ye, ye.DISTANCE),
  Qde = De(ye, ye.DIFFERENCE),
  xp = De(ye, ye.DOT),
  s6 = De(ye, ye.CROSS),
  Va = De(ye, ye.POW),
  o6 = De(ye, ye.POW, 2),
  Jde = De(ye, ye.POW, 3),
  efe = De(ye, ye.POW, 4),
  tfe = De(ye, ye.TRANSFORM_DIRECTION),
  nfe = (n) => hn(DR(n), Va(Ir(n), 1 / 3)),
  rfe = (n) => xp(n, n),
  _i = De(ye, ye.MIX),
  Zh = (n, e = 0, t = 1) => ct(new ye(ye.CLAMP, ct(n), ct(e), ct(t))),
  ife = (n) => Zh(n),
  a6 = De(ye, ye.REFRACT),
  Vl = De(ye, ye.SMOOTHSTEP),
  sfe = De(ye, ye.FACEFORWARD),
  ofe = (n, e, t) => _i(e, t, n),
  afe = (n, e, t) => Vl(e, t, n);
Ae("all", e6);
Ae("any", Pde);
Ae("equals", Ide);
Ae("radians", Lde);
Ae("degrees", Ode);
Ae("exp", t6);
Ae("exp2", PT);
Ae("log", n6);
Ae("log2", SS);
Ae("sqrt", Hd);
Ae("inverseSqrt", Dde);
Ae("floor", yp);
Ae("ceil", r6);
Ae("normalize", ns);
Ae("fract", AS);
Ae("sin", Sl);
Ae("cos", gc);
Ae("tan", Fde);
Ae("asin", Ude);
Ae("acos", kde);
Ae("atan", zde);
Ae("abs", Ir);
Ae("sign", DR);
Ae("length", tg);
Ae("lengthSq", rfe);
Ae("negate", Bde);
Ae("oneMinus", Vde);
Ae("dFdx", Hde);
Ae("dFdy", Gde);
Ae("round", Wde);
Ae("reciprocal", jde);
Ae("trunc", i6);
Ae("fwidth", $de);
Ae("atan2", Xde);
Ae("min", Kh);
Ae("max", fo);
Ae("mod", Yde);
Ae("step", qde);
Ae("reflect", Kde);
Ae("distance", Zde);
Ae("dot", xp);
Ae("cross", s6);
Ae("pow", Va);
Ae("pow2", o6);
Ae("pow3", Jde);
Ae("pow4", efe);
Ae("transformDirection", tfe);
Ae("mix", ofe);
Ae("clamp", Zh);
Ae("refract", a6);
Ae("smoothstep", afe);
Ae("faceForward", sfe);
Ae("difference", Qde);
Ae("saturate", ife);
Ae("cbrt", nfe);
qe("MathNode", ye);
const lfe = je((n) => {
    const { value: e } = n,
      { rgb: t } = e,
      r = t.mul(0.9478672986).add(0.0521327014).pow(2.4),
      i = t.mul(0.0773993808),
      s = t.lessThanEqual(0.04045),
      o = _i(r, i, s);
    return Tt(o, e.a);
  }),
  cfe = je((n) => {
    const { value: e } = n,
      { rgb: t } = e,
      r = t.pow(0.41666).mul(1.055).sub(0.055),
      i = t.mul(12.92),
      s = t.lessThanEqual(0.0031308),
      o = _i(r, i, s);
    return Tt(o, e.a);
  }),
  xD = (n) => {
    let e = null;
    return n === Ho ? (e = "Linear") : n === Xs && (e = "sRGB"), e;
  },
  l6 = (n, e) => xD(n) + "To" + xD(e);
class Ts extends Fn {
  constructor(e, t) {
    super("vec4"), (this.method = e), (this.node = t);
  }
  setup() {
    const { method: e, node: t } = this;
    return e === Ts.LINEAR_TO_LINEAR ? t : ufe[e]({ value: t });
  }
}
Ts.LINEAR_TO_LINEAR = "LinearToLinear";
Ts.LINEAR_TO_sRGB = "LinearTosRGB";
Ts.sRGB_TO_LINEAR = "sRGBToLinear";
const ufe = { [Ts.LINEAR_TO_sRGB]: cfe, [Ts.sRGB_TO_LINEAR]: lfe },
  dfe = (n, e) => ct(new Ts(l6(Ho, e), ct(n))),
  c6 = (n, e) => ct(new Ts(l6(e, Ho), ct(n))),
  ffe = De(Ts, Ts.LINEAR_TO_sRGB),
  hfe = De(Ts, Ts.sRGB_TO_LINEAR);
Ae("linearTosRGB", ffe);
Ae("sRGBToLinear", hfe);
Ae("linearToColorSpace", dfe);
Ae("colorSpaceToLinear", c6);
qe("ColorSpaceNode", Ts);
class u6 extends Lt {
  constructor(e = "", t = "void") {
    super(t), (this.snippet = e);
  }
  generate(e, t) {
    const r = this.getNodeType(e),
      i = this.snippet;
    if (r === "void") e.addLineFlowCode(i);
    else return e.format(`( ${i} )`, r, t);
  }
}
const wS = De(u6);
qe("ExpressionNode", u6);
class d6 extends Vd {
  constructor(e) {
    super(0), (this.textureNode = e), (this.updateType = On.FRAME);
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture,
      t = e.images,
      r = t && t.length > 0 ? (t[0] && t[0].image) || t[0] : e.image;
    if (r && r.width !== void 0) {
      const { width: i, height: s } = r;
      this.value = Math.log2(Math.max(i, s));
    }
  }
}
const pfe = De(d6);
qe("MaxMipLevelNode", d6);
class _p extends Vd {
  constructor(e, t = null, r = null) {
    super(e),
      (this.isTextureNode = !0),
      (this.uvNode = t),
      (this.levelNode = r),
      (this.compareNode = null),
      (this.depthNode = null),
      (this.gradNode = null),
      (this.sampler = !0),
      (this.updateMatrix = !1),
      (this.updateType = On.NONE),
      (this.referenceNode = null),
      (this._value = e),
      this.setUpdateMatrix(t === null);
  }
  set value(e) {
    this.referenceNode ? (this.referenceNode.value = e) : (this._value = e);
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return Ja(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(e) {
    const t = this.value;
    return Dn(t.matrix).mul(_e(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return (
      (this.updateMatrix = e), (this.updateType = e ? On.FRAME : On.NONE), this
    );
  }
  setupUV(e, t) {
    const r = this.value;
    return (
      e.isFlipY() &&
        (r.isRenderTargetTexture === !0 ||
          r.isFramebufferTexture === !0 ||
          r.isDepthTexture === !0) &&
        (t = t.setY(t.y.oneMinus())),
      t
    );
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let r = this.uvNode;
    (r === null || e.context.forceUVContext === !0) &&
      e.context.getUV &&
      (r = e.context.getUV(this)),
      r || (r = this.getDefaultUV()),
      this.updateMatrix === !0 && (r = this.getTransformedUV(r)),
      (r = this.setupUV(e, r));
    let i = this.levelNode;
    i === null &&
      e.context.getTextureLevel &&
      (i = e.context.getTextureLevel(this)),
      (t.uvNode = r),
      (t.levelNode = i),
      (t.compareNode = this.compareNode),
      (t.gradNode = this.gradNode),
      (t.depthNode = this.depthNode);
  }
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  generateSnippet(e, t, r, i, s, o, a) {
    const l = this.value;
    let c;
    return (
      i
        ? (c = e.generateTextureLevel(l, t, r, i, s))
        : a
        ? (c = e.generateTextureGrad(l, t, r, a, s))
        : o
        ? (c = e.generateTextureCompare(l, t, r, o, s))
        : this.sampler === !1
        ? (c = e.generateTextureLoad(l, t, r, s))
        : (c = e.generateTexture(l, t, r, s)),
      c
    );
  }
  generate(e, t) {
    const r = e.getNodeProperties(this),
      i = this.value;
    if (!i || i.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const s = super.generate(e, "property");
    if (t === "sampler") return s + "_sampler";
    if (e.isReference(t)) return s;
    {
      const o = e.getDataFromNode(this);
      let a = o.propertyName;
      if (a === void 0) {
        const {
            uvNode: u,
            levelNode: d,
            compareNode: h,
            depthNode: m,
            gradNode: g,
          } = r,
          x = this.generateUV(e, u),
          y = d ? d.build(e, "float") : null,
          v = m ? m.build(e, "int") : null,
          _ = h ? h.build(e, "float") : null,
          S = g ? [g[0].build(e, "vec2"), g[1].build(e, "vec2")] : null,
          w = e.getVarFromNode(this);
        a = e.getPropertyName(w);
        const T = this.generateSnippet(e, s, x, y, v, _, S);
        e.addLineFlowCode(`${a} = ${T}`),
          e.context.tempWrite !== !1 && ((o.snippet = T), (o.propertyName = a));
      }
      let l = a;
      const c = this.getNodeType(e);
      return (
        e.needsColorSpaceToLinear(i) &&
          (l = c6(wS(l, c), i.colorSpace).setup(e).build(e, c)),
        e.format(l, c, t)
      );
    }
  }
  setSampler(e) {
    return (this.sampler = e), this;
  }
  getSampler() {
    return this.sampler;
  }
  uv(e) {
    const t = this.clone();
    return (t.uvNode = e), (t.referenceNode = this), ct(t);
  }
  blur(e) {
    const t = this.clone();
    return (t.levelNode = e.mul(pfe(t))), (t.referenceNode = this), ct(t);
  }
  level(e) {
    const t = this.clone();
    return (t.levelNode = e), (t.referenceNode = this), t;
  }
  size(e) {
    return OR(this, e);
  }
  compare(e) {
    const t = this.clone();
    return (t.compareNode = ct(e)), (t.referenceNode = this), ct(t);
  }
  grad(e, t) {
    const r = this.clone();
    return (r.gradNode = [ct(e), ct(t)]), (r.referenceNode = this), ct(r);
  }
  depth(e) {
    const t = this.clone();
    return (t.depthNode = ct(e)), (t.referenceNode = this), ct(t);
  }
  serialize(e) {
    super.serialize(e), (e.value = this.value.toJSON(e.meta).uuid);
  }
  deserialize(e) {
    super.deserialize(e), (this.value = e.meta.textures[e.value]);
  }
  update() {
    const e = this.value;
    e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode);
    return (e.sampler = this.sampler), e;
  }
}
const so = De(_p),
  Hu = (...n) => so(...n).setSampler(!1);
Ae("texture", so);
qe("TextureNode", _p);
class bS extends Vd {
  constructor(e, t, r = 0) {
    super(e, t),
      (this.isBufferNode = !0),
      (this.bufferType = t),
      (this.bufferCount = r);
  }
  getInputType() {
    return "buffer";
  }
}
const FR = (n, e, t) => ct(new bS(n, e, t));
qe("BufferNode", bS);
class mfe extends vp {
  constructor(e, t) {
    super(e, t), (this.isArrayBufferElementNode = !0);
  }
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const t = super.generate(e),
      r = this.getNodeType();
    return e.format(t, "vec4", r);
  }
}
class f6 extends bS {
  constructor(e, t = null) {
    super(null, "vec4"),
      (this.array = e),
      (this.elementType = t),
      (this._elementType = null),
      (this._elementLength = 0),
      (this.updateType = On.RENDER),
      (this.isArrayBufferNode = !0);
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array: e, value: t } = this,
      r = this.getElementLength(),
      i = this.getElementType();
    if (r === 1)
      for (let s = 0; s < e.length; s++) {
        const o = s * 4;
        t[o] = e[s];
      }
    else if (i === "color")
      for (let s = 0; s < e.length; s++) {
        const o = s * 4,
          a = e[s];
        (t[o] = a.r), (t[o + 1] = a.g), (t[o + 2] = a.b || 0);
      }
    else
      for (let s = 0; s < e.length; s++) {
        const o = s * 4,
          a = e[s];
        (t[o] = a.x),
          (t[o + 1] = a.y),
          (t[o + 2] = a.z || 0),
          (t[o + 3] = a.w || 0);
      }
  }
  setup(e) {
    const t = this.array.length;
    return (
      (this._elementType =
        this.elementType === null ? Ec(this.array[0]) : this.elementType),
      (this._elementLength = e.getTypeLength(this._elementType)),
      (this.value = new Float32Array(t * 4)),
      (this.bufferCount = t),
      super.setup(e)
    );
  }
  element(e) {
    return ct(new mfe(this, ct(e)));
  }
}
const IT = (n, e) => ct(new f6(n, e));
qe("UniformsNode", f6);
class gfe extends vp {
  constructor(e, t) {
    super(e, t), (this.referenceNode = e), (this.isReferenceElementNode = !0);
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const t = super.generate(e),
      r = this.referenceNode.getNodeType(),
      i = this.getNodeType();
    return e.format(t, r, i);
  }
}
class Sp extends Lt {
  constructor(e, t, r = null, i = null) {
    super(),
      (this.property = e),
      (this.uniformType = t),
      (this.object = r),
      (this.count = i),
      (this.properties = e.split(".")),
      (this.reference = null),
      (this.node = null),
      (this.updateType = On.OBJECT);
  }
  element(e) {
    return ct(new gfe(this, ct(e)));
  }
  setNodeType(e) {
    let t = null;
    this.count !== null
      ? (t = FR(null, e, this.count))
      : Array.isArray(this.getValueFromReference())
      ? (t = IT(null, e))
      : e === "texture"
      ? (t = so(null))
      : (t = Dn(null, e)),
      (this.node = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  getValueFromReference(e = this.reference) {
    const { properties: t } = this;
    let r = e[t[0]];
    for (let i = 1; i < t.length; i++) r = r[t[i]];
    return r;
  }
  updateReference(e) {
    return (
      (this.reference = this.object !== null ? this.object : e.object),
      this.reference
    );
  }
  setup() {
    return this.updateValue(), this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? (this.node.array = e) : (this.node.value = e);
  }
}
const xa = (n, e, t) => ct(new Sp(n, e, t)),
  vfe = (n, e, t, r) => ct(new Sp(n, e, r, t));
qe("ReferenceNode", Sp);
class h6 extends Sp {
  constructor(e, t, r = null) {
    super(e, t, r), (this.material = r);
  }
  updateReference(e) {
    return (
      (this.reference = this.material !== null ? this.material : e.material),
      this.reference
    );
  }
}
const p6 = (n, e, t) => ct(new h6(n, e, t));
qe("MaterialReferenceNode", h6);
class Wt extends Lt {
  constructor(e = Wt.VIEW_MATRIX, t = null) {
    super(),
      (this.scope = e),
      (this.object3d = t),
      (this.updateType = On.OBJECT),
      (this._uniformNode = new Vd(null));
  }
  getNodeType() {
    const e = this.scope;
    if (e === Wt.WORLD_MATRIX || e === Wt.VIEW_MATRIX) return "mat4";
    if (e === Wt.NORMAL_MATRIX) return "mat3";
    if (
      e === Wt.POSITION ||
      e === Wt.VIEW_POSITION ||
      e === Wt.DIRECTION ||
      e === Wt.SCALE
    )
      return "vec3";
  }
  update(e) {
    const t = this.object3d,
      r = this._uniformNode,
      i = this.scope;
    if (i === Wt.VIEW_MATRIX) r.value = t.modelViewMatrix;
    else if (i === Wt.NORMAL_MATRIX) r.value = t.normalMatrix;
    else if (i === Wt.WORLD_MATRIX) r.value = t.matrixWorld;
    else if (i === Wt.POSITION)
      (r.value = r.value || new Q()),
        r.value.setFromMatrixPosition(t.matrixWorld);
    else if (i === Wt.SCALE)
      (r.value = r.value || new Q()), r.value.setFromMatrixScale(t.matrixWorld);
    else if (i === Wt.DIRECTION)
      (r.value = r.value || new Q()), t.getWorldDirection(r.value);
    else if (i === Wt.VIEW_POSITION) {
      const s = e.camera;
      (r.value = r.value || new Q()),
        r.value.setFromMatrixPosition(t.matrixWorld),
        r.value.applyMatrix4(s.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return (
      t === Wt.WORLD_MATRIX || t === Wt.VIEW_MATRIX
        ? (this._uniformNode.nodeType = "mat4")
        : t === Wt.NORMAL_MATRIX
        ? (this._uniformNode.nodeType = "mat3")
        : (t === Wt.POSITION ||
            t === Wt.VIEW_POSITION ||
            t === Wt.DIRECTION ||
            t === Wt.SCALE) &&
          (this._uniformNode.nodeType = "vec3"),
      this._uniformNode.build(e)
    );
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Wt.VIEW_MATRIX = "viewMatrix";
Wt.NORMAL_MATRIX = "normalMatrix";
Wt.WORLD_MATRIX = "worldMatrix";
Wt.POSITION = "position";
Wt.SCALE = "scale";
Wt.VIEW_POSITION = "viewPosition";
Wt.DIRECTION = "direction";
De(Wt, Wt.DIRECTION);
De(Wt, Wt.VIEW_MATRIX);
De(Wt, Wt.NORMAL_MATRIX);
De(Wt, Wt.WORLD_MATRIX);
const LT = De(Wt, Wt.POSITION);
De(Wt, Wt.SCALE);
const m6 = De(Wt, Wt.VIEW_POSITION);
qe("Object3DNode", Wt);
class Zt extends Wt {
  constructor(e = Zt.POSITION) {
    super(e), (this.updateType = On.RENDER);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === Zt.PROJECTION_MATRIX || t === Zt.PROJECTION_MATRIX_INVERSE
      ? "mat4"
      : t === Zt.NEAR || t === Zt.FAR || t === Zt.LOG_DEPTH
      ? "float"
      : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera,
      r = this._uniformNode,
      i = this.scope;
    i === Zt.VIEW_MATRIX
      ? (r.value = t.matrixWorldInverse)
      : i === Zt.PROJECTION_MATRIX
      ? (r.value = t.projectionMatrix)
      : i === Zt.PROJECTION_MATRIX_INVERSE
      ? (r.value = t.projectionMatrixInverse)
      : i === Zt.NEAR
      ? (r.value = t.near)
      : i === Zt.FAR
      ? (r.value = t.far)
      : i === Zt.LOG_DEPTH
      ? (r.value = 2 / (Math.log(t.far + 1) / Math.LN2))
      : ((this.object3d = t), super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return (
      t === Zt.PROJECTION_MATRIX || t === Zt.PROJECTION_MATRIX_INVERSE
        ? (this._uniformNode.nodeType = "mat4")
        : (t === Zt.NEAR || t === Zt.FAR || t === Zt.LOG_DEPTH) &&
          (this._uniformNode.nodeType = "float"),
      super.generate(e)
    );
  }
}
Zt.PROJECTION_MATRIX = "projectionMatrix";
Zt.PROJECTION_MATRIX_INVERSE = "projectionMatrixInverse";
Zt.NEAR = "near";
Zt.FAR = "far";
Zt.LOG_DEPTH = "logDepth";
const Ua = Qe(Zt, Zt.PROJECTION_MATRIX);
Qe(Zt, Zt.PROJECTION_MATRIX_INVERSE);
const Eb = Qe(Zt, Zt.NEAR),
  Mb = Qe(Zt, Zt.FAR),
  yfe = Qe(Zt, Zt.LOG_DEPTH),
  $l = Qe(Zt, Zt.VIEW_MATRIX);
Qe(Zt, Zt.NORMAL_MATRIX);
Qe(Zt, Zt.WORLD_MATRIX);
const xfe = Qe(Zt, Zt.POSITION);
qe("CameraNode", Zt);
class Si extends Wt {
  constructor(e = Si.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    (this.object3d = e.object), super.update(e);
  }
}
Qe(Si, Si.DIRECTION);
const Cd = Qe(Si, Si.VIEW_MATRIX)
    .label("modelViewMatrix")
    .temp("ModelViewMatrix"),
  g6 = Qe(Si, Si.NORMAL_MATRIX),
  Jg = Qe(Si, Si.WORLD_MATRIX);
Qe(Si, Si.POSITION);
Qe(Si, Si.SCALE);
Qe(Si, Si.VIEW_POSITION);
qe("ModelNode", Si);
class Gr extends Lt {
  constructor(e = Gr.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Gr.GEOMETRY)
      e.hasGeometryAttribute("normal") === !1
        ? (r = _e(0, 1, 0))
        : (r = Ui("normal", "vec3"));
    else if (t === Gr.LOCAL) r = fr(B1);
    else if (t === Gr.VIEW) {
      const i = g6.mul(_a);
      r = ns(fr(i));
    } else if (t === Gr.WORLD) {
      const i = Xc.transformDirection($l);
      r = ns(fr(i));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Gr.GEOMETRY = "geometry";
Gr.LOCAL = "local";
Gr.VIEW = "view";
Gr.WORLD = "world";
const B1 = Qe(Gr, Gr.GEOMETRY),
  _a = Qe(Gr, Gr.LOCAL).temp("Normal"),
  Xc = Qe(Gr, Gr.VIEW),
  v6 = Qe(Gr, Gr.WORLD),
  hr = di("vec3", "TransformedNormalView"),
  y6 = hr.transformDirection($l).normalize(),
  uh = di("vec3", "TransformedClearcoatNormalView");
qe("NormalNode", Gr);
const _D = new Map();
class $e extends Lt {
  constructor(e) {
    super(), (this.scope = e);
  }
  getCache(e, t) {
    let r = _D.get(e);
    return r === void 0 && ((r = p6(e, t)), _D.set(e, r)), r;
  }
  getFloat(e) {
    return this.getCache(e, "float");
  }
  getColor(e) {
    return this.getCache(e, "color");
  }
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  setup(e) {
    const t = e.context.material,
      r = this.scope;
    let i = null;
    if (r === $e.COLOR) {
      const s = this.getColor(r);
      t.map && t.map.isTexture === !0
        ? (i = s.mul(this.getTexture("map")))
        : (i = s);
    } else if (r === $e.OPACITY) {
      const s = this.getFloat(r);
      t.alphaMap && t.alphaMap.isTexture === !0
        ? (i = s.mul(this.getTexture("alpha")))
        : (i = s);
    } else if (r === $e.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0
        ? (i = this.getTexture("specular").r)
        : (i = oe(1));
    else if (r === $e.SPECULAR_INTENSITY) {
      const s = this.getFloat(r);
      t.specularMap ? (i = s.mul(this.getTexture(r).a)) : (i = s);
    } else if (r === $e.SPECULAR_COLOR) {
      const s = this.getColor(r);
      t.specularColorMap && t.specularColorMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).rgb))
        : (i = s);
    } else if (r === $e.ROUGHNESS) {
      const s = this.getFloat(r);
      t.roughnessMap && t.roughnessMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).g))
        : (i = s);
    } else if (r === $e.METALNESS) {
      const s = this.getFloat(r);
      t.metalnessMap && t.metalnessMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).b))
        : (i = s);
    } else if (r === $e.EMISSIVE) {
      const s = this.getColor(r);
      t.emissiveMap && t.emissiveMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r)))
        : (i = s);
    } else if (r === $e.NORMAL)
      t.normalMap
        ? (i = this.getTexture("normal").normalMap(
            this.getCache("normalScale", "vec2")
          ))
        : t.bumpMap
        ? (i = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")))
        : (i = Xc);
    else if (r === $e.CLEARCOAT) {
      const s = this.getFloat(r);
      t.clearcoatMap && t.clearcoatMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).r))
        : (i = s);
    } else if (r === $e.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat(r);
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).r))
        : (i = s);
    } else if (r === $e.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap
        ? (i = this.getTexture(r).normalMap(this.getCache(r + "Scale", "vec2")))
        : (i = Xc);
    else if (r === $e.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0
        ? (i = s.mul(this.getTexture("sheenColor").rgb))
        : (i = s);
    } else if (r === $e.SHEEN_ROUGHNESS) {
      const s = this.getFloat(r);
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0
        ? (i = s.mul(this.getTexture(r).a))
        : (i = s),
        (i = i.clamp(0.07, 1));
    } else if (r === $e.ANISOTROPY)
      if (t.anisotropyMap && t.anisotropyMap.isTexture === !0) {
        const s = this.getTexture(r);
        i = TR(Sm.x, Sm.y, Sm.y.negate(), Sm.x).mul(
          s.rg.mul(2).sub(Ct(1)).normalize().mul(s.b)
        );
      } else i = Sm;
    else if (r === $e.IRIDESCENCE_THICKNESS) {
      const s = xa("1", "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = xa("0", "float", t.iridescenceThicknessRange);
        i = s.sub(o).mul(this.getTexture(r).g).add(o);
      } else i = s;
    } else if (r === $e.TRANSMISSION) {
      const s = this.getFloat(r);
      t.transmissionMap ? (i = s.mul(this.getTexture(r).r)) : (i = s);
    } else if (r === $e.THICKNESS) {
      const s = this.getFloat(r);
      t.thicknessMap ? (i = s.mul(this.getTexture(r).g)) : (i = s);
    } else if (r === $e.IOR) i = this.getFloat(r);
    else {
      const s = this.getNodeType(e);
      i = this.getCache(r, s);
    }
    return i;
  }
}
$e.ALPHA_TEST = "alphaTest";
$e.COLOR = "color";
$e.OPACITY = "opacity";
$e.SHININESS = "shininess";
$e.SPECULAR = "specular";
$e.SPECULAR_STRENGTH = "specularStrength";
$e.SPECULAR_INTENSITY = "specularIntensity";
$e.SPECULAR_COLOR = "specularColor";
$e.REFLECTIVITY = "reflectivity";
$e.ROUGHNESS = "roughness";
$e.METALNESS = "metalness";
$e.NORMAL = "normal";
$e.CLEARCOAT = "clearcoat";
$e.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
$e.CLEARCOAT_NORMAL = "clearcoatNormal";
$e.EMISSIVE = "emissive";
$e.ROTATION = "rotation";
$e.SHEEN = "sheen";
$e.SHEEN_ROUGHNESS = "sheenRoughness";
$e.ANISOTROPY = "anisotropy";
$e.IRIDESCENCE = "iridescence";
$e.IRIDESCENCE_IOR = "iridescenceIOR";
$e.IRIDESCENCE_THICKNESS = "iridescenceThickness";
$e.IOR = "ior";
$e.TRANSMISSION = "transmission";
$e.THICKNESS = "thickness";
$e.ATTENUATION_DISTANCE = "attenuationDistance";
$e.ATTENUATION_COLOR = "attenuationColor";
$e.LINE_SCALE = "scale";
$e.LINE_DASH_SIZE = "dashSize";
$e.LINE_GAP_SIZE = "gapSize";
$e.LINE_WIDTH = "linewidth";
$e.LINE_DASH_OFFSET = "dashOffset";
$e.POINT_WIDTH = "pointWidth";
const _fe = Qe($e, $e.ALPHA_TEST),
  e0 = Qe($e, $e.COLOR),
  Sfe = Qe($e, $e.SHININESS),
  Afe = Qe($e, $e.EMISSIVE),
  x6 = Qe($e, $e.OPACITY),
  wfe = Qe($e, $e.SPECULAR),
  SD = Qe($e, $e.SPECULAR_INTENSITY),
  bfe = Qe($e, $e.SPECULAR_COLOR),
  Efe = Qe($e, $e.SPECULAR_STRENGTH);
Qe($e, $e.REFLECTIVITY);
const Mfe = Qe($e, $e.ROUGHNESS),
  Tfe = Qe($e, $e.METALNESS),
  Cfe = Qe($e, $e.NORMAL),
  Rfe = Qe($e, $e.CLEARCOAT),
  Nfe = Qe($e, $e.CLEARCOAT_ROUGHNESS),
  Pfe = Qe($e, $e.CLEARCOAT_NORMAL),
  Ife = Qe($e, $e.ROTATION),
  Lfe = Qe($e, $e.SHEEN),
  Ofe = Qe($e, $e.SHEEN_ROUGHNESS),
  Dfe = Qe($e, $e.ANISOTROPY),
  Ffe = Qe($e, $e.IRIDESCENCE),
  Ufe = Qe($e, $e.IRIDESCENCE_IOR),
  kfe = Qe($e, $e.IRIDESCENCE_THICKNESS),
  zfe = Qe($e, $e.TRANSMISSION),
  Bfe = Qe($e, $e.THICKNESS),
  Vfe = Qe($e, $e.IOR),
  Hfe = Qe($e, $e.ATTENUATION_DISTANCE),
  Gfe = Qe($e, $e.ATTENUATION_COLOR),
  OT = Qe($e, $e.LINE_SCALE),
  _6 = Qe($e, $e.LINE_DASH_SIZE),
  S6 = Qe($e, $e.LINE_GAP_SIZE),
  Tb = Qe($e, $e.LINE_WIDTH),
  AD = Qe($e, $e.LINE_DASH_OFFSET),
  Wfe = Qe($e, $e.POINT_WIDTH),
  Sm = Dn(new He())
    .onReference(function (n) {
      return n.material;
    })
    .onRenderUpdate(function ({ material: n }) {
      this.value.set(
        n.anisotropy * Math.cos(n.anisotropyRotation),
        n.anisotropy * Math.sin(n.anisotropyRotation)
      );
    });
qe("MaterialNode", $e);
class Ln extends Lt {
  constructor(e = Ln.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Ln.GEOMETRY) r = Ui("position", "vec3");
    else if (t === Ln.LOCAL) r = fr(ps);
    else if (t === Ln.WORLD) {
      const i = Jg.mul(Bi);
      r = fr(i);
    } else if (t === Ln.VIEW) {
      const i = Cd.mul(Bi);
      r = fr(i);
    } else if (t === Ln.VIEW_DIRECTION) {
      const i = to.negate();
      r = ns(fr(i));
    } else if (t === Ln.WORLD_DIRECTION) {
      const i = Bi.transformDirection(Jg);
      r = ns(fr(i));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Ln.GEOMETRY = "geometry";
Ln.LOCAL = "local";
Ln.WORLD = "world";
Ln.WORLD_DIRECTION = "worldDirection";
Ln.VIEW = "view";
Ln.VIEW_DIRECTION = "viewDirection";
const ps = Qe(Ln, Ln.GEOMETRY),
  Bi = Qe(Ln, Ln.LOCAL).temp("Position"),
  DT = Qe(Ln, Ln.WORLD),
  jfe = Qe(Ln, Ln.WORLD_DIRECTION),
  to = Qe(Ln, Ln.VIEW),
  tr = Qe(Ln, Ln.VIEW_DIRECTION);
qe("PositionNode", Ln);
class A6 extends Fn {
  constructor(e = null) {
    super("vec4"), (this.positionNode = e);
  }
  setup(e) {
    if (e.shaderStage === "fragment") return fr(e.context.mvp);
    const t = this.positionNode || Bi;
    return Ua.mul(Cd).mul(t);
  }
}
const wD = De(A6);
qe("ModelViewProjectionNode", A6);
class w6 extends gS {
  constructor(e, t = null, r = 0, i = 0) {
    super(e, t),
      (this.isBufferNode = !0),
      (this.bufferType = t),
      (this.bufferStride = r),
      (this.bufferOffset = i),
      (this.usage = Dh),
      (this.instanced = !1),
      (this.attribute = null),
      e &&
        e.isBufferAttribute === !0 &&
        ((this.attribute = e),
        (this.usage = e.usage),
        (this.instanced = e.isInstancedBufferAttribute));
  }
  getNodeType(e) {
    return (
      this.bufferType === null &&
        (this.bufferType = e.getTypeFromAttribute(this.attribute)),
      this.bufferType
    );
  }
  setup(e) {
    if (this.attribute !== null) return;
    const t = this.getNodeType(e),
      r = this.value,
      i = e.getTypeLength(t),
      s = this.bufferStride || i,
      o = this.bufferOffset,
      a = r.isInterleavedBuffer === !0 ? r : new g0(r, s),
      l = new Vc(a, i, o);
    a.setUsage(this.usage),
      (this.attribute = l),
      (this.attribute.isInstancedBufferAttribute = this.instanced);
  }
  generate(e) {
    const t = this.getNodeType(e),
      r = e.getBufferAttributeFromNode(this, t),
      i = e.getPropertyName(r);
    let s = null;
    return (
      e.shaderStage === "vertex" || e.shaderStage === "compute"
        ? ((this.name = i), (s = i))
        : (s = fr(this).build(e, t)),
      s
    );
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  setInstanced(e) {
    return (this.instanced = e), this;
  }
}
const ES = (n, e, t, r) => ct(new w6(n, e, t, r)),
  $fe = (n, e, t, r) => ES(n, e, t, r).setUsage(d1),
  bD = (n, e, t, r) => ES(n, e, t, r).setInstanced(!0),
  ED = (n, e, t, r) => $fe(n, e, t, r).setInstanced(!0);
Ae("toAttribute", (n) => ES(n.value));
qe("BufferAttributeNode", w6);
class b6 extends Lt {
  constructor(e) {
    super("void"),
      (this.instanceMesh = e),
      (this.instanceMatrixNode = null),
      (this.instanceColorNode = null);
  }
  setup() {
    let e = this.instanceMatrixNode;
    const t = this.instanceMesh;
    if (e === null) {
      const l = t.instanceMatrix,
        c = new oz(l.array, 16, 1),
        u = l.usage === d1 ? ED : bD,
        d = [
          u(c, "vec4", 16, 0),
          u(c, "vec4", 16, 4),
          u(c, "vec4", 16, 8),
          u(c, "vec4", 16, 12),
        ];
      (e = Ah(...d)), (this.instanceMatrixNode = e);
    }
    const r = t.instanceColor;
    if (r && this.instanceColorNode === null) {
      const l = new Hc(r.array, 3),
        c = r.usage === d1 ? ED : bD;
      this.instanceColorNode = _e(c(l, "vec3", 3, 0));
    }
    const i = e.mul(Bi).xyz,
      s = ya(e[0].xyz, e[1].xyz, e[2].xyz),
      o = _a.div(_e(s[0].dot(s[0]), s[1].dot(s[1]), s[2].dot(s[2]))),
      a = s.mul(o).xyz;
    Bi.assign(i),
      _a.assign(a),
      this.instanceColorNode !== null &&
        Da("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
}
const Xfe = De(b6);
qe("InstanceNode", b6);
class Lr extends Lt {
  constructor(e = Lr.LOCAL) {
    super(), (this.scope = e);
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === Lr.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let r = null;
    if (t === Lr.GEOMETRY)
      (r = Ui("tangent", "vec4")),
        e.geometry.hasAttribute("tangent") === !1 &&
          e.geometry.computeTangents();
    else if (t === Lr.LOCAL) r = fr(V1.xyz);
    else if (t === Lr.VIEW) {
      const i = Cd.mul(Tt(MS, 0)).xyz;
      r = ns(fr(i));
    } else if (t === Lr.WORLD) {
      const i = TS.transformDirection($l);
      r = ns(fr(i));
    }
    return r.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Lr.GEOMETRY = "geometry";
Lr.LOCAL = "local";
Lr.VIEW = "view";
Lr.WORLD = "world";
const V1 = Qe(Lr, Lr.GEOMETRY),
  MS = Qe(Lr, Lr.LOCAL),
  TS = Qe(Lr, Lr.VIEW),
  Yfe = Qe(Lr, Lr.WORLD),
  E6 = Qg(TS, "TransformedTangentView");
ns(E6.transformDirection($l));
qe("TangentNode", Lr);
class M6 extends Lt {
  constructor(e) {
    super("void"),
      (this.batchMesh = e),
      (this.instanceColorNode = null),
      (this.batchingIdNode = null);
  }
  setup(e) {
    this.batchingIdNode === null && (this.batchingIdNode = Ui("batchId"));
    const t = this.batchMesh._matricesTexture,
      r = OR(Hu(t), 0),
      i = oe(ce(this.batchingIdNode)).mul(4).toVar(),
      s = ce(i.mod(r)),
      o = ce(i).div(ce(r)),
      a = Ah(
        Hu(t, td(s, o)),
        Hu(t, td(s.add(1), o)),
        Hu(t, td(s.add(2), o)),
        Hu(t, td(s.add(3), o))
      ),
      l = ya(a[0].xyz, a[1].xyz, a[2].xyz);
    Bi.assign(a.mul(Bi));
    const c = _a.div(_e(l[0].dot(l[0]), l[1].dot(l[1]), l[2].dot(l[2]))),
      u = l.mul(c).xyz;
    _a.assign(u), e.hasGeometryAttribute("tangent") && MS.mulAssign(l);
  }
}
const qfe = De(M6);
qe("batch", M6);
class T6 extends Lt {
  constructor(e, t = !1) {
    super("void"),
      (this.skinnedMesh = e),
      (this.useReference = t),
      (this.updateType = On.OBJECT),
      (this.skinIndexNode = Ui("skinIndex", "uvec4")),
      (this.skinWeightNode = Ui("skinWeight", "vec4"));
    let r, i, s;
    t
      ? ((r = xa("bindMatrix", "mat4")),
        (i = xa("bindMatrixInverse", "mat4")),
        (s = vfe("skeleton.boneMatrices", "mat4", e.skeleton.bones.length)))
      : ((r = Dn(e.bindMatrix, "mat4")),
        (i = Dn(e.bindMatrixInverse, "mat4")),
        (s = FR(e.skeleton.boneMatrices, "mat4", e.skeleton.bones.length))),
      (this.bindMatrixNode = r),
      (this.bindMatrixInverseNode = i),
      (this.boneMatricesNode = s);
  }
  setup(e) {
    const {
        skinIndexNode: t,
        skinWeightNode: r,
        bindMatrixNode: i,
        bindMatrixInverseNode: s,
        boneMatricesNode: o,
      } = this,
      a = o.element(t.x),
      l = o.element(t.y),
      c = o.element(t.z),
      u = o.element(t.w),
      d = i.mul(Bi),
      h = uo(
        a.mul(r.x).mul(d),
        l.mul(r.y).mul(d),
        c.mul(r.z).mul(d),
        u.mul(r.w).mul(d)
      ),
      m = s.mul(h).xyz;
    let g = uo(r.x.mul(a), r.y.mul(l), r.z.mul(c), r.w.mul(u));
    g = s.mul(g).mul(i);
    const x = g.transformDirection(_a).xyz;
    Bi.assign(m),
      _a.assign(x),
      e.hasGeometryAttribute("tangent") && MS.assign(x);
  }
  generate(e, t) {
    if (t !== "void") return Bi.build(e, t);
  }
  update(e) {
    (this.useReference ? e.object : this.skinnedMesh).skeleton.update();
  }
}
const Kfe = (n) => ct(new T6(n, !0));
qe("SkinningNode", T6);
class C6 extends Lt {
  constructor(e = []) {
    super(), (this.params = e);
  }
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0) return t;
    const r = {};
    for (let i = 0, s = this.params.length - 1; i < s; i++) {
      const o = this.params[i],
        a = (o.isNode !== !0 && o.name) || this.getVarName(i),
        l = (o.isNode !== !0 && o.type) || "int";
      r[a] = wS(a, l);
    }
    return (
      (t.returnsNode = this.params[this.params.length - 1](r, e.addStack(), e)),
      (t.stackNode = e.removeStack()),
      t
    );
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e),
      r = { tempWrite: !1 },
      i = this.params,
      s = t.stackNode;
    for (let l = 0, c = i.length - 1; l < c; l++) {
      const u = i[l];
      let d = null,
        h = null,
        m = null,
        g = null,
        x = null,
        y = null;
      u.isNode
        ? ((g = "int"),
          (m = this.getVarName(l)),
          (d = "0"),
          (h = u.build(e, g)),
          (x = "<"))
        : ((g = u.type || "int"),
          (m = u.name || this.getVarName(l)),
          (d = u.start),
          (h = u.end),
          (x = u.condition),
          (y = u.update),
          typeof d == "number"
            ? (d = d.toString())
            : d && d.isNode && (d = d.build(e, g)),
          typeof h == "number"
            ? (h = h.toString())
            : h && h.isNode && (h = h.build(e, g)),
          d !== void 0 && h === void 0
            ? ((d = d + " - 1"), (h = "0"), (x = ">="))
            : h !== void 0 && d === void 0 && ((d = "0"), (x = "<")),
          x === void 0 && (Number(d) > Number(h) ? (x = ">=") : (x = "<")));
      const v = { start: d, end: h, condition: x },
        _ = v.start,
        S = v.end;
      let w = "",
        T = "",
        E = "";
      y ||
        (g === "int" || g === "uint"
          ? x.includes("<")
            ? (y = "++")
            : (y = "--")
          : x.includes("<")
          ? (y = "+= 1.")
          : (y = "-= 1.")),
        (w += e.getVar(g, m) + " = " + _),
        (T += m + " " + x + " " + S),
        (E += m + " " + y);
      const M = `for ( ${w}; ${T}; ${E} )`;
      e.addFlowCode(
        (l === 0
          ? `
`
          : "") +
          e.tab +
          M +
          ` {

`
      ).addFlowTab();
    }
    const o = Nl(s, r).build(e, "void"),
      a = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(
      `
` +
        e.tab +
        o
    );
    for (let l = 0, c = this.params.length - 1; l < c; l++)
      e.addFlowCode(
        (l === 0 ? "" : e.tab) +
          `}

`
      ).removeFlowTab();
    return e.addFlowTab(), a;
  }
}
const Bn = (...n) => ct(new C6(Sh(n, "int"))).append(),
  Zfe = () => wS("break").append();
Ae("loop", (n, ...e) => BV(n, Bn(...e)));
qe("LoopNode", C6);
const Cb = new WeakMap(),
  Ws = new rn(),
  MD = je(
    ({
      bufferMap: n,
      influence: e,
      stride: t,
      width: r,
      depth: i,
      offset: s,
    }) => {
      const o = ce(cde).mul(t).add(s),
        a = o.div(r),
        l = o.sub(a.mul(r));
      return Hu(n, td(l, a)).depth(i).mul(e);
    }
  );
function Qfe(n) {
  const e = n.morphAttributes.position !== void 0,
    t = n.morphAttributes.normal !== void 0,
    r = n.morphAttributes.color !== void 0,
    i =
      n.morphAttributes.position ||
      n.morphAttributes.normal ||
      n.morphAttributes.color,
    s = i !== void 0 ? i.length : 0;
  let o = Cb.get(n);
  if (o === void 0 || o.count !== s) {
    let _ = function () {
      y.dispose(), Cb.delete(n), n.removeEventListener("dispose", _);
    };
    var a = _;
    o !== void 0 && o.texture.dispose();
    const l = n.morphAttributes.position || [],
      c = n.morphAttributes.normal || [],
      u = n.morphAttributes.color || [];
    let d = 0;
    e === !0 && (d = 1), t === !0 && (d = 2), r === !0 && (d = 3);
    let h = n.attributes.position.count * d,
      m = 1;
    const g = 4096;
    h > g && ((m = Math.ceil(h / g)), (h = g));
    const x = new Float32Array(h * m * 4 * s),
      y = new f0(x, h, m, s);
    (y.type = Qs), (y.needsUpdate = !0);
    const v = d * 4;
    for (let S = 0; S < s; S++) {
      const w = l[S],
        T = c[S],
        E = u[S],
        M = h * m * 4 * S;
      for (let N = 0; N < w.count; N++) {
        const R = N * v;
        e === !0 &&
          (Ws.fromBufferAttribute(w, N),
          (x[M + R + 0] = Ws.x),
          (x[M + R + 1] = Ws.y),
          (x[M + R + 2] = Ws.z),
          (x[M + R + 3] = 0)),
          t === !0 &&
            (Ws.fromBufferAttribute(T, N),
            (x[M + R + 4] = Ws.x),
            (x[M + R + 5] = Ws.y),
            (x[M + R + 6] = Ws.z),
            (x[M + R + 7] = 0)),
          r === !0 &&
            (Ws.fromBufferAttribute(E, N),
            (x[M + R + 8] = Ws.x),
            (x[M + R + 9] = Ws.y),
            (x[M + R + 10] = Ws.z),
            (x[M + R + 11] = E.itemSize === 4 ? Ws.w : 1));
      }
    }
    (o = { count: s, texture: y, stride: d, size: new He(h, m) }),
      Cb.set(n, o),
      n.addEventListener("dispose", _);
  }
  return o;
}
class R6 extends Lt {
  constructor(e) {
    super("void"),
      (this.mesh = e),
      (this.morphBaseInfluence = Dn(1)),
      (this.updateType = On.OBJECT);
  }
  setup(e) {
    const { geometry: t } = e,
      r = t.morphAttributes.position !== void 0,
      i = t.morphAttributes.normal !== void 0,
      s =
        t.morphAttributes.position ||
        t.morphAttributes.normal ||
        t.morphAttributes.color,
      o = s !== void 0 ? s.length : 0,
      { texture: a, stride: l, size: c } = Qfe(t);
    r === !0 && Bi.mulAssign(this.morphBaseInfluence),
      i === !0 && _a.mulAssign(this.morphBaseInfluence);
    const u = ce(c.width);
    Bn(o, ({ i: d }) => {
      const h = oe(0).toVar();
      this.mesh.isInstancedMesh === !0 &&
      this.mesh.morphTexture !== null &&
      this.mesh.morphTexture !== void 0
        ? h.assign(Hu(this.mesh.morphTexture, td(ce(d).add(1), ce(HV))).r)
        : h.assign(xa("morphTargetInfluences", "float").element(d).toVar()),
        r === !0 &&
          Bi.addAssign(
            MD({
              bufferMap: a,
              influence: h,
              stride: l,
              width: u,
              depth: d,
              offset: ce(0),
            })
          ),
        i === !0 &&
          _a.addAssign(
            MD({
              bufferMap: a,
              influence: h,
              stride: l,
              width: u,
              depth: d,
              offset: ce(1),
            })
          );
    });
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative
      ? (e.value = 1)
      : (e.value =
          1 - this.mesh.morphTargetInfluences.reduce((t, r) => t + r, 0));
  }
}
const Jfe = De(R6);
qe("MorphNode", R6);
class N6 extends Lt {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return tr.negate().reflect(hr).transformDirection($l);
  }
}
const ehe = Qe(N6);
qe("ReflectVectorNode", N6);
class P6 extends _p {
  constructor(e, t = null, r = null) {
    super(e, t, r), (this.isCubeTextureNode = !0);
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return ehe;
  }
  setUpdateMatrix() {}
  setupUV(e, t) {
    const r = this.value;
    return e.renderer.coordinateSystem === _d || !r.isRenderTargetTexture
      ? _e(t.x.negate(), t.yz)
      : t;
  }
  generateUV(e, t) {
    return t.build(e, "vec3");
  }
}
const I6 = De(P6);
Ae("cubeTexture", I6);
qe("CubeTextureNode", P6);
class N0 extends Lt {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
qe("LightingNode", N0);
let Am = null;
class Gd extends N0 {
  constructor(e = null) {
    super(),
      (this.updateType = On.FRAME),
      (this.light = e),
      (this.rtt = null),
      (this.shadowNode = null),
      (this.shadowMaskNode = null),
      (this.color = new pt()),
      (this._defaultColorNode = Dn(this.color)),
      (this.colorNode = this._defaultColorNode),
      (this.isAnalyticLightNode = !0);
  }
  getCacheKey() {
    return (
      super.getCacheKey() +
      "-" +
      (this.light.id + "-" + (this.light.castShadow ? "1" : "0"))
    );
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(e) {
    const { object: t } = e;
    if (t.receiveShadow === !1) return;
    let r = this.shadowNode;
    if (r === null) {
      Am === null &&
        ((Am = e.createNodeMaterial()),
        (Am.fragmentNode = Tt(0, 0, 0, 1)),
        (Am.isShadowNodeMaterial = !0));
      const i = this.light.shadow,
        s = e.createRenderTarget(i.mapSize.width, i.mapSize.height),
        o = new sp();
      (o.minFilter = Dr),
        (o.magFilter = Dr),
        (o.image.width = i.mapSize.width),
        (o.image.height = i.mapSize.height),
        (o.compareFunction = r2),
        (s.depthTexture = o),
        i.camera.updateProjectionMatrix();
      const a = xa("bias", "float", i),
        l = xa("normalBias", "float", i),
        c = t.material.shadowPositionNode || DT;
      let u = Dn(i.matrix).mul(c.add(v6.mul(l)));
      u = u.xyz.div(u.w);
      const d = u.x
        .greaterThanEqual(0)
        .and(u.x.lessThanEqual(1))
        .and(u.y.greaterThanEqual(0))
        .and(u.y.lessThanEqual(1))
        .and(u.z.lessThanEqual(1));
      let h = u.z.add(a);
      e.renderer.coordinateSystem === _d && (h = h.mul(2).sub(1)),
        (u = _e(u.x, u.y.oneMinus(), h)),
        (r = ((y, v, _) => so(y, v).compare(_))(o, u.xy, u.z));
      const g = so(s.texture, u),
        x = d.mix(1, r.mix(g.a.mix(1, g), 1));
      (this.rtt = s),
        (this.colorNode = this.colorNode.mul(x)),
        (this.shadowNode = r),
        (this.shadowMaskNode = x),
        (this.updateBeforeType = On.RENDER);
    }
  }
  setup(e) {
    this.light.castShadow
      ? this.setupShadow(e)
      : this.shadowNode !== null && this.disposeShadow();
  }
  updateShadow(e) {
    const { rtt: t, light: r } = this,
      { renderer: i, scene: s } = e,
      o = s.overrideMaterial;
    (s.overrideMaterial = Am),
      t.setSize(r.shadow.mapSize.width, r.shadow.mapSize.height),
      r.shadow.updateMatrices(r);
    const a = i.toneMapping,
      l = i.getRenderTarget(),
      c = i.getRenderObjectFunction();
    i.setRenderObjectFunction((u, ...d) => {
      u.castShadow === !0 && i.renderObject(u, ...d);
    }),
      i.setRenderTarget(t),
      (i.toneMapping = ws),
      i.render(s, r.shadow.camera),
      i.setRenderTarget(l),
      i.setRenderObjectFunction(c),
      (i.toneMapping = a),
      (s.overrideMaterial = o);
  }
  disposeShadow() {
    this.rtt.dispose(),
      (this.shadowNode = null),
      (this.shadowMaskNode = null),
      (this.rtt = null),
      (this.colorNode = this._defaultColorNode);
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
qe("AnalyticLightNode", Gd);
const H1 = new WeakMap(),
  the = (n) => n.sort((e, t) => e.id - t.id);
class nhe extends Lt {
  constructor(e = []) {
    super("vec3"),
      (this.totalDiffuseNode = _e().temp("totalDiffuse")),
      (this.totalSpecularNode = _e().temp("totalSpecular")),
      (this.outgoingLightNode = _e().temp("outgoingLight")),
      (this.lightNodes = e),
      (this._hash = null);
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  getHash() {
    if (this._hash === null) {
      const e = [];
      for (const t of this.lightNodes) e.push(t.getHash());
      this._hash = "lights-" + e.join(",");
    }
    return this._hash;
  }
  setup(e) {
    const t = e.context,
      r = t.lightingModel;
    let i = this.outgoingLightNode;
    if (r) {
      const { lightNodes: s, totalDiffuseNode: o, totalSpecularNode: a } = this;
      t.outgoingLight = i;
      const l = e.addStack();
      r.start(t, l, e);
      for (const y of s) y.build(e);
      r.indirectDiffuse(t, l, e),
        r.indirectSpecular(t, l, e),
        r.ambientOcclusion(t, l, e);
      const { backdrop: c, backdropAlpha: u } = t,
        {
          directDiffuse: d,
          directSpecular: h,
          indirectDiffuse: m,
          indirectSpecular: g,
        } = t.reflectedLight;
      let x = d.add(m);
      c !== null &&
        (u !== null ? (x = _e(u.mix(x, c))) : (x = _e(c)),
        (t.material.transparent = !0)),
        o.assign(x),
        a.assign(h.add(g)),
        i.assign(o.add(a)),
        r.finish(t, l, e),
        (i = i.bypass(e.removeStack()));
    }
    return i;
  }
  _getLightNodeById(e) {
    for (const t of this.lightNodes)
      if (t.isAnalyticLightNode && t.light.id === e) return t;
    return null;
  }
  fromLights(e = []) {
    const t = [];
    e = the(e);
    for (const r of e) {
      let i = this._getLightNodeById(r.id);
      if (i === null) {
        const s = r.constructor,
          o = H1.has(s) ? H1.get(s) : Gd;
        i = ct(new o(r));
      }
      t.push(i);
    }
    return (this.lightNodes = t), (this._hash = null), this;
  }
}
const rhe = De(nhe);
function Ap(n, e) {
  if (H1.has(n)) {
    console.warn(`Redefinition of light node ${e.type}`);
    return;
  }
  if (typeof n != "function") throw new Error(`Light ${n.name} is not a class`);
  if (typeof e != "function" || !e.type)
    throw new Error(`Light node ${e.type} is not a class`);
  H1.set(n, e);
}
class L6 extends N0 {
  constructor(e = null) {
    super(), (this.aoNode = e);
  }
  setup(e) {
    const r = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(r);
  }
}
qe("AONode", L6);
class O6 extends CR {
  constructor(e, t = null, r = null, i = null) {
    super(e),
      (this.lightingModel = t),
      (this.backdropNode = r),
      (this.backdropAlphaNode = i),
      (this._context = null);
  }
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this,
      r = _e().temp("directDiffuse"),
      i = _e().temp("directSpecular"),
      s = _e().temp("indirectDiffuse"),
      o = _e().temp("indirectSpecular"),
      a = {
        directDiffuse: r,
        directSpecular: i,
        indirectDiffuse: s,
        indirectSpecular: o,
      };
    return {
      radiance: _e().temp("radiance"),
      irradiance: _e().temp("irradiance"),
      iblIrradiance: _e().temp("iblIrradiance"),
      ambientOcclusion: oe(1).temp("ambientOcclusion"),
      reflectedLight: a,
      backdrop: e,
      backdropAlpha: t,
    };
  }
  setup(e) {
    return (
      (this.context = this._context || (this._context = this.getContext())),
      (this.context.lightingModel =
        this.lightingModel || e.context.lightingModel),
      super.setup(e)
    );
  }
}
const D6 = De(O6);
Ae("lightingContext", D6);
qe("LightingContextNode", O6);
class Wr extends Lt {
  constructor(e = Wr.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let r;
    t === Wr.GEOMETRY
      ? (r = B1.cross(V1))
      : t === Wr.LOCAL
      ? (r = _a.cross(MS))
      : t === Wr.VIEW
      ? (r = Xc.cross(TS))
      : t === Wr.WORLD && (r = v6.cross(Yfe));
    const i = r.mul(V1.w).xyz;
    return ns(fr(i)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Wr.GEOMETRY = "geometry";
Wr.LOCAL = "local";
Wr.VIEW = "view";
Wr.WORLD = "world";
Qe(Wr, Wr.GEOMETRY);
Qe(Wr, Wr.LOCAL);
const ihe = Qe(Wr, Wr.VIEW);
Qe(Wr, Wr.WORLD);
const she = ns(hr.cross(E6).mul(V1.w));
ns(she.transformDirection($l));
qe("BitangentNode", Wr);
const dh = ya(TS, ihe, Xc);
tr.mul(dh);
const ohe = (() => {
  let n = wh.cross(tr);
  return (
    (n = n.cross(wh).normalize()),
    (n = _i(n, hr, zu.mul(Mc.oneMinus()).oneMinus().pow2().pow2()).normalize()),
    n
  );
})();
class UR extends Lt {
  constructor(e, t, r = null) {
    super(), (this.condNode = e), (this.ifNode = t), (this.elseNode = r);
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (this.elseNode !== null) {
      const r = this.elseNode.getNodeType(e);
      if (e.getTypeLength(r) > e.getTypeLength(t)) return r;
    }
    return t;
  }
  generate(e, t) {
    const r = this.getNodeType(e),
      i = { tempWrite: !1 },
      s = e.getDataFromNode(this);
    if (s.nodeProperty !== void 0) return s.nodeProperty;
    const { ifNode: o, elseNode: a } = this,
      l = t !== "void",
      c = l ? di(r).build(e) : "";
    s.nodeProperty = c;
    const u = Nl(this.condNode).build(e, "bool");
    e.addFlowCode(
      `
${e.tab}if ( ${u} ) {

`
    ).addFlowTab();
    let d = Nl(o, i).build(e, r);
    if (
      (d && (l ? (d = c + " = " + d + ";") : (d = "return " + d + ";")),
      e.removeFlowTab().addFlowCode(
        e.tab +
          "	" +
          d +
          `

` +
          e.tab +
          "}"
      ),
      a !== null)
    ) {
      e.addFlowCode(
        ` else {

`
      ).addFlowTab();
      let h = Nl(a, i).build(e, r);
      h && (l ? (h = c + " = " + h + ";") : (h = "return " + h + ";")),
        e.removeFlowTab().addFlowCode(
          e.tab +
            "	" +
            h +
            `

` +
            e.tab +
            `}

`
        );
    } else
      e.addFlowCode(`

`);
    return e.format(c, r, t);
  }
}
const no = De(UR);
Ae("cond", no);
qe("CondNode", UR);
const TD = oe(1),
  FT = oe(-2),
  ex = oe(0.8),
  Rb = oe(-1),
  tx = oe(0.4),
  Nb = oe(2),
  nx = oe(0.305),
  Pb = oe(3),
  CD = oe(0.21),
  ahe = oe(4),
  RD = oe(4),
  lhe = oe(16),
  che = je(([n]) => {
    const e = _e(Ir(n)).toVar(),
      t = oe(-1).toVar();
    return (
      on(e.x.greaterThan(e.z), () => {
        on(e.x.greaterThan(e.y), () => {
          t.assign(no(n.x.greaterThan(0), 0, 3));
        }).else(() => {
          t.assign(no(n.y.greaterThan(0), 1, 4));
        });
      }).else(() => {
        on(e.z.greaterThan(e.y), () => {
          t.assign(no(n.z.greaterThan(0), 2, 5));
        }).else(() => {
          t.assign(no(n.y.greaterThan(0), 1, 4));
        });
      }),
      t
    );
  }).setLayout({
    name: "getFace",
    type: "float",
    inputs: [{ name: "direction", type: "vec3" }],
  }),
  uhe = je(([n, e]) => {
    const t = Ct().toVar();
    return (
      on(e.equal(0), () => {
        t.assign(Ct(n.z, n.y).div(Ir(n.x)));
      })
        .elseif(e.equal(1), () => {
          t.assign(Ct(n.x.negate(), n.z.negate()).div(Ir(n.y)));
        })
        .elseif(e.equal(2), () => {
          t.assign(Ct(n.x.negate(), n.y).div(Ir(n.z)));
        })
        .elseif(e.equal(3), () => {
          t.assign(Ct(n.z.negate(), n.y).div(Ir(n.x)));
        })
        .elseif(e.equal(4), () => {
          t.assign(Ct(n.x.negate(), n.z).div(Ir(n.y)));
        })
        .else(() => {
          t.assign(Ct(n.x, n.y).div(Ir(n.z)));
        }),
      hn(0.5, t.add(1))
    );
  }).setLayout({
    name: "getUV",
    type: "vec2",
    inputs: [
      { name: "direction", type: "vec3" },
      { name: "face", type: "float" },
    ],
  }),
  dhe = je(([n]) => {
    const e = oe(0).toVar();
    return (
      on(n.greaterThanEqual(ex), () => {
        e.assign(TD.sub(n).mul(Rb.sub(FT)).div(TD.sub(ex)).add(FT));
      })
        .elseif(n.greaterThanEqual(tx), () => {
          e.assign(ex.sub(n).mul(Nb.sub(Rb)).div(ex.sub(tx)).add(Rb));
        })
        .elseif(n.greaterThanEqual(nx), () => {
          e.assign(tx.sub(n).mul(Pb.sub(Nb)).div(tx.sub(nx)).add(Nb));
        })
        .elseif(n.greaterThanEqual(CD), () => {
          e.assign(nx.sub(n).mul(ahe.sub(Pb)).div(nx.sub(CD)).add(Pb));
        })
        .else(() => {
          e.assign(oe(-2).mul(SS(hn(1.16, n))));
        }),
      e
    );
  }).setLayout({
    name: "roughnessToMip",
    type: "float",
    inputs: [{ name: "roughness", type: "float" }],
  });
je(([n, e]) => {
  const t = n.toVar();
  t.assign(hn(2, t).sub(1));
  const r = _e(t, 1).toVar();
  return (
    on(e.equal(0), () => {
      r.assign(r.zyx);
    })
      .elseif(e.equal(1), () => {
        r.assign(r.xzy), r.xz.mulAssign(-1);
      })
      .elseif(e.equal(2), () => {
        r.x.mulAssign(-1);
      })
      .elseif(e.equal(3), () => {
        r.assign(r.zyx), r.xz.mulAssign(-1);
      })
      .elseif(e.equal(4), () => {
        r.assign(r.xzy), r.xy.mulAssign(-1);
      })
      .elseif(e.equal(5), () => {
        r.z.mulAssign(-1);
      }),
    r
  );
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" },
  ],
});
const fhe = je(([n, e, t, r, i, s]) => {
    const o = oe(t),
      a = _e(e),
      l = Zh(dhe(o), FT, s),
      c = AS(l),
      u = yp(l),
      d = _e(UT(n, a, u, r, i, s)).toVar();
    return (
      on(c.notEqual(0), () => {
        const h = _e(UT(n, a, u.add(1), r, i, s)).toVar();
        d.assign(_i(d, h, c));
      }),
      d
    );
  }),
  UT = je(([n, e, t, r, i, s]) => {
    const o = oe(t).toVar(),
      a = _e(e),
      l = oe(che(a)).toVar(),
      c = oe(fo(RD.sub(o), 0)).toVar();
    o.assign(fo(o, RD));
    const u = oe(PT(o)).toVar(),
      d = Ct(uhe(a, l).mul(u.sub(2)).add(1)).toVar();
    return (
      on(l.greaterThan(2), () => {
        d.y.addAssign(u), l.subAssign(3);
      }),
      d.x.addAssign(l.mul(u)),
      d.x.addAssign(c.mul(hn(3, lhe))),
      d.y.addAssign(hn(4, PT(s).sub(u))),
      d.x.mulAssign(r),
      d.y.mulAssign(i),
      n.uv(d).grad(Ct(), Ct())
    );
  }),
  Ib = je(
    ({
      envMap: n,
      mipInt: e,
      outputDirection: t,
      theta: r,
      axis: i,
      CUBEUV_TEXEL_WIDTH: s,
      CUBEUV_TEXEL_HEIGHT: o,
      CUBEUV_MAX_MIP: a,
    }) => {
      const l = gc(r),
        c = t
          .mul(l)
          .add(i.cross(t).mul(Sl(r)))
          .add(i.mul(i.dot(t).mul(l.oneMinus())));
      return UT(n, c, e, s, o, a);
    }
  );
je(
  ({
    n,
    latitudinal: e,
    poleAxis: t,
    outputDirection: r,
    weights: i,
    samples: s,
    dTheta: o,
    mipInt: a,
    envMap: l,
    CUBEUV_TEXEL_WIDTH: c,
    CUBEUV_TEXEL_HEIGHT: u,
    CUBEUV_MAX_MIP: d,
  }) => {
    const h = _e(no(e, t, s6(t, r))).toVar();
    on(e6(h.equals(_e(0))), () => {
      h.assign(_e(r.z, 0, r.x.negate()));
    }),
      h.assign(ns(h));
    const m = _e().toVar();
    return (
      m.addAssign(
        i
          .element(ce(0))
          .mul(
            Ib({
              theta: 0,
              axis: h,
              outputDirection: r,
              mipInt: a,
              envMap: l,
              CUBEUV_TEXEL_WIDTH: c,
              CUBEUV_TEXEL_HEIGHT: u,
              CUBEUV_MAX_MIP: d,
            })
          )
      ),
      Bn({ start: ce(1), end: n }, ({ i: g }) => {
        on(g.greaterThanEqual(s), () => {
          Zfe();
        });
        const x = oe(o.mul(oe(g))).toVar();
        m.addAssign(
          i
            .element(g)
            .mul(
              Ib({
                theta: x.mul(-1),
                axis: h,
                outputDirection: r,
                mipInt: a,
                envMap: l,
                CUBEUV_TEXEL_WIDTH: c,
                CUBEUV_TEXEL_HEIGHT: u,
                CUBEUV_MAX_MIP: d,
              })
            )
        ),
          m.addAssign(
            i
              .element(g)
              .mul(
                Ib({
                  theta: x,
                  axis: h,
                  outputDirection: r,
                  mipInt: a,
                  envMap: l,
                  CUBEUV_TEXEL_WIDTH: c,
                  CUBEUV_TEXEL_HEIGHT: u,
                  CUBEUV_MAX_MIP: d,
                })
              )
          );
      }),
      Tt(m, 1)
    );
  }
);
let G1 = null;
const ND = new WeakMap();
function hhe(n) {
  const e = Math.log2(n) - 2,
    t = 1 / n;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
    texelHeight: t,
    maxMip: e,
  };
}
function phe(n) {
  let e = ND.get(n);
  if ((e !== void 0 ? e.pmremVersion : -1) !== n.pmremVersion) {
    if (n.isCubeTexture) {
      if (n.source.data.some((r) => r === void 0))
        throw new Error(
          "PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader"
        );
      e = G1.fromCubemap(n, e);
    } else {
      if (n.image === void 0)
        throw new Error(
          "PMREMNode: Undefined image in Texture. Use onLoad callback or async loader"
        );
      e = G1.fromEquirectangular(n, e);
    }
    (e.pmremVersion = n.pmremVersion), ND.set(n, e);
  }
  return e.texture;
}
class F6 extends Fn {
  constructor(e, t = null, r = null) {
    super("vec3"),
      (this._value = e),
      (this._pmrem = null),
      (this.uvNode = t),
      (this.levelNode = r),
      (this._generator = null),
      (this._texture = so(null)),
      (this._width = Dn(0)),
      (this._height = Dn(0)),
      (this._maxMip = Dn(0)),
      (this.updateBeforeType = On.RENDER);
  }
  set value(e) {
    (this._value = e), (this._pmrem = null);
  }
  get value() {
    return this._value;
  }
  updateFromTexture(e) {
    const t = hhe(e.image.height);
    (this._texture.value = e),
      (this._width.value = t.texelWidth),
      (this._height.value = t.texelHeight),
      (this._maxMip.value = t.maxMip);
  }
  updateBefore() {
    let e = this._pmrem;
    const t = e ? e.pmremVersion : -1,
      r = this._value;
    t !== r.pmremVersion &&
      (r.isPMREMTexture === !0 ? (e = r) : (e = phe(r)),
      (this._pmrem = e),
      this.updateFromTexture(e));
  }
  setup(e) {
    G1 === null && (G1 = e.createPMREMGenerator()), this.updateBefore(e);
    let t = this.uvNode;
    t === null && e.context.getUV && (t = e.context.getUV(this));
    const r = this.value;
    e.renderer.coordinateSystem === Do &&
      r.isPMREMTexture !== !0 &&
      r.isRenderTargetTexture === !0 &&
      (t = _e(t.x.negate(), t.yz));
    let i = this.levelNode;
    return (
      i === null &&
        e.context.getTextureLevel &&
        (i = e.context.getTextureLevel(this)),
      fhe(this._texture, t, i, this._width, this._height, this._maxMip)
    );
  }
}
const mhe = De(F6);
qe("PMREMNode", F6);
const PD = new WeakMap();
class U6 extends N0 {
  constructor(e = null) {
    super(), (this.envNode = e);
  }
  setup(e) {
    let t = this.envNode;
    if (t.isTextureNode) {
      let h = PD.get(t.value);
      h === void 0 && ((h = mhe(t.value)), PD.set(t.value, h)), (t = h);
    }
    const { material: r } = e,
      s = r.envMap
        ? xa("envMapIntensity", "float", e.material)
        : xa("environmentIntensity", "float", e.scene),
      a = r.useAnisotropy === !0 || r.anisotropy > 0 ? ohe : hr,
      l = Nl(t, ID(Mc, a)).mul(s),
      c = Nl(t, ghe(y6)).mul(Math.PI).mul(s),
      u = D1(l);
    e.context.radiance.addAssign(u), e.context.iblIrradiance.addAssign(c);
    const d = e.context.lightingModel.clearcoatRadiance;
    if (d) {
      const h = Nl(t, ID(U1, uh)).mul(s),
        m = D1(h);
      d.addAssign(m);
    }
  }
}
const ID = (n, e) => {
    let t = null;
    return {
      getUV: () => (
        t === null &&
          ((t = tr.negate().reflect(e)),
          (t = n.mul(n).mix(t, e).normalize()),
          (t = t.transformDirection($l))),
        t
      ),
      getTextureLevel: () => n,
    };
  },
  ghe = (n) => ({ getUV: () => n, getTextureLevel: () => oe(1) });
qe("EnvironmentNode", U6);
class k6 extends N0 {
  constructor(e) {
    super(), (this.node = e);
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
qe("IrradianceNode", k6);
let Lb, Ob;
class _n extends Lt {
  constructor(e) {
    super(), (this.scope = e), (this.isViewportNode = !0);
  }
  getNodeType() {
    return this.scope === _n.VIEWPORT
      ? "vec4"
      : this.scope === _n.COORDINATE
      ? "vec3"
      : "vec2";
  }
  getUpdateType() {
    let e = On.NONE;
    return (
      (this.scope === _n.RESOLUTION || this.scope === _n.VIEWPORT) &&
        (e = On.FRAME),
      (this.updateType = e),
      e
    );
  }
  update({ renderer: e }) {
    this.scope === _n.VIEWPORT ? e.getViewport(Ob) : e.getDrawingBufferSize(Lb);
  }
  setup() {
    const e = this.scope;
    let t = null;
    if (e === _n.RESOLUTION) t = Dn(Lb || (Lb = new He()));
    else if (e === _n.VIEWPORT) t = Dn(Ob || (Ob = new rn()));
    else {
      t = vhe.div(kT);
      let r = t.x,
        i = t.y;
      /bottom/i.test(e) && (i = i.oneMinus()),
        /right/i.test(e) && (r = r.oneMinus()),
        (t = Ct(r, i));
    }
    return t;
  }
  generate(e) {
    if (this.scope === _n.COORDINATE) {
      let t = e.getFragCoord();
      if (e.isFlipY()) {
        const r = e.getNodeProperties(kT).outputNode.build(e);
        t = `${e.getType("vec3")}( ${t}.x, ${r}.y - ${t}.y, ${t}.z )`;
      }
      return t;
    }
    return super.generate(e);
  }
}
_n.COORDINATE = "coordinate";
_n.RESOLUTION = "resolution";
_n.VIEWPORT = "viewport";
_n.TOP_LEFT = "topLeft";
_n.BOTTOM_LEFT = "bottomLeft";
_n.TOP_RIGHT = "topRight";
_n.BOTTOM_RIGHT = "bottomRight";
const vhe = Qe(_n, _n.COORDINATE),
  kT = Qe(_n, _n.RESOLUTION),
  Eh = Qe(_n, _n.VIEWPORT),
  t0 = Qe(_n, _n.TOP_LEFT);
Qe(_n, _n.BOTTOM_LEFT);
Qe(_n, _n.TOP_RIGHT);
Qe(_n, _n.BOTTOM_RIGHT);
qe("ViewportNode", _n);
const wm = new He();
class P0 extends _p {
  constructor(e = t0, t = null, r = null) {
    r === null && ((r = new h2()), (r.minFilter = ca)),
      super(r, e, t),
      (this.generateMipmaps = !1),
      (this.isOutputTextureNode = !0),
      (this.updateBeforeType = On.FRAME);
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(wm);
    const r = this.value;
    (r.image.width !== wm.width || r.image.height !== wm.height) &&
      ((r.image.width = wm.width),
      (r.image.height = wm.height),
      (r.needsUpdate = !0));
    const i = r.generateMipmaps;
    (r.generateMipmaps = this.generateMipmaps),
      t.copyFramebufferToTexture(r),
      (r.generateMipmaps = i);
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return (e.generateMipmaps = this.generateMipmaps), e;
  }
}
const yhe = De(P0),
  z6 = De(P0, null, null, { generateMipmaps: !0 });
Ae("viewportTexture", yhe);
Ae("viewportMipTexture", z6);
qe("ViewportTextureNode", P0);
let Db = null;
class B6 extends P0 {
  constructor(e = t0, t = null) {
    Db === null && (Db = new sp()), super(e, t, Db);
  }
}
const V6 = De(B6);
Ae("viewportDepthTexture", V6);
qe("ViewportDepthTextureNode", B6);
class fi extends Lt {
  constructor(e, t = null) {
    super("float"),
      (this.scope = e),
      (this.valueNode = t),
      (this.isViewportDepthNode = !0);
  }
  generate(e) {
    const { scope: t } = this;
    return t === fi.DEPTH_PIXEL ? e.getFragDepth() : super.generate(e);
  }
  setup() {
    const { scope: e } = this;
    let t = null;
    if (e === fi.DEPTH) t = zT(to.z, Eb, Mb);
    else if (e === fi.DEPTH_TEXTURE) {
      const r = this.valueNode || V6(),
        i = H6(r, Eb, Mb);
      t = zT(i, Eb, Mb);
    } else
      e === fi.DEPTH_PIXEL &&
        this.valueNode !== null &&
        (t = G6().assign(this.valueNode));
    return t;
  }
}
const zT = (n, e, t) => n.add(e).div(e.sub(t)),
  H6 = (n, e, t) => e.mul(t).div(t.sub(e).mul(n).sub(t));
fi.DEPTH = "depth";
fi.DEPTH_TEXTURE = "depthTexture";
fi.DEPTH_PIXEL = "depthPixel";
const G6 = De(fi, fi.DEPTH_PIXEL);
Qe(fi, fi.DEPTH);
De(fi, fi.DEPTH_TEXTURE);
const W6 = Qe(fi, fi.DEPTH_PIXEL);
W6.assign = (n) => G6(n);
qe("ViewportDepthNode", fi);
class Yc extends Lt {
  constructor(e = Yc.DEFAULT) {
    super(), (this.scope = e);
  }
  setup(e) {
    super.setup(e);
    const t = e.clippingContext,
      {
        localClipIntersection: r,
        localClippingCount: i,
        globalClippingCount: s,
      } = t,
      o = s + i,
      a = r ? o - i : o;
    return this.scope === Yc.ALPHA_TO_COVERAGE
      ? this.setupAlphaToCoverage(t.planes, o, a)
      : this.setupDefault(t.planes, o, a);
  }
  setupAlphaToCoverage(e, t, r) {
    return je(() => {
      const i = IT(e),
        s = di("float", "distanceToPlane"),
        o = di("float", "distanceToGradient"),
        a = di("float", "clipOpacity");
      a.assign(1);
      let l;
      if (
        (Bn(r, ({ i: c }) => {
          (l = i.element(c)),
            s.assign(to.dot(l.xyz).negate().add(l.w)),
            o.assign(s.fwidth().div(2)),
            a.mulAssign(Vl(o.negate(), o, s)),
            a.equal(0).discard();
        }),
        r < t)
      ) {
        const c = di("float", "unionclipOpacity");
        c.assign(1),
          Bn({ start: r, end: t }, ({ i: u }) => {
            (l = i.element(u)),
              s.assign(to.dot(l.xyz).negate().add(l.w)),
              o.assign(s.fwidth().div(2)),
              c.mulAssign(Vl(o.negate(), o, s).oneMinus());
          }),
          a.mulAssign(c.oneMinus());
      }
      er.a.mulAssign(a), er.a.equal(0).discard();
    })();
  }
  setupDefault(e, t, r) {
    return je(() => {
      const i = IT(e);
      let s;
      if (
        (Bn(r, ({ i: o }) => {
          (s = i.element(o)), to.dot(s.xyz).greaterThan(s.w).discard();
        }),
        r < t)
      ) {
        const o = di("bool", "clipped");
        o.assign(!0),
          Bn({ start: r, end: t }, ({ i: a }) => {
            (s = i.element(a)), o.assign(to.dot(s.xyz).greaterThan(s.w).and(o));
          }),
          o.discard();
      }
    })();
  }
}
Yc.ALPHA_TO_COVERAGE = "alphaToCoverage";
Yc.DEFAULT = "default";
const xhe = () => ct(new Yc()),
  _he = () => ct(new Yc(Yc.ALPHA_TO_COVERAGE));
class j6 extends Lt {
  constructor() {
    super("bool"), (this.isFrontFacingNode = !0);
  }
  generate(e) {
    const { renderer: t, material: r } = e;
    return t.coordinateSystem === Do && r.side === pi
      ? "false"
      : e.getFrontFacing();
  }
}
const She = Qe(j6),
  W1 = oe(She).mul(2).sub(1);
qe("FrontFacingNode", j6);
const BT = new Map();
class go extends Bo {
  constructor() {
    super(),
      (this.isNodeMaterial = !0),
      (this.type = this.constructor.type),
      (this.forceSinglePass = !1),
      (this.fog = !0),
      (this.lights = !0),
      (this.normals = !0),
      (this.lightsNode = null),
      (this.envNode = null),
      (this.aoNode = null),
      (this.colorNode = null),
      (this.normalNode = null),
      (this.opacityNode = null),
      (this.backdropNode = null),
      (this.backdropAlphaNode = null),
      (this.alphaTestNode = null),
      (this.positionNode = null),
      (this.depthNode = null),
      (this.shadowNode = null),
      (this.shadowPositionNode = null),
      (this.outputNode = null),
      (this.fragmentNode = null),
      (this.vertexNode = null);
  }
  customProgramCacheKey() {
    return this.type + CV(this);
  }
  build(e) {
    this.setup(e);
  }
  setup(e) {
    e.addStack(),
      (e.stack.outputNode = this.vertexNode || this.setupPosition(e)),
      e.addFlow("vertex", e.removeStack()),
      e.addStack();
    let t;
    const r = this.setupClipping(e);
    if (
      (this.depthWrite === !0 && this.setupDepth(e), this.fragmentNode === null)
    ) {
      this.normals === !0 && this.setupNormal(e),
        this.setupDiffuseColor(e),
        this.setupVariants(e);
      const i = this.setupLighting(e);
      r !== null && e.stack.add(r);
      const s = Tt(i, er.a).max(0);
      (t = this.setupOutput(e, s)),
        ude.assign(t),
        this.outputNode !== null && (t = this.outputNode);
    } else {
      let i = this.fragmentNode;
      i.isOutputStructNode !== !0 && (i = Tt(i)), (t = this.setupOutput(e, i));
    }
    (e.stack.outputNode = t), e.addFlow("fragment", e.removeStack());
  }
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { globalClippingCount: t, localClippingCount: r } = e.clippingContext;
    let i = null;
    return (
      (t || r) && (this.alphaToCoverage ? (i = _he()) : e.stack.add(xhe())), i
    );
  }
  setupDepth(e) {
    const { renderer: t } = e;
    let r = this.depthNode;
    r === null &&
      t.logarithmicDepthBuffer === !0 &&
      (r = wD().w.add(1).log2().mul(yfe).mul(0.5)),
      r !== null && W6.assign(r).append();
  }
  setupPosition(e) {
    const { object: t } = e,
      r = t.geometry;
    e.addStack(),
      (r.morphAttributes.position ||
        r.morphAttributes.normal ||
        r.morphAttributes.color) &&
        Jfe(t).append(),
      t.isSkinnedMesh === !0 && Kfe(t).append(),
      t.isBatchedMesh && qfe(t).append(),
      t.instanceMatrix &&
        t.instanceMatrix.isInstancedBufferAttribute === !0 &&
        e.isAvailable("instance") === !0 &&
        Xfe(t).append(),
      this.positionNode !== null && Bi.assign(this.positionNode);
    const i = wD();
    return (e.context.vertex = e.removeStack()), (e.context.mvp = i), i;
  }
  setupDiffuseColor({ object: e, geometry: t }) {
    let r = this.colorNode ? Tt(this.colorNode) : e0;
    this.vertexColors === !0 &&
      t.hasAttribute("color") &&
      (r = Tt(r.xyz.mul(Ui("color", "vec3")), r.a)),
      e.instanceColor && (r = Da("vec3", "vInstanceColor").mul(r)),
      er.assign(r);
    const i = this.opacityNode ? oe(this.opacityNode) : x6;
    if (
      (er.a.assign(er.a.mul(i)),
      this.alphaTestNode !== null || this.alphaTest > 0)
    ) {
      const s = this.alphaTestNode !== null ? oe(this.alphaTestNode) : _fe;
      er.a.lessThanEqual(s).discard();
    }
  }
  setupVariants() {}
  setupNormal() {
    if (this.flatShading === !0) {
      const e = to.dFdx().cross(to.dFdy()).normalize();
      hr.assign(e.mul(W1));
    } else {
      const e = this.normalNode ? _e(this.normalNode) : Cfe;
      hr.assign(e.mul(W1));
    }
  }
  getEnvNode(e) {
    let t = null;
    return (
      this.envNode
        ? (t = this.envNode)
        : this.envMap
        ? (t = this.envMap.isCubeTexture ? I6(this.envMap) : so(this.envMap))
        : e.environmentNode && (t = e.environmentNode),
      t
    );
  }
  setupLights(e) {
    const t = this.getEnvNode(e),
      r = [];
    if (
      (t && r.push(new U6(t)),
      e.material.lightMap && r.push(new k6(p6("lightMap", "texture"))),
      this.aoNode !== null || e.material.aoMap)
    ) {
      const s = this.aoNode !== null ? this.aoNode : so(e.material.aoMap);
      r.push(new L6(s));
    }
    let i = this.lightsNode || e.lightsNode;
    return r.length > 0 && (i = rhe([...i.lightNodes, ...r])), i;
  }
  setupLightingModel() {}
  setupLighting(e) {
    const { material: t } = e,
      { backdropNode: r, backdropAlphaNode: i, emissiveNode: s } = this,
      a =
        this.lights === !0 || this.lightsNode !== null
          ? this.setupLights(e)
          : null;
    let l = er.rgb;
    if (a && a.hasLight !== !1) {
      const c = this.setupLightingModel(e);
      l = D6(a, c, r, i);
    } else r !== null && (l = _e(i !== null ? _i(l, r, i) : r));
    return (
      ((s && s.isNode === !0) || (t.emissive && t.emissive.isColor === !0)) &&
        (l = l.add(_e(s || Afe))),
      l
    );
  }
  setupOutput(e, t) {
    const r = e.fogNode;
    return r && (t = Tt(r.mix(t.rgb, r.colorNode), t.a)), t;
  }
  setDefaultValues(e) {
    for (const r in e) {
      const i = e[r];
      this[r] === void 0 &&
        ((this[r] = i), i && i.clone && (this[r] = i.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const r in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, r) ===
        void 0 &&
        t[r].get !== void 0 &&
        Object.defineProperty(this.constructor.prototype, r, t[r]);
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {}, nodes: {} });
    const r = oi.prototype.toJSON.call(this, e),
      i = O1(this);
    r.inputNodes = {};
    for (const { property: o, childNode: a } of i)
      r.inputNodes[o] = a.toJSON(e).uuid;
    function s(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (t) {
      const o = s(e.textures),
        a = s(e.images),
        l = s(e.nodes);
      o.length > 0 && (r.textures = o),
        a.length > 0 && (r.images = a),
        l.length > 0 && (r.nodes = l);
    }
    return r;
  }
  copy(e) {
    return (
      (this.lightsNode = e.lightsNode),
      (this.envNode = e.envNode),
      (this.colorNode = e.colorNode),
      (this.normalNode = e.normalNode),
      (this.opacityNode = e.opacityNode),
      (this.backdropNode = e.backdropNode),
      (this.backdropAlphaNode = e.backdropAlphaNode),
      (this.alphaTestNode = e.alphaTestNode),
      (this.positionNode = e.positionNode),
      (this.depthNode = e.depthNode),
      (this.shadowNode = e.shadowNode),
      (this.shadowPositionNode = e.shadowPositionNode),
      (this.outputNode = e.outputNode),
      (this.fragmentNode = e.fragmentNode),
      (this.vertexNode = e.vertexNode),
      super.copy(e)
    );
  }
  static fromMaterial(e) {
    if (e.isNodeMaterial === !0) return e;
    const t = e.type.replace("Material", "NodeMaterial"),
      r = $6(t);
    if (r === void 0)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const i in e) r[i] = e[i];
    return r;
  }
}
function as(n, e) {
  if (typeof e != "function" || !n)
    throw new Error(`Node material ${n} is not a class`);
  if (BT.has(n)) {
    console.warn(`Redefinition of node material ${n}`);
    return;
  }
  BT.set(n, e), (e.type = n);
}
function $6(n) {
  const e = BT.get(n);
  if (e !== void 0) return new e();
}
as("NodeMaterial", go);
class X6 extends Lt {
  constructor(e = null) {
    super(),
      (this.nodes = []),
      (this.outputNode = null),
      (this.parent = e),
      (this._currentCond = null),
      (this.isStackNode = !0);
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(e), this;
  }
  if(e, t) {
    const r = new eg(t);
    return (this._currentCond = no(e, r)), this.add(this._currentCond);
  }
  elseif(e, t) {
    const r = new eg(t),
      i = no(e, r);
    return (this._currentCond.elseNode = i), (this._currentCond = i), this;
  }
  else(e) {
    return (this._currentCond.elseNode = new eg(e)), this;
  }
  build(e, ...t) {
    const r = Fue();
    vD(this);
    for (const i of this.nodes) i.build(e, "void");
    return (
      vD(r),
      this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t)
    );
  }
}
De(X6);
qe("StackNode", X6);
class Y6 extends Fn {
  constructor(e = jfe) {
    super("vec2"), (this.dirNode = e);
  }
  setup() {
    const e = this.dirNode,
      t = e.z
        .atan2(e.x)
        .mul(1 / (Math.PI * 2))
        .add(0.5),
      r = e.y
        .clamp(-1, 1)
        .asin()
        .mul(1 / Math.PI)
        .add(0.5);
    return Ct(t, r);
  }
}
De(Y6);
qe("EquirectUVNode", Y6);
class q6 extends Lt {
  constructor(e) {
    super(), (this.types = e), (this.isStructTypeNode = !0);
  }
  getMemberTypes() {
    return this.types;
  }
}
qe("StructTypeNode", q6);
class K6 extends Lt {
  constructor(...e) {
    super(), (this.members = e), (this.isOutputStructNode = !0);
  }
  setup(e) {
    super.setup(e);
    const t = this.members,
      r = [];
    for (let i = 0; i < t.length; i++) r.push(t[i].getNodeType(e));
    this.nodeType = e.getStructTypeFromNode(new q6(r)).name;
  }
  generate(e, t) {
    const r = e.getVarFromNode(this);
    r.isOutputStructVar = !0;
    const i = e.getPropertyName(r),
      s = this.members,
      o = i !== "" ? i + "." : "";
    for (let a = 0; a < s.length; a++) {
      const l = s[a].build(e, t);
      e.addLineFlowCode(`${o}m${a} = ${l}`);
    }
    return i;
  }
}
De(K6);
qe("OutputStructNode", K6);
class Z6 extends Lt {
  constructor(e) {
    super(), (this.seedNode = e);
  }
  setup() {
    const e = this.seedNode.uint().mul(747796405).add(2891336453),
      t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
    return t
      .shiftRight(22)
      .bitXor(t)
      .float()
      .mul(1 / 2 ** 32);
  }
}
const Ahe = De(Z6);
Ae("hash", Ahe);
qe("HashNode", Z6);
const VT = (n, e) => Va(hn(4, n.mul(Mr(1, n))), e),
  whe = (n, e) =>
    n.lessThan(0.5)
      ? VT(n.mul(2), e).div(2)
      : Mr(1, VT(hn(Mr(1, n), 2), e).div(2)),
  bhe = (n, e, t) => Va($c(Va(n, e), uo(Va(n, e), Va(Mr(1, n), t))), 1 / e),
  Ehe = (n, e) => Sl(yD.mul(e.mul(n).sub(1))).div(yD.mul(e.mul(n).sub(1)));
Ae("parabola", VT);
Ae("gain", whe);
Ae("pcurve", bhe);
Ae("sinc", Ehe);
const ka = je(([n]) => n.fract().sub(0.5).abs()),
  Q6 = je(([n]) =>
    _e(
      ka(n.z.add(ka(n.y.mul(1)))),
      ka(n.z.add(ka(n.x.mul(1)))),
      ka(n.y.add(ka(n.x.mul(1))))
    )
  ),
  Mhe = je(([n, e, t]) => {
    const r = _e(n).toVar(),
      i = oe(1.4).toVar(),
      s = oe(0).toVar(),
      o = _e(r).toVar();
    return (
      Bn({ start: oe(0), end: oe(3), type: "float", condition: "<=" }, () => {
        const a = _e(Q6(o.mul(2))).toVar();
        r.addAssign(a.add(t.mul(oe(0.1).mul(e)))),
          o.mulAssign(1.8),
          i.mulAssign(1.5),
          r.mulAssign(1.2);
        const l = oe(ka(r.z.add(ka(r.x.add(ka(r.y)))))).toVar();
        s.addAssign(l.div(i)), o.addAssign(0.14);
      }),
      s
    );
  });
ka.setLayout({
  name: "tri",
  type: "float",
  inputs: [{ name: "x", type: "float" }],
});
Q6.setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
Mhe.setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "spd", type: "float" },
    { name: "time", type: "float" },
  ],
});
let Fb;
class J6 extends UR {
  constructor(e) {
    (Fb = Fb || wS("discard")), super(e, Fb);
  }
}
const The = De(J6),
  Che = (n) => The(n).append();
Ae("discard", Che);
qe("DiscardNode", J6);
class e8 extends Lt {
  constructor(e = [], ...t) {
    super(),
      (this.functionNodes = e),
      (this.parametersNodes = t),
      (this._candidateFnCall = null);
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(e) {
    const t = this.parametersNodes;
    let r = this._candidateFnCall;
    if (r === null) {
      let i = null,
        s = -1;
      for (const o of this.functionNodes) {
        const l = o.shaderNode.layout;
        if (l === null)
          throw new Error(
            "FunctionOverloadingNode: FunctionNode must be a layout."
          );
        const c = l.inputs;
        if (t.length === c.length) {
          let u = 0;
          for (let d = 0; d < t.length; d++) {
            const h = t[d],
              m = c[d];
            h.getNodeType(e) === m.type ? u++ : (u = 0);
          }
          u > s && ((i = o), (s = u));
        }
      }
      this._candidateFnCall = r = i(...t);
    }
    return r;
  }
}
const Rhe = De(e8),
  $o =
    (n) =>
    (...e) =>
      Rhe(n, ...e);
qe("FunctionOverloadingNode", e8);
class t8 extends Fn {
  constructor() {
    super("vec2");
  }
  setup() {
    const e = _e(tr.z, 0, tr.x.negate()).normalize(),
      t = tr.cross(e);
    return Ct(e.dot(hr), t.dot(hr)).mul(0.495).add(0.5);
  }
}
Qe(t8);
qe("MatcapUVNode", t8);
class xs extends Vd {
  constructor(e = xs.LOCAL, t = 1, r = 0) {
    super(r), (this.scope = e), (this.scale = t), (this.updateType = On.FRAME);
  }
  update(e) {
    const t = this.scope,
      r = this.scale;
    t === xs.LOCAL
      ? (this.value += e.deltaTime * r)
      : t === xs.DELTA
      ? (this.value = e.deltaTime * r)
      : t === xs.FRAME
      ? (this.value = e.frameId)
      : (this.value = e.time * r);
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope), (e.scale = this.scale);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope), (this.scale = e.scale);
  }
}
xs.LOCAL = "local";
xs.GLOBAL = "global";
xs.DELTA = "delta";
xs.FRAME = "frame";
const Nhe = (n, e = 0) => ct(new xs(xs.LOCAL, n, e));
Qe(xs, xs.FRAME).uint();
qe("TimerNode", xs);
class jr extends Lt {
  constructor(e = jr.SINE, t = Nhe()) {
    super(), (this.method = e), (this.timeNode = t);
  }
  getNodeType(e) {
    return this.timeNode.getNodeType(e);
  }
  setup() {
    const e = this.method,
      t = ct(this.timeNode);
    let r = null;
    return (
      e === jr.SINE
        ? (r = t
            .add(0.75)
            .mul(Math.PI * 2)
            .sin()
            .mul(0.5)
            .add(0.5))
        : e === jr.SQUARE
        ? (r = t.fract().round())
        : e === jr.TRIANGLE
        ? (r = t.add(0.5).fract().mul(2).sub(1).abs())
        : e === jr.SAWTOOTH && (r = t.fract()),
      r
    );
  }
  serialize(e) {
    super.serialize(e), (e.method = this.method);
  }
  deserialize(e) {
    super.deserialize(e), (this.method = e.method);
  }
}
jr.SINE = "sine";
jr.SQUARE = "square";
jr.TRIANGLE = "triangle";
jr.SAWTOOTH = "sawtooth";
De(jr, jr.SINE);
De(jr, jr.SQUARE);
De(jr, jr.TRIANGLE);
De(jr, jr.SAWTOOTH);
qe("OscNode", jr);
class Ka extends Fn {
  constructor(e, t) {
    super(), (this.scope = e), (this.node = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup() {
    const { scope: e, node: t } = this;
    let r = null;
    return (
      e === Ka.DIRECTION_TO_COLOR
        ? (r = t.mul(0.5).add(0.5))
        : e === Ka.COLOR_TO_DIRECTION && (r = t.mul(2).sub(1)),
      r
    );
  }
}
Ka.DIRECTION_TO_COLOR = "directionToColor";
Ka.COLOR_TO_DIRECTION = "colorToDirection";
const n8 = De(Ka, Ka.DIRECTION_TO_COLOR),
  Phe = De(Ka, Ka.COLOR_TO_DIRECTION);
Ae("directionToColor", n8);
Ae("colorToDirection", Phe);
qe("PackingNode", Ka);
class kR extends Lt {
  constructor(e, t, r, i = oe(0), s = oe(1)) {
    super(),
      (this.node = e),
      (this.inLowNode = t),
      (this.inHighNode = r),
      (this.outLowNode = i),
      (this.outHighNode = s),
      (this.doClamp = !0);
  }
  setup() {
    const {
      node: e,
      inLowNode: t,
      inHighNode: r,
      outLowNode: i,
      outHighNode: s,
      doClamp: o,
    } = this;
    let a = e.sub(t).div(r.sub(t));
    return o === !0 && (a = a.clamp()), a.mul(s.sub(i)).add(i);
  }
}
const Ihe = De(kR, null, null, { doClamp: !1 }),
  Lhe = De(kR);
Ae("remap", Ihe);
Ae("remapClamp", Lhe);
qe("RemapNode", kR);
class r8 extends Fn {
  constructor(e, t, r = Ct(0.5)) {
    super("vec2"),
      (this.uvNode = e),
      (this.rotationNode = t),
      (this.centerNode = r);
  }
  setup() {
    const { uvNode: e, rotationNode: t, centerNode: r } = this;
    return e.sub(r).rotate(t).add(r);
  }
}
const Ohe = De(r8);
Ae("rotateUV", Ohe);
qe("RotateUVNode", r8);
class i8 extends Fn {
  constructor(e, t) {
    super(), (this.positionNode = e), (this.rotationNode = t);
  }
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: t, positionNode: r } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = t.cos(),
        o = t.sin();
      return TR(s, o, o.negate(), s).mul(r);
    } else {
      const s = t,
        o = Ah(
          Tt(1, 0, 0, 0),
          Tt(0, gc(s.x), Sl(s.x).negate(), 0),
          Tt(0, Sl(s.x), gc(s.x), 0),
          Tt(0, 0, 0, 1)
        ),
        a = Ah(
          Tt(gc(s.y), 0, Sl(s.y), 0),
          Tt(0, 1, 0, 0),
          Tt(Sl(s.y).negate(), 0, gc(s.y), 0),
          Tt(0, 0, 0, 1)
        ),
        l = Ah(
          Tt(gc(s.z), Sl(s.z).negate(), 0, 0),
          Tt(Sl(s.z), gc(s.z), 0, 0),
          Tt(0, 0, 1, 0),
          Tt(0, 0, 0, 1)
        );
      return o.mul(a).mul(l).mul(Tt(r, 1)).xyz;
    }
  }
}
const Dhe = De(i8);
Ae("rotate", Dhe);
qe("RotateNode", i8);
class s8 extends Lt {
  constructor(e, t = Ja(), r = oe(0)) {
    super("vec2"),
      (this.countNode = e),
      (this.uvNode = t),
      (this.frameNode = r);
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: r } = this,
      { width: i, height: s } = r,
      o = e.mod(i.mul(s)).floor(),
      a = o.mod(i),
      l = s.sub(o.add(1).div(i).ceil()),
      c = r.reciprocal(),
      u = Ct(a, l);
    return t.add(u).mul(c);
  }
}
De(s8);
qe("SpriteSheetUVNode", s8);
class o8 extends vp {
  constructor(e, t) {
    super(e, t), (this.isStorageArrayElementNode = !0);
  }
  set storageBufferNode(e) {
    this.node = e;
  }
  get storageBufferNode() {
    return this.node;
  }
  setup(e) {
    return (
      e.isAvailable("storageBuffer") === !1 &&
        !this.node.instanceIndex &&
        this.node.bufferObject === !0 &&
        e.setupPBO(this.node),
      super.setup(e)
    );
  }
  generate(e, t) {
    let r;
    const i = e.context.assign;
    if (e.isAvailable("storageBuffer") === !1) {
      const { node: s } = this;
      !s.instanceIndex && this.node.bufferObject === !0 && i !== !0
        ? (r = e.generatePBO(this))
        : (r = s.build(e));
    } else r = super.generate(e);
    if (i !== !0) {
      const s = this.getNodeType(e);
      r = e.format(r, s, t);
    }
    return r;
  }
}
const a8 = De(o8);
Ae("storageElement", a8);
qe("StorageArrayElementNode", o8);
class l8 extends Lt {
  constructor(e, t = null, r = null, i = oe(1), s = Bi, o = _a) {
    super("vec4"),
      (this.textureXNode = e),
      (this.textureYNode = t),
      (this.textureZNode = r),
      (this.scaleNode = i),
      (this.positionNode = s),
      (this.normalNode = o);
  }
  setup() {
    const {
      textureXNode: e,
      textureYNode: t,
      textureZNode: r,
      scaleNode: i,
      positionNode: s,
      normalNode: o,
    } = this;
    let a = o.abs().normalize();
    a = a.div(a.dot(_e(1)));
    const l = s.yz.mul(i),
      c = s.zx.mul(i),
      u = s.xy.mul(i),
      d = e.value,
      h = t !== null ? t.value : d,
      m = r !== null ? r.value : d,
      g = so(d, l).mul(a.x),
      x = so(h, c).mul(a.y),
      y = so(m, u).mul(a.z);
    return uo(g, x, y);
  }
}
const Fhe = De(l8),
  Uhe = (...n) => Fhe(...n);
Ae("triplanarTexture", Uhe);
qe("TriplanarTexturesNode", l8);
new Fa();
new Q();
new Q();
new Q();
new Ut();
new Q(0, 0, -1);
new rn();
new Q();
new Q();
new rn();
new He();
new Fl();
Ct(t0.x.oneMinus(), t0.y);
class khe extends _S {
  constructor(e = 0) {
    super(null, "vec4"), (this.isVertexColorNode = !0), (this.index = e);
  }
  getAttributeName() {
    const e = this.index;
    return "color" + (e > 0 ? e : "");
  }
  generate(e) {
    const t = this.getAttributeName(e),
      r = e.hasGeometryAttribute(t);
    let i;
    return (
      r === !0
        ? (i = super.generate(e))
        : (i = e.generateConst(this.nodeType, new rn(1, 1, 1, 1))),
      i
    );
  }
  serialize(e) {
    super.serialize(e), (e.index = this.index);
  }
  deserialize(e) {
    super.deserialize(e), (this.index = e.index);
  }
}
qe("VertexColorNode", khe);
class c8 extends Sp {
  constructor(e, t, r = null) {
    super(e, t, r), (this.renderer = r);
  }
  updateReference(e) {
    return (
      (this.reference = this.renderer !== null ? this.renderer : e.renderer),
      this.reference
    );
  }
}
const zhe = (n, e, t) => ct(new c8(n, e, t));
qe("RendererReferenceNode", c8);
const CS = 1 / 6,
  u8 = (n) => hn(CS, hn(n, hn(n, n.negate().add(3)).sub(3)).add(1)),
  HT = (n) => hn(CS, hn(n, hn(n, hn(3, n).sub(6))).add(4)),
  d8 = (n) => hn(CS, hn(n, hn(n, hn(-3, n).add(3)).add(3)).add(1)),
  GT = (n) => hn(CS, Va(n, 3)),
  LD = (n) => u8(n).add(HT(n)),
  OD = (n) => d8(n).add(GT(n)),
  DD = (n) => uo(-1, HT(n).div(u8(n).add(HT(n)))),
  FD = (n) => uo(1, GT(n).div(d8(n).add(GT(n)))),
  UD = (n, e, t) => {
    const r = n.uvNode,
      i = hn(r, e.zw).add(0.5),
      s = yp(i),
      o = AS(i),
      a = LD(o.x),
      l = OD(o.x),
      c = DD(o.x),
      u = FD(o.x),
      d = DD(o.y),
      h = FD(o.y),
      m = Ct(s.x.add(c), s.y.add(d)).sub(0.5).mul(e.xy),
      g = Ct(s.x.add(u), s.y.add(d)).sub(0.5).mul(e.xy),
      x = Ct(s.x.add(c), s.y.add(h)).sub(0.5).mul(e.xy),
      y = Ct(s.x.add(u), s.y.add(h)).sub(0.5).mul(e.xy),
      v = LD(o.y).mul(uo(a.mul(n.uv(m).level(t)), l.mul(n.uv(g).level(t)))),
      _ = OD(o.y).mul(uo(a.mul(n.uv(x).level(t)), l.mul(n.uv(y).level(t))));
    return v.add(_);
  },
  Bhe = (n, e) => {
    const t = Ct(n.size(ce(e))),
      r = Ct(n.size(ce(e.add(1)))),
      i = $c(1, t),
      s = $c(1, r),
      o = UD(n, Tt(i, t), yp(e)),
      a = UD(n, Tt(s, r), r6(e));
    return AS(e).mix(o, a);
  };
class f8 extends Fn {
  constructor(e, t = oe(3)) {
    super("vec4"), (this.textureNode = e), (this.blurNode = t);
  }
  setup() {
    return Bhe(this.textureNode, this.blurNode);
  }
}
const Vhe = De(f8);
Ae("bicubic", Vhe);
qe("TextureBicubicNode", f8);
class h8 extends Lt {
  constructor() {
    super("vec2"), (this.isPointUVNode = !0);
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
Qe(h8);
qe("PointUVNode", h8);
class pa extends Lt {
  constructor(e = pa.BACKGROUND_BLURRINESS, t = null) {
    super(), (this.scope = e), (this.scene = t);
  }
  setup(e) {
    const t = this.scope,
      r = this.scene !== null ? this.scene : e.scene;
    let i;
    return (
      t === pa.BACKGROUND_BLURRINESS
        ? (i = xa("backgroundBlurriness", "float", r))
        : t === pa.BACKGROUND_INTENSITY
        ? (i = xa("backgroundIntensity", "float", r))
        : console.error("THREE.SceneNode: Unknown scope:", t),
      i
    );
  }
}
pa.BACKGROUND_BLURRINESS = "backgroundBlurriness";
pa.BACKGROUND_INTENSITY = "backgroundIntensity";
Qe(pa, pa.BACKGROUND_BLURRINESS);
Qe(pa, pa.BACKGROUND_INTENSITY);
qe("SceneNode", pa);
class Hhe extends bS {
  constructor(e, t, r = 0) {
    super(e, t, r),
      (this.isStorageBufferNode = !0),
      (this.bufferObject = !1),
      (this._attribute = null),
      (this._varying = null),
      e.isStorageBufferAttribute !== !0 &&
        e.isStorageInstancedBufferAttribute !== !0 &&
        (e.isInstancedBufferAttribute
          ? (e.isStorageInstancedBufferAttribute = !0)
          : (e.isStorageBufferAttribute = !0));
  }
  getInputType() {
    return "storageBuffer";
  }
  element(e) {
    return a8(this, e);
  }
  setBufferObject(e) {
    return (this.bufferObject = e), this;
  }
  generate(e) {
    if (e.isAvailable("storageBuffer")) return super.generate(e);
    const t = this.getNodeType(e);
    this._attribute === null &&
      ((this._attribute = ES(this.value)),
      (this._varying = fr(this._attribute)));
    const r = this._varying.build(e, t);
    return e.registerTransform(r, this._attribute), r;
  }
}
qe("StorageBufferNode", Hhe);
class p8 extends _p {
  constructor(e, t, r = null) {
    super(e, t), (this.storeNode = r), (this.isStoreTextureNode = !0);
  }
  getInputType() {
    return "storageTexture";
  }
  setup(e) {
    super.setup(e);
    const t = e.getNodeProperties(this);
    t.storeNode = this.storeNode;
  }
  generate(e, t) {
    let r;
    return (
      this.storeNode !== null
        ? (r = this.generateStore(e))
        : (r = super.generate(e, t)),
      r
    );
  }
  generateStore(e) {
    const t = e.getNodeProperties(this),
      { uvNode: r, storeNode: i } = t,
      s = super.generate(e, "property"),
      o = r.build(e, "uvec2"),
      a = i.build(e, "vec4"),
      l = e.generateTextureStore(e, s, o, a);
    e.addLineFlowCode(l);
  }
}
De(p8);
qe("TextureStoreNode", p8);
class Ghe extends Sp {
  constructor(e, t, r = null) {
    super(e, t, r), (this.userData = r);
  }
  update(e) {
    (this.reference =
      this.userData !== null ? this.userData : e.object.userData),
      super.update(e);
  }
}
qe("UserDataNode", Ghe);
const Whe = je(({ base: n, blend: e }) => {
    const t = (r) =>
      e[r].lessThan(JV).cond(e[r], n[r].oneMinus().div(e[r]).oneMinus().max(0));
    return _e(t("x"), t("y"), t("z"));
  }).setLayout({
    name: "burnColor",
    type: "vec3",
    inputs: [
      { name: "base", type: "vec3" },
      { name: "blend", type: "vec3" },
    ],
  }),
  jhe = je(({ base: n, blend: e }) => {
    const t = (r) => e[r].equal(1).cond(e[r], n[r].div(e[r].oneMinus()).max(0));
    return _e(t("x"), t("y"), t("z"));
  }).setLayout({
    name: "dodgeColor",
    type: "vec3",
    inputs: [
      { name: "base", type: "vec3" },
      { name: "blend", type: "vec3" },
    ],
  }),
  $he = je(({ base: n, blend: e }) => {
    const t = (r) => n[r].oneMinus().mul(e[r].oneMinus()).oneMinus();
    return _e(t("x"), t("y"), t("z"));
  }).setLayout({
    name: "screenColor",
    type: "vec3",
    inputs: [
      { name: "base", type: "vec3" },
      { name: "blend", type: "vec3" },
    ],
  }),
  Xhe = je(({ base: n, blend: e }) => {
    const t = (r) =>
      n[r]
        .lessThan(0.5)
        .cond(
          n[r].mul(e[r], 2),
          n[r].oneMinus().mul(e[r].oneMinus()).oneMinus()
        );
    return _e(t("x"), t("y"), t("z"));
  }).setLayout({
    name: "overlayColor",
    type: "vec3",
    inputs: [
      { name: "base", type: "vec3" },
      { name: "blend", type: "vec3" },
    ],
  });
class ii extends Fn {
  constructor(e, t, r) {
    super(), (this.blendMode = e), (this.baseNode = t), (this.blendNode = r);
  }
  setup() {
    const { blendMode: e, baseNode: t, blendNode: r } = this,
      i = { base: t, blend: r };
    let s = null;
    return (
      e === ii.BURN
        ? (s = Whe(i))
        : e === ii.DODGE
        ? (s = jhe(i))
        : e === ii.SCREEN
        ? (s = $he(i))
        : e === ii.OVERLAY && (s = Xhe(i)),
      s
    );
  }
}
ii.BURN = "burn";
ii.DODGE = "dodge";
ii.SCREEN = "screen";
ii.OVERLAY = "overlay";
const Yhe = De(ii, ii.BURN),
  qhe = De(ii, ii.DODGE),
  Khe = De(ii, ii.OVERLAY),
  Zhe = De(ii, ii.SCREEN);
Ae("burn", Yhe);
Ae("dodge", qhe);
Ae("overlay", Khe);
Ae("screen", Zhe);
qe("BlendModeNode", ii);
const Qhe = je(({ textureNode: n, bumpScale: e }) => {
    const t = (i) =>
        n
          .cache()
          .context({ getUV: (s) => i(s.uvNode || Ja()), forceUVContext: !0 }),
      r = oe(t((i) => i));
    return Ct(
      oe(t((i) => i.add(i.dFdx()))).sub(r),
      oe(t((i) => i.add(i.dFdy()))).sub(r)
    ).mul(e);
  }),
  Jhe = je((n) => {
    const { surf_pos: e, surf_norm: t, dHdxy: r } = n,
      i = e.dFdx().normalize(),
      s = e.dFdy().normalize(),
      o = t,
      a = s.cross(o),
      l = o.cross(i),
      c = i.dot(a).mul(W1),
      u = c.sign().mul(r.x.mul(a).add(r.y.mul(l)));
    return c.abs().mul(t).sub(u).normalize();
  });
class m8 extends Fn {
  constructor(e, t = null) {
    super("vec3"), (this.textureNode = e), (this.scaleNode = t);
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1,
      t = Qhe({ textureNode: this.textureNode, bumpScale: e });
    return Jhe({ surf_pos: to, surf_norm: Xc, dHdxy: t });
  }
}
const epe = De(m8);
Ae("bumpMap", epe);
qe("BumpMapNode", m8);
const tpe = je(({ color: n, adjustment: e }) => e.mix(g8(n.rgb), n.rgb)),
  npe = je(({ color: n, adjustment: e }) => {
    const t = uo(n.r, n.g, n.b).div(3),
      r = n.r.max(n.g.max(n.b)),
      i = r.sub(t).mul(e).mul(-3);
    return _i(n.rgb, r, i);
  }),
  rpe = je(({ color: n, adjustment: e }) => {
    const t = _e(0.57735, 0.57735, 0.57735),
      r = e.cos();
    return _e(
      n.rgb.mul(r).add(
        t
          .cross(n.rgb)
          .mul(e.sin())
          .add(t.mul(xp(t, n.rgb).mul(r.oneMinus())))
      )
    );
  });
class Ms extends Fn {
  constructor(e, t, r = oe(1)) {
    super("vec3"),
      (this.method = e),
      (this.colorNode = t),
      (this.adjustmentNode = r);
  }
  setup() {
    const { method: e, colorNode: t, adjustmentNode: r } = this,
      i = { color: t, adjustment: r };
    let s = null;
    return (
      e === Ms.SATURATION
        ? (s = tpe(i))
        : e === Ms.VIBRANCE
        ? (s = npe(i))
        : e === Ms.HUE
        ? (s = rpe(i))
        : console.error(`${this.type}: Method "${this.method}" not supported!`),
      s
    );
  }
}
Ms.SATURATION = "saturation";
Ms.VIBRANCE = "vibrance";
Ms.HUE = "hue";
const ipe = De(Ms, Ms.SATURATION),
  spe = De(Ms, Ms.VIBRANCE),
  ope = De(Ms, Ms.HUE),
  ape = _e(0.2125, 0.7154, 0.0721),
  g8 = (n, e = ape) => xp(n, e),
  v8 = (n, e) => _i(_e(0), n, g8(n).sub(e).max(0));
Ae("saturation", ipe);
Ae("vibrance", spe);
Ae("hue", ope);
Ae("threshold", v8);
qe("ColorAdjustmentNode", Ms);
const lpe = je((n) => {
  const { eye_pos: e, surf_norm: t, mapN: r, uv: i } = n,
    s = e.dFdx(),
    o = e.dFdy(),
    a = i.dFdx(),
    l = i.dFdy(),
    c = t,
    u = o.cross(c),
    d = c.cross(s),
    h = u.mul(a.x).add(d.mul(l.x)),
    m = u.mul(a.y).add(d.mul(l.y)),
    g = h.dot(h).max(m.dot(m)),
    x = W1.mul(g.inverseSqrt());
  return uo(h.mul(r.x, x), m.mul(r.y, x), c.mul(r.z)).normalize();
});
class y8 extends Fn {
  constructor(e, t = null) {
    super("vec3"),
      (this.node = e),
      (this.scaleNode = t),
      (this.normalMapType = Xa);
  }
  setup(e) {
    const { normalMapType: t, scaleNode: r } = this;
    let i = this.node.mul(2).sub(1);
    r !== null && (i = _e(i.xy.mul(r), i.z));
    let s = null;
    return (
      t === n2
        ? (s = g6.mul(i).normalize())
        : t === Xa &&
          (e.hasGeometryAttribute("tangent") === !0
            ? (s = dh.mul(i).normalize())
            : (s = lpe({ eye_pos: to, surf_norm: Xc, mapN: i, uv: Ja() }))),
      s
    );
  }
}
const cpe = De(y8);
Ae("normalMap", cpe);
qe("NormalMapNode", y8);
class x8 extends Fn {
  constructor(e, t) {
    super(), (this.sourceNode = e), (this.stepsNode = t);
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const upe = De(x8);
Ae("posterize", upe);
qe("PosterizeNode", x8);
const dpe = je(({ color: n, exposure: e }) => n.mul(e).clamp()),
  fpe = je(
    ({ color: n, exposure: e }) => ((n = n.mul(e)), n.div(n.add(1)).clamp())
  ),
  hpe = je(({ color: n, exposure: e }) => {
    (n = n.mul(e)), (n = n.sub(0.004).max(0));
    const t = n.mul(n.mul(6.2).add(0.5)),
      r = n.mul(n.mul(6.2).add(1.7)).add(0.06);
    return t.div(r).pow(2.2);
  }),
  ppe = je(({ color: n }) => {
    const e = n.mul(n.add(0.0245786)).sub(90537e-9),
      t = n.mul(n.add(0.432951).mul(0.983729)).add(0.238081);
    return e.div(t);
  }),
  mpe = je(({ color: n, exposure: e }) => {
    const t = ya(
        0.59719,
        0.35458,
        0.04823,
        0.076,
        0.90834,
        0.01566,
        0.0284,
        0.13383,
        0.83777
      ),
      r = ya(
        1.60475,
        -0.53108,
        -0.07367,
        -0.10208,
        1.10813,
        -0.00605,
        -0.00327,
        -0.07276,
        1.07602
      );
    return (
      (n = n.mul(e).div(0.6)),
      (n = t.mul(n)),
      (n = ppe({ color: n })),
      (n = r.mul(n)),
      n.clamp()
    );
  }),
  gpe = ya(
    _e(1.6605, -0.1246, -0.0182),
    _e(-0.5876, 1.1329, -0.1006),
    _e(-0.0728, -0.0083, 1.1187)
  ),
  vpe = ya(
    _e(0.6274, 0.0691, 0.0164),
    _e(0.3293, 0.9195, 0.088),
    _e(0.0433, 0.0113, 0.8956)
  ),
  ype = je(([n]) => {
    const e = _e(n).toVar(),
      t = _e(e.mul(e)).toVar(),
      r = _e(t.mul(t)).toVar();
    return oe(15.5)
      .mul(r.mul(t))
      .sub(hn(40.14, r.mul(e)))
      .add(
        hn(31.96, r)
          .sub(hn(6.868, t.mul(e)))
          .add(hn(0.4298, t).add(hn(0.1191, e).sub(0.00232)))
      );
  }),
  xpe = je(({ color: n, exposure: e }) => {
    const t = _e(n).toVar(),
      r = ya(
        _e(0.856627153315983, 0.137318972929847, 0.11189821299995),
        _e(0.0951212405381588, 0.761241990602591, 0.0767994186031903),
        _e(0.0482516061458583, 0.101439036467562, 0.811302368396859)
      ),
      i = ya(
        _e(1.1271005818144368, -0.1413297634984383, -0.14132976349843826),
        _e(-0.11060664309660323, 1.157823702216272, -0.11060664309660294),
        _e(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)
      ),
      s = oe(-12.47393),
      o = oe(4.026069);
    return (
      t.mulAssign(e),
      t.assign(vpe.mul(t)),
      t.assign(r.mul(t)),
      t.assign(fo(t, 1e-10)),
      t.assign(SS(t)),
      t.assign(t.sub(s).div(o.sub(s))),
      t.assign(Zh(t, 0, 1)),
      t.assign(ype(t)),
      t.assign(i.mul(t)),
      t.assign(Va(fo(_e(0), t), _e(2.2))),
      t.assign(gpe.mul(t)),
      t.assign(Zh(t, 0, 1)),
      t
    );
  }),
  _pe = { [VC]: dpe, [HC]: fpe, [GC]: hpe, [f_]: mpe, [WC]: xpe };
class _8 extends Fn {
  constructor(e = ws, t = Ape, r = null) {
    super("vec3"),
      (this.toneMapping = e),
      (this.exposureNode = t),
      (this.colorNode = r);
  }
  getCacheKey() {
    let e = super.getCacheKey();
    return (e = "{toneMapping:" + this.toneMapping + ",nodes:" + e + "}"), e;
  }
  setup(e) {
    const t = this.colorNode || e.context.color,
      r = this.toneMapping;
    if (r === ws) return t;
    const i = { exposure: this.exposureNode, color: t },
      s = _pe[r];
    let o = null;
    return (
      s
        ? (o = s(i))
        : (console.error(
            "ToneMappingNode: Unsupported Tone Mapping configuration.",
            r
          ),
          (o = t)),
      o
    );
  }
}
const Spe = (n, e, t) => ct(new _8(n, ct(e), ct(t))),
  Ape = zhe("toneMappingExposure", "float");
Ae("toneMapping", (n, e, t) => Spe(e, t, n));
qe("ToneMappingNode", _8);
let Ub = null;
class S8 extends P0 {
  constructor(e = t0, t = null) {
    Ub === null && (Ub = new h2()), super(e, t, Ub);
  }
  updateReference() {
    return this;
  }
}
const wpe = De(S8);
Ae("viewportSharedTexture", wpe);
qe("ViewportSharedTextureNode", S8);
class WT extends _p {
  constructor(e, t) {
    super(t), (this.passNode = e), this.setUpdateMatrix(!1);
  }
  setup(e) {
    return this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class I0 extends Fn {
  constructor(e, t, r) {
    super("vec4"),
      (this.scope = e),
      (this.scene = t),
      (this.camera = r),
      (this._pixelRatio = 1),
      (this._width = 1),
      (this._height = 1);
    const i = new sp();
    (i.isRenderTargetTexture = !0), (i.name = "PostProcessingDepth");
    const s = new Fl(
      this._width * this._pixelRatio,
      this._height * this._pixelRatio,
      { type: rp }
    );
    (s.texture.name = "PostProcessing"),
      (s.depthTexture = i),
      (this.renderTarget = s),
      (this.updateBeforeType = On.FRAME),
      (this._textureNode = ct(new WT(this, s.texture))),
      (this._depthTextureNode = ct(new WT(this, i))),
      (this._depthNode = null),
      (this._viewZNode = null),
      (this._cameraNear = Dn(0)),
      (this._cameraFar = Dn(0)),
      (this.isPassNode = !0);
  }
  isGlobal() {
    return !0;
  }
  getTextureNode() {
    return this._textureNode;
  }
  getTextureDepthNode() {
    return this._depthTextureNode;
  }
  getViewZNode() {
    if (this._viewZNode === null) {
      const e = this._cameraNear,
        t = this._cameraFar;
      this._viewZNode = H6(this._depthTextureNode, e, t);
    }
    return this._viewZNode;
  }
  getDepthNode() {
    if (this._depthNode === null) {
      const e = this._cameraNear,
        t = this._cameraFar;
      this._depthNode = zT(this.getViewZNode(), e, t);
    }
    return this._depthNode;
  }
  setup() {
    return this.scope === I0.COLOR
      ? this.getTextureNode()
      : this.getDepthNode();
  }
  updateBefore(e) {
    const { renderer: t } = e,
      { scene: r, camera: i } = this;
    this._pixelRatio = t.getPixelRatio();
    const s = t.getSize(new He());
    this.setSize(s.width, s.height);
    const o = t.toneMapping,
      a = t.toneMappingNode,
      l = t.getRenderTarget();
    (this._cameraNear.value = i.near),
      (this._cameraFar.value = i.far),
      (t.toneMapping = ws),
      (t.toneMappingNode = null),
      t.setRenderTarget(this.renderTarget),
      t.render(r, i),
      (t.toneMapping = o),
      (t.toneMappingNode = a),
      t.setRenderTarget(l);
  }
  setSize(e, t) {
    (this._width = e), (this._height = t);
    const r = this._width * this._pixelRatio,
      i = this._height * this._pixelRatio;
    this.renderTarget.setSize(r, i);
  }
  setPixelRatio(e) {
    (this._pixelRatio = e), this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
}
I0.COLOR = "color";
I0.DEPTH = "depth";
const zR = (n, e) => ct(new WT(n, e));
qe("PassNode", I0);
const kb = new Fo(-1, 1, 1, -1, 0, 1);
class bpe extends qt {
  constructor(e = !1) {
    super();
    const t = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new At([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
      this.setAttribute("uv", new At(t, 2));
  }
}
const Epe = new bpe();
class RS extends qn {
  constructor(e = null) {
    super(Epe, e), (this.camera = kb);
  }
  renderAsync(e) {
    return e.renderAsync(this, kb);
  }
  render(e) {
    e.render(this, kb);
  }
}
const kD = new RS(),
  zD = new RS();
class Mpe extends Fn {
  constructor(e, t = 2) {
    super("vec4"),
      (this.textureNode = e),
      (this.sigma = t),
      (this.directionNode = Ct(1)),
      (this._invSize = Dn(new He())),
      (this._passDirection = Dn(new He())),
      (this._horizontalRT = new Fl()),
      (this._horizontalRT.texture.name = "GaussianBlurNode.horizontal"),
      (this._verticalRT = new Fl()),
      (this._verticalRT.texture.name = "GaussianBlurNode.vertical"),
      (this._textureNode = zR(this, this._verticalRT.texture)),
      (this.updateBeforeType = On.RENDER),
      (this.resolution = new He(1, 1));
  }
  setSize(e, t) {
    (e = Math.max(Math.round(e * this.resolution.x), 1)),
      (t = Math.max(Math.round(t * this.resolution.y), 1)),
      this._invSize.value.set(1 / e, 1 / t),
      this._horizontalRT.setSize(e, t),
      this._verticalRT.setSize(e, t);
  }
  updateBefore(e) {
    const { renderer: t } = e,
      r = this.textureNode,
      i = r.value,
      s = t.getRenderTarget(),
      o = r.value;
    (kD.material = this._material),
      (zD.material = this._material),
      this.setSize(i.image.width, i.image.height);
    const a = i.type;
    (this._horizontalRT.texture.type = a),
      (this._verticalRT.texture.type = a),
      t.setRenderTarget(this._horizontalRT),
      this._passDirection.value.set(1, 0),
      kD.render(t),
      (r.value = this._horizontalRT.texture),
      t.setRenderTarget(this._verticalRT),
      this._passDirection.value.set(0, 1),
      zD.render(t),
      t.setRenderTarget(s),
      (r.value = o);
  }
  getTextureNode() {
    return this._textureNode;
  }
  setup(e) {
    const t = this.textureNode;
    if (t.isTextureNode !== !0)
      return console.error("GaussianBlurNode requires a TextureNode."), Tt();
    const r = t.uvNode || Ja(),
      i = (l) => t.cache().context({ getUV: () => l, forceUVContext: !0 }),
      s = je(() => {
        const l = 3 + 2 * this.sigma,
          c = this._getCoefficients(l),
          u = this._invSize,
          d = Ct(this.directionNode).mul(this._passDirection),
          h = oe(c[0]).toVar(),
          m = Tt(i(r).mul(h)).toVar();
        for (let g = 1; g < l; g++) {
          const x = oe(g),
            y = oe(c[g]),
            v = Ct(d.mul(u.mul(x))).toVar(),
            _ = Tt(i(r.add(v))),
            S = Tt(i(r.sub(v)));
          m.addAssign(_.add(S).mul(y)), h.addAssign(hn(2, y));
        }
        return m.div(h);
      }),
      o = this._material || (this._material = e.createNodeMaterial());
    o.fragmentNode = s();
    const a = e.getNodeProperties(this);
    return (a.textureNode = t), this._textureNode;
  }
  _getCoefficients(e) {
    const t = [];
    for (let r = 0; r < e; r++)
      t.push((0.39894 * Math.exp((-0.5 * r * r) / (e * e))) / e);
    return t;
  }
}
const Tpe = (n, e) => ct(new Mpe(ct(n), e));
Ae("gaussianBlur", Tpe);
const BD = new RS();
class Cpe extends Fn {
  constructor(e, t = 0.96) {
    super(e),
      (this.textureNode = e),
      (this.textureNodeOld = so()),
      (this.damp = Dn(t)),
      (this._compRT = new Fl()),
      (this._compRT.texture.name = "AfterImageNode.comp"),
      (this._oldRT = new Fl()),
      (this._oldRT.texture.name = "AfterImageNode.old"),
      (this._textureNode = zR(this, this._compRT.texture)),
      (this.updateBeforeType = On.RENDER);
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(e, t) {
    this._compRT.setSize(e, t), this._oldRT.setSize(e, t);
  }
  updateBefore(e) {
    const { renderer: t } = e,
      r = this.textureNode,
      i = r.value,
      s = i.type;
    (this._compRT.texture.type = s), (this._oldRT.texture.type = s);
    const o = t.getRenderTarget(),
      a = r.value;
    (this.textureNodeOld.value = this._oldRT.texture),
      t.setRenderTarget(this._compRT),
      BD.render(t);
    const l = this._oldRT;
    (this._oldRT = this._compRT),
      (this._compRT = l),
      this.setSize(i.image.width, i.image.height),
      t.setRenderTarget(o),
      (r.value = a);
  }
  setup(e) {
    const t = this.textureNode,
      r = this.textureNodeOld;
    if (t.isTextureNode !== !0)
      return console.error("AfterImageNode requires a TextureNode."), Tt();
    const i = t.uvNode || Ja();
    r.uvNode = i;
    const s = (u) => t.cache().context({ getUV: () => u, forceUVContext: !0 }),
      o = je(([u, d]) => {
        const h = oe(d).toVar(),
          m = Tt(u).toVar();
        return fo(DR(m.sub(h)), 0);
      }),
      a = je(() => {
        const u = Tt(r),
          d = Tt(s(i));
        return u.mulAssign(this.damp.mul(o(u, 0.1))), fo(d, u);
      }),
      l =
        this._materialComposed ||
        (this._materialComposed = e.createNodeMaterial());
    (l.fragmentNode = a()), (BD.material = l);
    const c = e.getNodeProperties(this);
    return (c.textureNode = t), this._textureNode;
  }
}
const Rpe = (n, e) => ct(new Cpe(ct(n), e));
Ae("afterImage", Rpe);
const VD = new RS();
class Npe extends Fn {
  constructor(e, t, r, i) {
    super("vec4"),
      (this.textureNode = e),
      (this.tresholdNode = t),
      (this.scaleNode = r),
      (this.colorNode = _e(0.1, 0, 1)),
      (this.samples = i),
      (this.resolution = new He(1, 1)),
      (this._renderTarget = new Fl()),
      (this._renderTarget.texture.name = "anamorphic"),
      (this._invSize = Dn(new He())),
      (this._textureNode = zR(this, this._renderTarget.texture)),
      (this.updateBeforeType = On.RENDER);
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(e, t) {
    this._invSize.value.set(1 / e, 1 / t),
      (e = Math.max(Math.round(e * this.resolution.x), 1)),
      (t = Math.max(Math.round(t * this.resolution.y), 1)),
      this._renderTarget.setSize(e, t);
  }
  updateBefore(e) {
    const { renderer: t } = e,
      r = this.textureNode,
      i = r.value;
    this._renderTarget.texture.type = i.type;
    const s = t.getRenderTarget(),
      o = r.value;
    (VD.material = this._material),
      this.setSize(i.image.width, i.image.height),
      t.setRenderTarget(this._renderTarget),
      VD.render(t),
      t.setRenderTarget(s),
      (r.value = o);
  }
  setup(e) {
    const t = this.textureNode;
    if (t.isTextureNode !== !0)
      return console.error("AnamorphNode requires a TextureNode."), Tt();
    const r = t.uvNode || Ja(),
      i = (l) => t.cache().context({ getUV: () => l, forceUVContext: !0 }),
      s = je(() => {
        const l = this.samples,
          c = Math.floor(l / 2),
          u = _e(0).toVar();
        return (
          Bn({ start: -c, end: c }, ({ i: d }) => {
            const h = oe(d).abs().div(c).oneMinus(),
              m = Ct(r.x.add(this._invSize.x.mul(d).mul(this.scaleNode)), r.y),
              g = i(m),
              x = v8(g, this.tresholdNode).mul(h);
            u.addAssign(x);
          }),
          u.mul(this.colorNode)
        );
      }),
      o = this._material || (this._material = e.createNodeMaterial());
    o.fragmentNode = s();
    const a = e.getNodeProperties(this);
    return (a.textureNode = t), this._textureNode;
  }
}
const Ppe = (n, e = 0.9, t = 3, r = 32) => ct(new Npe(ct(n), ct(e), ct(t), r));
Ae("anamorphic", Ppe);
class A8 extends Fn {
  constructor(e = null, t = {}) {
    super(), (this.functionNode = e), (this.parameters = t);
  }
  setParameters(e) {
    return (this.parameters = e), this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [],
      r = this.functionNode,
      i = r.getInputs(e),
      s = this.parameters;
    if (Array.isArray(s))
      for (let a = 0; a < s.length; a++) {
        const l = i[a],
          c = s[a];
        t.push(c.build(e, l.type));
      }
    else
      for (const a of i) {
        const l = s[a.name];
        if (l !== void 0) t.push(l.build(e, a.type));
        else
          throw new Error(
            `FunctionCallNode: Input '${a.name}' not found in FunctionNode.`
          );
      }
    return `${r.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const Ipe = (n, ...e) => (
  (e = e.length > 1 || (e[0] && e[0].isNode === !0) ? Sh(e) : xS(e[0])),
  ct(new A8(ct(n), e))
);
Ae("call", Ipe);
qe("FunctionCallNode", A8);
class w8 extends Lt {
  constructor(e = null) {
    super(),
      (this._value = e),
      (this._cache = null),
      (this.inputType = null),
      (this.outpuType = null),
      (this.events = new Go()),
      (this.isScriptableValueNode = !0);
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e &&
      (this._cache &&
        this.inputType === "URL" &&
        this.value.value instanceof ArrayBuffer &&
        (URL.revokeObjectURL(this._cache), (this._cache = null)),
      (this._value = e),
      this.events.dispatchEvent({ type: "change" }),
      this.refresh());
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const e = this.value;
    if (
      e &&
      this._cache === null &&
      this.inputType === "URL" &&
      e.value instanceof ArrayBuffer
    )
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (
      e &&
      e.value !== null &&
      e.value !== void 0 &&
      (((this.inputType === "URL" || this.inputType === "String") &&
        typeof e.value == "string") ||
        (this.inputType === "Number" && typeof e.value == "number") ||
        (this.inputType === "Vector2" && e.value.isVector2) ||
        (this.inputType === "Vector3" && e.value.isVector3) ||
        (this.inputType === "Vector4" && e.value.isVector4) ||
        (this.inputType === "Color" && e.value.isColor) ||
        (this.inputType === "Matrix3" && e.value.isMatrix3) ||
        (this.inputType === "Matrix4" && e.value.isMatrix4))
    )
      return e.value;
    return this._cache || e;
  }
  getNodeType(e) {
    return this.value && this.value.isNode
      ? this.value.getNodeType(e)
      : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : oe();
  }
  serialize(e) {
    super.serialize(e),
      this.value !== null
        ? this.inputType === "ArrayBuffer"
          ? (e.value = NV(this.value))
          : (e.value = this.value ? this.value.toJSON(e.meta).uuid : null)
        : (e.value = null),
      (e.inputType = this.inputType),
      (e.outputType = this.outputType);
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null &&
      (e.inputType === "ArrayBuffer"
        ? (t = PV(e.value))
        : e.inputType === "Texture"
        ? (t = e.meta.textures[e.value])
        : (t = e.meta.nodes[e.value] || null)),
      (this.value = t),
      (this.inputType = e.inputType),
      (this.outputType = e.outputType);
  }
}
const kx = De(w8);
Ae("scriptableValue", kx);
qe("ScriptableValueNode", w8);
class b8 extends Map {
  get(e, t = null, ...r) {
    if (this.has(e)) return super.get(e);
    if (t !== null) {
      const i = t(...r);
      return this.set(e, i), i;
    }
  }
}
class Lpe {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const zb = new b8();
class E8 extends Lt {
  constructor(e = null, t = {}) {
    super(),
      (this.codeNode = e),
      (this.parameters = t),
      (this._local = new b8()),
      (this._output = kx()),
      (this._outputs = {}),
      (this._source = this.source),
      (this._method = null),
      (this._object = null),
      (this._value = null),
      (this._needsOutputUpdate = !0),
      (this.onRefresh = this.onRefresh.bind(this)),
      (this.isScriptableNode = !0);
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  getLocal(e) {
    return this._local.get(e);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e)) return t;
  }
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e)) return t;
  }
  setOutput(e, t) {
    const r = this._outputs;
    return r[e] === void 0 ? (r[e] = kx(t)) : (r[e].value = t), this;
  }
  getOutput(e) {
    return this._outputs[e];
  }
  getParameter(e) {
    return this.parameters[e];
  }
  setParameter(e, t) {
    const r = this.parameters;
    return (
      t && t.isScriptableNode
        ? (this.deleteParameter(e),
          (r[e] = t),
          r[e]
            .getDefaultOutput()
            .events.addEventListener("refresh", this.onRefresh))
        : t && t.isScriptableValueNode
        ? (this.deleteParameter(e),
          (r[e] = t),
          r[e].events.addEventListener("refresh", this.onRefresh))
        : r[e] === void 0
        ? ((r[e] = kx(t)),
          r[e].events.addEventListener("refresh", this.onRefresh))
        : (r[e].value = t),
      this
    );
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(e) {
    let t = this.parameters[e];
    return (
      t &&
        (t.isScriptableNode && (t = t.getDefaultOutput()),
        t.events.removeEventListener("refresh", this.onRefresh)),
      this
    );
  }
  clearParameters() {
    for (const e of Object.keys(this.parameters)) this.deleteParameter(e);
    return (this.needsUpdate = !0), this;
  }
  call(e, ...t) {
    const i = this.getObject()[e];
    if (typeof i == "function") return i(...t);
  }
  async callAsync(e, ...t) {
    const i = this.getObject()[e];
    if (typeof i == "function")
      return i.constructor.name === "AsyncFunction" ? await i(...t) : i(...t);
  }
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  getObject() {
    if ((this.needsUpdate && this.dispose(), this._object !== null))
      return this._object;
    const e = () => this.refresh(),
      t = (c, u) => this.setOutput(c, u),
      r = new Lpe(this),
      i = zb.get("THREE"),
      s = zb.get("TSL"),
      o = this.getMethod(this.codeNode),
      a = [r, this._local, zb, e, t, i, s];
    this._object = o(...a);
    const l = this._object.layout;
    if (
      l &&
      (l.cache === !1 && this._local.clear(),
      (this._output.outputType = l.outputType || null),
      Array.isArray(l.elements))
    )
      for (const c of l.elements) {
        const u = c.id || c.name;
        c.inputType &&
          (this.getParameter(u) === void 0 && this.setParameter(u, null),
          (this.getParameter(u).inputType = c.inputType)),
          c.outputType &&
            (this.getOutput(u) === void 0 && this.setOutput(u, null),
            (this.getOutput(u).outputType = c.outputType));
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let r = this.parameters[t];
      r.isScriptableNode && (r = r.getDefaultOutput()),
        r.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : oe();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if ((this.needsUpdate && this.dispose(), this._method !== null))
      return this._method;
    const e = [
        "parameters",
        "local",
        "global",
        "refresh",
        "setOutput",
        "THREE",
        "TSL",
      ],
      r = ["layout", "init", "main", "dispose"].join(", "),
      i =
        "var " +
        r +
        `; var output = {};
`,
      s =
        `
return { ...output, ` +
        r +
        " };",
      o = i + this.codeNode.code + s;
    return (this._method = new Function(...e, o)), this._method;
  }
  dispose() {
    this._method !== null &&
      (this._object &&
        typeof this._object.dispose == "function" &&
        this._object.dispose(),
      (this._method = null),
      (this._object = null),
      (this._source = null),
      (this._value = null),
      (this._needsOutputUpdate = !0),
      (this._output.value = null),
      (this._outputs = {}));
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    return this.codeNode === null
      ? this
      : (this._needsOutputUpdate === !0 &&
          ((this._value = this.call("main")), (this._needsOutputUpdate = !1)),
        (this._output.value = this._value),
        this);
  }
  _refresh() {
    (this.needsUpdate = !0), this._exec(), this._output.refresh();
  }
}
const Ope = De(E8);
Ae("scriptable", Ope);
qe("ScriptableNode", E8);
class NS extends Lt {
  constructor(e, t) {
    super("float"),
      (this.isFogNode = !0),
      (this.colorNode = e),
      (this.factorNode = t);
  }
  getViewZNode(e) {
    let t;
    const r = e.context.getViewZ;
    return r !== void 0 && (t = r(this)), (t || to.z).negate();
  }
  setup() {
    return this.factorNode;
  }
}
const Dpe = De(NS);
Ae("fog", Dpe);
qe("FogNode", NS);
class M8 extends NS {
  constructor(e, t, r) {
    super(e),
      (this.isFogRangeNode = !0),
      (this.nearNode = t),
      (this.farNode = r);
  }
  setup(e) {
    const t = this.getViewZNode(e);
    return Vl(this.nearNode, this.farNode, t);
  }
}
const Fpe = De(M8);
Ae("rangeFog", Fpe);
qe("FogRangeNode", M8);
class T8 extends NS {
  constructor(e, t) {
    super(e), (this.isFogExp2Node = !0), (this.densityNode = t);
  }
  setup(e) {
    const t = this.getViewZNode(e),
      r = this.densityNode;
    return r.mul(r, t, t).negate().exp().oneMinus();
  }
}
const Upe = De(T8);
Ae("densityFog", Upe);
qe("FogExp2Node", T8);
let Nu = null,
  Pu = null;
class C8 extends Lt {
  constructor(e = oe(), t = oe()) {
    super(), (this.minNode = e), (this.maxNode = t);
  }
  getVectorLength(e) {
    const t = e.getTypeLength(Ec(this.minNode.value)),
      r = e.getTypeLength(Ec(this.maxNode.value));
    return t > r ? t : r;
  }
  getNodeType(e) {
    return e.object.isInstancedMesh === !0
      ? e.getTypeFromLength(this.getVectorLength(e))
      : "float";
  }
  setup(e) {
    const t = e.object;
    let r = null;
    if (t.isInstancedMesh === !0) {
      const i = this.minNode.value,
        s = this.maxNode.value,
        o = e.getTypeLength(Ec(i)),
        a = e.getTypeLength(Ec(s));
      (Nu = Nu || new rn()),
        (Pu = Pu || new rn()),
        Nu.setScalar(0),
        Pu.setScalar(0),
        o === 1
          ? Nu.setScalar(i)
          : i.isColor
          ? Nu.set(i.r, i.g, i.b)
          : Nu.set(i.x, i.y, i.z || 0, i.w || 0),
        a === 1
          ? Pu.setScalar(s)
          : s.isColor
          ? Pu.set(s.r, s.g, s.b)
          : Pu.set(s.x, s.y, s.z || 0, s.w || 0);
      const l = 4,
        c = l * t.count,
        u = new Float32Array(c);
      for (let h = 0; h < c; h++) {
        const m = h % l,
          g = Nu.getComponent(m),
          x = Pu.getComponent(m);
        u[h] = o2.lerp(g, x, Math.random());
      }
      const d = this.getNodeType(e);
      r = FR(u, "vec4", t.count).element(HV).convert(d);
    } else r = oe(0);
    return r;
  }
}
De(C8);
qe("RangeNode", C8);
class R8 extends Lt {
  constructor(e, t, r = [64]) {
    super("void"),
      (this.isComputeNode = !0),
      (this.computeNode = e),
      (this.count = t),
      (this.workgroupSize = r),
      (this.dispatchCount = 0),
      (this.version = 1),
      (this.updateBeforeType = On.OBJECT),
      this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let r = t[0];
    for (let i = 1; i < t.length; i++) r *= t[i];
    this.dispatchCount = Math.ceil(e / r);
  }
  onInit() {}
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  generate(e) {
    const { shaderStage: t } = e;
    if (t === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r);
    }
  }
}
const kpe = (n, e, t) => ct(new R8(ct(n), e, t));
Ae("compute", kpe);
qe("ComputeNode", R8);
class Rd extends Lt {
  constructor(e = Rd.TARGET_DIRECTION, t = null) {
    super(), (this.scope = e), (this.light = t);
  }
  setup() {
    const { scope: e, light: t } = this;
    let r = null;
    return (
      e === Rd.TARGET_DIRECTION &&
        (r = $l.transformDirection(LT(t).sub(LT(t.target)))),
      r
    );
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
Rd.TARGET_DIRECTION = "targetDirection";
const N8 = De(Rd, Rd.TARGET_DIRECTION);
qe("LightNode", Rd);
const P8 = je((n) => {
  const { lightDistance: e, cutoffDistance: t, decayExponent: r } = n,
    i = e.pow(r).max(0.01).reciprocal();
  return t
    .greaterThan(0)
    .cond(i.mul(e.div(t).pow4().oneMinus().clamp().pow2()), i);
});
class I8 extends Gd {
  constructor(e = null) {
    super(e),
      (this.cutoffDistanceNode = Dn(0)),
      (this.decayExponentNode = Dn(0));
  }
  update(e) {
    const { light: t } = this;
    super.update(e),
      (this.cutoffDistanceNode.value = t.distance),
      (this.decayExponentNode.value = t.decay);
  }
  setup(e) {
    const {
        colorNode: t,
        cutoffDistanceNode: r,
        decayExponentNode: i,
        light: s,
      } = this,
      o = e.context.lightingModel,
      a = m6(s).sub(to),
      l = a.normalize(),
      c = a.length(),
      u = P8({ lightDistance: c, cutoffDistance: r, decayExponent: i }),
      d = t.mul(u),
      h = e.context.reflectedLight;
    o.direct(
      {
        lightDirection: l,
        lightColor: d,
        reflectedLight: h,
        shadowMask: this.shadowMaskNode,
      },
      e.stack,
      e
    );
  }
}
qe("PointLightNode", I8);
Ap(P2, I8);
class L8 extends Gd {
  constructor(e = null) {
    super(e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel,
      r = this.colorNode,
      i = N8(this.light),
      s = e.context.reflectedLight;
    t.direct(
      {
        lightDirection: i,
        lightColor: r,
        reflectedLight: s,
        shadowMask: this.shadowMaskNode,
      },
      e.stack,
      e
    );
  }
}
qe("DirectionalLightNode", L8);
Ap(I2, L8);
class BR extends Gd {
  constructor(e = null) {
    super(e),
      (this.coneCosNode = Dn(0)),
      (this.penumbraCosNode = Dn(0)),
      (this.cutoffDistanceNode = Dn(0)),
      (this.decayExponentNode = Dn(0));
  }
  update(e) {
    super.update(e);
    const { light: t } = this;
    (this.coneCosNode.value = Math.cos(t.angle)),
      (this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra))),
      (this.cutoffDistanceNode.value = t.distance),
      (this.decayExponentNode.value = t.decay);
  }
  getSpotAttenuation(e) {
    const { coneCosNode: t, penumbraCosNode: r } = this;
    return Vl(t, r, e);
  }
  setup(e) {
    super.setup(e);
    const t = e.context.lightingModel,
      {
        colorNode: r,
        cutoffDistanceNode: i,
        decayExponentNode: s,
        light: o,
      } = this,
      a = m6(o).sub(to),
      l = a.normalize(),
      c = l.dot(N8(o)),
      u = this.getSpotAttenuation(c),
      d = a.length(),
      h = P8({ lightDistance: d, cutoffDistance: i, decayExponent: s }),
      m = r.mul(u).mul(h),
      g = e.context.reflectedLight;
    t.direct(
      {
        lightDirection: l,
        lightColor: m,
        reflectedLight: g,
        shadowMask: this.shadowMaskNode,
      },
      e.stack,
      e
    );
  }
}
qe("SpotLightNode", BR);
Ap(B_, BR);
class zpe extends B_ {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, i, s, o), (this.iesMap = null);
  }
  copy(e, t) {
    return super.copy(e, t), (this.iesMap = e.iesMap), this;
  }
}
class O8 extends BR {
  getSpotAttenuation(e) {
    const t = this.light.iesMap;
    let r = null;
    if (t && t.isTexture === !0) {
      const i = e.acos().mul(1 / Math.PI);
      r = so(t, Ct(i, 0), 0).r;
    } else r = super.getSpotAttenuation(e);
    return r;
  }
}
qe("IESSpotLightNode", O8);
Ap(zpe, O8);
class D8 extends Gd {
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
qe("AmbientLightNode", D8);
Ap(L2, D8);
class F8 extends Gd {
  constructor(e = null) {
    super(e),
      (this.lightPositionNode = LT(e)),
      (this.lightDirectionNode = this.lightPositionNode.normalize()),
      (this.groundColorNode = Dn(new pt()));
  }
  update(e) {
    const { light: t } = this;
    super.update(e),
      (this.lightPositionNode.object3d = t),
      this.groundColorNode.value
        .copy(t.groundColor)
        .multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: r, lightDirectionNode: i } = this,
      o = Xc.dot(i).mul(0.5).add(0.5),
      a = _i(r, t, o);
    e.context.irradiance.addAssign(a);
  }
}
qe("HemisphereLightNode", F8);
Ap(R2, F8);
const Bpe = je((n) => {
  const e = n.uv.mul(2),
    t = e.x.floor(),
    r = e.y.floor();
  return t.add(r).mod(2).sign();
});
class U8 extends Fn {
  constructor(e = Ja()) {
    super("float"), (this.uvNode = e);
  }
  setup() {
    return Bpe({ uv: this.uvNode });
  }
}
const Vpe = De(U8);
Ae("checker", Vpe);
qe("CheckerNode", U8);
const Hpe = new v0();
class Gpe extends go {
  constructor(e = {}) {
    super(),
      (this.normals = !1),
      (this.lights = !1),
      (this.useAlphaToCoverage = !0),
      (this.useColor = e.vertexColors),
      (this.pointWidth = 1),
      (this.pointColorNode = null),
      this.setDefaultValues(Hpe),
      this.setupShaders(),
      this.setValues(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage,
      t = this.useColor;
    (this.vertexNode = je(() => {
      fr(Ct(), "vUv").assign(Ja());
      const r = Ui("instancePosition"),
        i = di("vec4", "mvPos");
      i.assign(Cd.mul(Tt(r, 1)));
      const s = Eh.z.div(Eh.w),
        o = Ua.mul(i),
        a = di("vec2", "offset");
      return (
        a.assign(ps.xy),
        a.assign(a.mul(Wfe)),
        a.assign(a.div(Eh.z)),
        a.y.assign(a.y.mul(s)),
        a.assign(a.mul(o.w)),
        o.assign(o.add(Tt(a, 0, 0))),
        o
      );
    })()),
      (this.fragmentNode = je(() => {
        const r = fr(Ct(), "vUv"),
          i = di("float", "alpha");
        i.assign(1);
        const s = r.x,
          o = r.y,
          a = s.mul(s).add(o.mul(o));
        if (e) {
          const c = di("float", "dlen");
          c.assign(a.fwidth()),
            i.assign(Vl(c.oneMinus(), c.add(1), a).oneMinus());
        } else a.greaterThan(1).discard();
        let l;
        return (
          this.pointColorNode
            ? (l = this.pointColorNode)
            : t
            ? (l = Ui("instanceColor").mul(e0))
            : (l = e0),
          Tt(l, i)
        );
      })()),
      (this.needsUpdate = !0);
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e &&
      ((this.useAlphaToCoverage = e), this.setupShaders());
  }
}
as("InstancedPointsNodeMaterial", Gpe);
const Wpe = new Hi();
class jpe extends go {
  constructor(e) {
    super(),
      (this.isLineBasicNodeMaterial = !0),
      (this.lights = !1),
      (this.normals = !1),
      this.setDefaultValues(Wpe),
      this.setValues(e);
  }
}
as("LineBasicNodeMaterial", jpe);
const $pe = new z_();
class Xpe extends go {
  constructor(e) {
    super(),
      (this.isLineDashedNodeMaterial = !0),
      (this.lights = !1),
      (this.normals = !1),
      this.setDefaultValues($pe),
      (this.offsetNode = null),
      (this.dashScaleNode = null),
      (this.dashSizeNode = null),
      (this.gapSizeNode = null),
      this.setValues(e);
  }
  setupVariants() {
    const e = this.offsetNode,
      t = this.dashScaleNode ? oe(this.dashScaleNode) : OT,
      r = this.dashSizeNode ? oe(this.dashSizeNode) : _6,
      i = this.dashSizeNode ? oe(this.dashGapNode) : S6;
    bh.assign(r), z1.assign(i);
    const s = fr(Ui("lineDistance").mul(t));
    (e ? s.add(e) : s).mod(bh.add(z1)).greaterThan(bh).discard();
  }
}
as("LineDashedNodeMaterial", Xpe);
const Ype = new z_();
class qpe extends go {
  constructor(e = {}) {
    super(),
      (this.normals = !1),
      (this.lights = !1),
      this.setDefaultValues(Ype),
      (this.useAlphaToCoverage = !0),
      (this.useColor = e.vertexColors),
      (this.useDash = e.dashed),
      (this.useWorldUnits = !1),
      (this.dashOffset = 0),
      (this.lineWidth = 1),
      (this.lineColorNode = null),
      (this.offsetNode = null),
      (this.dashScaleNode = null),
      (this.dashSizeNode = null),
      (this.gapSizeNode = null),
      this.setValues(e);
  }
  setup(e) {
    this.setupShaders(), super.setup(e);
  }
  setupShaders() {
    const e = this.alphaToCoverage,
      t = this.useColor,
      r = this.dashed,
      i = this.worldUnits,
      s = je(({ start: a, end: l }) => {
        const c = Ua.element(2).element(2),
          h = Ua.element(3)
            .element(2)
            .mul(-0.5)
            .div(c)
            .sub(a.z)
            .div(l.z.sub(a.z));
        return Tt(_i(a.xyz, l.xyz, h), l.w);
      });
    this.vertexNode = je(() => {
      Da("vec2", "vUv").assign(Ja());
      const a = Ui("instanceStart"),
        l = Ui("instanceEnd"),
        c = di("vec4", "start"),
        u = di("vec4", "end");
      c.assign(Cd.mul(Tt(a, 1))),
        u.assign(Cd.mul(Tt(l, 1))),
        i &&
          (Da("vec3", "worldStart").assign(c.xyz),
          Da("vec3", "worldEnd").assign(u.xyz));
      const d = Eh.z.div(Eh.w),
        h = Ua.element(2).element(3).equal(-1);
      on(h, () => {
        on(c.z.lessThan(0).and(u.z.greaterThan(0)), () => {
          u.assign(s({ start: c, end: u }));
        }).elseif(u.z.lessThan(0).and(c.z.greaterThanEqual(0)), () => {
          c.assign(s({ start: u, end: c }));
        });
      });
      const m = Ua.mul(c),
        g = Ua.mul(u),
        x = m.xyz.div(m.w),
        y = g.xyz.div(g.w),
        v = y.xy.sub(x.xy).temp();
      v.x.assign(v.x.mul(d)), v.assign(v.normalize());
      const _ = Qg(Tt());
      if (i) {
        const S = u.xyz.sub(c.xyz).normalize(),
          w = _i(c.xyz, u.xyz, 0.5).normalize(),
          T = S.cross(w).normalize(),
          E = S.cross(T),
          M = Da("vec4", "worldPos");
        M.assign(ps.y.lessThan(0.5).cond(c, u));
        const N = Tb.mul(0.5);
        M.addAssign(Tt(ps.x.lessThan(0).cond(T.mul(N), T.mul(N).negate()), 0)),
          r ||
            (M.addAssign(
              Tt(ps.y.lessThan(0.5).cond(S.mul(N).negate(), S.mul(N)), 0)
            ),
            M.addAssign(Tt(E.mul(N), 0)),
            on(ps.y.greaterThan(1).or(ps.y.lessThan(0)), () => {
              M.subAssign(Tt(E.mul(2).mul(N), 0));
            })),
          _.assign(Ua.mul(M));
        const R = Qg(_e());
        R.assign(ps.y.lessThan(0.5).cond(x, y)), _.z.assign(R.z.mul(_.w));
      } else {
        const S = di("vec2", "offset");
        S.assign(Ct(v.y, v.x.negate())),
          v.x.assign(v.x.div(d)),
          S.x.assign(S.x.div(d)),
          S.assign(ps.x.lessThan(0).cond(S.negate(), S)),
          on(ps.y.lessThan(0), () => {
            S.assign(S.sub(v));
          }).elseif(ps.y.greaterThan(1), () => {
            S.assign(S.add(v));
          }),
          S.assign(S.mul(Tb)),
          S.assign(S.div(Eh.w)),
          _.assign(ps.y.lessThan(0.5).cond(m, g)),
          S.assign(S.mul(_.w)),
          _.assign(_.add(Tt(S, 0, 0)));
      }
      return _;
    })();
    const o = je(({ p1: a, p2: l, p3: c, p4: u }) => {
      const d = a.sub(c),
        h = u.sub(c),
        m = l.sub(a),
        g = d.dot(h),
        x = h.dot(m),
        y = d.dot(m),
        v = h.dot(h),
        S = m.dot(m).mul(v).sub(x.mul(x)),
        T = g.mul(x).sub(y.mul(v)).div(S).clamp(),
        E = g.add(x.mul(T)).div(v).clamp();
      return Ct(T, E);
    });
    this.fragmentNode = je(() => {
      const a = Da("vec2", "vUv");
      if (r) {
        const u = this.offsetNode ? oe(this.offsetNodeNode) : AD,
          d = this.dashScaleNode ? oe(this.dashScaleNode) : OT,
          h = this.dashSizeNode ? oe(this.dashSizeNode) : _6,
          m = this.dashSizeNode ? oe(this.dashGapNode) : S6;
        bh.assign(h), z1.assign(m);
        const g = Ui("instanceDistanceStart"),
          x = Ui("instanceDistanceEnd"),
          y = ps.y.lessThan(0.5).cond(d.mul(g), OT.mul(x)),
          v = fr(y.add(AD)),
          _ = u ? v.add(u) : v;
        a.y.lessThan(-1).or(a.y.greaterThan(1)).discard(),
          _.mod(bh.add(z1)).greaterThan(bh).discard();
      }
      const l = di("float", "alpha");
      if ((l.assign(1), i)) {
        const u = Da("vec3", "worldStart"),
          d = Da("vec3", "worldEnd"),
          h = Da("vec4", "worldPos").xyz.normalize().mul(1e5),
          m = d.sub(u),
          g = o({ p1: u, p2: d, p3: _e(0, 0, 0), p4: h }),
          x = u.add(m.mul(g.x)),
          y = h.mul(g.y),
          S = x.sub(y).length().div(Tb);
        if (!r)
          if (e) {
            const w = S.fwidth();
            l.assign(Vl(w.negate().add(0.5), w.add(0.5), S).oneMinus());
          } else S.greaterThan(0.5).discard();
      } else if (e) {
        const u = a.x,
          d = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1)),
          h = u.mul(u).add(d.mul(d)),
          m = di("float", "dlen");
        m.assign(h.fwidth()),
          on(a.y.abs().greaterThan(1), () => {
            l.assign(Vl(m.oneMinus(), m.add(1), h).oneMinus());
          });
      } else
        on(a.y.abs().greaterThan(1), () => {
          const u = a.x,
            d = a.y.greaterThan(0).cond(a.y.sub(1), a.y.add(1));
          u.mul(u).add(d.mul(d)).greaterThan(1).discard();
        });
      let c;
      if (this.lineColorNode) c = this.lineColorNode;
      else if (t) {
        const u = Ui("instanceColorStart"),
          d = Ui("instanceColorEnd");
        c = ps.y.lessThan(0.5).cond(u, d).mul(e0);
      } else c = e0;
      return Tt(c, l);
    })();
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(e) {
    this.useWorldUnits !== e &&
      ((this.useWorldUnits = e), (this.needsUpdate = !0));
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(e) {
    this.useDash !== e && ((this.useDash = e), (this.needsUpdate = !0));
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this.useAlphaToCoverage !== e &&
      ((this.useAlphaToCoverage = e), (this.needsUpdate = !0));
  }
}
as("Line2NodeMaterial", qpe);
const Kpe = new w2();
class Zpe extends go {
  constructor(e) {
    super(),
      (this.isMeshNormalNodeMaterial = !0),
      this.setDefaultValues(Kpe),
      this.setValues(e);
  }
  setupDiffuseColor() {
    const e = this.opacityNode ? oe(this.opacityNode) : x6;
    er.assign(Tt(n8(hr), e));
  }
}
as("MeshNormalNodeMaterial", Zpe);
const Qpe = new Za();
class Jpe extends go {
  constructor(e) {
    super(),
      (this.isMeshBasicNodeMaterial = !0),
      (this.lights = !1),
      this.setDefaultValues(Qpe),
      this.setValues(e);
  }
}
as("MeshBasicNodeMaterial", Jpe);
const n0 = je(({ f0: n, f90: e, dotVH: t }) => {
    const r = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
    return n.mul(r.oneMinus()).add(e.mul(r));
  }),
  j1 = je((n) => n.diffuseColor.mul(1 / Math.PI)),
  eme = () => oe(0.25),
  tme = je(({ dotNH: n }) =>
    RT.mul(oe(0.5))
      .add(1)
      .mul(oe(1 / Math.PI))
      .mul(n.pow(RT))
  ),
  nme = je(({ lightDirection: n }) => {
    const e = n.add(tr).normalize(),
      t = hr.dot(e).clamp(),
      r = tr.dot(e).clamp(),
      i = n0({ f0: sa, f90: 1, dotVH: r }),
      s = eme(),
      o = tme({ dotNH: t });
    return i.mul(s).mul(o);
  });
class k8 extends RR {
  constructor(e = !0) {
    super(), (this.specular = e);
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = hr.dot(e).clamp().mul(t);
    r.directDiffuse.addAssign(s.mul(j1({ diffuseColor: er.rgb }))),
      this.specular === !0 &&
        r.directSpecular.addAssign(s.mul(nme({ lightDirection: e })).mul(Efe));
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(j1({ diffuseColor: er })));
  }
}
const rme = new b2();
class ime extends go {
  constructor(e) {
    super(),
      (this.isMeshLambertNodeMaterial = !0),
      (this.lights = !0),
      this.setDefaultValues(rme),
      this.setValues(e);
  }
  setupLightingModel() {
    return new k8(!1);
  }
}
as("MeshLambertNodeMaterial", ime);
const sme = new A2();
class ome extends go {
  constructor(e) {
    super(),
      (this.isMeshPhongNodeMaterial = !0),
      (this.lights = !0),
      (this.shininessNode = null),
      (this.specularNode = null),
      this.setDefaultValues(sme),
      this.setValues(e);
  }
  setupLightingModel() {
    return new k8();
  }
  setupVariants() {
    const e = (this.shininessNode ? oe(this.shininessNode) : Sfe).max(1e-4);
    RT.assign(e);
    const t = this.specularNode || wfe;
    sa.assign(t);
  }
  copy(e) {
    return (
      (this.shininessNode = e.shininessNode),
      (this.specularNode = e.specularNode),
      super.copy(e)
    );
  }
}
as("MeshPhongNodeMaterial", ome);
const ame = je(() => {
    const n = B1.dFdx().abs().max(B1.dFdy().abs());
    return n.x.max(n.y).max(n.z);
  }),
  lme = je((n) => {
    const { roughness: e } = n,
      t = ame();
    let r = e.max(0.0525);
    return (r = r.add(t)), (r = r.min(1)), r;
  }),
  cme = je(({ alpha: n, dotNL: e, dotNV: t }) => {
    const r = n.pow2(),
      i = e.mul(r.add(r.oneMinus().mul(t.pow2())).sqrt()),
      s = t.mul(r.add(r.oneMinus().mul(e.pow2())).sqrt());
    return $c(0.5, i.add(s).max(JV));
  }).setLayout({
    name: "V_GGX_SmithCorrelated",
    type: "float",
    inputs: [
      { name: "alpha", type: "float" },
      { name: "dotNL", type: "float" },
      { name: "dotNV", type: "float" },
    ],
  }),
  ume = je(
    ({
      alphaT: n,
      alphaB: e,
      dotTV: t,
      dotBV: r,
      dotTL: i,
      dotBL: s,
      dotNV: o,
      dotNL: a,
    }) => {
      const l = a.mul(_e(n.mul(t), e.mul(r), o).length()),
        c = o.mul(_e(n.mul(i), e.mul(s), a).length());
      return $c(0.5, l.add(c)).saturate();
    }
  ).setLayout({
    name: "V_GGX_SmithCorrelated_Anisotropic",
    type: "float",
    inputs: [
      { name: "alphaT", type: "float", qualifier: "in" },
      { name: "alphaB", type: "float", qualifier: "in" },
      { name: "dotTV", type: "float", qualifier: "in" },
      { name: "dotBV", type: "float", qualifier: "in" },
      { name: "dotTL", type: "float", qualifier: "in" },
      { name: "dotBL", type: "float", qualifier: "in" },
      { name: "dotNV", type: "float", qualifier: "in" },
      { name: "dotNL", type: "float", qualifier: "in" },
    ],
  }),
  dme = je(({ alpha: n, dotNH: e }) => {
    const t = n.pow2(),
      r = e.pow2().mul(t.oneMinus()).oneMinus();
    return t.div(r.pow2()).mul(1 / Math.PI);
  }).setLayout({
    name: "D_GGX",
    type: "float",
    inputs: [
      { name: "alpha", type: "float" },
      { name: "dotNH", type: "float" },
    ],
  }),
  fme = oe(1 / Math.PI),
  hme = je(({ alphaT: n, alphaB: e, dotNH: t, dotTH: r, dotBH: i }) => {
    const s = n.mul(e),
      o = _e(e.mul(r), n.mul(i), s.mul(t)),
      a = o.dot(o),
      l = s.div(a);
    return fme.mul(s.mul(l.pow2()));
  }).setLayout({
    name: "D_GGX_Anisotropic",
    type: "float",
    inputs: [
      { name: "alphaT", type: "float", qualifier: "in" },
      { name: "alphaB", type: "float", qualifier: "in" },
      { name: "dotNH", type: "float", qualifier: "in" },
      { name: "dotTH", type: "float", qualifier: "in" },
      { name: "dotBH", type: "float", qualifier: "in" },
    ],
  }),
  HD = je((n) => {
    const {
        lightDirection: e,
        f0: t,
        f90: r,
        roughness: i,
        f: s,
        USE_IRIDESCENCE: o,
        USE_ANISOTROPY: a,
      } = n,
      l = n.normalView || hr,
      c = i.pow2(),
      u = e.add(tr).normalize(),
      d = l.dot(e).clamp(),
      h = l.dot(tr).clamp(),
      m = l.dot(u).clamp(),
      g = tr.dot(u).clamp();
    let x = n0({ f0: t, f90: r, dotVH: g }),
      y,
      v;
    if ((gD(o) && (x = PR.mix(x, s)), gD(a))) {
      const _ = Fx.dot(e),
        S = Fx.dot(tr),
        w = Fx.dot(u),
        T = wh.dot(e),
        E = wh.dot(tr),
        M = wh.dot(u);
      (y = ume({
        alphaT: CT,
        alphaB: c,
        dotTV: S,
        dotBV: E,
        dotTL: _,
        dotBL: T,
        dotNV: h,
        dotNL: d,
      })),
        (v = hme({ alphaT: CT, alphaB: c, dotNH: m, dotTH: w, dotBH: M }));
    } else
      (y = cme({ alpha: c, dotNL: d, dotNV: h })),
        (v = dme({ alpha: c, dotNH: m }));
    return x.mul(y).mul(v);
  }),
  z8 = je(({ roughness: n, dotNV: e }) => {
    const t = Tt(-1, -0.0275, -0.572, 0.022),
      r = Tt(1, 0.0425, 1.04, -0.04),
      i = n.mul(t).add(r),
      s = i.x.mul(i.x).min(e.mul(-9.28).exp2()).mul(i.x).add(i.y);
    return Ct(-1.04, 1.04).mul(s).add(i.zw);
  }).setLayout({
    name: "DFGApprox",
    type: "vec2",
    inputs: [
      { name: "roughness", type: "float" },
      { name: "dotNV", type: "vec3" },
    ],
  }),
  B8 = je((n) => {
    const { dotNV: e, specularColor: t, specularF90: r, roughness: i } = n,
      s = z8({ dotNV: e, roughness: i });
    return t.mul(s.x).add(r.mul(s.y));
  }),
  pme = je(({ f: n, f90: e, dotVH: t }) => {
    const r = t.oneMinus().saturate(),
      i = r.mul(r),
      s = r.mul(i, i).clamp(0, 0.9999);
    return n.sub(_e(e).mul(s)).div(s.oneMinus());
  }).setLayout({
    name: "Schlick_to_F0",
    type: "vec3",
    inputs: [
      { name: "f", type: "vec3" },
      { name: "f90", type: "float" },
      { name: "dotVH", type: "float" },
    ],
  }),
  mme = je(({ roughness: n, dotNH: e }) => {
    const t = n.pow2(),
      r = oe(1).div(t),
      s = e.pow2().oneMinus().max(0.0078125);
    return oe(2)
      .add(r)
      .mul(s.pow(r.mul(0.5)))
      .div(2 * Math.PI);
  }).setLayout({
    name: "D_Charlie",
    type: "float",
    inputs: [
      { name: "roughness", type: "float" },
      { name: "dotNH", type: "float" },
    ],
  }),
  gme = je(({ dotNV: n, dotNL: e }) =>
    oe(1).div(oe(4).mul(e.add(n).sub(e.mul(n))))
  ).setLayout({
    name: "V_Neubelt",
    type: "float",
    inputs: [
      { name: "dotNV", type: "float" },
      { name: "dotNL", type: "float" },
    ],
  }),
  vme = je(({ lightDirection: n }) => {
    const e = n.add(tr).normalize(),
      t = hr.dot(n).clamp(),
      r = hr.dot(tr).clamp(),
      i = hr.dot(e).clamp(),
      s = mme({ roughness: NR, dotNH: i }),
      o = gme({ dotNV: r, dotNL: t });
    return ch.mul(s).mul(o);
  }),
  yme = je(([n, e, t, r, i]) => {
    const s = _e(a6(e.negate(), ns(n), $c(1, r))),
      o = _e(tg(i[0].xyz), tg(i[1].xyz), tg(i[2].xyz));
    return ns(s).mul(t.mul(o));
  }).setLayout({
    name: "getVolumeTransmissionRay",
    type: "vec3",
    inputs: [
      { name: "n", type: "vec3" },
      { name: "v", type: "vec3" },
      { name: "thickness", type: "float" },
      { name: "ior", type: "float" },
      { name: "modelMatrix", type: "mat4" },
    ],
  }),
  xme = je(([n, e]) => n.mul(Zh(e.mul(2).sub(2), 0, 1))).setLayout({
    name: "applyIorToRoughness",
    type: "float",
    inputs: [
      { name: "roughness", type: "float" },
      { name: "ior", type: "float" },
    ],
  }),
  _me = z6(),
  Sme = je(([n, e, t]) => {
    const r = _me.uv(n),
      i = SS(oe(kT.x)).mul(xme(e, t));
    return r.bicubic(i);
  }),
  Ame = je(
    ([n, e, t]) => (
      on(t.notEqual(0), () => {
        const r = n6(e).negate().div(t);
        return t6(r.negate().mul(n));
      }),
      _e(1)
    )
  ).setLayout({
    name: "volumeAttenuation",
    type: "vec3",
    inputs: [
      { name: "transmissionDistance", type: "float" },
      { name: "attenuationColor", type: "vec3" },
      { name: "attenuationDistance", type: "float" },
    ],
  }),
  wme = je(([n, e, t, r, i, s, o, a, l, c, u, d, h, m]) => {
    const g = yme(n, e, d, u, a),
      x = o.add(g),
      y = c.mul(l.mul(Tt(x, 1))),
      v = Ct(y.xy.div(y.w)).toVar();
    v.addAssign(1), v.divAssign(2), v.assign(Ct(v.x, v.y.oneMinus()));
    const _ = Sme(v, t, u),
      S = r.mul(Ame(tg(g), h, m)),
      w = S.rgb.mul(_.rgb),
      T = n.dot(e).clamp(),
      E = _e(B8({ dotNV: T, specularColor: i, specularF90: s, roughness: t })),
      M = S.r.add(S.g, S.b).div(3);
    return Tt(E.oneMinus().mul(w), _.a.oneMinus().mul(M).oneMinus());
  }),
  bme = ya(
    3.2404542,
    -0.969266,
    0.0556434,
    -1.5371385,
    1.8760108,
    -0.2040259,
    -0.4985314,
    0.041556,
    1.0572252
  ),
  Eme = (n) => {
    const e = n.sqrt();
    return _e(1).add(e).div(_e(1).sub(e));
  },
  GD = (n, e) => n.sub(e).div(n.add(e)).pow2(),
  Mme = (n, e) => {
    const t = n.mul(2 * Math.PI * 1e-9),
      r = _e(54856e-17, 44201e-17, 52481e-17),
      i = _e(1681e3, 1795300, 2208400),
      s = _e(43278e5, 93046e5, 66121e5),
      o = oe(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5))
        .mul(t.mul(2239900).add(e.x).cos())
        .mul(t.pow2().mul(-45282e5).exp());
    let a = r
      .mul(s.mul(2 * Math.PI).sqrt())
      .mul(i.mul(t).add(e).cos())
      .mul(t.pow2().negate().mul(s).exp());
    return (a = _e(a.x.add(o), a.y, a.z).div(10685e-11)), bme.mul(a);
  },
  Tme = je(
    ({
      outsideIOR: n,
      eta2: e,
      cosTheta1: t,
      thinFilmThickness: r,
      baseF0: i,
    }) => {
      const s = _i(n, e, Vl(0, 0.03, r)),
        o = n.div(s).pow2().mul(oe(1).sub(t.pow2())),
        l = oe(1).sub(o).sqrt(),
        c = GD(s, n),
        u = n0({ f0: c, f90: 1, dotVH: t }),
        d = u.oneMinus(),
        h = s.lessThan(n).cond(Math.PI, 0),
        m = oe(Math.PI).sub(h),
        g = Eme(i.clamp(0, 0.9999)),
        x = GD(g, s.vec3()),
        y = n0({ f0: x, f90: 1, dotVH: l }),
        v = _e(
          g.x.lessThan(s).cond(Math.PI, 0),
          g.y.lessThan(s).cond(Math.PI, 0),
          g.z.lessThan(s).cond(Math.PI, 0)
        ),
        _ = s.mul(r, l, 2),
        S = _e(m).add(v),
        w = u.mul(y).clamp(1e-5, 0.9999),
        T = w.sqrt(),
        E = d.pow2().mul(y).div(_e(1).sub(w));
      let N = u.add(E),
        R = E.sub(d);
      for (let C = 1; C <= 2; ++C) {
        R = R.mul(T);
        const L = Mme(oe(C).mul(_), oe(C).mul(S)).mul(2);
        N = N.add(R.mul(L));
      }
      return N.max(_e(0));
    }
  ).setLayout({
    name: "evalIridescence",
    type: "vec3",
    inputs: [
      { name: "outsideIOR", type: "float" },
      { name: "eta2", type: "float" },
      { name: "cosTheta1", type: "float" },
      { name: "thinFilmThickness", type: "float" },
      { name: "baseF0", type: "vec3" },
    ],
  }),
  Cme = je(({ normal: n, viewDir: e, roughness: t }) => {
    const r = n.dot(e).saturate(),
      i = t.pow2(),
      s = no(
        t.lessThan(0.25),
        oe(-339.2).mul(i).add(oe(161.4).mul(t)).sub(25.9),
        oe(-8.48).mul(i).add(oe(14.3).mul(t)).sub(9.95)
      ),
      o = no(
        t.lessThan(0.25),
        oe(44).mul(i).sub(oe(23.7).mul(t)).add(3.26),
        oe(1.97).mul(i).sub(oe(3.27).mul(t)).add(0.72)
      );
    return no(t.lessThan(0.25), 0, oe(0.1).mul(t).sub(0.025))
      .add(s.mul(r).add(o).exp())
      .mul(1 / Math.PI)
      .saturate();
  }),
  Bb = _e(0.04),
  Vb = _e(1);
class VR extends RR {
  constructor(e = !1, t = !1, r = !1, i = !1, s = !1) {
    super(),
      (this.clearcoat = e),
      (this.sheen = t),
      (this.iridescence = r),
      (this.anisotropy = i),
      (this.transmission = s),
      (this.clearcoatRadiance = null),
      (this.clearcoatSpecularDirect = null),
      (this.clearcoatSpecularIndirect = null),
      (this.sheenSpecularDirect = null),
      (this.sheenSpecularIndirect = null),
      (this.iridescenceFresnel = null),
      (this.iridescenceF0 = null);
  }
  start(e) {
    if (
      (this.clearcoat === !0 &&
        ((this.clearcoatRadiance = _e().temp("clearcoatRadiance")),
        (this.clearcoatSpecularDirect = _e().temp("clearcoatSpecularDirect")),
        (this.clearcoatSpecularIndirect = _e().temp(
          "clearcoatSpecularIndirect"
        ))),
      this.sheen === !0 &&
        ((this.sheenSpecularDirect = _e().temp("sheenSpecularDirect")),
        (this.sheenSpecularIndirect = _e().temp("sheenSpecularIndirect"))),
      this.iridescence === !0)
    ) {
      const t = hr.dot(tr).clamp();
      (this.iridescenceFresnel = Tme({
        outsideIOR: oe(1),
        eta2: WV,
        cosTheta1: t,
        thinFilmThickness: jV,
        baseF0: sa,
      })),
        (this.iridescenceF0 = pme({
          f: this.iridescenceFresnel,
          f90: 1,
          dotVH: t,
        }));
    }
    if (this.transmission === !0) {
      const t = DT,
        r = xfe.sub(DT).normalize(),
        i = y6;
      (e.backdrop = wme(i, r, Mc, er, sa, k1, t, Jg, $l, Ua, Ux, $V, YV, XV)),
        (e.backdropAlpha = NT),
        er.a.mulAssign(_i(1, e.backdrop.a, NT));
    }
  }
  computeMultiscattering(e, t, r) {
    const i = hr.dot(tr).clamp(),
      s = z8({ roughness: Mc, dotNV: i }),
      a = (this.iridescenceF0 ? PR.mix(sa, this.iridescenceF0) : sa)
        .mul(s.x)
        .add(r.mul(s.y)),
      c = s.x.add(s.y).oneMinus(),
      u = sa.add(sa.oneMinus().mul(0.047619)),
      d = a.mul(u).div(c.mul(u).oneMinus());
    e.addAssign(a), t.addAssign(d.mul(c));
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }) {
    const s = hr.dot(e).clamp().mul(t);
    if (
      (this.sheen === !0 &&
        this.sheenSpecularDirect.addAssign(s.mul(vme({ lightDirection: e }))),
      this.clearcoat === !0)
    ) {
      const a = uh.dot(e).clamp().mul(t);
      this.clearcoatSpecularDirect.addAssign(
        a.mul(
          HD({
            lightDirection: e,
            f0: Bb,
            f90: Vb,
            roughness: U1,
            normalView: uh,
          })
        )
      );
    }
    r.directDiffuse.addAssign(s.mul(j1({ diffuseColor: er.rgb }))),
      r.directSpecular.addAssign(
        s.mul(
          HD({
            lightDirection: e,
            f0: sa,
            f90: 1,
            roughness: Mc,
            iridescence: this.iridescence,
            f: this.iridescenceFresnel,
            USE_IRIDESCENCE: this.iridescence,
            USE_ANISOTROPY: this.anisotropy,
          })
        )
      );
  }
  indirectDiffuse({ irradiance: e, reflectedLight: t }) {
    t.indirectDiffuse.addAssign(e.mul(j1({ diffuseColor: er })));
  }
  indirectSpecular({ radiance: e, iblIrradiance: t, reflectedLight: r }) {
    if (
      (this.sheen === !0 &&
        this.sheenSpecularIndirect.addAssign(
          t.mul(ch, Cme({ normal: hr, viewDir: tr, roughness: NR }))
        ),
      this.clearcoat === !0)
    ) {
      const c = uh.dot(tr).clamp(),
        u = B8({ dotNV: c, specularColor: Bb, specularF90: Vb, roughness: U1 });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(u));
    }
    const i = _e().temp("singleScattering"),
      s = _e().temp("multiScattering"),
      o = t.mul(1 / Math.PI);
    this.computeMultiscattering(i, s, k1);
    const a = i.add(s),
      l = er.mul(a.r.max(a.g).max(a.b).oneMinus());
    r.indirectSpecular.addAssign(e.mul(i)),
      r.indirectSpecular.addAssign(s.mul(o)),
      r.indirectDiffuse.addAssign(l.mul(o));
  }
  ambientOcclusion({ ambientOcclusion: e, reflectedLight: t }) {
    const i = hr.dot(tr).clamp().add(e),
      s = Mc.mul(-16).oneMinus().negate().exp2(),
      o = e.sub(i.pow(s).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(e),
      this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(e),
      t.indirectDiffuse.mulAssign(e),
      t.indirectSpecular.mulAssign(o);
  }
  finish(e) {
    const { outgoingLight: t } = e;
    if (this.clearcoat === !0) {
      const r = uh.dot(tr).clamp(),
        i = n0({ dotVH: r, f0: Bb, f90: Vb }),
        s = t
          .mul(TT.mul(i).oneMinus())
          .add(
            this.clearcoatSpecularDirect
              .add(this.clearcoatSpecularIndirect)
              .mul(TT)
          );
      t.assign(s);
    }
    if (this.sheen === !0) {
      const r = ch.r.max(ch.g).max(ch.b).mul(0.157).oneMinus(),
        i = t.mul(r).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      t.assign(i);
    }
  }
}
const Rme = new k_();
class V8 extends go {
  constructor(e) {
    super(),
      (this.isMeshStandardNodeMaterial = !0),
      (this.emissiveNode = null),
      (this.metalnessNode = null),
      (this.roughnessNode = null),
      this.setDefaultValues(Rme),
      this.setValues(e);
  }
  setupLightingModel() {
    return new VR();
  }
  setupSpecular() {
    const e = _i(_e(0.04), er.rgb, F1);
    sa.assign(e), k1.assign(1);
  }
  setupVariants() {
    const e = this.metalnessNode ? oe(this.metalnessNode) : Tfe;
    F1.assign(e);
    let t = this.roughnessNode ? oe(this.roughnessNode) : Mfe;
    (t = lme({ roughness: t })),
      Mc.assign(t),
      this.setupSpecular(),
      er.assign(Tt(er.rgb.mul(e.oneMinus()), er.a));
  }
  copy(e) {
    return (
      (this.emissiveNode = e.emissiveNode),
      (this.metalnessNode = e.metalnessNode),
      (this.roughnessNode = e.roughnessNode),
      super.copy(e)
    );
  }
}
as("MeshStandardNodeMaterial", V8);
const Nme = new S2();
class H8 extends V8 {
  constructor(e) {
    super(),
      (this.isMeshPhysicalNodeMaterial = !0),
      (this.clearcoatNode = null),
      (this.clearcoatRoughnessNode = null),
      (this.clearcoatNormalNode = null),
      (this.sheenNode = null),
      (this.sheenRoughnessNode = null),
      (this.iridescenceNode = null),
      (this.iridescenceIORNode = null),
      (this.iridescenceThicknessNode = null),
      (this.specularIntensityNode = null),
      (this.specularColorNode = null),
      (this.iorNode = null),
      (this.transmissionNode = null),
      (this.thicknessNode = null),
      (this.attenuationDistanceNode = null),
      (this.attenuationColorNode = null),
      (this.anisotropyNode = null),
      this.setDefaultValues(Nme),
      this.setValues(e);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  setupSpecular() {
    const e = this.iorNode ? oe(this.iorNode) : Vfe;
    Ux.assign(e),
      sa.assign(
        _i(Kh(o6(Ux.sub(1).div(Ux.add(1))).mul(bfe), _e(1)).mul(SD), er.rgb, F1)
      ),
      k1.assign(_i(SD, 1, F1));
  }
  setupLightingModel() {
    return new VR(
      this.useClearcoat,
      this.useSheen,
      this.useIridescence,
      this.useAnisotropy,
      this.useTransmission
    );
  }
  setupVariants(e) {
    if ((super.setupVariants(e), this.useClearcoat)) {
      const t = this.clearcoatNode ? oe(this.clearcoatNode) : Rfe,
        r = this.clearcoatRoughnessNode ? oe(this.clearcoatRoughnessNode) : Nfe;
      TT.assign(t), U1.assign(r);
    }
    if (this.useSheen) {
      const t = this.sheenNode ? _e(this.sheenNode) : Lfe,
        r = this.sheenRoughnessNode ? oe(this.sheenRoughnessNode) : Ofe;
      ch.assign(t), NR.assign(r);
    }
    if (this.useIridescence) {
      const t = this.iridescenceNode ? oe(this.iridescenceNode) : Ffe,
        r = this.iridescenceIORNode ? oe(this.iridescenceIORNode) : Ufe,
        i = this.iridescenceThicknessNode
          ? oe(this.iridescenceThicknessNode)
          : kfe;
      PR.assign(t), WV.assign(r), jV.assign(i);
    }
    if (this.useAnisotropy) {
      const t = (this.anisotropyNode ? Ct(this.anisotropyNode) : Dfe).toVar();
      zu.assign(t.length()),
        on(zu.equal(0), () => {
          t.assign(Ct(1, 0));
        }).else(() => {
          t.divAssign(zu), zu.assign(zu.saturate());
        }),
        CT.assign(zu.pow2().mix(Mc.pow2(), 1)),
        Fx.assign(dh[0].mul(t.x).add(dh[1].mul(t.y))),
        wh.assign(dh[1].mul(t.x).sub(dh[0].mul(t.y)));
    }
    if (this.useTransmission) {
      const t = this.transmissionNode ? oe(this.transmissionNode) : zfe,
        r = this.thicknessNode ? oe(this.thicknessNode) : Bfe,
        i = this.attenuationDistanceNode
          ? oe(this.attenuationDistanceNode)
          : Hfe,
        s = this.attenuationColorNode ? _e(this.attenuationColorNode) : Gfe;
      NT.assign(t), $V.assign(r), XV.assign(i), YV.assign(s);
    }
  }
  setupNormal(e) {
    super.setupNormal(e);
    const t = this.clearcoatNormalNode ? _e(this.clearcoatNormalNode) : Pfe;
    uh.assign(t);
  }
  copy(e) {
    return (
      (this.clearcoatNode = e.clearcoatNode),
      (this.clearcoatRoughnessNode = e.clearcoatRoughnessNode),
      (this.clearcoatNormalNode = e.clearcoatNormalNode),
      (this.sheenNode = e.sheenNode),
      (this.sheenRoughnessNode = e.sheenRoughnessNode),
      (this.iridescenceNode = e.iridescenceNode),
      (this.iridescenceIORNode = e.iridescenceIORNode),
      (this.iridescenceThicknessNode = e.iridescenceThicknessNode),
      (this.specularIntensityNode = e.specularIntensityNode),
      (this.specularColorNode = e.specularColorNode),
      (this.transmissionNode = e.transmissionNode),
      (this.thicknessNode = e.thicknessNode),
      (this.attenuationDistanceNode = e.attenuationDistanceNode),
      (this.attenuationColorNode = e.attenuationColorNode),
      (this.anisotropyNode = e.anisotropyNode),
      super.copy(e)
    );
  }
}
as("MeshPhysicalNodeMaterial", H8);
class Pme extends VR {
  constructor(e, t, r, i) {
    super(e, t, r), (this.useSSS = i);
  }
  direct({ lightDirection: e, lightColor: t, reflectedLight: r }, i, s) {
    if (this.useSSS === !0) {
      const o = s.material,
        {
          thicknessColorNode: a,
          thicknessDistortionNode: l,
          thicknessAmbientNode: c,
          thicknessAttenuationNode: u,
          thicknessPowerNode: d,
          thicknessScaleNode: h,
        } = o,
        m = e.add(hr.mul(l)).normalize(),
        g = oe(tr.dot(m.negate()).saturate().pow(d).mul(h)),
        x = _e(g.add(c).mul(a));
      r.directDiffuse.addAssign(x.mul(u.mul(t)));
    }
    super.direct({ lightDirection: e, lightColor: t, reflectedLight: r }, i, s);
  }
}
class Ime extends H8 {
  constructor(e) {
    super(e),
      (this.thicknessColorNode = null),
      (this.thicknessDistortionNode = oe(0.1)),
      (this.thicknessAmbientNode = oe(0)),
      (this.thicknessAttenuationNode = oe(0.1)),
      (this.thicknessPowerNode = oe(2)),
      (this.thicknessScaleNode = oe(10));
  }
  get useSSS() {
    return this.thicknessColorNode !== null;
  }
  setupLightingModel() {
    return new Pme(
      this.useClearcoat,
      this.useSheen,
      this.useIridescence,
      this.useSSS
    );
  }
  copy(e) {
    return (
      (this.thicknessColorNode = e.thicknessColorNode),
      (this.thicknessDistortionNode = e.thicknessDistortionNode),
      (this.thicknessAmbientNode = e.thicknessAmbientNode),
      (this.thicknessAttenuationNode = e.thicknessAttenuationNode),
      (this.thicknessPowerNode = e.thicknessPowerNode),
      (this.thicknessScaleNode = e.thicknessScaleNode),
      super.copy(e)
    );
  }
}
as("MeshSSSNodeMaterial", Ime);
const Lme = new v0();
class Ome extends go {
  constructor(e) {
    super(),
      (this.isPointsNodeMaterial = !0),
      (this.lights = !1),
      (this.normals = !1),
      (this.transparent = !0),
      (this.sizeNode = null),
      this.setDefaultValues(Lme),
      this.setValues(e);
  }
  copy(e) {
    return (this.sizeNode = e.sizeNode), super.copy(e);
  }
}
as("PointsNodeMaterial", Ome);
const Dme = new S_();
class Fme extends go {
  constructor(e) {
    super(),
      (this.isSpriteNodeMaterial = !0),
      (this.lights = !1),
      (this.normals = !1),
      (this.positionNode = null),
      (this.rotationNode = null),
      (this.scaleNode = null),
      this.setDefaultValues(Dme),
      this.setValues(e);
  }
  setupPosition({ object: e, context: t }) {
    const { positionNode: r, rotationNode: i, scaleNode: s } = this,
      o = Bi;
    let a = Cd.mul(_e(r || 0)),
      l = Ct(Jg[0].xyz.length(), Jg[1].xyz.length());
    s !== null && (l = l.mul(s));
    let c = o.xy;
    e.center && e.center.isVector2 === !0 && (c = c.sub(Dn(e.center).sub(0.5))),
      (c = c.mul(l));
    const u = oe(i || Ife),
      d = c.rotate(u);
    a = Tt(a.xy.add(d), a.zw);
    const h = Ua.mul(a);
    return (t.vertex = o), h;
  }
  copy(e) {
    return (
      (this.positionNode = e.positionNode),
      (this.rotationNode = e.rotationNode),
      (this.scaleNode = e.scaleNode),
      super.copy(e)
    );
  }
}
as("SpriteNodeMaterial", Fme);
class Ume extends RR {
  constructor() {
    super(), (this.shadowNode = oe(1).toVar("shadowMask"));
  }
  direct({ shadowMask: e }) {
    this.shadowNode.mulAssign(e);
  }
  finish(e) {
    er.a.mulAssign(this.shadowNode.oneMinus()),
      e.outgoingLight.rgb.assign(er.rgb);
  }
}
const kme = new _2();
class zme extends go {
  constructor(e) {
    super(),
      (this.isShadowNodeMaterial = !0),
      (this.lights = !0),
      this.setDefaultValues(kme),
      this.setValues(e);
  }
  setupLightingModel() {
    return new Ume();
  }
}
as("ShadowNodeMaterial", zme);
const Bme = cp.createMaterialFromType;
cp.createMaterialFromType = function (n) {
  const e = $6(n);
  return e !== void 0 ? e : Bme.call(this, n);
};
const Mh = je(([n, e, t]) => {
    const r = oe(t).toVar(),
      i = oe(e).toVar(),
      s = Td(n).toVar();
    return no(s, i, r);
  }),
  r0 = je(([n, e]) => {
    const t = Td(e).toVar(),
      r = oe(n).toVar();
    return no(t, r.negate(), r);
  }),
  pr = je(([n]) => {
    const e = oe(n).toVar();
    return ce(yp(e));
  }),
  Wn = je(([n, e]) => {
    const t = oe(n).toVar();
    return e.assign(pr(t)), t.sub(oe(e));
  }),
  G8 = je(([n, e, t, r, i, s]) => {
    const o = oe(s).toVar(),
      a = oe(i).toVar(),
      l = oe(r).toVar(),
      c = oe(t).toVar(),
      u = oe(e).toVar(),
      d = oe(n).toVar(),
      h = oe(Mr(1, a)).toVar();
    return Mr(1, o)
      .mul(d.mul(h).add(u.mul(a)))
      .add(o.mul(c.mul(h).add(l.mul(a))));
  }),
  W8 = je(([n, e, t, r, i, s]) => {
    const o = oe(s).toVar(),
      a = oe(i).toVar(),
      l = _e(r).toVar(),
      c = _e(t).toVar(),
      u = _e(e).toVar(),
      d = _e(n).toVar(),
      h = oe(Mr(1, a)).toVar();
    return Mr(1, o)
      .mul(d.mul(h).add(u.mul(a)))
      .add(o.mul(c.mul(h).add(l.mul(a))));
  }),
  j8 = $o([G8, W8]),
  $8 = je(([n, e, t, r, i, s, o, a, l, c, u]) => {
    const d = oe(u).toVar(),
      h = oe(c).toVar(),
      m = oe(l).toVar(),
      g = oe(a).toVar(),
      x = oe(o).toVar(),
      y = oe(s).toVar(),
      v = oe(i).toVar(),
      _ = oe(r).toVar(),
      S = oe(t).toVar(),
      w = oe(e).toVar(),
      T = oe(n).toVar(),
      E = oe(Mr(1, m)).toVar(),
      M = oe(Mr(1, h)).toVar();
    return oe(Mr(1, d))
      .toVar()
      .mul(M.mul(T.mul(E).add(w.mul(m))).add(h.mul(S.mul(E).add(_.mul(m)))))
      .add(
        d.mul(M.mul(v.mul(E).add(y.mul(m))).add(h.mul(x.mul(E).add(g.mul(m)))))
      );
  }),
  X8 = je(([n, e, t, r, i, s, o, a, l, c, u]) => {
    const d = oe(u).toVar(),
      h = oe(c).toVar(),
      m = oe(l).toVar(),
      g = _e(a).toVar(),
      x = _e(o).toVar(),
      y = _e(s).toVar(),
      v = _e(i).toVar(),
      _ = _e(r).toVar(),
      S = _e(t).toVar(),
      w = _e(e).toVar(),
      T = _e(n).toVar(),
      E = oe(Mr(1, m)).toVar(),
      M = oe(Mr(1, h)).toVar();
    return oe(Mr(1, d))
      .toVar()
      .mul(M.mul(T.mul(E).add(w.mul(m))).add(h.mul(S.mul(E).add(_.mul(m)))))
      .add(
        d.mul(M.mul(v.mul(E).add(y.mul(m))).add(h.mul(x.mul(E).add(g.mul(m)))))
      );
  }),
  Y8 = $o([$8, X8]),
  q8 = je(([n, e, t]) => {
    const r = oe(t).toVar(),
      i = oe(e).toVar(),
      s = ut(n).toVar(),
      o = ut(s.bitAnd(ut(7))).toVar(),
      a = oe(Mh(o.lessThan(ut(4)), i, r)).toVar(),
      l = oe(hn(2, Mh(o.lessThan(ut(4)), r, i))).toVar();
    return r0(a, Td(o.bitAnd(ut(1)))).add(r0(l, Td(o.bitAnd(ut(2)))));
  }),
  K8 = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = oe(e).toVar(),
      a = ut(n).toVar(),
      l = ut(a.bitAnd(ut(15))).toVar(),
      c = oe(Mh(l.lessThan(ut(8)), o, s)).toVar(),
      u = oe(
        Mh(l.lessThan(ut(4)), s, Mh(l.equal(ut(12)).or(l.equal(ut(14))), o, i))
      ).toVar();
    return r0(c, Td(l.bitAnd(ut(1)))).add(r0(u, Td(l.bitAnd(ut(2)))));
  }),
  ri = $o([q8, K8]),
  Z8 = je(([n, e, t]) => {
    const r = oe(t).toVar(),
      i = oe(e).toVar(),
      s = R0(n).toVar();
    return _e(ri(s.x, i, r), ri(s.y, i, r), ri(s.z, i, r));
  }),
  Q8 = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = oe(e).toVar(),
      a = R0(n).toVar();
    return _e(ri(a.x, o, s, i), ri(a.y, o, s, i), ri(a.z, o, s, i));
  }),
  Ro = $o([Z8, Q8]),
  J8 = je(([n]) => {
    const e = oe(n).toVar();
    return hn(0.6616, e);
  }),
  eH = je(([n]) => {
    const e = oe(n).toVar();
    return hn(0.982, e);
  }),
  tH = je(([n]) => {
    const e = _e(n).toVar();
    return hn(0.6616, e);
  }),
  nH = $o([J8, tH]),
  rH = je(([n]) => {
    const e = _e(n).toVar();
    return hn(0.982, e);
  }),
  iH = $o([eH, rH]),
  ms = je(([n, e]) => {
    const t = ce(e).toVar(),
      r = ut(n).toVar();
    return r.shiftLeft(t).bitOr(r.shiftRight(ce(32).sub(t)));
  }),
  sH = je(([n, e, t]) => {
    n.subAssign(t),
      n.bitXorAssign(ms(t, ce(4))),
      t.addAssign(e),
      e.subAssign(n),
      e.bitXorAssign(ms(n, ce(6))),
      n.addAssign(t),
      t.subAssign(e),
      t.bitXorAssign(ms(e, ce(8))),
      e.addAssign(n),
      n.subAssign(t),
      n.bitXorAssign(ms(t, ce(16))),
      t.addAssign(e),
      e.subAssign(n),
      e.bitXorAssign(ms(n, ce(19))),
      n.addAssign(t),
      t.subAssign(e),
      t.bitXorAssign(ms(e, ce(4))),
      e.addAssign(n);
  }),
  wp = je(([n, e, t]) => {
    const r = ut(t).toVar(),
      i = ut(e).toVar(),
      s = ut(n).toVar();
    return (
      r.bitXorAssign(i),
      r.subAssign(ms(i, ce(14))),
      s.bitXorAssign(r),
      s.subAssign(ms(r, ce(11))),
      i.bitXorAssign(s),
      i.subAssign(ms(s, ce(25))),
      r.bitXorAssign(i),
      r.subAssign(ms(i, ce(16))),
      s.bitXorAssign(r),
      s.subAssign(ms(r, ce(4))),
      i.bitXorAssign(s),
      i.subAssign(ms(s, ce(14))),
      r.bitXorAssign(i),
      r.subAssign(ms(i, ce(24))),
      r
    );
  }),
  vi = je(([n]) => {
    const e = ut(n).toVar();
    return oe(e).div(oe(ut(ce(4294967295))));
  }),
  ma = je(([n]) => {
    const e = oe(n).toVar();
    return e.mul(e.mul(e.mul(e.mul(e.mul(6).sub(15)).add(10))));
  }),
  oH = je(([n]) => {
    const e = ce(n).toVar(),
      t = ut(ut(1)).toVar(),
      r = ut(ut(ce(3735928559)).add(t.shiftLeft(ut(2)).add(ut(13)))).toVar();
    return wp(r.add(ut(e)), r, r);
  }),
  aH = je(([n, e]) => {
    const t = ce(e).toVar(),
      r = ce(n).toVar(),
      i = ut(ut(2)).toVar(),
      s = ut().toVar(),
      o = ut().toVar(),
      a = ut().toVar();
    return (
      s.assign(
        o.assign(
          a.assign(ut(ce(3735928559)).add(i.shiftLeft(ut(2)).add(ut(13))))
        )
      ),
      s.addAssign(ut(r)),
      o.addAssign(ut(t)),
      wp(s, o, a)
    );
  }),
  lH = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = ce(e).toVar(),
      s = ce(n).toVar(),
      o = ut(ut(3)).toVar(),
      a = ut().toVar(),
      l = ut().toVar(),
      c = ut().toVar();
    return (
      a.assign(
        l.assign(
          c.assign(ut(ce(3735928559)).add(o.shiftLeft(ut(2)).add(ut(13))))
        )
      ),
      a.addAssign(ut(s)),
      l.addAssign(ut(i)),
      c.addAssign(ut(r)),
      wp(a, l, c)
    );
  }),
  cH = je(([n, e, t, r]) => {
    const i = ce(r).toVar(),
      s = ce(t).toVar(),
      o = ce(e).toVar(),
      a = ce(n).toVar(),
      l = ut(ut(4)).toVar(),
      c = ut().toVar(),
      u = ut().toVar(),
      d = ut().toVar();
    return (
      c.assign(
        u.assign(
          d.assign(ut(ce(3735928559)).add(l.shiftLeft(ut(2)).add(ut(13))))
        )
      ),
      c.addAssign(ut(a)),
      u.addAssign(ut(o)),
      d.addAssign(ut(s)),
      sH(c, u, d),
      c.addAssign(ut(i)),
      wp(c, u, d)
    );
  }),
  uH = je(([n, e, t, r, i]) => {
    const s = ce(i).toVar(),
      o = ce(r).toVar(),
      a = ce(t).toVar(),
      l = ce(e).toVar(),
      c = ce(n).toVar(),
      u = ut(ut(5)).toVar(),
      d = ut().toVar(),
      h = ut().toVar(),
      m = ut().toVar();
    return (
      d.assign(
        h.assign(
          m.assign(ut(ce(3735928559)).add(u.shiftLeft(ut(2)).add(ut(13))))
        )
      ),
      d.addAssign(ut(c)),
      h.addAssign(ut(l)),
      m.addAssign(ut(a)),
      sH(d, h, m),
      d.addAssign(ut(o)),
      h.addAssign(ut(s)),
      wp(d, h, m)
    );
  }),
  Sn = $o([oH, aH, lH, cH, uH]),
  dH = je(([n, e]) => {
    const t = ce(e).toVar(),
      r = ce(n).toVar(),
      i = ut(Sn(r, t)).toVar(),
      s = R0().toVar();
    return (
      s.x.assign(i.bitAnd(ce(255))),
      s.y.assign(i.shiftRight(ce(8)).bitAnd(ce(255))),
      s.z.assign(i.shiftRight(ce(16)).bitAnd(ce(255))),
      s
    );
  }),
  fH = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = ce(e).toVar(),
      s = ce(n).toVar(),
      o = ut(Sn(s, i, r)).toVar(),
      a = R0().toVar();
    return (
      a.x.assign(o.bitAnd(ce(255))),
      a.y.assign(o.shiftRight(ce(8)).bitAnd(ce(255))),
      a.z.assign(o.shiftRight(ce(16)).bitAnd(ce(255))),
      a
    );
  }),
  No = $o([dH, fH]),
  hH = je(([n]) => {
    const e = Ct(n).toVar(),
      t = ce().toVar(),
      r = ce().toVar(),
      i = oe(Wn(e.x, t)).toVar(),
      s = oe(Wn(e.y, r)).toVar(),
      o = oe(ma(i)).toVar(),
      a = oe(ma(s)).toVar(),
      l = oe(
        j8(
          ri(Sn(t, r), i, s),
          ri(Sn(t.add(ce(1)), r), i.sub(1), s),
          ri(Sn(t, r.add(ce(1))), i, s.sub(1)),
          ri(Sn(t.add(ce(1)), r.add(ce(1))), i.sub(1), s.sub(1)),
          o,
          a
        )
      ).toVar();
    return nH(l);
  }),
  pH = je(([n]) => {
    const e = _e(n).toVar(),
      t = ce().toVar(),
      r = ce().toVar(),
      i = ce().toVar(),
      s = oe(Wn(e.x, t)).toVar(),
      o = oe(Wn(e.y, r)).toVar(),
      a = oe(Wn(e.z, i)).toVar(),
      l = oe(ma(s)).toVar(),
      c = oe(ma(o)).toVar(),
      u = oe(ma(a)).toVar(),
      d = oe(
        Y8(
          ri(Sn(t, r, i), s, o, a),
          ri(Sn(t.add(ce(1)), r, i), s.sub(1), o, a),
          ri(Sn(t, r.add(ce(1)), i), s, o.sub(1), a),
          ri(Sn(t.add(ce(1)), r.add(ce(1)), i), s.sub(1), o.sub(1), a),
          ri(Sn(t, r, i.add(ce(1))), s, o, a.sub(1)),
          ri(Sn(t.add(ce(1)), r, i.add(ce(1))), s.sub(1), o, a.sub(1)),
          ri(Sn(t, r.add(ce(1)), i.add(ce(1))), s, o.sub(1), a.sub(1)),
          ri(
            Sn(t.add(ce(1)), r.add(ce(1)), i.add(ce(1))),
            s.sub(1),
            o.sub(1),
            a.sub(1)
          ),
          l,
          c,
          u
        )
      ).toVar();
    return iH(d);
  }),
  Vme = $o([hH, pH]),
  mH = je(([n]) => {
    const e = Ct(n).toVar(),
      t = ce().toVar(),
      r = ce().toVar(),
      i = oe(Wn(e.x, t)).toVar(),
      s = oe(Wn(e.y, r)).toVar(),
      o = oe(ma(i)).toVar(),
      a = oe(ma(s)).toVar(),
      l = _e(
        j8(
          Ro(No(t, r), i, s),
          Ro(No(t.add(ce(1)), r), i.sub(1), s),
          Ro(No(t, r.add(ce(1))), i, s.sub(1)),
          Ro(No(t.add(ce(1)), r.add(ce(1))), i.sub(1), s.sub(1)),
          o,
          a
        )
      ).toVar();
    return nH(l);
  }),
  gH = je(([n]) => {
    const e = _e(n).toVar(),
      t = ce().toVar(),
      r = ce().toVar(),
      i = ce().toVar(),
      s = oe(Wn(e.x, t)).toVar(),
      o = oe(Wn(e.y, r)).toVar(),
      a = oe(Wn(e.z, i)).toVar(),
      l = oe(ma(s)).toVar(),
      c = oe(ma(o)).toVar(),
      u = oe(ma(a)).toVar(),
      d = _e(
        Y8(
          Ro(No(t, r, i), s, o, a),
          Ro(No(t.add(ce(1)), r, i), s.sub(1), o, a),
          Ro(No(t, r.add(ce(1)), i), s, o.sub(1), a),
          Ro(No(t.add(ce(1)), r.add(ce(1)), i), s.sub(1), o.sub(1), a),
          Ro(No(t, r, i.add(ce(1))), s, o, a.sub(1)),
          Ro(No(t.add(ce(1)), r, i.add(ce(1))), s.sub(1), o, a.sub(1)),
          Ro(No(t, r.add(ce(1)), i.add(ce(1))), s, o.sub(1), a.sub(1)),
          Ro(
            No(t.add(ce(1)), r.add(ce(1)), i.add(ce(1))),
            s.sub(1),
            o.sub(1),
            a.sub(1)
          ),
          l,
          c,
          u
        )
      ).toVar();
    return iH(d);
  }),
  Hme = $o([mH, gH]),
  Gme = je(([n]) => {
    const e = oe(n).toVar(),
      t = ce(pr(e)).toVar();
    return vi(Sn(t));
  }),
  Wme = je(([n]) => {
    const e = Ct(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar();
    return vi(Sn(t, r));
  }),
  jme = je(([n]) => {
    const e = _e(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar(),
      i = ce(pr(e.z)).toVar();
    return vi(Sn(t, r, i));
  }),
  $me = je(([n]) => {
    const e = Tt(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar(),
      i = ce(pr(e.z)).toVar(),
      s = ce(pr(e.w)).toVar();
    return vi(Sn(t, r, i, s));
  }),
  vH = je(([n]) => {
    const e = oe(n).toVar(),
      t = ce(pr(e)).toVar();
    return _e(vi(Sn(t, ce(0))), vi(Sn(t, ce(1))), vi(Sn(t, ce(2))));
  }),
  yH = je(([n]) => {
    const e = Ct(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar();
    return _e(vi(Sn(t, r, ce(0))), vi(Sn(t, r, ce(1))), vi(Sn(t, r, ce(2))));
  }),
  xH = je(([n]) => {
    const e = _e(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar(),
      i = ce(pr(e.z)).toVar();
    return _e(
      vi(Sn(t, r, i, ce(0))),
      vi(Sn(t, r, i, ce(1))),
      vi(Sn(t, r, i, ce(2)))
    );
  }),
  _H = je(([n]) => {
    const e = Tt(n).toVar(),
      t = ce(pr(e.x)).toVar(),
      r = ce(pr(e.y)).toVar(),
      i = ce(pr(e.z)).toVar(),
      s = ce(pr(e.w)).toVar();
    return _e(
      vi(Sn(t, r, i, s, ce(0))),
      vi(Sn(t, r, i, s, ce(1))),
      vi(Sn(t, r, i, s, ce(2)))
    );
  }),
  SH = $o([vH, yH, xH, _H]),
  $1 = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = ce(e).toVar(),
      a = _e(n).toVar(),
      l = oe(0).toVar(),
      c = oe(1).toVar();
    return (
      Bn({ start: ce(0), end: o }, ({ i: u }) => {
        l.addAssign(c.mul(Vme(a))), c.mulAssign(i), a.mulAssign(s);
      }),
      l
    );
  }),
  AH = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = ce(e).toVar(),
      a = _e(n).toVar(),
      l = _e(0).toVar(),
      c = oe(1).toVar();
    return (
      Bn({ start: ce(0), end: o }, ({ i: u }) => {
        l.addAssign(c.mul(Hme(a))), c.mulAssign(i), a.mulAssign(s);
      }),
      l
    );
  }),
  Xme = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = ce(e).toVar(),
      a = _e(n).toVar();
    return Ct($1(a, o, s, i), $1(a.add(_e(ce(19), ce(193), ce(17))), o, s, i));
  }),
  Yme = je(([n, e, t, r]) => {
    const i = oe(r).toVar(),
      s = oe(t).toVar(),
      o = ce(e).toVar(),
      a = _e(n).toVar(),
      l = _e(AH(a, o, s, i)).toVar(),
      c = oe($1(a.add(_e(ce(19), ce(193), ce(17))), o, s, i)).toVar();
    return Tt(l, c);
  }),
  wH = je(([n, e, t, r, i, s, o]) => {
    const a = ce(o).toVar(),
      l = oe(s).toVar(),
      c = ce(i).toVar(),
      u = ce(r).toVar(),
      d = ce(t).toVar(),
      h = ce(e).toVar(),
      m = Ct(n).toVar(),
      g = _e(SH(Ct(h.add(u), d.add(c)))).toVar(),
      x = Ct(g.x, g.y).toVar();
    x.subAssign(0.5), x.mulAssign(l), x.addAssign(0.5);
    const y = Ct(Ct(oe(h), oe(d)).add(x)).toVar(),
      v = Ct(y.sub(m)).toVar();
    return (
      on(a.equal(ce(2)), () => Ir(v.x).add(Ir(v.y))),
      on(a.equal(ce(3)), () => fo(Ir(v.x), Ir(v.y))),
      xp(v, v)
    );
  }),
  bH = je(([n, e, t, r, i, s, o, a, l]) => {
    const c = ce(l).toVar(),
      u = oe(a).toVar(),
      d = ce(o).toVar(),
      h = ce(s).toVar(),
      m = ce(i).toVar(),
      g = ce(r).toVar(),
      x = ce(t).toVar(),
      y = ce(e).toVar(),
      v = _e(n).toVar(),
      _ = _e(SH(_e(y.add(m), x.add(h), g.add(d)))).toVar();
    _.subAssign(0.5), _.mulAssign(u), _.addAssign(0.5);
    const S = _e(_e(oe(y), oe(x), oe(g)).add(_)).toVar(),
      w = _e(S.sub(v)).toVar();
    return (
      on(c.equal(ce(2)), () => Ir(w.x).add(Ir(w.y).add(Ir(w.z)))),
      on(c.equal(ce(3)), () => fo(fo(Ir(w.x), Ir(w.y)), Ir(w.z))),
      xp(w, w)
    );
  }),
  bp = $o([wH, bH]),
  qme = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = Ct(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = Ct(Wn(s.x, o), Wn(s.y, a)).toVar(),
      c = oe(1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: u }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: d }) => {
            const h = oe(bp(l, u, d, o, a, i, r)).toVar();
            c.assign(Kh(c, h));
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        c.assign(Hd(c));
      }),
      c
    );
  }),
  Kme = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = Ct(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = Ct(Wn(s.x, o), Wn(s.y, a)).toVar(),
      c = Ct(1e6, 1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: u }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: d }) => {
            const h = oe(bp(l, u, d, o, a, i, r)).toVar();
            on(h.lessThan(c.x), () => {
              c.y.assign(c.x), c.x.assign(h);
            }).elseif(h.lessThan(c.y), () => {
              c.y.assign(h);
            });
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        c.assign(Hd(c));
      }),
      c
    );
  }),
  Zme = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = Ct(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = Ct(Wn(s.x, o), Wn(s.y, a)).toVar(),
      c = _e(1e6, 1e6, 1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: u }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: d }) => {
            const h = oe(bp(l, u, d, o, a, i, r)).toVar();
            on(h.lessThan(c.x), () => {
              c.z.assign(c.y), c.y.assign(c.x), c.x.assign(h);
            })
              .elseif(h.lessThan(c.y), () => {
                c.z.assign(c.y), c.y.assign(h);
              })
              .elseif(h.lessThan(c.z), () => {
                c.z.assign(h);
              });
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        c.assign(Hd(c));
      }),
      c
    );
  }),
  Qme = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = _e(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = ce().toVar(),
      c = _e(Wn(s.x, o), Wn(s.y, a), Wn(s.z, l)).toVar(),
      u = oe(1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: d }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: h }) => {
            Bn(
              { start: -1, end: ce(1), name: "z", condition: "<=" },
              ({ z: m }) => {
                const g = oe(bp(c, d, h, m, o, a, l, i, r)).toVar();
                u.assign(Kh(u, g));
              }
            );
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        u.assign(Hd(u));
      }),
      u
    );
  }),
  Jme = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = _e(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = ce().toVar(),
      c = _e(Wn(s.x, o), Wn(s.y, a), Wn(s.z, l)).toVar(),
      u = Ct(1e6, 1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: d }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: h }) => {
            Bn(
              { start: -1, end: ce(1), name: "z", condition: "<=" },
              ({ z: m }) => {
                const g = oe(bp(c, d, h, m, o, a, l, i, r)).toVar();
                on(g.lessThan(u.x), () => {
                  u.y.assign(u.x), u.x.assign(g);
                }).elseif(g.lessThan(u.y), () => {
                  u.y.assign(g);
                });
              }
            );
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        u.assign(Hd(u));
      }),
      u
    );
  }),
  ege = je(([n, e, t]) => {
    const r = ce(t).toVar(),
      i = oe(e).toVar(),
      s = _e(n).toVar(),
      o = ce().toVar(),
      a = ce().toVar(),
      l = ce().toVar(),
      c = _e(Wn(s.x, o), Wn(s.y, a), Wn(s.z, l)).toVar(),
      u = _e(1e6, 1e6, 1e6).toVar();
    return (
      Bn({ start: -1, end: ce(1), name: "x", condition: "<=" }, ({ x: d }) => {
        Bn(
          { start: -1, end: ce(1), name: "y", condition: "<=" },
          ({ y: h }) => {
            Bn(
              { start: -1, end: ce(1), name: "z", condition: "<=" },
              ({ z: m }) => {
                const g = oe(bp(c, d, h, m, o, a, l, i, r)).toVar();
                on(g.lessThan(u.x), () => {
                  u.z.assign(u.y), u.y.assign(u.x), u.x.assign(g);
                })
                  .elseif(g.lessThan(u.y), () => {
                    u.z.assign(u.y), u.y.assign(g);
                  })
                  .elseif(g.lessThan(u.z), () => {
                    u.z.assign(g);
                  });
              }
            );
          }
        );
      }),
      on(r.equal(ce(0)), () => {
        u.assign(Hd(u));
      }),
      u
    );
  });
Mh.setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" },
  ],
});
r0.setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" },
  ],
});
pr.setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [{ name: "x", type: "float" }],
});
G8.setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
  ],
});
W8.setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
  ],
});
$8.setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" },
  ],
});
X8.setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" },
  ],
});
q8.setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
  ],
});
K8.setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" },
  ],
});
Z8.setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
  ],
});
Q8.setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" },
  ],
});
J8.setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [{ name: "v", type: "float" }],
});
eH.setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [{ name: "v", type: "float" }],
});
tH.setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [{ name: "v", type: "vec3" }],
});
rH.setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [{ name: "v", type: "vec3" }],
});
ms.setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" },
  ],
});
wp.setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" },
  ],
});
vi.setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [{ name: "bits", type: "uint" }],
});
ma.setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [{ name: "t", type: "float" }],
});
oH.setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [{ name: "x", type: "int" }],
});
aH.setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
  ],
});
lH.setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
  ],
});
cH.setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
  ],
});
uH.setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" },
  ],
});
dH.setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
  ],
});
fH.setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
  ],
});
hH.setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [{ name: "p", type: "vec2" }],
});
pH.setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [{ name: "p", type: "vec3" }],
});
mH.setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [{ name: "p", type: "vec2" }],
});
gH.setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
Gme.setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [{ name: "p", type: "float" }],
});
Wme.setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [{ name: "p", type: "vec2" }],
});
jme.setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [{ name: "p", type: "vec3" }],
});
$me.setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [{ name: "p", type: "vec4" }],
});
vH.setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [{ name: "p", type: "float" }],
});
yH.setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [{ name: "p", type: "vec2" }],
});
xH.setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [{ name: "p", type: "vec3" }],
});
_H.setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [{ name: "p", type: "vec4" }],
});
$1.setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
AH.setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
Xme.setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
Yme.setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" },
  ],
});
wH.setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
bH.setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
qme.setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
Kme.setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
Zme.setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
Qme.setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
Jme.setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
ege.setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" },
  ],
});
const tge = je(([n]) => {
    const e = _e(n).toVar(),
      t = oe(e.x).toVar(),
      r = oe(e.y).toVar(),
      i = oe(e.z).toVar();
    on(r.lessThan(1e-4), () => _e(i, i, i)).else(() => {
      t.assign(hn(6, t.sub(yp(t))));
      const s = ce(i6(t)).toVar(),
        o = oe(t.sub(oe(s))).toVar(),
        a = oe(i.mul(Mr(1, r))).toVar(),
        l = oe(i.mul(Mr(1, r.mul(o)))).toVar(),
        c = oe(i.mul(Mr(1, r.mul(Mr(1, o))))).toVar();
      return (
        on(s.equal(ce(0)), () => _e(i, c, a))
          .elseif(s.equal(ce(1)), () => _e(l, i, a))
          .elseif(s.equal(ce(2)), () => _e(a, i, c))
          .elseif(s.equal(ce(3)), () => _e(a, l, i))
          .elseif(s.equal(ce(4)), () => _e(c, a, i)),
        _e(i, a, l)
      );
    });
  }),
  nge = je(([n]) => {
    const e = _e(n).toVar(),
      t = oe(e.x).toVar(),
      r = oe(e.y).toVar(),
      i = oe(e.z).toVar(),
      s = oe(Kh(t, Kh(r, i))).toVar(),
      o = oe(fo(t, fo(r, i))).toVar(),
      a = oe(o.sub(s)).toVar(),
      l = oe().toVar(),
      c = oe().toVar(),
      u = oe().toVar();
    return (
      u.assign(o),
      on(o.greaterThan(0), () => {
        c.assign(a.div(o));
      }).else(() => {
        c.assign(0);
      }),
      on(c.lessThanEqual(0), () => {
        l.assign(0);
      }).else(() => {
        on(t.greaterThanEqual(o), () => {
          l.assign(r.sub(i).div(a));
        })
          .elseif(r.greaterThanEqual(o), () => {
            l.assign(uo(2, i.sub(t).div(a)));
          })
          .else(() => {
            l.assign(uo(4, t.sub(r).div(a)));
          }),
          l.mulAssign(1 / 6),
          on(l.lessThan(0), () => {
            l.addAssign(1);
          });
      }),
      _e(l, c, u)
    );
  });
tge.setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [{ name: "hsv", type: "vec3" }],
});
nge.setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [{ name: "c", type: "vec3" }],
});
const rge = je(([n]) => {
  const e = _e(n).toVar(),
    t = FV(QV(e, _e(0.04045))).toVar(),
    r = _e(e.div(12.92)).toVar(),
    i = _e(Va(fo(e.add(_e(0.055)), _e(0)).div(1.055), _e(2.4))).toVar();
  return _i(r, i, t);
});
rge.setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [{ name: "color", type: "vec3" }],
});
const EH = () => {
  const n = Sa(),
    e = () => {
      n(fB(!0));
    },
    { isFileTransfered: t, step: r, instructionIncludes: i } = Cs((s) => s.exp);
  return (
    I.useEffect(() => {
      r.includes("3") &&
        i.length < 4 &&
        (n(A1(i[i.length - 1] + 1)),
        n(w1(["Enter the filename of the memory dump copied from Step 1."])),
        n(A1(i[i.length - 1] + 1)),
        n(b0(["3"])));
    }, [r, i]),
    J.jsx("div", {
      children: J.jsx("div", {
        children: J.jsx(jl, {
          onClick: e,
          style: {
            background: t | r.includes("3") ? "grey" : "#0c2133",
            color: "white",
          },
          disabled: t,
          children: "Transfer File",
        }),
      }),
    })
  );
};
var ige = {
    icon: {
      tag: "svg",
      attrs: { viewBox: "64 64 896 896", focusable: "false" },
      children: [
        {
          tag: "path",
          attrs: {
            d: "M168 504.2c1-43.7 10-86.1 26.9-126 17.3-41 42.1-77.7 73.7-109.4S337 212.3 378 195c42.4-17.9 87.4-27 133.9-27s91.5 9.1 133.8 27A341.5 341.5 0 01755 268.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.7 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c0-6.7-7.7-10.5-12.9-6.3l-56.4 44.1C765.8 155.1 646.2 92 511.8 92 282.7 92 96.3 275.6 92 503.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8zm756 7.8h-60c-4.4 0-7.9 3.5-8 7.8-1 43.7-10 86.1-26.9 126-17.3 41-42.1 77.8-73.7 109.4A342.45 342.45 0 01512.1 856a342.24 342.24 0 01-243.2-100.8c-9.9-9.9-19.2-20.4-27.8-31.4l60.2-47a8 8 0 00-3-14.1l-175.7-43c-5-1.2-9.9 2.6-9.9 7.7l-.7 181c0 6.7 7.7 10.5 12.9 6.3l56.4-44.1C258.2 868.9 377.8 932 512.2 932c229.2 0 415.5-183.7 419.8-411.8a8 8 0 00-8-8.2z",
          },
        },
      ],
    },
    name: "sync",
    theme: "outlined",
  },
  sge = function (e, t) {
    return I.createElement(Ns, an({}, e, { ref: t, icon: ige }));
  },
  jT = I.forwardRef(sge);
const oge = () => {
    const n = Sa(),
      {
        dumbFileDetails: e,
        volitilitySteps: t,
        checkedValue: r,
        instructionIncludes: i,
        analyseStep: s,
        steps: o,
      } = Cs((y) => y.exp);
    I.useState(0);
    const [a, l] = I.useState(!1),
      {
        fileName: c,
        profileName: u,
        systemOffset: d,
        samOffset: h,
        hashFile: m,
      } = e;
    console.log(o);
    const g = (y) => {
        const { name: v, value: _ } = y.target;
        n(hB({ ...e, [v]: _ }));
      },
      x = () => {
        if ((console.log(t), t.includes("1"))) {
          if (c.toLowerCase() !== "memory.dump") {
            Rl.error("File name is incorrect");
            return;
          }
          n(ud("1")), l(!1);
        }
        if (t.includes("2")) {
          if ((console.log("hi"), u.trim() !== "Win7SP1x64")) {
            Rl.error("Profile Name is incorrect");
            return;
          }
          n(ud("2")), l(!1);
        }
        if (t.includes("3")) {
          if (
            d.trim() !== "0xfffff8a000022010" ||
            h.trim() !== "0xfffff8a0016a7420"
          ) {
            Rl.error("SAM or SYSTEM offset is incorrect");
            return;
          }
          n(ud("3")), l(!1);
        }
      };
    return J.jsxs("div", {
      children: [
        t.includes("1") &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", {
                  children: "1.Identify the memory profile using Volatility",
                }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 50,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  display: "flex",
                  flexWrap: "wrap",
                  minHeight: 80,
                },
                children: [
                  "Volatility -f imageinfo",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: g,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "Enter the file name",
                    disabled: t.includes("2"),
                  }),
                  " ",
                ],
              }),
            ],
          }),
        t.includes("2") &&
          r === "1" &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", {
                  children: "2.List the Registery hive",
                }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "Volatility -f",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: g,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "hivelist ",
                  J.jsx("br", {}),
                  " --profile=",
                  J.jsx("input", {
                    name: "profileName",
                    value: u,
                    onChange: g,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "Enter the profile name t",
                    disabled: t.includes("3"),
                  }),
                ],
              }),
            ],
          }),
        t.includes("2") &&
          r === "2" &&
          J.jsxs("div", {
            children: [
              J.jsx("h4", {
                children:
                  "2.Check all file entries in the memory using filescan",
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "Volatility -f",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: g,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "hivelist ",
                  J.jsx("br", {}),
                  " --profile=",
                  J.jsx("input", {
                    name: "profileName",
                    value: u,
                    onChange: g,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: t.includes("3"),
                  }),
                ],
              }),
            ],
          }),
        t.includes("3") &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", { children: "3.Extract the hashes" }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  minHeight: 130,
                },
                children: [
                  "Volatility -f",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: c,
                    onChange: g,
                    style: { width: 100 },
                    disabled: !0,
                    placeholder: "Enter the file name",
                  }),
                  " ",
                  J.jsx("br", {}),
                  " --profile=",
                  J.jsx("input", {
                    name: "profileName",
                    value: u,
                    onChange: g,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: !0,
                  }),
                  " ",
                  "hashdump ",
                  J.jsx("br", {}),
                  " -y",
                  " ",
                  J.jsx("input", {
                    name: "systemOffset",
                    value: d,
                    onChange: g,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    placeholder: "SYSTEM offset",
                    disabled: t.includes("4"),
                  }),
                  "-s",
                  " ",
                  J.jsx("input", {
                    name: "samOffset",
                    value: h,
                    onChange: g,
                    style: {
                      width: 150,
                      height: 20,
                      outline: "none",
                      padding: 3,
                    },
                    disabled: t.includes("4"),
                    placeholder: "SAM offset",
                  }),
                  " ",
                  J.jsx("br", {}),
                ],
              }),
              s === "4" &&
                J.jsxs("div", {
                  children: [
                    J.jsx("h4", {
                      style: { textDecoration: "underline" },
                      children: "Hash Password:",
                    }),
                    J.jsx("h4", {
                      style: { color: "green" },
                      children:
                        "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::",
                    }),
                  ],
                }),
            ],
          }),
        s !== "4" &&
          J.jsx("div", {
            style: { display: "flex", justifyContent: "flex-end" },
            children: J.jsx(jl, {
              onClick: x,
              style: { background: "#0c2133", color: "white" },
              children: "Run",
            }),
          }),
      ],
    });
  },
  age = () => {
    const { isCracked: n, carckedData: e } = Cs((a) => a.exp),
      [t, r] = I.useState(""),
      i = Sa(),
      s = (a) => {
        const { value: l } = a.target;
        r(l.trim());
      },
      o = () => {
        if ((console.log(t), t !== "")) {
          const a =
            t === "GuestUser:500:password=5f4dcc3b5aa765d61d8327deb882cf99:::"
              ? "HELLOWORLD"
              : t === "5f4dcc3b5aa765d61d8327deb882cf99"
              ? "HOWAREYOU"
              : t === "5f4dcc3b5aa765d61d8327deb882cf99"
              ? "GOODDAY"
              : Rl.error("Please enter the correct password.");
          i(Ate(a));
        } else Rl.error("Please enter the correct password.");
      };
    return J.jsx("div", {
      children: J.jsxs("div", {
        children: [
          J.jsx("h4", { children: "Enter Hashed password" }),
          J.jsx(gp, {
            name: "hashFile",
            style: { width: 250, margin: 5 },
            value: t,
            onChange: s,
            placeholder: "Enter hash file name",
          }),
          J.jsx(jl, {
            onClick: o,
            style: { background: "#0c2133", color: "white" },
            children: "Crack",
          }),
          n &&
            J.jsxs("div", {
              style: { display: "flex", alignItems: "center" },
              children: [
                J.jsx("h5", { children: "Cracked password = " }),
                J.jsx("b", { style: { color: "green" }, children: e }),
              ],
            }),
        ],
      }),
    });
  },
  lge = () => {
    const {
      step: n,
      showDumb: e,
      isFileTransfered: t,
      activeAccordien: r,
    } = Cs((l) => l.exp);
    console.log(r);
    const i = () => {
        s(pB());
      },
      s = Sa(),
      o = [
        {
          key: "1",
          label: J.jsx("p", {
            style: { margin: 0 },
            children: J.jsx("b", {
              children: " STEP-1 : Create a memory dump file",
            }),
          }),
          children: J.jsx(TV, {}),
        },
        {
          key: "2",
          label: J.jsx("p", {
            style: { margin: 0 },
            children: J.jsx("b", {
              children:
                " STEP-2 : Transfer memorydump file to an Analyst machine",
            }),
          }),
          children: J.jsx(EH, {}),
          collapsible: n.includes("2") ? "header" : "disabled",
        },
        {
          key: "3",
          label: J.jsxs("p", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
            },
            children: [
              J.jsx("b", { children: " STEP-3 : Analyse memory dump file" }),
              J.jsx(jT, {
                style: { color: "#0c2133", fontWeight: 800 },
                onClick: i,
              }),
            ],
          }),
          children: J.jsx(oge, {}),
          collapsible: n.includes("3") ? "header" : "disabled",
        },
        {
          key: "4",
          label: J.jsx("p", {
            style: { margin: 0 },
            children: J.jsx("b", { children: " STEP-4 : Crack the Hash" }),
          }),
          children: J.jsx(age, {}),
          collapsible: n.includes("4") ? "header" : "disabled",
        },
      ],
      a = (l) => {
        s(b0(l));
      };
    return J.jsx("div", {
      id: "style-8",
      style: { overflowY: "auto", height: "500px" },
      children: J.jsx(SV, {
        onChange: a,
        items: o,
        activeKey: r,
        accordion: !0,
      }),
    });
  },
  cge = () => {
    const n = Sa(),
      {
        dumbFileDetails: e,
        volitilitySteps: t,
        instructionIncludes: r,
        analyseStep: i,
      } = Cs((h) => h.exp),
      [s, o] = I.useState(!1);
    I.useState(0);
    const { fileName: a, profileName: l, systemOffset: c } = e,
      u = (h) => {
        const { name: m, value: g } = h.target;
        n(hB({ ...e, [m]: g }));
      },
      d = () => {
        if (t.includes("1")) {
          if (a.toLowerCase() !== "memory.dump") {
            Rl.error("File name is incorrect");
            return;
          }
          n(ud("1")), o(!1);
        }
        if (t.includes("2")) {
          if (l.trim() !== "Win7SP1x64") {
            Rl.error("Profile Name is incorrect");
            return;
          }
          n(ud("2")), o(!1);
        }
        if (t.includes("3")) {
          if (c.trim() !== "0x0000000004a41433") {
            Rl.error("JPG offset is incorrect");
            return;
          }
          n(ud("3")), o(!1), n(A1(r[r.length - 1] + 1));
        }
      };
    return J.jsxs("div", {
      children: [
        t.includes("1") &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", {
                  children: "1.Analysis the image info of the given file",
                }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 50,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                  display: "flex",
                  flexWrap: "wrap",
                  minHeight: 80,
                },
                children: [
                  "./vol.py -f",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: a,
                    onChange: u,
                    style: { width: 100, height: 20 },
                    placeholder: "Enter the file name",
                    disabled: t.includes("2"),
                  }),
                  "    ",
                  "imageinfo",
                ],
              }),
            ],
          }),
        t.includes("2") &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", { children: "2.Locate the image file." }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 100,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "Volatility -f husky",
                  " ",
                  J.jsx("input", {
                    name: "fileName",
                    value: a,
                    onChange: u,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  "--profile",
                  J.jsx("br", {}),
                  J.jsx("input", {
                    name: "profileName",
                    value: l,
                    onChange: u,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: t.includes("3"),
                  }),
                  " ",
                  J.jsx("br", {}),
                  "filescan",
                ],
              }),
            ],
          }),
        t.includes("3") &&
          J.jsxs("div", {
            children: [
              J.jsx("div", {
                style: { display: "flex", justifyContent: "space-between" },
                children: J.jsx("h4", { children: "3.Dump the image file." }),
              }),
              J.jsxs("pre", {
                style: {
                  background: "#2c2c2e",
                  height: 120,
                  color: "white",
                  paddingTop: 10,
                  paddingInline: 2,
                  paddingLeft: 5,
                },
                children: [
                  "Volatility -f",
                  J.jsx("input", {
                    name: "fileName",
                    value: a,
                    onChange: u,
                    style: { width: 100 },
                    placeholder: "Enter the file name",
                    disabled: !0,
                  }),
                  " ",
                  J.jsx("br", {}),
                  " --profile=",
                  J.jsx("input", {
                    name: "profileName",
                    value: l,
                    onChange: u,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter profile name",
                    disabled: !0,
                  }),
                  "dumpfiles -Q",
                  J.jsx("br", {}),
                  J.jsx("input", {
                    name: "systemOffset",
                    value: c,
                    onChange: u,
                    style: { width: 120, margin: 5 },
                    placeholder: "Enter offset",
                    disabled: t.includes("4"),
                  }),
                  J.jsx("br", {}),
                  " --name file -D /opt/",
                ],
              }),
            ],
          }),
        i !== "4" &&
          J.jsx("div", {
            style: { display: "flex", justifyContent: "flex-end" },
            children: J.jsx(jl, {
              onClick: d,
              style: { background: "#0c2133", color: "white" },
              children: "Run",
            }),
          }),
      ],
    });
  },
  uge = () => {
    const n = Sa(),
      { openComputer: e, openFolder: t, openImage: r } = Cs((s) => s.exp);
    console.log(e);
    const i = (s) => {
      switch (s) {
        case "open":
          n(xte(!0));
          break;
        case "openFolder":
          n(_te(!0));
          break;
        case "openImage":
          n(VM(!0));
          break;
      }
    };
    return J.jsx("div", {
      children: J.jsx("div", {
        children: J.jsx(jl, {
          onClick: () => i("openImage"),
          style: { background: "#0c2133", color: "white" },
          disabled: r,
          children: "open image",
        }),
      }),
    });
  },
  dge = () => {
    const {
      step: n,
      showDumb: e,
      isFileTransfered: t,
      analyseStep: r,
      activeAccordien: i,
    } = Cs((c) => c.exp);
    console.log(r, n);
    const s = () => {
        o(VM(!1)), o(pB());
      },
      o = Sa(),
      a = [
        {
          key: "1",
          label: J.jsx("p", {
            style: { margin: 0 },
            children: J.jsx("b", {
              children: " STEP-1 : Create a memory dump file",
            }),
          }),
          children: J.jsx(TV, {}),
        },
        {
          key: "2",
          label: J.jsx("p", {
            style: { margin: 0 },
            children: J.jsx("b", {
              children:
                "STEP-2 : Transfer the memory dump file to Forensic Computer for analysis",
            }),
          }),
          children: J.jsx(EH, {}),
          collapsible: n.includes("2") ? "header" : "disabled",
        },
        {
          key: "3",
          label: J.jsxs("p", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
            },
            children: [
              J.jsx("b", { children: " STEP-3 : Analyse memory dump file" }),
              J.jsx(jT, {
                style: { color: "#0c2133", fontWeight: 800 },
                onClick: s,
              }),
            ],
          }),
          children: J.jsx(cge, {}),
          collapsible: n.includes("3") ? "header" : "disabled",
        },
        {
          key: "4",
          label: J.jsxs("p", {
            style: {
              margin: 0,
              display: "flex",
              justifyContent: "space-between",
            },
            children: [
              J.jsx("b", { children: " STEP-4 :View the image file." }),
              J.jsx(jT, {
                style: { color: "#0c2133", fontWeight: 800 },
                onClick: s,
              }),
            ],
          }),
          children: J.jsx(uge, {}),
          collapsible: r.includes("4") ? "header" : "disabled",
        },
      ],
      l = (c) => {
        o(b0(c)),
          o(VM(!1)),
          console.log(c),
          c.includes("2") && e
            ? o(By("step-2"))
            : c.includes("3") && n.includes("3")
            ? o(By("step-3"))
            : c.includes("1") && n.includes("1")
            ? o(By("step-1"))
            : c.includes("4") && n.includes("4") && o(By("step-4"));
      };
    return J.jsx("div", {
      id: "style-8",
      style: { overflowY: "auto", height: "500px" },
      children: J.jsx(SV, {
        onChange: l,
        items: a,
        activeKey: i,
        accordion: !0,
      }),
    });
  },
  fge = () => {
    const { checkedValue: n } = Cs((e) => e.exp);
    return J.jsxs("div", {
      style: { marginTop: 20, paddingInline: 5 },
      children: [n === "1" && J.jsx(lge, {}), n === "2" && J.jsx(dge, {})],
    });
  },
  hge = () =>
    J.jsxs("div", {
      style: {
        flex: "1 1 25%",
        maxWidth: "25%",
        borderTopRightRadius: "500px",
        background: "white",
      },
      children: [
        J.jsx("div", {
          style: {
            background: "#0c2136",
            height: 50,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          },
          children: J.jsx("h4", {
            style: { textAlign: "center", margin: 0, color: "white" },
            children: "Memory forensic",
          }),
        }),
        J.jsx("div", {
          style: {
            padding: 5,
            paddingBlock: 10,
            display: "flex",
            justifyContent: "center",
            width: "100%",
          },
          children: J.jsx(MV, { radioValue: Zte }),
        }),
        J.jsx("div", {
          style: { height: "auto", padding: 4, width: "100%" },
          children: J.jsx(fge, {}),
        }),
      ],
    }),
  pge = () => {
    const { instructions: n, steps: e } = Cs((r) => r.exp),
      t = I.useRef(null);
    return (
      I.useEffect(() => {
        t.current && (t.current.scrollTop = t.current.scrollHeight);
      }, [e, n]),
      J.jsxs("div", {
        style: {
          marginBlock: 10,
          marginLeft: 10,
          height: "100%",
          overflow: "scroll",
        },
        id: "scroll",
        ref: t,
        children: [
          n.map((r, i) =>
            J.jsx(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  height: "auto",
                  background: "#EFF7FF",
                  borderRadius: 20,
                  marginInline: 10,
                  justifyContent: "center",
                  padding: 10,
                  marginBlock: 10,
                },
                children: J.jsx("div", {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    marginInline: 10,
                    justifyContent: "center",
                  },
                  children: J.jsxs("div", {
                    style: { display: "flex", marginBlock: 15 },
                    children: [
                      J.jsxs("h5", {
                        style: { margin: 0, marginRight: 5 },
                        children: [i + 1, ")"],
                      }),
                      J.jsx("h5", {
                        style: {
                          margin: 0,
                          fontWeight: 500,
                          fontSize: 14,
                          color: "#0c2136",
                        },
                        children: r,
                      }),
                    ],
                  }),
                }),
              },
              i
            )
          ),
          e.map((r, i) =>
            J.jsx(
              "div",
              {
                style: {
                  width: "95%",
                  marginInline: "auto",
                  background: "#eff7ff",
                  borderRadius: 20,
                  paddingInline: 20,
                  paddingBlock: 15,
                  marginBlock: 15,
                },
                children: J.jsxs("div", {
                  style: { display: "flex", flexDirection: "column" },
                  children: [
                    J.jsxs("h5", {
                      style: { color: "#0c2136", fontSize: 15, margin: 1 },
                      children: [" ", "Step-", i + 1, ":"],
                    }),
                    r == null
                      ? void 0
                      : r.map((s, o) =>
                          J.jsxs(
                            "div",
                            {
                              style: {
                                marginBlock: 10,
                                display: "flex",
                                width: "90%",
                                fontWeight: 500,
                              },
                              children: [
                                J.jsxs("h5", {
                                  style: {
                                    margin: 0,
                                    fontSize: 13,
                                    fontWeight: 500,
                                    color: "black",
                                  },
                                  children: [o + 1, "."],
                                }),
                                J.jsx("h5", {
                                  style: {
                                    margin: 0,
                                    fontSize: 13,
                                    marginLeft: 5,
                                    fontWeight: 500,
                                    color: "black",
                                  },
                                  children: s,
                                }),
                              ],
                            },
                            o
                          )
                        ),
                  ],
                }),
              },
              i
            )
          ),
        ],
      })
    );
  },
  mge = () =>
    J.jsxs("div", {
      style: {
        display: "flex",
        flex: 1,
        width: "100%",
        height: "100%",
        overflow: "hidden",
      },
      children: [
        J.jsx(hge, {}),
        J.jsx(ene, {}),
        J.jsxs("div", {
          style: { flex: "1 1 25%", maxWidth: "25%" },
          children: [
            J.jsx("div", {
              style: {
                background: "#0c2136",
                height: 50,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
              },
              children: J.jsx("h5", {
                style: { color: "white", margin: 0 },
                children: "Steps",
              }),
            }),
            J.jsx(pge, {}),
          ],
        }),
      ],
    }),
  gge = qee({ reducer: { exp: wte } });
function vge() {
  return (
    ((e) => {
      let t = "";
      for (let r = e.length - 1; r >= 0; r--) t += t[r];
      return t;
    })("hello"),
    J.jsx(Y9, { store: gge, children: J.jsx(mge, {}) })
  );
}
Hb.createRoot(document.getElementById("root")).render(
  J.jsx(Je.StrictMode, { children: J.jsx(vge, {}) })
);
